import { ICompilerID, IListItemData } from './ICompilerRegistry'
import { IProcessedScriptOutput } from '@/lib/IScriptBlock'
import { IBlockDefinition, IBlocklyToolbox } from './IBlocklyHelper'

export enum KnownBlockTypes {
    PLAYGROUND = 'PLAYGROUND',
    TEXT = 'TEXT',
    BLOCKHIDDEN = 'BLOCK-hidden',
    BLOCKSTATIC = 'BLOCK-static',
    BLOCK = 'BLOCK',
    BLOCKLY = 'BLOCKLY',
}

export enum CodeOutputTypes {
    AUTO = 'auto',
    TEXT = 'text',
    JSON = 'json',
    MAGIC = 'magic',
}

export enum CodeExpansionType {
    LARGE = 2,
    AUTO = 1,
    TINY = 0,
}

export interface IBlockloadManager {
    readonly blockTag: string
    loadFromDatablock: (
        bl: HTMLElement,
        inBlock: IBlockElementData,
        block: IBlockDataBase,
        editMode: boolean
    ) => void
}

export interface IRandomizerSet {
    uuid: string
    values: IRandomizerSetTag[]
}

export interface IRandomizerSetTag {
    tag: string
    value: string
}
export interface IRandomizerSettings {
    active: boolean
    previewIndex: number
    knownTags: string[]
    sets: IRandomizerSet[]
}

export interface IBlockDataPlayground {
    width: string
    height: string
    align: string
}

export interface IBlockError {
    error: string
    uuid: string
}

export interface IBlockElementData {
    readonly?: string
    static?: string
    hidden?: string
    visibleLines?: string
    shouldAutoreset?: string
    expanded?: string
    codeExpanded?: string
    noContent?: string
    alternativeContent?: string
    width?: string
    height?: string
    align?: string
    version?: string
    scopeUUID?: string
    scopeSelector?: string
    showControls?: boolean
    as?: string
}

export interface IBlockDataBlockly {
    toolbox: IBlocklyToolbox
    blocks: IBlockDefinition[]
    _blockErrors: IBlockError[]
    useOverride: boolean
    toolboxOverride: string
    showControls: boolean
}

export interface ICodeBlockDataState {
    readonly: boolean
    static: boolean
    hidden: boolean
}
export interface IBlockDataBase extends IBlockDataPlayground, ICodeBlockDataState {
    hasCode: boolean
    type: KnownBlockTypes
    content: string
    alternativeContent: string | null
    noContent: boolean
    id: number
    uuid: string
    parentID: number
    expanded: boolean
    codeExpanded: CodeExpansionType
    obj: object | null
    version: string
    readyCount: number
    errors: any[]
    scopeUUID?: string
    scopeSelector?: string
    visibleLines: number | 'auto'
    hasAlternativeContent: boolean
    shouldAutoreset: boolean
    blockly: IBlockDataBlockly
    lineCountHint: number
    as?: KnownBlockTypes
}

export interface IBlockData extends IBlockDataBase {
    getThemeForBlock(bl: ICodeBlockDataState): string
    readonly themeForCodeBlock: string
}

export interface IGlobalSettings {
    baseurl: string
}
export interface IGlobalState extends IGlobalSettings {
    format_info(text: string): string
    format_error(text: string): string

    /**
     * Seperates an outputObject (like the one you will get in the update-method of a playground handler) into a string and a json object seperated by a magic String. Returns an object that contains
     *  <code>type</code> = <code>'dual'</code> parsed a magic string, <code>'json'</code> parsed as json, <code>'text'</code> plain text
     *  <code>json</code> = the JSON object that was sent after the magicString
     *  <code>text</code> = the String that was sent before the magicString
     * @param {*} outputObject  The outputObject generated by the student code
     * @param {*} type  'auto' = (default, try to determin what kind of output was generated), 'text', 'json' = (force json parsing), 'magic' = (force use of magic string seperator)
     * @param {*} magicString The seperating String. By default it is '\n\n<JSON>\n'
     */
    processMixedOutput(
        outputObject: string[] | string,
        type: CodeOutputTypes,
        magicString?: string,
        resultData?: object | any[]
    ): IProcessedScriptOutput
    mimeType(language: string): string
    knownLanguages(): IListItemData[]

    refreshAllCodeMirrors(): void
    refreshAllCodeMirrorsSync(): void

    itemForValue(items: IListItemData[], value: string): IListItemData
}
