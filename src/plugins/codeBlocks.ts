import Vue from 'vue'
import { CodeOutputTypes, IGlobalSettings, IGlobalState } from '@/lib/ICodeBlocks'
import { IProcessedScriptOutput } from '@/lib/IScriptBlock'
import { IListItemData } from '@/lib/ICompilerRegistry'

/**
 * This object defines the programming languages supported for code highlighting
 * using CodeMirror
 * @namespace cmMode The programminglanguages supported
 */
const mimeTypesForLanguage = {
    c: { mime: 'text/x-csrc', displayName: 'C' }, // (C),
    'c++': { mime: 'text/x-c++src', displayName: 'C++' }, // (C++),
    'c#': { mime: 'text/x-csharp', displayName: 'C#' }, // (C#),
    css: { mime: 'text/css', displayName: 'CSS' }, // (CSS)
    fortran: { mime: 'text/x-fortran', displayName: 'Fortran' }, // (Fortran)
    glsl: { mime: 'text/x-glsl', displayName: 'GLSL' }, // (GLSL)
    html: { mime: 'text/html', displayName: 'HTML' }, // (HTML)
    java: { mime: 'text/x-java', displayName: 'Java' }, // (Java),
    javascript: { mime: 'text/javascript', displayName: 'JavaScript' }, // (JavaScript)
    perl: { mime: 'text/x-perl', displayName: 'Perl' }, // (Perl)
    php: { mime: 'application/x-httpd-php', displayName: 'PHP' }, // (PHP)
    python: { mime: 'text/x-python', displayName: 'Python' }, // (Python)
    r: { mime: 'text/x-rsrc', displayName: 'R' }, //(R)
}

function loadSettings(scope: HTMLElement | Document): IGlobalSettings {
    const options = {
        baseurl: '',
    }
    const settings = scope.querySelectorAll('meta[name^=codeblocks]')
    settings.forEach((opt) => {
        const name = opt.getAttribute('name')
        const value = opt.getAttribute('content')

        if (name == 'codeblocks-baseurl' && value) {
            options.baseurl = value
        }
    })
    return options
}

export class GlobalState implements IGlobalState {
    public readonly baseurl: string

    constructor() {
        const options = loadSettings(document)
        this.baseurl = options.baseurl
    }
    format_info(text: string): string {
        return '<span style="color:green">' + text + '</span>'
    }
    format_error(text: string): string {
        return '<span style="color:red">' + text + '</span>'
    }

    /**
     * Seperates an outputObject (like the one you will get in the update-method of a playground handler) into a string and a json object seperated by a magic String. Returns an object that contains
     *  <code>type</code> = <code>'dual'</code> parsed a magic string, <code>'json'</code> parsed as json, <code>'text'</code> plain text
     *  <code>json</code> = the JSON object that was sent after the magicString
     *  <code>text</code> = the String that was sent before the magicString
     * @param {*} outputObject  The outputObject generated by the student code
     * @param {*} type  'auto' = (default, try to determin what kind of output was generated), 'text', 'json' = (force json parsing), 'magic' = (force use of magic string seperator)
     * @param {*} magicString The seperating String. By default it is '\n\n<JSON>\n'
     */
    processMixedOutput(
        outputObject: string[] | string,
        type: CodeOutputTypes,
        magicString?: string,
        resultData?: object | any[]
    ): IProcessedScriptOutput {
        if (outputObject !== undefined && Array.isArray(outputObject)) {
            return {
                type: 'json',
                json: outputObject,
                text: '',
            }
        }

        if (magicString === undefined) {
            magicString = '\n\n<JSON>\n'
        }
        const idx = outputObject.indexOf(magicString)

        if (
            type === CodeOutputTypes.DATA ||
            (type === CodeOutputTypes.AUTO && resultData != undefined)
        ) {
            return {
                type: 'dual',
                json: resultData,
                text: outputObject,
            }
        } else if ((type === CodeOutputTypes.AUTO && idx >= 0) || type === CodeOutputTypes.MAGIC) {
            const str = outputObject.substr(0, idx)
            let json = undefined
            const pString = outputObject.substr(idx + magicString.length)
            try {
                json = JSON.parse(pString)
            } catch (ee) {
                const e: any = ee
                e.parsedString = pString
                console.log('catch')
                throw e
            }

            return {
                type: 'dual',
                json: json,
                text: str,
            }
        } else {
            if (type === CodeOutputTypes.JSON && resultData !== undefined) {
                return {
                    type: CodeOutputTypes.JSON,
                    json: resultData,
                    text: '',
                }
            }
            const too = outputObject.trim()
            if (
                (type === CodeOutputTypes.AUTO &&
                    (too.indexOf('[') == 0 || too.indexOf('{') == 0)) ||
                type === CodeOutputTypes.JSON
            ) {
                return {
                    type: CodeOutputTypes.JSON,
                    json: JSON.parse(outputObject),
                    text: '',
                }
            }
        }

        return {
            type: 'text',
            json: resultData,
            text: outputObject,
        }
    }
    mimeType(language: string): string {
        const o = mimeTypesForLanguage[language]
        if (o === undefined) {
            return 'text/javascript'
        }
        return o.mime
    }
    knownLanguages(): IListItemData[] {
        return Object.keys(mimeTypesForLanguage)
            .map((k) => {
                return { label: mimeTypesForLanguage[k].displayName, value: k }
            })
            .sort((a, b) => (a.value < b.value ? -1 : 1))
    }
    refreshAllCodeMirrorsSync(): void {
        document.querySelectorAll('.CodeMirror').forEach((e: any) => e.CodeMirror.refresh())
    }
    refreshAllCodeMirrors(): void {
        setTimeout(() => {
            this.refreshAllCodeMirrorsSync()
        }, 100)
        setTimeout(() => {
            this.refreshAllCodeMirrorsSync()
        }, 500)
    }
    public itemForValue(items: IListItemData[], value: string): IListItemData {
        const ret = items.find((i) => i.value == value)
        if (ret === undefined) {
            return {
                label: '???',
                value: '???',
            }
        }
        return ret
    }
}
export const globalState = new GlobalState()
Vue.prototype.$CodeBlock = globalState
Vue.$CodeBlock = globalState

Vue.$GlobalEventHub = new Vue()
