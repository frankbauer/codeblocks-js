<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta name="codeblocks-baseurl" content="<%= BASE_URL %>">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title>frontend</title>
    <link rel=stylesheet href="<%= BASE_URL %>css/loader.css">     
    <link rel=stylesheet href="<%= BASE_URL %>css/roboto.css">  
    <link rel=stylesheet href="<%= BASE_URL %>css/main.css">  
    <script src="<%= BASE_URL %>js/jquery.min.js" type="text/javascript"></script>
    <style>
      codeblockseditor > *,  codeblocks > *, [codeblockseditor] > *,  [codeblocks] > *{
				display:none;        
      }
    </style>
  </head>
  <body>
    <noscript>
      <strong>We're sorry but this doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    
    <p highlight="javascript">
      This is just a <b>test</b>:
    [code]update: function(text, json, canvasElement, outputElement) {<br />        canvasElement.removeClass('hiddenBlock');<br />        console.log("FOO", text, json);
        return "New Text is here\n\n";<br />    } //update[/code]
    </p>
    
    <div id="app"></div>
    <div style="padding-left:50px;padding-right:50px">
     
        <div data-readonly codeblockseditor data-id="78" data-compiler="javascript" data-compiler-version="100" data-language="javascript" data-execution-timeout="500" ddata-max-characters="6000" data-run-code="true" data-solution-theme="solarized light" data-code-theme="xq-light" data-dom-libs='["d3-5.13.4"]' data-worker-libs='[]' data-output-parser="auto" ><loading><div></div><div></div></loading><playground data-version="101" width="100%" height="200px" align="left" >{
            graph : {  
                    nodes: [
                        {name:'A', id:0},
                        {name:'B', id:1},
                        {name:'C', id:2},
                        {name:'D', id:3},
                        {name:'E', id:4},
                        {name:'F', id:5},
                        {name:'G', id:6},
                    ],
                    edges : [
                        {source:0, target:5, w:7.0},
                        {source:0, target:6, w:1.0},
                        {source:0, target:1, w:7.0},
                        {source:1, target:2, w:1.0},
                        {source:1, target:3, w:5.0},
                        {source:1, target:5, w:3.0},
                        {source:1, target:6, w:8.0},
                        {source:2, target:5, w:1.0},
                        {source:3, target:6, w:15.0},
                        {source:4, target:0, w:2.0},
                        {source:4, target:5, w:8.0},                
                        {source:1, target:6, w:1.0}
                    ]
            },	
            showRows:[[-1, -1, -1, -1, 0, -1, -1]],
            solution:undefined,
            ui:undefined, 
            readonly:false,
            translate: function(val, infty){
                if (val === undefined || val&lt;0) return infty || '&infin;';
                return Math.round(val);
            },
          init: function (canvasElement) {
                const width = 400;
                const height = 400;
                const graph = this.graph;         
        
                //if (this.findUIElements===undefined){
                    function findUIElements(canvasElement){
                        let res = {};
                        res.questionID = canvasElement.attr('data-question')
                        res.container = canvasElement.parents('.codeblocks')
                        res.runContainer = res.container.find("div.runner")
                        res.textEdit = res.container.find(".codeblock.block-block textarea[name]")
                        res.stateBox = res.runContainer.find(".runnerState")
                        res.runButton = res.runContainer.find("button")
                        console.log(res.container.hasClass('block-readonly'))
                        if (res.textEdit!==undefined) {
                            res.editor = res.container.find('.codeblock.block-block .CodeMirror').get(0).CodeMirror;
                        } else {
                            res.editor = undefined;
                        } 
                        return res;
                    }
        
                    function hideUIElements(canvasElement){
                        let res = findUIElements(canvasElement);
                        if (res.container.hasClass("editmode")) return res; 

                        if (res.editor===undefined){
                            console.error("Could not find a valid answer Element");
                        } else {
                            $(res.editor.getWrapperElement()).hide();
                            res.runButton.hide();
                            res.stateBox.hide();
                            if (res.runContainer) res.runContainer.hide();
                        }
                        return res;
                    }
                //}
        
                //this.ui = findUIElements(canvasElement);
                this.ui = hideUIElements(canvasElement);
                this.readonly = this.ui.container.hasClass('block-readonly');
                canvasElement.css("background-color", 'unset');
                canvasElement.css("border", 'unset');
                canvasElement.css("height", 'unset');
        
                const styles = document.createElement('style');
                styles.append('.links line {stroke: #BC8958;}');
                styles.append('.links text {pointer-events: none;font: 12px sans-serif;font-weight:bold}');
                styles.append('.lineLabelBox {fill:#fff; stroke:#BC8958}');
                styles.append('.nodes text {pointer-events: none;font: 18px sans-serif;font-weight:bold;fill:white}');
                styles.append('.nodes circle {pointer-events: all;stroke: white;stroke-width: 3px;fill:#437094}');
                styles.append('.container {background-color:#ffff; border:1px dashed rgba(128, 48, 48, 0.66);margin:0px;padding:0px}');
                styles.append('#dijkstra {background-color:#fff;margin-left:20px}')
                styles.append('#dijkstra tr td, #dijkstra tr th{border:1px solid #437094;width:64px;text-align:center}');
                styles.append('#dijkstra tr td{height:25px;vertical-align:center;padding-top:3px;padding-bottom:3px}');
                styles.append('#dijkstra tr td.static{background-color:rgba(255, 255, 255, 0.8)}');
                styles.append('#dijkstra tr th{background-color:#437094;color:white}');
                styles.append('#dijkstra tr td input {background-color:#FCF6E5}');
                styles.append('#dijkstra tr td input.none {background-color:#FCF6E522}');
                canvasElement.append(styles);
        
                canvasElement.append('&lt;table>&lt;tr>&lt;td id="fblayout0">&lt;/td>&lt;td id="fblayout1">&lt;/td>&lt;/tr>&lt;/table>');
                
                const container = $(document.createElement('div'));
                container.addClass('container');
                container.width(width);
                container.height(height);
        
                $('#fblayout0').append(container);
                const t = $('#fblayout1');
                
                //if (!this.ui.container.hasClass("editmode")) 
                {
                  try {
                      const old = JSON.parse(this.ui.textEdit.val());
                      
                      this.solution = old.solution;
                  } catch (e){
                      console.error(e);
                  }
                }
        
            
                let s = '&lt;table id="dijkstra">';
                s += '&lt;tr>';
                $.each(graph.nodes, (i, n) => {
                    s += '&lt;th>';
                    s += n.name;
                    s += '&lt;/th>';
              graph.nodes[n.id].mapped = i;
                });
                s += '&lt;/tr>';
        
            $.each(graph.edges, (i, e) => {
              e.source = graph.nodes[e.source].mapped;
              e.target = graph.nodes[e.target].mapped;
            });
                const buildSolution = this.solution === undefined;
                if (buildSolution) this.solution = [];
                $.each(graph.nodes, (row, n) => {
                    s += '&lt;tr>';
                        if (buildSolution) this.solution[row] = [];
                    $.each(graph.nodes, (col, n) => {
                        if (row&lt;this.showRows.length) {
                            s += '&lt;td class="static">';                    
                            if (buildSolution) this.solution[row][col] = this.showRows[row][col];
                            s += this.translate(this.solution[row][col]);
                        } else {
                            s += '&lt;td>';
                                if (buildSolution) this.solution[row][col] = '';
                            s += '&lt;input type="text" id="fbDijkstra_'+row+'_'+col+'" maxlength="4" size="3" value="'+this.solution[row][col]+'" '+((''+this.solution[row][col]).trim()==''?'class="none"':'')+(this.readonly?' readonly':'')+'>';                    
                        }                
                        s += '&lt;/td>';
                    });            
                    s += '&lt;/tr>';
                });
                s += '&lt;/table>'
                t.append(s);
        
                const mdiv = document.createElement("div");
                mdiv.innerHTML = this.translate(-1); 
                const infty = (mdiv.textContent || mdiv.innerText);       
        
                let firstInput = true;
                const self = this;
                $.each(graph.nodes, (row, n) => {            
                    $.each(graph.nodes, (col, n) => {
                        if (row>=this.showRows.length) {
                            const input = t.find('#fbDijkstra_'+row+'_'+col);
                            if (firstInput){
                                firstInput = false;
                                input.focus();
                            }
                            input.keyup(()=>{
                                let v = input.val().trim();
                                if (v===infty) v = -1;
                                
                                if (v&lt;0) input.val(infty);
                                if (v=='') input.addClass('none');
                                else input.removeClass('none');
                                self.solution[row][col] = v;
                                this.storeResult()
                            });
                            input.on('change', ()=>{
                                let v = input.val().trim();
                                if (v===infty || v=='-') v = -1;
                                if (v!='') v = this.translate(Number(v), infty);
                                input.val(v);
                                self.solution[row][col] = v;
                                
                                this.storeResult()
                            });
                        }
                    });
                });
                
                const svg = d3.select(container.get(0)).append("svg")
                    .attr("width", width)
                    .attr("height", height);
                
                const simulation = d3.forceSimulation(graph.nodes) 
                    .force("charge", d3.forceManyBody().strength(-1000))
                    .force("link", d3.forceLink(graph.Edges).distance(25))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collide', d3.forceCollide(25))            
        
                const link = svg.append("g")
                    .attr("class", "links")
                    .selectAll("line")
                    .data(graph.edges)
                    .enter()
                    .append('g');
                   
                link.append("line")
                    .attr('class', 'line');
        
                const labelGroup = link.append('g')
                    .attr('class', 'labelGroup');
                
                labelGroup.append("text")
                    .attr('class', 'lineLabel')            
                    .attr('alignment-baseline', 'middle')
                    .attr('text-anchor', 'middle')
                    .text(d => d.w)                 
        
                link.selectAll("text").each(function(d, i) {
                    d.bb = this.getBBox(); 
                });  
        
                const padding = 3;
                labelGroup.insert("rect", ":first-child")           
                    .attr('class', 'lineLabelBox')  
                    .attr("width", function(d) { return d.bb.width + 2*padding; })
                    .attr("height", function(d) { return d.bb.height + 2*padding; })
                    .attr("x", function(d) { return - d.bb.width/2 - padding; })
                    .attr("y", function(d) { return - d.bb.height/2 - padding; });        
        
                var node = svg.append("g")
                    .attr("class", "nodes")
                    .selectAll(".nodes")
                    .data(graph.nodes)
                    .enter()
                        .append('g')
                        .attr("class", "node")
                        .call(d3.drag()
                            .on("start", dragstarted)
                            .on("drag", dragged)
                            .on("end", dragended));
                    
                node.append("circle")
                    .attr('cx', 0)
                    .attr('cy', 0)
                    .attr("r", 16)                
                            
                node.append("text")
                    .attr('class', 'nodeLabel')
                    .attr('alignment-baseline', 'middle')
                    .attr('text-anchor', 'middle')
                    .attr('x', 0)
                    .attr('y', 1)
                    .text(d => d.name);
        
        
                simulation
                    .nodes(graph.nodes)
                    .on("tick", ticked);
        
                simulation.force("link")
                    .links(graph.edges);
        
                function ticked() {
                    link.selectAll('line')
                        .attr("x1", function(d) { return d.source.x; })
                        .attr("y1", function(d) { return d.source.y; })
                        .attr("x2", function(d) { return d.target.x; })
                        .attr("y2", function(d) { return d.target.y; });
        
                    link.selectAll('g')
                        .attr('transform', d => 'translate('+
                                                            (d.source.x + d.target.x)/2
                                                            +', '+
                                                            (d.source.y + d.target.y)/2
                                                            +')'
                        )                        
                                        
                    node.attr('transform', d => 'translate('+d.x+', '+d.y+')')              
                }
        
                function dragstarted(d) {
                    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }
        
                function dragged(d) {
                    d.fx = d3.event.x;
                    d.fy = d3.event.y;
                }
        
                function dragended(d) {
                    if (!d3.event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }
        
                this.storeResult();
          },
            storeResult: function(){
                if (this.readonly) return;
                const val = JSON.stringify({
                    solution:this.solution,
                    graph:{
                        nodes:this.graph.nodes.map(n=>{return {n:n.name, id:n.id};}),
                        edges:this.graph.edges.map(e=>{return {s:e.source, t:e.target, w:e.w};}),
                    }
                });
                
                if (this.ui.editor !== undefined) this.ui.editor.getDoc().setValue(val);
                this.ui.textEdit.val(val);
            },
          shouldAutoReset: function(){
            return true
          },
          update: function (text, json, canvasElement, outputElement) {
            outputObject = processMixedOutput(outputObject, canvasElement)		
            
            if (outputObject.json) {	
              const self = this;		
                    
              
            } else {
                    
            } 
                
            return outputObject.text;
                
          } // update
        }</playground><block data-visible-lines="10" >{"solution":[[-1,-1,-1,-1,0,-1,-1],[2,"∞","∞","∞","","8","∞"],["",9,"∞","∞","",8,3],["",4,"∞",18,"",8,""],["","",5,9,"",7,""],["","","",9,"",6,""],["","","",9,"","",""]]}</block></div>
        
    <!-- built files will be auto injected -->
  </body>
</html>
