(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"));
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["codeblocks"] = factory(require("vue"));
	else
		root["codeblocks"] = factory(root["Vue"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__8bbf__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded CSS chunks
/******/ 	var installedCssChunks = {
/******/ 		0: 0
/******/ 	}
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		0: 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "codeblocks.umd." + ({}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// mini-css-extract-plugin CSS loading
/******/ 		var cssChunks = {"1":1};
/******/ 		if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);
/******/ 		else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {
/******/ 			promises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {
/******/ 				var href = "css/" + ({}[chunkId]||chunkId) + ".css";
/******/ 				var fullhref = __webpack_require__.p + href;
/******/ 				var existingLinkTags = document.getElementsByTagName("link");
/******/ 				for(var i = 0; i < existingLinkTags.length; i++) {
/******/ 					var tag = existingLinkTags[i];
/******/ 					var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");
/******/ 					if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return resolve();
/******/ 				}
/******/ 				var existingStyleTags = document.getElementsByTagName("style");
/******/ 				for(var i = 0; i < existingStyleTags.length; i++) {
/******/ 					var tag = existingStyleTags[i];
/******/ 					var dataHref = tag.getAttribute("data-href");
/******/ 					if(dataHref === href || dataHref === fullhref) return resolve();
/******/ 				}
/******/ 				var linkTag = document.createElement("link");
/******/ 				linkTag.rel = "stylesheet";
/******/ 				linkTag.type = "text/css";
/******/ 				linkTag.onload = resolve;
/******/ 				linkTag.onerror = function(event) {
/******/ 					var request = event && event.target && event.target.src || fullhref;
/******/ 					var err = new Error("Loading CSS chunk " + chunkId + " failed.\n(" + request + ")");
/******/ 					err.code = "CSS_CHUNK_LOAD_FAILED";
/******/ 					err.request = request;
/******/ 					delete installedCssChunks[chunkId]
/******/ 					linkTag.parentNode.removeChild(linkTag)
/******/ 					reject(err);
/******/ 				};
/******/ 				linkTag.href = fullhref;
/******/
/******/ 				var head = document.getElementsByTagName("head")[0];
/******/ 				head.appendChild(linkTag);
/******/ 			}).then(function() {
/******/ 				installedCssChunks[chunkId] = 0;
/******/ 			}));
/******/ 		}
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = (typeof self !== 'undefined' ? self : this)["webpackJsonpcodeblocks"] = (typeof self !== 'undefined' ? self : this)["webpackJsonpcodeblocks"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fae3");
/******/ })
/************************************************************************/
/******/ ({

/***/ "0016":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5530");
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("3835");
/* harmony import */ var core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("4d63");
/* harmony import */ var core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_regexp_dot_all_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("c607");
/* harmony import */ var core_js_modules_es_regexp_dot_all_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_dot_all_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("ac1f");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_regexp_sticky_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("2c3e");
/* harmony import */ var core_js_modules_es_regexp_sticky_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_sticky_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("25f0");
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("a15b");
/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("b64b");
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("b0c0");
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es_regexp_test_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("00b4");
/* harmony import */ var core_js_modules_es_regexp_test_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_test_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("d81d");
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("466d");
/* harmony import */ var core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("99af");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _mixins_size_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("6642");
/* harmony import */ var _mixins_tag_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("e2fa");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("87e8");
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("e277");



















var defaultViewBox = '0 0 24 24';
var sameFn = function sameFn(i) {
  return i;
};
var ionFn = function ionFn(i) {
  return "ionicons ".concat(i);
};
var libMap = {
  'mdi-': function mdi(i) {
    return "mdi ".concat(i);
  },
  'icon-': sameFn,
  // fontawesome equiv
  'bt-': function bt(i) {
    return "bt ".concat(i);
  },
  'eva-': function eva(i) {
    return "eva ".concat(i);
  },
  'ion-md': ionFn,
  'ion-ios': ionFn,
  'ion-logo': ionFn,
  'iconfont ': sameFn,
  'ti-': function ti(i) {
    return "themify-icon ".concat(i);
  },
  'bi-': function bi(i) {
    return "bootstrap-icons ".concat(i);
  }
};
var matMap = {
  o_: '-outlined',
  r_: '-round',
  s_: '-sharp'
};
var symMap = {
  sym_o_: '-outlined',
  sym_r_: '-rounded',
  sym_s_: '-sharp'
};
var libRE = new RegExp('^(' + Object.keys(libMap).join('|') + ')');
var matRE = new RegExp('^(' + Object.keys(matMap).join('|') + ')');
var symRE = new RegExp('^(' + Object.keys(symMap).join('|') + ')');
var mRE = /^[Mm]\s?[-+]?\.?\d/;
var imgRE = /^img:/;
var svgUseRE = /^svguse:/;
var ionRE = /^ion-/;
var faRE = /^(fa-(sharp|solid|regular|light|brands|duotone|thin)|[lf]a[srlbdk]?) /;
/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_14___default.a.extend({
  name: 'QIcon',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"], _mixins_size_js__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"], _mixins_tag_js__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]],
  props: {
    tag: {
      type: String,
      default: 'i'
    },
    name: String,
    color: String,
    left: Boolean,
    right: Boolean
  },
  computed: {
    classes: function classes() {
      return 'q-icon' + (this.left === true ? ' on-left' : '') + (this.right === true ? ' on-right' : '') + (this.color !== void 0 ? " text-".concat(this.color) : '');
    },
    type: function type() {
      var _this = this;
      var cls;
      var icon = this.name;
      if (icon === 'none' || !icon) {
        return {
          none: true
        };
      }
      if (this.$q.iconMapFn !== void 0) {
        var res = this.$q.iconMapFn(icon);
        if (res !== void 0) {
          if (res.icon !== void 0) {
            icon = res.icon;
            if (icon === 'none' || !icon) {
              return {
                none: true
              };
            }
          } else {
            return {
              cls: res.cls,
              content: res.content !== void 0 ? res.content : ' '
            };
          }
        }
      }
      if (mRE.test(icon) === true) {
        var _icon$split = icon.split('|'),
          _icon$split2 = Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_icon$split, 2),
          def = _icon$split2[0],
          _icon$split2$ = _icon$split2[1],
          viewBox = _icon$split2$ === void 0 ? defaultViewBox : _icon$split2$;
        return {
          svg: true,
          viewBox: viewBox,
          nodes: def.split('&&').map(function (path) {
            var _path$split = path.split('@@'),
              _path$split2 = Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_path$split, 3),
              d = _path$split2[0],
              style = _path$split2[1],
              transform = _path$split2[2];
            return _this.$createElement('path', {
              attrs: {
                d: d,
                transform: transform
              },
              style: style
            });
          })
        };
      }
      if (imgRE.test(icon) === true) {
        return {
          img: true,
          src: icon.substring(4)
        };
      }
      if (svgUseRE.test(icon) === true) {
        var _icon$split3 = icon.split('|'),
          _icon$split4 = Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_icon$split3, 2),
          _def = _icon$split4[0],
          _icon$split4$ = _icon$split4[1],
          _viewBox = _icon$split4$ === void 0 ? defaultViewBox : _icon$split4$;
        return {
          svguse: true,
          src: _def.substring(7),
          viewBox: _viewBox
        };
      }
      var content = ' ';
      var matches = icon.match(libRE);
      if (matches !== null) {
        cls = libMap[matches[1]](icon);
      } else if (faRE.test(icon) === true) {
        cls = icon;
      } else if (ionRE.test(icon) === true) {
        cls = "ionicons ion-".concat(this.$q.platform.is.ios === true ? 'ios' : 'md').concat(icon.substr(3));
      } else if (symRE.test(icon) === true) {
        // "notranslate" class is for Google Translate
        // to avoid tampering with Material Symbols ligature font
        //
        // Caution: To be able to add suffix to the class name,
        // keep the 'material-symbols' at the end of the string.
        cls = 'notranslate material-symbols';
        var _matches = icon.match(symRE);
        if (_matches !== null) {
          icon = icon.substring(6);
          cls += symMap[_matches[1]];
        }
        content = icon;
      } else {
        // "notranslate" class is for Google Translate
        // to avoid tampering with Material Icons ligature font
        //
        // Caution: To be able to add suffix to the class name,
        // keep the 'material-icons' at the end of the string.
        cls = 'notranslate material-icons';
        var _matches2 = icon.match(matRE);
        if (_matches2 !== null) {
          icon = icon.substring(2);
          cls += matMap[_matches2[1]];
        }
        content = icon;
      }
      return {
        cls: cls,
        content: content
      };
    }
  },
  render: function render(h) {
    var data = {
      class: this.classes,
      style: this.sizeStyle,
      on: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.qListeners),
      attrs: {
        'aria-hidden': 'true',
        role: 'presentation'
      }
    };
    if (this.type.none === true) {
      return h(this.tag, data, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_18__[/* slot */ "c"])(this, 'default'));
    }
    if (this.type.img === true) {
      return h('span', data, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_18__[/* mergeSlot */ "a"])([h('img', {
        attrs: {
          src: this.type.src
        }
      })], this, 'default'));
    }
    if (this.type.svg === true) {
      return h('span', data, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_18__[/* mergeSlot */ "a"])([h('svg', {
        attrs: {
          viewBox: this.type.viewBox || '0 0 24 24',
          focusable: 'false' /* needed for IE11 */
        }
      }, this.type.nodes)], this, 'default'));
    }
    if (this.type.svguse === true) {
      return h('span', data, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_18__[/* mergeSlot */ "a"])([h('svg', {
        attrs: {
          viewBox: this.type.viewBox,
          focusable: 'false' /* needed for IE11 */
        }
      }, [h('use', {
        attrs: {
          'xlink:href': this.type.src
        }
      })])], this, 'default'));
    }
    if (this.type.cls !== void 0) {
      data.class += ' ' + this.type.cls;
    }
    return h(this.tag, data, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_18__[/* mergeSlot */ "a"])([this.type.content], this, 'default'));
  }
}));

/***/ }),

/***/ "0094":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FREEZING = __webpack_require__("bb2f");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var defineBuiltIns = __webpack_require__("6964");
var InternalMetadataModule = __webpack_require__("f183");
var collection = __webpack_require__("6d61");
var collectionWeak = __webpack_require__("acac");
var isObject = __webpack_require__("861d");
var enforceInternalState = __webpack_require__("69f3").enforce;
var fails = __webpack_require__("d039");
var NATIVE_WEAK_MAP = __webpack_require__("cdce");

var $Object = Object;
// eslint-disable-next-line es/no-array-isarray -- safe
var isArray = Array.isArray;
// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible = $Object.isExtensible;
// eslint-disable-next-line es/no-object-isfrozen -- safe
var isFrozen = $Object.isFrozen;
// eslint-disable-next-line es/no-object-issealed -- safe
var isSealed = $Object.isSealed;
// eslint-disable-next-line es/no-object-freeze -- safe
var freeze = $Object.freeze;
// eslint-disable-next-line es/no-object-seal -- safe
var seal = $Object.seal;

var FROZEN = {};
var SEALED = {};
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var InternalWeakMap;

var wrapper = function (init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
};

// `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor
var $WeakMap = collection('WeakMap', wrapper, collectionWeak);
var WeakMapPrototype = $WeakMap.prototype;
var nativeSet = uncurryThis(WeakMapPrototype.set);

// Chakra Edge bug: adding frozen arrays to WeakMap unfreeze them
var hasMSEdgeFreezingBug = function () {
  return FREEZING && fails(function () {
    var frozenArray = freeze([]);
    nativeSet(new $WeakMap(), frozenArray, 1);
    return !isFrozen(frozenArray);
  });
};

// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP) if (IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.enable();
  var nativeDelete = uncurryThis(WeakMapPrototype['delete']);
  var nativeHas = uncurryThis(WeakMapPrototype.has);
  var nativeGet = uncurryThis(WeakMapPrototype.get);
  defineBuiltIns(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete(this, key) || state.frozen['delete'](key);
      } return nativeDelete(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) || state.frozen.has(key);
      } return nativeHas(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);
      } return nativeGet(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceInternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);
      } else nativeSet(this, key, value);
      return this;
    }
  });
// Chakra Edge frozen keys fix
} else if (hasMSEdgeFreezingBug()) {
  defineBuiltIns(WeakMapPrototype, {
    set: function set(key, value) {
      var arrayIntegrityLevel;
      if (isArray(key)) {
        if (isFrozen(key)) arrayIntegrityLevel = FROZEN;
        else if (isSealed(key)) arrayIntegrityLevel = SEALED;
      }
      nativeSet(this, key, value);
      if (arrayIntegrityLevel == FROZEN) freeze(key);
      if (arrayIntegrityLevel == SEALED) seal(key);
      return this;
    }
  });
}


/***/ }),

/***/ "00b1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlocks_vue_vue_type_style_index_0_id_7e42fd95_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("db4f");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlocks_vue_vue_type_style_index_0_id_7e42fd95_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlocks_vue_vue_type_style_index_0_id_7e42fd95_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "00b4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__("ac1f");
var $ = __webpack_require__("23e7");
var call = __webpack_require__("c65b");
var isCallable = __webpack_require__("1626");
var anObject = __webpack_require__("825a");
var toString = __webpack_require__("577e");

var DELEGATES_TO_EXEC = function () {
  var execCalled = false;
  var re = /[ac]/;
  re.exec = function () {
    execCalled = true;
    return /./.exec.apply(this, arguments);
  };
  return re.test('abc') === true && execCalled;
}();

var nativeTest = /./.test;

// `RegExp.prototype.test` method
// https://tc39.es/ecma262/#sec-regexp.prototype.test
$({ target: 'RegExp', proto: true, forced: !DELEGATES_TO_EXEC }, {
  test: function (S) {
    var R = anObject(this);
    var string = toString(S);
    var exec = R.exec;
    if (!isCallable(exec)) return call(nativeTest, R, string);
    var result = call(exec, R, string);
    if (result === null) return false;
    anObject(result);
    return true;
  }
});


/***/ }),

/***/ "00ee":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "0170":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5530");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("a9e3");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("87e8");
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("e277");





/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_2___default.a.extend({
  name: 'QItemLabel',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]],
  props: {
    overline: Boolean,
    caption: Boolean,
    header: Boolean,
    lines: [Number, String]
  },
  computed: {
    classes: function classes() {
      return {
        'q-item__label--overline text-overline': this.overline,
        'q-item__label--caption text-caption': this.caption,
        'q-item__label--header': this.header,
        'ellipsis': parseInt(this.lines, 10) === 1
      };
    },
    style: function style() {
      if (this.lines !== void 0 && parseInt(this.lines, 10) > 1) {
        return {
          overflow: 'hidden',
          display: '-webkit-box',
          '-webkit-box-orient': 'vertical',
          '-webkit-line-clamp': this.lines
        };
      }
    }
  },
  render: function render(h) {
    return h('div', {
      staticClass: 'q-item__label',
      style: this.style,
      class: this.classes,
      on: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.qListeners)
    }, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_4__[/* slot */ "c"])(this, 'default'));
  }
}));

/***/ }),

/***/ "01b4":
/***/ (function(module, exports) {

var Queue = function () {
  this.head = null;
  this.tail = null;
};

Queue.prototype = {
  add: function (item) {
    var entry = { item: item, next: null };
    var tail = this.tail;
    if (tail) tail.next = entry;
    else this.head = entry;
    this.tail = entry;
  },
  get: function () {
    var entry = this.head;
    if (entry) {
      var next = this.head = entry.next;
      if (next === null) this.tail = null;
      return entry.item;
    }
  }
};

module.exports = Queue;


/***/ }),

/***/ "0209":
/***/ (function(module, exports) {

/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function lookahead(re) {
  return concat('(?=', re, ')');
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function optional(re) {
  return concat('(', re, ')?');
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}

/*
Language: C++
Category: common, system
Website: https://isocpp.org
*/

/** @type LanguageFn */
function cpp(hljs) {
  // added for historic reasons because `hljs.C_LINE_COMMENT_MODE` does
  // not include such support nor can we be sure all the grammars depending
  // on it would desire this behavior
  const C_LINE_COMMENT_MODE = hljs.COMMENT('//', '$', {
    contains: [
      {
        begin: /\\\n/
      }
    ]
  });
  const DECLTYPE_AUTO_RE = 'decltype\\(auto\\)';
  const NAMESPACE_RE = '[a-zA-Z_]\\w*::';
  const TEMPLATE_ARGUMENT_RE = '<[^<>]+>';
  const FUNCTION_TYPE_RE = '(' +
    DECLTYPE_AUTO_RE + '|' +
    optional(NAMESPACE_RE) +
    '[a-zA-Z_]\\w*' + optional(TEMPLATE_ARGUMENT_RE) +
  ')';
  const CPP_PRIMITIVE_TYPES = {
    className: 'keyword',
    begin: '\\b[a-z\\d_]*_t\\b'
  };

  // https://en.cppreference.com/w/cpp/language/escape
  // \\ \x \xFF \u2837 \u00323747 \374
  const CHARACTER_ESCAPES = '\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)';
  const STRINGS = {
    className: 'string',
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: '\\n',
        contains: [ hljs.BACKSLASH_ESCAPE ]
      },
      {
        begin: '(u8?|U|L)?\'(' + CHARACTER_ESCAPES + "|.)",
        end: '\'',
        illegal: '.'
      },
      hljs.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  };

  const NUMBERS = {
    className: 'number',
    variants: [
      {
        begin: '\\b(0b[01\']+)'
      },
      {
        begin: '(-?)\\b([\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)'
      },
      {
        begin: '(-?)(\\b0[xX][a-fA-F0-9\']+|(\\b[\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)([eE][-+]?[\\d\']+)?)'
      }
    ],
    relevance: 0
  };

  const PREPROCESSOR = {
    className: 'meta',
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: {
      'meta-keyword':
        'if else elif endif define undef warning error line ' +
        'pragma _Pragma ifdef ifndef include'
    },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      hljs.inherit(STRINGS, {
        className: 'meta-string'
      }),
      {
        className: 'meta-string',
        begin: /<.*?>/
      },
      C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE
    ]
  };

  const TITLE_MODE = {
    className: 'title',
    begin: optional(NAMESPACE_RE) + hljs.IDENT_RE,
    relevance: 0
  };

  const FUNCTION_TITLE = optional(NAMESPACE_RE) + hljs.IDENT_RE + '\\s*\\(';

  const COMMON_CPP_HINTS = [
    'asin',
    'atan2',
    'atan',
    'calloc',
    'ceil',
    'cosh',
    'cos',
    'exit',
    'exp',
    'fabs',
    'floor',
    'fmod',
    'fprintf',
    'fputs',
    'free',
    'frexp',
    'auto_ptr',
    'deque',
    'list',
    'queue',
    'stack',
    'vector',
    'map',
    'set',
    'pair',
    'bitset',
    'multiset',
    'multimap',
    'unordered_set',
    'fscanf',
    'future',
    'isalnum',
    'isalpha',
    'iscntrl',
    'isdigit',
    'isgraph',
    'islower',
    'isprint',
    'ispunct',
    'isspace',
    'isupper',
    'isxdigit',
    'tolower',
    'toupper',
    'labs',
    'ldexp',
    'log10',
    'log',
    'malloc',
    'realloc',
    'memchr',
    'memcmp',
    'memcpy',
    'memset',
    'modf',
    'pow',
    'printf',
    'putchar',
    'puts',
    'scanf',
    'sinh',
    'sin',
    'snprintf',
    'sprintf',
    'sqrt',
    'sscanf',
    'strcat',
    'strchr',
    'strcmp',
    'strcpy',
    'strcspn',
    'strlen',
    'strncat',
    'strncmp',
    'strncpy',
    'strpbrk',
    'strrchr',
    'strspn',
    'strstr',
    'tanh',
    'tan',
    'unordered_map',
    'unordered_multiset',
    'unordered_multimap',
    'priority_queue',
    'make_pair',
    'array',
    'shared_ptr',
    'abort',
    'terminate',
    'abs',
    'acos',
    'vfprintf',
    'vprintf',
    'vsprintf',
    'endl',
    'initializer_list',
    'unique_ptr',
    'complex',
    'imaginary',
    'std',
    'string',
    'wstring',
    'cin',
    'cout',
    'cerr',
    'clog',
    'stdin',
    'stdout',
    'stderr',
    'stringstream',
    'istringstream',
    'ostringstream'
  ];

  const CPP_KEYWORDS = {
    keyword: 'int float while private char char8_t char16_t char32_t catch import module export virtual operator sizeof ' +
      'dynamic_cast|10 typedef const_cast|10 const for static_cast|10 union namespace ' +
      'unsigned long volatile static protected bool template mutable if public friend ' +
      'do goto auto void enum else break extern using asm case typeid wchar_t ' +
      'short reinterpret_cast|10 default double register explicit signed typename try this ' +
      'switch continue inline delete alignas alignof constexpr consteval constinit decltype ' +
      'concept co_await co_return co_yield requires ' +
      'noexcept static_assert thread_local restrict final override ' +
      'atomic_bool atomic_char atomic_schar ' +
      'atomic_uchar atomic_short atomic_ushort atomic_int atomic_uint atomic_long atomic_ulong atomic_llong ' +
      'atomic_ullong new throw return ' +
      'and and_eq bitand bitor compl not not_eq or or_eq xor xor_eq',
    built_in: '_Bool _Complex _Imaginary',
    _relevance_hints: COMMON_CPP_HINTS,
    literal: 'true false nullptr NULL'
  };

  const FUNCTION_DISPATCH = {
    className: "function.dispatch",
    relevance: 0,
    keywords: CPP_KEYWORDS,
    begin: concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!while)/,
      hljs.IDENT_RE,
      lookahead(/\s*\(/))
  };

  const EXPRESSION_CONTAINS = [
    FUNCTION_DISPATCH,
    PREPROCESSOR,
    CPP_PRIMITIVE_TYPES,
    C_LINE_COMMENT_MODE,
    hljs.C_BLOCK_COMMENT_MODE,
    NUMBERS,
    STRINGS
  ];


  const EXPRESSION_CONTEXT = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: 'new throw return else',
        end: /;/
      }
    ],
    keywords: CPP_KEYWORDS,
    contains: EXPRESSION_CONTAINS.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: CPP_KEYWORDS,
        contains: EXPRESSION_CONTAINS.concat([ 'self' ]),
        relevance: 0
      }
    ]),
    relevance: 0
  };

  const FUNCTION_DECLARATION = {
    className: 'function',
    begin: '(' + FUNCTION_TYPE_RE + '[\\*&\\s]+)+' + FUNCTION_TITLE,
    returnBegin: true,
    end: /[{;=]/,
    excludeEnd: true,
    keywords: CPP_KEYWORDS,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      { // to prevent it from being confused as the function title
        begin: DECLTYPE_AUTO_RE,
        keywords: CPP_KEYWORDS,
        relevance: 0
      },
      {
        begin: FUNCTION_TITLE,
        returnBegin: true,
        contains: [ TITLE_MODE ],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: true,
        contains: [
          STRINGS,
          NUMBERS
        ]
      },
      {
        className: 'params',
        begin: /\(/,
        end: /\)/,
        keywords: CPP_KEYWORDS,
        relevance: 0,
        contains: [
          C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          STRINGS,
          NUMBERS,
          CPP_PRIMITIVE_TYPES,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: CPP_KEYWORDS,
            relevance: 0,
            contains: [
              'self',
              C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE,
              STRINGS,
              NUMBERS,
              CPP_PRIMITIVE_TYPES
            ]
          }
        ]
      },
      CPP_PRIMITIVE_TYPES,
      C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      PREPROCESSOR
    ]
  };

  return {
    name: 'C++',
    aliases: [
      'cc',
      'c++',
      'h++',
      'hpp',
      'hh',
      'hxx',
      'cxx'
    ],
    keywords: CPP_KEYWORDS,
    illegal: '</',
    classNameAliases: {
      "function.dispatch": "built_in"
    },
    contains: [].concat(
      EXPRESSION_CONTEXT,
      FUNCTION_DECLARATION,
      FUNCTION_DISPATCH,
      EXPRESSION_CONTAINS,
      [
        PREPROCESSOR,
        { // containers: ie, `vector <int> rooms (9);`
          begin: '\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<',
          end: '>',
          keywords: CPP_KEYWORDS,
          contains: [
            'self',
            CPP_PRIMITIVE_TYPES
          ]
        },
        {
          begin: hljs.IDENT_RE + '::',
          keywords: CPP_KEYWORDS
        },
        {
          className: 'class',
          beginKeywords: 'enum class struct union',
          end: /[{;:<>=]/,
          contains: [
            {
              beginKeywords: "final class struct"
            },
            hljs.TITLE_MODE
          ]
        }
      ]),
    exports: {
      preprocessor: PREPROCESSOR,
      strings: STRINGS,
      keywords: CPP_KEYWORDS
    }
  };
}

module.exports = cpp;


/***/ }),

/***/ "0366":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("4625");
var aCallable = __webpack_require__("59ed");
var NATIVE_BIND = __webpack_require__("40d5");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "0402":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var setTask = __webpack_require__("2cf4").set;
var schedulersFix = __webpack_require__("20cc");

// https://github.com/oven-sh/bun/issues/1633
var setImmediate = global.setImmediate ? schedulersFix(setTask, false) : setTask;

// `setImmediate` method
// http://w3c.github.io/setImmediate/#si-setImmediate
$({ global: true, bind: true, enumerable: true, forced: global.setImmediate !== setImmediate }, {
  setImmediate: setImmediate
});


/***/ }),

/***/ "0481":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var flattenIntoArray = __webpack_require__("a2bf");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");
var toIntegerOrInfinity = __webpack_require__("5926");
var arraySpeciesCreate = __webpack_require__("65f0");

// `Array.prototype.flat` method
// https://tc39.es/ecma262/#sec-array.prototype.flat
$({ target: 'Array', proto: true }, {
  flat: function flat(/* depthArg = 1 */) {
    var depthArg = arguments.length ? arguments[0] : undefined;
    var O = toObject(this);
    var sourceLen = lengthOfArrayLike(O);
    var A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toIntegerOrInfinity(depthArg));
    return A;
  }
});


/***/ }),

/***/ "04d1":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");

var firefox = userAgent.match(/firefox\/(\d+)/i);

module.exports = !!firefox && +firefox[1];


/***/ }),

/***/ "04f8":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__("2d00");
var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "0538":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__("e330");
var aCallable = __webpack_require__("59ed");
var isObject = __webpack_require__("861d");
var hasOwn = __webpack_require__("1a2d");
var arraySlice = __webpack_require__("f36a");
var NATIVE_BIND = __webpack_require__("40d5");

var $Function = Function;
var concat = uncurryThis([].concat);
var join = uncurryThis([].join);
var factories = {};

var construct = function (C, argsLength, args) {
  if (!hasOwn(factories, argsLength)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
// eslint-disable-next-line es/no-function-prototype-bind -- detection
module.exports = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */) {
  var F = aCallable(this);
  var Prototype = F.prototype;
  var partArgs = arraySlice(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = concat(partArgs, arraySlice(arguments));
    return this instanceof boundFunction ? construct(F, args.length, args) : F.apply(that, args);
  };
  if (isObject(Prototype)) boundFunction.prototype = Prototype;
  return boundFunction;
};


/***/ }),

/***/ "057f":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__("c6b6");
var toIndexedObject = __webpack_require__("fc6a");
var $getOwnPropertyNames = __webpack_require__("241c").f;
var arraySlice = __webpack_require__("4dae");

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) == 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "05c0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5530");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("a9e3");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_string_anchor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("18a5");
/* harmony import */ var core_js_modules_es_string_anchor_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_anchor_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("d81d");
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _mixins_anchor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("c474");
/* harmony import */ var _mixins_timeout_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("463c");
/* harmony import */ var _mixins_model_toggle_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("7ee0");
/* harmony import */ var _mixins_portal_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("9e62");
/* harmony import */ var _mixins_transition_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("7562");
/* harmony import */ var _utils_scroll_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("0831");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("d882");
/* harmony import */ var _utils_private_selection_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("f249");
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("e277");
/* harmony import */ var _utils_private_position_engine_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("2f79");















var attrs = {
  role: 'tooltip'
};
/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_4___default.a.extend({
  name: 'QTooltip',
  mixins: [_mixins_anchor_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], _mixins_timeout_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"], _mixins_model_toggle_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"], _mixins_portal_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "b"], _mixins_transition_js__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"]],
  props: {
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    },
    transitionShow: {
      default: 'jump-down'
    },
    transitionHide: {
      default: 'jump-up'
    },
    anchor: {
      type: String,
      default: 'bottom middle',
      validator: _utils_private_position_engine_js__WEBPACK_IMPORTED_MODULE_14__[/* validatePosition */ "d"]
    },
    self: {
      type: String,
      default: 'top middle',
      validator: _utils_private_position_engine_js__WEBPACK_IMPORTED_MODULE_14__[/* validatePosition */ "d"]
    },
    offset: {
      type: Array,
      default: function _default() {
        return [14, 14];
      },
      validator: _utils_private_position_engine_js__WEBPACK_IMPORTED_MODULE_14__[/* validateOffset */ "c"]
    },
    scrollTarget: {
      default: void 0
    },
    delay: {
      type: Number,
      default: 0
    },
    hideDelay: {
      type: Number,
      default: 0
    }
  },
  computed: {
    anchorOrigin: function anchorOrigin() {
      return Object(_utils_private_position_engine_js__WEBPACK_IMPORTED_MODULE_14__[/* parsePosition */ "a"])(this.anchor, this.$q.lang.rtl);
    },
    selfOrigin: function selfOrigin() {
      return Object(_utils_private_position_engine_js__WEBPACK_IMPORTED_MODULE_14__[/* parsePosition */ "a"])(this.self, this.$q.lang.rtl);
    },
    hideOnRouteChange: function hideOnRouteChange() {
      return this.persistent !== true;
    }
  },
  methods: {
    __show: function __show(evt) {
      var _this = this;
      this.__showPortal();
      this.__registerTick(function () {
        _this.observer = new MutationObserver(function () {
          return _this.updatePosition();
        });
        _this.observer.observe(_this.__portal.$el, {
          attributes: false,
          childList: true,
          characterData: true,
          subtree: true
        });
        _this.updatePosition();
        _this.__configureScrollTarget();
      });
      if (this.unwatch === void 0) {
        this.unwatch = this.$watch(function () {
          return _this.$q.screen.width + '|' + _this.$q.screen.height + '|' + _this.self + '|' + _this.anchor + '|' + _this.$q.lang.rtl;
        }, this.updatePosition);
      }

      // should __removeTimeout() if this gets removed
      this.__registerTimeout(function () {
        _this.__showPortal(true);
        _this.$emit('show', evt);
      }, 300);
    },
    __hide: function __hide(evt) {
      var _this2 = this;
      this.__removeTick();
      this.__anchorCleanup();
      this.__hidePortal();

      // should __removeTimeout() if this gets removed
      this.__registerTimeout(function () {
        _this2.__hidePortal(true); // done hiding, now destroy
        _this2.$emit('hide', evt);
      }, 300);
    },
    __anchorCleanup: function __anchorCleanup() {
      if (this.observer !== void 0) {
        this.observer.disconnect();
        this.observer = void 0;
      }
      if (this.unwatch !== void 0) {
        this.unwatch();
        this.unwatch = void 0;
      }
      this.__unconfigureScrollTarget();
      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_11__[/* cleanEvt */ "b"])(this, 'tooltipTemp');
    },
    updatePosition: function updatePosition() {
      if (this.anchorEl === void 0 || this.__portal === void 0) {
        return;
      }
      var el = this.__portal.$el;
      if (el.nodeType === 8) {
        // IE replaces the comment with delay
        setTimeout(this.updatePosition, 25);
        return;
      }
      Object(_utils_private_position_engine_js__WEBPACK_IMPORTED_MODULE_14__[/* setPosition */ "b"])({
        el: el,
        offset: this.offset,
        anchorEl: this.anchorEl,
        anchorOrigin: this.anchorOrigin,
        selfOrigin: this.selfOrigin,
        maxHeight: this.maxHeight,
        maxWidth: this.maxWidth
      });
    },
    __delayShow: function __delayShow(evt) {
      var _this3 = this;
      if (this.$q.platform.is.mobile === true) {
        Object(_utils_private_selection_js__WEBPACK_IMPORTED_MODULE_12__[/* clearSelection */ "a"])();
        document.body.classList.add('non-selectable');
        var target = this.anchorEl;
        var evts = ['touchmove', 'touchcancel', 'touchend', 'click'].map(function (e) {
          return [target, e, '__delayHide', 'passiveCapture'];
        });
        Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_11__[/* addEvt */ "a"])(this, 'tooltipTemp', evts);
      }
      this.__registerTimeout(function () {
        _this3.show(evt);
      }, this.delay);
    },
    __delayHide: function __delayHide(evt) {
      var _this4 = this;
      if (this.$q.platform.is.mobile === true) {
        Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_11__[/* cleanEvt */ "b"])(this, 'tooltipTemp');
        Object(_utils_private_selection_js__WEBPACK_IMPORTED_MODULE_12__[/* clearSelection */ "a"])();
        // delay needed otherwise selection still occurs
        setTimeout(function () {
          document.body.classList.remove('non-selectable');
        }, 10);
      }

      // should __removeTimeout() if this gets removed
      this.__registerTimeout(function () {
        _this4.hide(evt);
      }, this.hideDelay);
    },
    __configureAnchorEl: function __configureAnchorEl() {
      if (this.noParentEvent === true || this.anchorEl === void 0) {
        return;
      }
      var evts = this.$q.platform.is.mobile === true ? [[this.anchorEl, 'touchstart', '__delayShow', 'passive']] : [[this.anchorEl, 'mouseenter', '__delayShow', 'passive'], [this.anchorEl, 'mouseleave', '__delayHide', 'passive']];
      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_11__[/* addEvt */ "a"])(this, 'anchor', evts);
    },
    __unconfigureScrollTarget: function __unconfigureScrollTarget() {
      if (this.__scrollTarget !== void 0) {
        this.__changeScrollEvent(this.__scrollTarget);
        this.__scrollTarget = void 0;
      }
    },
    __configureScrollTarget: function __configureScrollTarget() {
      if (this.anchorEl !== void 0 || this.scrollTarget !== void 0) {
        this.__scrollTarget = Object(_utils_scroll_js__WEBPACK_IMPORTED_MODULE_10__[/* getScrollTarget */ "c"])(this.anchorEl, this.scrollTarget);
        var fn = this.noParentEvent === true ? this.updatePosition : this.hide;
        this.__changeScrollEvent(this.__scrollTarget, fn);
      }
    },
    __renderPortal: function __renderPortal(h) {
      return h('transition', {
        props: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.transitionProps)
      }, [this.showing === true ? h('div', {
        staticClass: 'q-tooltip q-tooltip--style q-position-engine no-pointer-events',
        class: this.contentClass,
        style: this.contentStyle,
        attrs: attrs
      }, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_13__[/* slot */ "c"])(this, 'default')) : null]);
    }
  },
  created: function created() {
    this.__useTick('__registerTick', '__removeTick');
    this.__useTimeout('__registerTimeout');
  },
  mounted: function mounted() {
    this.__processModelChange(this.value);
  }
}));

/***/ }),

/***/ "0680":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = __webpack_require__("7037").default;
__webpack_require__("c73d");
/*!
 * Quasar Framework v1.22.10
 * (c) 2015-present Razvan Stoenescu
 * Released under the MIT License.
 */
!function (e, a) {
  "object" == ( false ? undefined : _typeof(exports)) && "undefined" != typeof module ? module.exports = a() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (a),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
}(this, function () {
  "use strict";

  return {
    isoName: "en-gb",
    nativeName: "English (UK)",
    label: {
      clear: "Clear",
      ok: "OK",
      cancel: "Cancel",
      close: "Close",
      set: "Set",
      select: "Select",
      reset: "Reset",
      remove: "Remove",
      update: "Update",
      create: "Create",
      search: "Search",
      filter: "Filter",
      refresh: "Refresh",
      expand: function expand(e) {
        return e ? 'Expand "' + e + '"' : "Expand";
      },
      collapse: function collapse(e) {
        return e ? 'Collapse "' + e + '"' : "Collapse";
      }
    },
    date: {
      days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
      daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      firstDayOfWeek: 1,
      format24h: !0,
      pluralDay: "days"
    },
    table: {
      noData: "No data available",
      noResults: "No matching records found",
      loading: "Loading...",
      selectedRecords: function selectedRecords(e) {
        return 1 === e ? "1 record selected." : (0 === e ? "No" : e) + " records selected.";
      },
      recordsPerPage: "Records per page:",
      allRows: "All",
      pagination: function pagination(e, a, n) {
        return e + "-" + a + " of " + n;
      },
      columns: "Columns"
    },
    editor: {
      url: "URL",
      bold: "Bold",
      italic: "Italic",
      strikethrough: "Strikethrough",
      underline: "Underline",
      unorderedList: "Unordered List",
      orderedList: "Ordered List",
      subscript: "Subscript",
      superscript: "Superscript",
      hyperlink: "Hyperlink",
      toggleFullscreen: "Toggle Fullscreen",
      quote: "Quote",
      left: "Left align",
      center: "Center align",
      right: "Right align",
      justify: "Justify align",
      print: "Print",
      outdent: "Decrease indentation",
      indent: "Increase indentation",
      removeFormat: "Remove formatting",
      formatting: "Formatting",
      fontSize: "Font Size",
      align: "Align",
      hr: "Insert Horizontal Rule",
      undo: "Undo",
      redo: "Redo",
      heading1: "Heading 1",
      heading2: "Heading 2",
      heading3: "Heading 3",
      heading4: "Heading 4",
      heading5: "Heading 5",
      heading6: "Heading 6",
      paragraph: "Paragraph",
      code: "Code",
      size1: "Very small",
      size2: "A bit small",
      size3: "Normal",
      size4: "Medium-large",
      size5: "Big",
      size6: "Very big",
      size7: "Maximum",
      defaultFont: "Default Font",
      viewSource: "View Source"
    },
    tree: {
      noNodes: "No nodes available",
      noResults: "No matching nodes found"
    }
  };
});

/***/ }),

/***/ "06c5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _unsupportedIterableToArray; });
/* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fb6a");
/* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("25f0");
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("b0c0");
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_array_from_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("a630");
/* harmony import */ var core_js_modules_es_array_from_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_from_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("3ca3");
/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("ac1f");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_regexp_test_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("00b4");
/* harmony import */ var core_js_modules_es_regexp_test_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_test_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("6b75");









function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Object(_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(o, minLen);
}

/***/ }),

/***/ "06cf":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var call = __webpack_require__("c65b");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var createPropertyDescriptor = __webpack_require__("5c6c");
var toIndexedObject = __webpack_require__("fc6a");
var toPropertyKey = __webpack_require__("a04b");
var hasOwn = __webpack_require__("1a2d");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "07fa":
/***/ (function(module, exports, __webpack_require__) {

var toLength = __webpack_require__("50c4");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "0831":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return rtlHasScrollBug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getScrollTarget; });
/* unused harmony export getScrollHeight */
/* unused harmony export getScrollWidth */
/* unused harmony export getVerticalScrollPosition */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getScrollPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getHorizontalScrollPosition; });
/* unused harmony export animVerticalScrollTo */
/* unused harmony export animScrollTo */
/* unused harmony export animHorizontalScrollTo */
/* unused harmony export setVerticalScrollPosition */
/* unused harmony export setScrollPosition */
/* unused harmony export setHorizontalScrollPosition */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getScrollbarWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return hasScrollbar; });
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("cca6");
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("caad");
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("2532");
/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("0967");
/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("f303");





var scrollTargets = _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_3__[/* isSSR */ "e"] === true ? [] : [null, document, document.body, document.scrollingElement, document.documentElement];
var rtlHasScrollBugStatus;
function rtlHasScrollBug() {
  if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_3__[/* isSSR */ "e"] === true) {
    return false;
  }
  if (rtlHasScrollBugStatus === void 0) {
    var scroller = document.createElement('div');
    var spacer = document.createElement('div');
    Object.assign(scroller.style, {
      direction: 'rtl',
      width: '1px',
      height: '1px',
      overflow: 'auto'
    });
    Object.assign(spacer.style, {
      width: '1000px',
      height: '1px'
    });
    scroller.appendChild(spacer);
    document.body.appendChild(scroller);
    scroller.scrollLeft = -1000;
    rtlHasScrollBugStatus = scroller.scrollLeft >= 0;
    scroller.remove();
  }
  return rtlHasScrollBugStatus;
}
function getScrollTarget(el, targetEl) {
  var target = Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__[/* getElement */ "d"])(targetEl);
  if (target === null) {
    if (el !== Object(el) || typeof el.closest !== 'function') {
      return window;
    }
    target = el.closest('.scroll,.scroll-y,.overflow-auto');
  }
  return scrollTargets.includes(target) ? window : target;
}
function getScrollHeight(el) {
  return (el === window ? document.body : el).scrollHeight;
}
function getScrollWidth(el) {
  return (el === window ? document.body : el).scrollWidth;
}
function getVerticalScrollPosition(scrollTarget) {
  return scrollTarget === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : scrollTarget.scrollTop;
}
var getScrollPosition = getVerticalScrollPosition;
function getHorizontalScrollPosition(scrollTarget) {
  return scrollTarget === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : scrollTarget.scrollLeft;
}
function animVerticalScrollTo(el, to) {
  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var prevTime = arguments[3] === void 0 ? performance.now() : arguments[3];
  var pos = getVerticalScrollPosition(el);
  if (duration <= 0) {
    if (pos !== to) {
      setScroll(el, to);
    }
    return;
  }
  requestAnimationFrame(function (nowTime) {
    var frameTime = nowTime - prevTime;
    var newPos = pos + (to - pos) / Math.max(frameTime, duration) * frameTime;
    setScroll(el, newPos);
    if (newPos !== to) {
      animVerticalScrollTo(el, to, duration - frameTime, nowTime);
    }
  });
}
var animScrollTo = animVerticalScrollTo;
function animHorizontalScrollTo(el, to) {
  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var prevTime = arguments[3] === void 0 ? performance.now() : arguments[3];
  var pos = getHorizontalScrollPosition(el);
  if (duration <= 0) {
    if (pos !== to) {
      setHorizontalScroll(el, to);
    }
    return;
  }
  requestAnimationFrame(function (nowTime) {
    var frameTime = nowTime - prevTime;
    var newPos = pos + (to - pos) / Math.max(frameTime, duration) * frameTime;
    setHorizontalScroll(el, newPos);
    if (newPos !== to) {
      animHorizontalScrollTo(el, to, duration - frameTime, nowTime);
    }
  });
}
function setScroll(scrollTarget, offset) {
  if (scrollTarget === window) {
    window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, offset);
    return;
  }
  scrollTarget.scrollTop = offset;
}
function setHorizontalScroll(scrollTarget, offset) {
  if (scrollTarget === window) {
    window.scrollTo(offset, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
    return;
  }
  scrollTarget.scrollLeft = offset;
}
function setVerticalScrollPosition(scrollTarget, offset, duration) {
  if (duration) {
    animVerticalScrollTo(scrollTarget, offset, duration);
    return;
  }
  setScroll(scrollTarget, offset);
}
var setScrollPosition = setVerticalScrollPosition;
function setHorizontalScrollPosition(scrollTarget, offset, duration) {
  if (duration) {
    animHorizontalScrollTo(scrollTarget, offset, duration);
    return;
  }
  setHorizontalScroll(scrollTarget, offset);
}
var size;
function getScrollbarWidth() {
  if (size !== void 0) {
    return size;
  }
  var inner = document.createElement('p'),
    outer = document.createElement('div');
  Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__[/* css */ "b"])(inner, {
    width: '100%',
    height: '200px'
  });
  Object(_dom_js__WEBPACK_IMPORTED_MODULE_4__[/* css */ "b"])(outer, {
    position: 'absolute',
    top: '0px',
    left: '0px',
    visibility: 'hidden',
    width: '200px',
    height: '150px',
    overflow: 'hidden'
  });
  outer.appendChild(inner);
  document.body.appendChild(outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  var w2 = inner.offsetWidth;
  if (w1 === w2) {
    w2 = outer.clientWidth;
  }
  outer.remove();
  size = w1 - w2;
  return size;
}
function hasScrollbar(el) {
  var onY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (!el || el.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  return onY ? el.scrollHeight > el.clientHeight && (el.classList.contains('scroll') || el.classList.contains('overflow-auto') || ['auto', 'scroll'].includes(window.getComputedStyle(el)['overflow-y'])) : el.scrollWidth > el.clientWidth && (el.classList.contains('scroll') || el.classList.contains('overflow-auto') || ['auto', 'scroll'].includes(window.getComputedStyle(el)['overflow-x']));
}
/* unused harmony default export */ var _unused_webpack_default_export = ({
  getScrollTarget: getScrollTarget,
  getScrollHeight: getScrollHeight,
  getScrollWidth: getScrollWidth,
  getScrollPosition: getScrollPosition,
  getVerticalScrollPosition: getVerticalScrollPosition,
  getHorizontalScrollPosition: getHorizontalScrollPosition,
  rtlHasScrollBug: rtlHasScrollBug,
  animScrollTo: animScrollTo,
  animVerticalScrollTo: animVerticalScrollTo,
  animHorizontalScrollTo: animHorizontalScrollTo,
  setScrollPosition: setScrollPosition,
  setVerticalScrollPosition: setVerticalScrollPosition,
  setHorizontalScrollPosition: setHorizontalScrollPosition,
  getScrollbarWidth: getScrollbarWidth,
  hasScrollbar: hasScrollbar
});

/***/ }),

/***/ "083a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var tryToString = __webpack_require__("0d51");

var $TypeError = TypeError;

module.exports = function (O, P) {
  if (!delete O[P]) throw $TypeError('Cannot delete property ' + tryToString(P) + ' of ' + tryToString(O));
};


/***/ }),

/***/ "08a0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_Terminal_vue_vue_type_style_index_0_id_2ec5dfe0_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("bcd4");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_Terminal_vue_vue_type_style_index_0_id_2ec5dfe0_prod_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_7_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_7_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_7_oneOf_1_2_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_Terminal_vue_vue_type_style_index_0_id_2ec5dfe0_prod_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "0967":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isSSR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return fromSSR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return onSSR; });
/* unused harmony export iosEmulated */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return iosCorrection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return client; });
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ade3");
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("5530");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("ac1f");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("cca6");
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("b0c0");
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_web_self_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("c73d");
/* harmony import */ var core_js_modules_web_self_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_self_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("14d9");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_7__);







/* eslint-disable no-useless-escape */
/* eslint-disable no-unused-expressions */
/* eslint-disable no-mixed-operators */


var isSSR = typeof window === 'undefined';
var fromSSR = false;
var onSSR = isSSR;
var iosEmulated = false;
var iosCorrection;
function getMatch(userAgent, platformMatch) {
  var match = /(edge|edga|edgios)\/([\w.]+)/.exec(userAgent) || /(opr)[\/]([\w.]+)/.exec(userAgent) || /(vivaldi)[\/]([\w.]+)/.exec(userAgent) || /(chrome|crios)[\/]([\w.]+)/.exec(userAgent) || /(iemobile)[\/]([\w.]+)/.exec(userAgent) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent) || /(firefox|fxios)[\/]([\w.]+)/.exec(userAgent) || /(webkit)[\/]([\w.]+)/.exec(userAgent) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(userAgent) || /(msie) ([\w.]+)/.exec(userAgent) || userAgent.indexOf('trident') >= 0 && /(rv)(?::| )([\w.]+)/.exec(userAgent) || userAgent.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(userAgent) || [];
  return {
    browser: match[5] || match[3] || match[1] || '',
    version: match[2] || match[4] || '0',
    versionNumber: match[4] || match[2] || '0',
    platform: platformMatch[0] || ''
  };
}
function getPlatformMatch(userAgent) {
  return /(ipad)/.exec(userAgent) || /(ipod)/.exec(userAgent) || /(windows phone)/.exec(userAgent) || /(iphone)/.exec(userAgent) || /(kindle)/.exec(userAgent) || /(silk)/.exec(userAgent) || /(android)/.exec(userAgent) || /(win)/.exec(userAgent) || /(mac)/.exec(userAgent) || /(linux)/.exec(userAgent) || /(cros)/.exec(userAgent) || /(playbook)/.exec(userAgent) || /(bb)/.exec(userAgent) || /(blackberry)/.exec(userAgent) || [];
}
var hasTouch = isSSR === false ? 'ontouchstart' in window || window.navigator.maxTouchPoints > 0 : false;
function applyIosCorrection(is) {
  iosCorrection = {
    is: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({}, is)
  };
  delete is.mac;
  delete is.desktop;
  var platform = Math.min(window.innerHeight, window.innerWidth) > 414 ? 'ipad' : 'iphone';
  Object.assign(is, Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({
    mobile: true,
    ios: true,
    platform: platform
  }, platform, true));
}
function getPlatform(UA) {
  var userAgent = UA.toLowerCase(),
    platformMatch = getPlatformMatch(userAgent),
    matched = getMatch(userAgent, platformMatch),
    browser = {};
  if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
    browser.versionNumber = parseInt(matched.versionNumber, 10);
  }
  if (matched.platform) {
    browser[matched.platform] = true;
  }
  var knownMobiles = browser.android || browser.ios || browser.bb || browser.blackberry || browser.ipad || browser.iphone || browser.ipod || browser.kindle || browser.playbook || browser.silk || browser['windows phone'];

  // These are all considered mobile platforms, meaning they run a mobile browser
  if (knownMobiles === true || userAgent.indexOf('mobile') > -1) {
    browser.mobile = true;
    if (browser.edga || browser.edgios) {
      browser.edge = true;
      matched.browser = 'edge';
    } else if (browser.crios) {
      browser.chrome = true;
      matched.browser = 'chrome';
    } else if (browser.fxios) {
      browser.firefox = true;
      matched.browser = 'firefox';
    }
  }
  // If it's not mobile we should consider it's desktop platform, meaning it runs a desktop browser
  // It's a workaround for anonymized user agents
  // (browser.cros || browser.mac || browser.linux || browser.win)
  else {
    browser.desktop = true;
  }

  // Set iOS if on iPod, iPad or iPhone
  if (browser.ipod || browser.ipad || browser.iphone) {
    browser.ios = true;
  }
  if (browser['windows phone']) {
    browser.winphone = true;
    delete browser['windows phone'];
  }

  // Chrome, Opera 15+, Vivaldi and Safari are webkit based browsers
  if (browser.chrome || browser.opr || browser.safari || browser.vivaldi ||
  // we expect unknown, non iOS mobile browsers to be webkit based

  browser.mobile === true && browser.ios !== true && knownMobiles !== true) {
    browser.webkit = true;
  }

  // IE11 has a new token so we will assign it msie to avoid breaking changes
  if (browser.rv || browser.iemobile) {
    matched.browser = 'ie';
    browser.ie = true;
  }

  // Blackberry browsers are marked as Safari on BlackBerry
  if (browser.safari && browser.blackberry || browser.bb) {
    matched.browser = 'blackberry';
    browser.blackberry = true;
  }

  // Playbook browsers are marked as Safari on Playbook
  if (browser.safari && browser.playbook) {
    matched.browser = 'playbook';
    browser.playbook = true;
  }

  // Opera 15+ are identified as opr
  if (browser.opr) {
    matched.browser = 'opera';
    browser.opera = true;
  }

  // Stock Android browsers are marked as Safari on Android.
  if (browser.safari && browser.android) {
    matched.browser = 'android';
    browser.android = true;
  }

  // Kindle browsers are marked as Safari on Kindle
  if (browser.safari && browser.kindle) {
    matched.browser = 'kindle';
    browser.kindle = true;
  }

  // Kindle Silk browsers are marked as Safari on Kindle
  if (browser.safari && browser.silk) {
    matched.browser = 'silk';
    browser.silk = true;
  }
  if (browser.vivaldi) {
    matched.browser = 'vivaldi';
    browser.vivaldi = true;
  }

  // Assign the name and platform variable
  browser.name = matched.browser;
  browser.platform = matched.platform;
  if (isSSR === false) {
    if (userAgent.indexOf('electron') > -1) {
      browser.electron = true;
    } else if (document.location.href.indexOf('-extension://') > -1) {
      browser.bex = true;
    } else {
      if (window.Capacitor !== void 0) {
        browser.capacitor = true;
        browser.nativeMobile = true;
        browser.nativeMobileWrapper = 'capacitor';
      } else if (window._cordovaNative !== void 0 || window.cordova !== void 0) {
        browser.cordova = true;
        browser.nativeMobile = true;
        browser.nativeMobileWrapper = 'cordova';
      }
      if (hasTouch === true && browser.mac === true && (browser.desktop === true && browser.safari === true || browser.nativeMobile === true && browser.android !== true && browser.ios !== true && browser.ipad !== true)) {
        /*
        * Correction needed for iOS since the default
        * setting on iPad is to request desktop view; if we have
        * touch support and the user agent says it's a
        * desktop, we infer that it's an iPhone/iPad with desktop view
        * so we must fix the false positives
        */
        applyIosCorrection(browser);
      }
    }
    fromSSR = browser.nativeMobile === void 0 && browser.electron === void 0 && document.querySelector('[data-server-rendered]') !== null;
    if (fromSSR === true) {
      onSSR = true;
    }
  }
  return browser;
}
var userAgent = isSSR !== true ? navigator.userAgent || navigator.vendor || window.opera : '';
var ssrClient = {
  has: {
    touch: false,
    webStorage: false
  },
  within: {
    iframe: false
  }
};

// We export "client" for hydration error-free parts,
// like touch directives who do not (and must NOT) wait
// for the client takeover;
// Do NOT import this directly in your app, unless you really know
// what you are doing.
var client = isSSR === false ? {
  userAgent: userAgent,
  is: getPlatform(userAgent),
  has: {
    touch: hasTouch,
    webStorage: function () {
      try {
        if (window.localStorage) {
          return true;
        }
      } catch (e) {}
      return false;
    }()
  },
  within: {
    iframe: window.self !== window.top
  }
} : ssrClient;
var Platform = {
  install: function install($q, queues) {
    var _this = this;
    if (isSSR === true) {
      // we're on server-side, so we push
      // to the server queue instead of
      // applying directly
      queues.server.push(function (q, ctx) {
        q.platform = _this.parseSSR(ctx.ssr);
      });
    } else if (fromSSR === true) {
      // must match with server-side before
      // client taking over in order to prevent
      // hydration errors
      Object.assign(this, client, iosCorrection, ssrClient);

      // takeover should increase accuracy for
      // the rest of the props; we also avoid
      // hydration errors
      queues.takeover.push(function (q) {
        onSSR = fromSSR = false;
        Object.assign(q.platform, client);
        iosCorrection = void 0;
      });

      // we need to make platform reactive
      // for the takeover phase
      vue__WEBPACK_IMPORTED_MODULE_7___default.a.util.defineReactive($q, 'platform', this);
    } else {
      // we don't have any business with SSR, so
      // directly applying...
      Object.assign(this, client);
      $q.platform = this;
    }
  }
};
if (isSSR === true) {
  Platform.parseSSR = function ( /* ssrContext */ssr) {
    var userAgent = ssr.req.headers['user-agent'] || ssr.req.headers['User-Agent'] || '';
    return Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({}, client), {}, {
      userAgent: userAgent,
      is: getPlatform(userAgent)
    });
  };
} else {
  iosEmulated = client.is.ios === true && window.navigator.vendor.toLowerCase().indexOf('apple') === -1;
}
/* harmony default export */ __webpack_exports__["b"] = (Platform);

/***/ }),

/***/ "0b25":
/***/ (function(module, exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__("5926");
var toLength = __webpack_require__("50c4");

var $RangeError = RangeError;

// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toIntegerOrInfinity(it);
  var length = toLength(number);
  if (number !== length) throw $RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ "0b42":
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__("e8b5");
var isConstructor = __webpack_require__("68ee");
var isObject = __webpack_require__("861d");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ "0b43":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__("04f8");

/* eslint-disable es/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


/***/ }),

/***/ "0c47":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var setToStringTag = __webpack_require__("d44e");

// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "0cb2":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var toObject = __webpack_require__("7b0b");

var floor = Math.floor;
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);
// eslint-disable-next-line redos/no-vulnerable -- safe
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// `GetSubstitution` abstract operation
// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace(replacement, symbols, function (match, ch) {
    var capture;
    switch (charAt(ch, 0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return stringSlice(str, 0, position);
      case "'": return stringSlice(str, tailPos);
      case '<':
        capture = namedCaptures[stringSlice(ch, 1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),

/***/ "0cfb":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var createElement = __webpack_require__("cc12");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "0d26":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

var $Error = Error;
var replace = uncurryThis(''.replace);

var TEST = (function (arg) { return String($Error(arg).stack); })('zxcasd');
// eslint-disable-next-line redos/no-vulnerable -- safe
var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

module.exports = function (stack, dropEntries) {
  if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {
    while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');
  } return stack;
};


/***/ }),

/***/ "0d51":
/***/ (function(module, exports) {

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "0d59":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/size.js
var size = __webpack_require__("6642");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("87e8");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/spinner/spinner-mixin.js



/* harmony default export */ var spinner_mixin = ({
  mixins: [listeners["a" /* default */]],
  props: {
    color: String,
    size: {
      type: [Number, String],
      default: '1em'
    }
  },
  computed: {
    cSize: function cSize() {
      return this.size in size["c" /* sizes */] ? "".concat(size["c" /* sizes */][this.size], "px") : this.size;
    },
    classes: function classes() {
      if (this.color) {
        return "text-".concat(this.color);
      }
    }
  }
});
// CONCATENATED MODULE: ./node_modules/quasar/src/components/spinner/QSpinner.js




/* harmony default export */ var QSpinner = __webpack_exports__["a"] = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QSpinner',
  mixins: [spinner_mixin],
  props: {
    thickness: {
      type: Number,
      default: 5
    }
  },
  render: function render(h) {
    return h('svg', {
      staticClass: 'q-spinner q-spinner-mat',
      class: this.classes,
      on: Object(objectSpread2["a" /* default */])({}, this.qListeners),
      attrs: {
        focusable: 'false' /* needed for IE11 */,
        'width': this.cSize,
        'height': this.cSize,
        'viewBox': '25 25 50 50'
      }
    }, [h('circle', {
      staticClass: 'path',
      attrs: {
        'cx': '50',
        'cy': '50',
        'r': '20',
        'fill': 'none',
        'stroke': 'currentColor',
        'stroke-width': this.thickness,
        'stroke-miterlimit': '10'
      }
    })]);
  }
}));

/***/ }),

/***/ "0dbe":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "0fa8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePanel_vue_vue_type_style_index_0_id_f34c54ee_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fa37");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePanel_vue_vue_type_style_index_0_id_f34c54ee_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePanel_vue_vue_type_style_index_0_id_f34c54ee_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "1020":
/***/ (function(module, exports) {

function deepFreeze(obj) {
    if (obj instanceof Map) {
        obj.clear = obj.delete = obj.set = function () {
            throw new Error('map is read-only');
        };
    } else if (obj instanceof Set) {
        obj.add = obj.clear = obj.delete = function () {
            throw new Error('set is read-only');
        };
    }

    // Freeze self
    Object.freeze(obj);

    Object.getOwnPropertyNames(obj).forEach(function (name) {
        var prop = obj[name];

        // Freeze prop if it is an object
        if (typeof prop == 'object' && !Object.isFrozen(prop)) {
            deepFreeze(prop);
        }
    });

    return obj;
}

var deepFreezeEs6 = deepFreeze;
var _default = deepFreeze;
deepFreezeEs6.default = _default;

/** @implements CallbackResponse */
class Response {
  /**
   * @param {CompiledMode} mode
   */
  constructor(mode) {
    // eslint-disable-next-line no-undefined
    if (mode.data === undefined) mode.data = {};

    this.data = mode.data;
    this.isMatchIgnored = false;
  }

  ignoreMatch() {
    this.isMatchIgnored = true;
  }
}

/**
 * @param {string} value
 * @returns {string}
 */
function escapeHTML(value) {
  return value
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
}

/**
 * performs a shallow merge of multiple objects into one
 *
 * @template T
 * @param {T} original
 * @param {Record<string,any>[]} objects
 * @returns {T} a single new object
 */
function inherit(original, ...objects) {
  /** @type Record<string,any> */
  const result = Object.create(null);

  for (const key in original) {
    result[key] = original[key];
  }
  objects.forEach(function(obj) {
    for (const key in obj) {
      result[key] = obj[key];
    }
  });
  return /** @type {T} */ (result);
}

/**
 * @typedef {object} Renderer
 * @property {(text: string) => void} addText
 * @property {(node: Node) => void} openNode
 * @property {(node: Node) => void} closeNode
 * @property {() => string} value
 */

/** @typedef {{kind?: string, sublanguage?: boolean}} Node */
/** @typedef {{walk: (r: Renderer) => void}} Tree */
/** */

const SPAN_CLOSE = '</span>';

/**
 * Determines if a node needs to be wrapped in <span>
 *
 * @param {Node} node */
const emitsWrappingTags = (node) => {
  return !!node.kind;
};

/** @type {Renderer} */
class HTMLRenderer {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(parseTree, options) {
    this.buffer = "";
    this.classPrefix = options.classPrefix;
    parseTree.walk(this);
  }

  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(text) {
    this.buffer += escapeHTML(text);
  }

  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(node) {
    if (!emitsWrappingTags(node)) return;

    let className = node.kind;
    if (!node.sublanguage) {
      className = `${this.classPrefix}${className}`;
    }
    this.span(className);
  }

  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(node) {
    if (!emitsWrappingTags(node)) return;

    this.buffer += SPAN_CLOSE;
  }

  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }

  // helpers

  /**
   * Builds a span element
   *
   * @param {string} className */
  span(className) {
    this.buffer += `<span class="${className}">`;
  }
}

/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */
/** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */
/**  */

class TokenTree {
  constructor() {
    /** @type DataNode */
    this.rootNode = { children: [] };
    this.stack = [this.rootNode];
  }

  get top() {
    return this.stack[this.stack.length - 1];
  }

  get root() { return this.rootNode; }

  /** @param {Node} node */
  add(node) {
    this.top.children.push(node);
  }

  /** @param {string} kind */
  openNode(kind) {
    /** @type Node */
    const node = { kind, children: [] };
    this.add(node);
    this.stack.push(node);
  }

  closeNode() {
    if (this.stack.length > 1) {
      return this.stack.pop();
    }
    // eslint-disable-next-line no-undefined
    return undefined;
  }

  closeAllNodes() {
    while (this.closeNode());
  }

  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }

  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(builder) {
    // this does not
    return this.constructor._walk(builder, this.rootNode);
    // this works
    // return TokenTree._walk(builder, this.rootNode);
  }

  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(builder, node) {
    if (typeof node === "string") {
      builder.addText(node);
    } else if (node.children) {
      builder.openNode(node);
      node.children.forEach((child) => this._walk(builder, child));
      builder.closeNode(node);
    }
    return builder;
  }

  /**
   * @param {Node} node
   */
  static _collapse(node) {
    if (typeof node === "string") return;
    if (!node.children) return;

    if (node.children.every(el => typeof el === "string")) {
      // node.text = node.children.join("");
      // delete node.children;
      node.children = [node.children.join("")];
    } else {
      node.children.forEach((child) => {
        TokenTree._collapse(child);
      });
    }
  }
}

/**
  Currently this is all private API, but this is the minimal API necessary
  that an Emitter must implement to fully support the parser.

  Minimal interface:

  - addKeyword(text, kind)
  - addText(text)
  - addSublanguage(emitter, subLanguageName)
  - finalize()
  - openNode(kind)
  - closeNode()
  - closeAllNodes()
  - toHTML()

*/

/**
 * @implements {Emitter}
 */
class TokenTreeEmitter extends TokenTree {
  /**
   * @param {*} options
   */
  constructor(options) {
    super();
    this.options = options;
  }

  /**
   * @param {string} text
   * @param {string} kind
   */
  addKeyword(text, kind) {
    if (text === "") { return; }

    this.openNode(kind);
    this.addText(text);
    this.closeNode();
  }

  /**
   * @param {string} text
   */
  addText(text) {
    if (text === "") { return; }

    this.add(text);
  }

  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  addSublanguage(emitter, name) {
    /** @type DataNode */
    const node = emitter.root;
    node.kind = name;
    node.sublanguage = true;
    this.add(node);
  }

  toHTML() {
    const renderer = new HTMLRenderer(this, this.options);
    return renderer.value();
  }

  finalize() {
    return true;
  }
}

/**
 * @param {string} value
 * @returns {RegExp}
 * */
function escape(value) {
  return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'm');
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}

/**
 * Any of the passed expresssions may match
 *
 * Creates a huge this | this | that | that match
 * @param {(RegExp | string)[] } args
 * @returns {string}
 */
function either(...args) {
  const joined = '(' + args.map((x) => source(x)).join("|") + ")";
  return joined;
}

/**
 * @param {RegExp} re
 * @returns {number}
 */
function countMatchGroups(re) {
  return (new RegExp(re.toString() + '|')).exec('').length - 1;
}

/**
 * Does lexeme start with a regular expression match at the beginning
 * @param {RegExp} re
 * @param {string} lexeme
 */
function startsWith(re, lexeme) {
  const match = re && re.exec(lexeme);
  return match && match.index === 0;
}

// BACKREF_RE matches an open parenthesis or backreference. To avoid
// an incorrect parse, it additionally matches the following:
// - [...] elements, where the meaning of parentheses and escapes change
// - other escape sequences, so we do not misparse escape sequences as
//   interesting elements
// - non-matching or lookahead parentheses, which do not capture. These
//   follow the '(' with a '?'.
const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;

// join logically computes regexps.join(separator), but fixes the
// backreferences so they continue to match.
// it also places each individual regular expression into it's own
// match group, keeping track of the sequencing of those match groups
// is currently an exercise for the caller. :-)
/**
 * @param {(string | RegExp)[]} regexps
 * @param {string} separator
 * @returns {string}
 */
function join(regexps, separator = "|") {
  let numCaptures = 0;

  return regexps.map((regex) => {
    numCaptures += 1;
    const offset = numCaptures;
    let re = source(regex);
    let out = '';

    while (re.length > 0) {
      const match = BACKREF_RE.exec(re);
      if (!match) {
        out += re;
        break;
      }
      out += re.substring(0, match.index);
      re = re.substring(match.index + match[0].length);
      if (match[0][0] === '\\' && match[1]) {
        // Adjust the backreference.
        out += '\\' + String(Number(match[1]) + offset);
      } else {
        out += match[0];
        if (match[0] === '(') {
          numCaptures++;
        }
      }
    }
    return out;
  }).map(re => `(${re})`).join(separator);
}

// Common regexps
const MATCH_NOTHING_RE = /\b\B/;
const IDENT_RE = '[a-zA-Z]\\w*';
const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
const C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
const BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

/**
* @param { Partial<Mode> & {binary?: string | RegExp} } opts
*/
const SHEBANG = (opts = {}) => {
  const beginShebang = /^#![ ]*\//;
  if (opts.binary) {
    opts.begin = concat(
      beginShebang,
      /.*\b/,
      opts.binary,
      /\b.*/);
  }
  return inherit({
    className: 'meta',
    begin: beginShebang,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (m, resp) => {
      if (m.index !== 0) resp.ignoreMatch();
    }
  }, opts);
};

// Common modes
const BACKSLASH_ESCAPE = {
  begin: '\\\\[\\s\\S]', relevance: 0
};
const APOS_STRING_MODE = {
  className: 'string',
  begin: '\'',
  end: '\'',
  illegal: '\\n',
  contains: [BACKSLASH_ESCAPE]
};
const QUOTE_STRING_MODE = {
  className: 'string',
  begin: '"',
  end: '"',
  illegal: '\\n',
  contains: [BACKSLASH_ESCAPE]
};
const PHRASAL_WORDS_MODE = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
/**
 * Creates a comment mode
 *
 * @param {string | RegExp} begin
 * @param {string | RegExp} end
 * @param {Mode | {}} [modeOptions]
 * @returns {Partial<Mode>}
 */
const COMMENT = function(begin, end, modeOptions = {}) {
  const mode = inherit(
    {
      className: 'comment',
      begin,
      end,
      contains: []
    },
    modeOptions
  );
  mode.contains.push(PHRASAL_WORDS_MODE);
  mode.contains.push({
    className: 'doctag',
    begin: '(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):',
    relevance: 0
  });
  return mode;
};
const C_LINE_COMMENT_MODE = COMMENT('//', '$');
const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
const HASH_COMMENT_MODE = COMMENT('#', '$');
const NUMBER_MODE = {
  className: 'number',
  begin: NUMBER_RE,
  relevance: 0
};
const C_NUMBER_MODE = {
  className: 'number',
  begin: C_NUMBER_RE,
  relevance: 0
};
const BINARY_NUMBER_MODE = {
  className: 'number',
  begin: BINARY_NUMBER_RE,
  relevance: 0
};
const CSS_NUMBER_MODE = {
  className: 'number',
  begin: NUMBER_RE + '(' +
    '%|em|ex|ch|rem' +
    '|vw|vh|vmin|vmax' +
    '|cm|mm|in|pt|pc|px' +
    '|deg|grad|rad|turn' +
    '|s|ms' +
    '|Hz|kHz' +
    '|dpi|dpcm|dppx' +
    ')?',
  relevance: 0
};
const REGEXP_MODE = {
  // this outer rule makes sure we actually have a WHOLE regex and not simply
  // an expression such as:
  //
  //     3 / something
  //
  // (which will then blow up when regex's `illegal` sees the newline)
  begin: /(?=\/[^/\n]*\/)/,
  contains: [{
    className: 'regexp',
    begin: /\//,
    end: /\/[gimuy]*/,
    illegal: /\n/,
    contains: [
      BACKSLASH_ESCAPE,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [BACKSLASH_ESCAPE]
      }
    ]
  }]
};
const TITLE_MODE = {
  className: 'title',
  begin: IDENT_RE,
  relevance: 0
};
const UNDERSCORE_TITLE_MODE = {
  className: 'title',
  begin: UNDERSCORE_IDENT_RE,
  relevance: 0
};
const METHOD_GUARD = {
  // excludes method names from keyword processing
  begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
  relevance: 0
};

/**
 * Adds end same as begin mechanics to a mode
 *
 * Your mode must include at least a single () match group as that first match
 * group is what is used for comparison
 * @param {Partial<Mode>} mode
 */
const END_SAME_AS_BEGIN = function(mode) {
  return Object.assign(mode,
    {
      /** @type {ModeCallback} */
      'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },
      /** @type {ModeCallback} */
      'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }
    });
};

var MODES = /*#__PURE__*/Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE: MATCH_NOTHING_RE,
    IDENT_RE: IDENT_RE,
    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,
    NUMBER_RE: NUMBER_RE,
    C_NUMBER_RE: C_NUMBER_RE,
    BINARY_NUMBER_RE: BINARY_NUMBER_RE,
    RE_STARTERS_RE: RE_STARTERS_RE,
    SHEBANG: SHEBANG,
    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,
    APOS_STRING_MODE: APOS_STRING_MODE,
    QUOTE_STRING_MODE: QUOTE_STRING_MODE,
    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,
    COMMENT: COMMENT,
    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,
    HASH_COMMENT_MODE: HASH_COMMENT_MODE,
    NUMBER_MODE: NUMBER_MODE,
    C_NUMBER_MODE: C_NUMBER_MODE,
    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,
    CSS_NUMBER_MODE: CSS_NUMBER_MODE,
    REGEXP_MODE: REGEXP_MODE,
    TITLE_MODE: TITLE_MODE,
    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,
    METHOD_GUARD: METHOD_GUARD,
    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN
});

// Grammar extensions / plugins
// See: https://github.com/highlightjs/highlight.js/issues/2833

// Grammar extensions allow "syntactic sugar" to be added to the grammar modes
// without requiring any underlying changes to the compiler internals.

// `compileMatch` being the perfect small example of now allowing a grammar
// author to write `match` when they desire to match a single expression rather
// than being forced to use `begin`.  The extension then just moves `match` into
// `begin` when it runs.  Ie, no features have been added, but we've just made
// the experience of writing (and reading grammars) a little bit nicer.

// ------

// TODO: We need negative look-behind support to do this properly
/**
 * Skip a match if it has a preceding dot
 *
 * This is used for `beginKeywords` to prevent matching expressions such as
 * `bob.keyword.do()`. The mode compiler automatically wires this up as a
 * special _internal_ 'on:begin' callback for modes with `beginKeywords`
 * @param {RegExpMatchArray} match
 * @param {CallbackResponse} response
 */
function skipIfhasPrecedingDot(match, response) {
  const before = match.input[match.index - 1];
  if (before === ".") {
    response.ignoreMatch();
  }
}


/**
 * `beginKeywords` syntactic sugar
 * @type {CompilerExt}
 */
function beginKeywords(mode, parent) {
  if (!parent) return;
  if (!mode.beginKeywords) return;

  // for languages with keywords that include non-word characters checking for
  // a word boundary is not sufficient, so instead we check for a word boundary
  // or whitespace - this does no harm in any case since our keyword engine
  // doesn't allow spaces in keywords anyways and we still check for the boundary
  // first
  mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)';
  mode.__beforeBegin = skipIfhasPrecedingDot;
  mode.keywords = mode.keywords || mode.beginKeywords;
  delete mode.beginKeywords;

  // prevents double relevance, the keywords themselves provide
  // relevance, the mode doesn't need to double it
  // eslint-disable-next-line no-undefined
  if (mode.relevance === undefined) mode.relevance = 0;
}

/**
 * Allow `illegal` to contain an array of illegal values
 * @type {CompilerExt}
 */
function compileIllegal(mode, _parent) {
  if (!Array.isArray(mode.illegal)) return;

  mode.illegal = either(...mode.illegal);
}

/**
 * `match` to match a single expression for readability
 * @type {CompilerExt}
 */
function compileMatch(mode, _parent) {
  if (!mode.match) return;
  if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");

  mode.begin = mode.match;
  delete mode.match;
}

/**
 * provides the default 1 relevance to all modes
 * @type {CompilerExt}
 */
function compileRelevance(mode, _parent) {
  // eslint-disable-next-line no-undefined
  if (mode.relevance === undefined) mode.relevance = 1;
}

// keywords that should have no default relevance value
const COMMON_KEYWORDS = [
  'of',
  'and',
  'for',
  'in',
  'not',
  'or',
  'if',
  'then',
  'parent', // common variable name
  'list', // common variable name
  'value' // common variable name
];

const DEFAULT_KEYWORD_CLASSNAME = "keyword";

/**
 * Given raw keywords from a language definition, compile them.
 *
 * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords
 * @param {boolean} caseInsensitive
 */
function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {
  /** @type KeywordDict */
  const compiledKeywords = {};

  // input can be a string of keywords, an array of keywords, or a object with
  // named keys representing className (which can then point to a string or array)
  if (typeof rawKeywords === 'string') {
    compileList(className, rawKeywords.split(" "));
  } else if (Array.isArray(rawKeywords)) {
    compileList(className, rawKeywords);
  } else {
    Object.keys(rawKeywords).forEach(function(className) {
      // collapse all our objects back into the parent object
      Object.assign(
        compiledKeywords,
        compileKeywords(rawKeywords[className], caseInsensitive, className)
      );
    });
  }
  return compiledKeywords;

  // ---

  /**
   * Compiles an individual list of keywords
   *
   * Ex: "for if when while|5"
   *
   * @param {string} className
   * @param {Array<string>} keywordList
   */
  function compileList(className, keywordList) {
    if (caseInsensitive) {
      keywordList = keywordList.map(x => x.toLowerCase());
    }
    keywordList.forEach(function(keyword) {
      const pair = keyword.split('|');
      compiledKeywords[pair[0]] = [className, scoreForKeyword(pair[0], pair[1])];
    });
  }
}

/**
 * Returns the proper score for a given keyword
 *
 * Also takes into account comment keywords, which will be scored 0 UNLESS
 * another score has been manually assigned.
 * @param {string} keyword
 * @param {string} [providedScore]
 */
function scoreForKeyword(keyword, providedScore) {
  // manual scores always win over common keywords
  // so you can force a score of 1 if you really insist
  if (providedScore) {
    return Number(providedScore);
  }

  return commonKeyword(keyword) ? 0 : 1;
}

/**
 * Determines if a given keyword is common or not
 *
 * @param {string} keyword */
function commonKeyword(keyword) {
  return COMMON_KEYWORDS.includes(keyword.toLowerCase());
}

// compilation

/**
 * Compiles a language definition result
 *
 * Given the raw result of a language definition (Language), compiles this so
 * that it is ready for highlighting code.
 * @param {Language} language
 * @param {{plugins: HLJSPlugin[]}} opts
 * @returns {CompiledLanguage}
 */
function compileLanguage(language, { plugins }) {
  /**
   * Builds a regex with the case sensativility of the current language
   *
   * @param {RegExp | string} value
   * @param {boolean} [global]
   */
  function langRe(value, global) {
    return new RegExp(
      source(value),
      'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
    );
  }

  /**
    Stores multiple regular expressions and allows you to quickly search for
    them all in a string simultaneously - returning the first match.  It does
    this by creating a huge (a|b|c) regex - each individual item wrapped with ()
    and joined by `|` - using match groups to track position.  When a match is
    found checking which position in the array has content allows us to figure
    out which of the original regexes / match groups triggered the match.

    The match object itself (the result of `Regex.exec`) is returned but also
    enhanced by merging in any meta-data that was registered with the regex.
    This is how we keep track of which mode matched, and what type of rule
    (`illegal`, `begin`, end, etc).
  */
  class MultiRegex {
    constructor() {
      this.matchIndexes = {};
      // @ts-ignore
      this.regexes = [];
      this.matchAt = 1;
      this.position = 0;
    }

    // @ts-ignore
    addRule(re, opts) {
      opts.position = this.position++;
      // @ts-ignore
      this.matchIndexes[this.matchAt] = opts;
      this.regexes.push([opts, re]);
      this.matchAt += countMatchGroups(re) + 1;
    }

    compile() {
      if (this.regexes.length === 0) {
        // avoids the need to check length every time exec is called
        // @ts-ignore
        this.exec = () => null;
      }
      const terminators = this.regexes.map(el => el[1]);
      this.matcherRe = langRe(join(terminators), true);
      this.lastIndex = 0;
    }

    /** @param {string} s */
    exec(s) {
      this.matcherRe.lastIndex = this.lastIndex;
      const match = this.matcherRe.exec(s);
      if (!match) { return null; }

      // eslint-disable-next-line no-undefined
      const i = match.findIndex((el, i) => i > 0 && el !== undefined);
      // @ts-ignore
      const matchData = this.matchIndexes[i];
      // trim off any earlier non-relevant match groups (ie, the other regex
      // match groups that make up the multi-matcher)
      match.splice(0, i);

      return Object.assign(match, matchData);
    }
  }

  /*
    Created to solve the key deficiently with MultiRegex - there is no way to
    test for multiple matches at a single location.  Why would we need to do
    that?  In the future a more dynamic engine will allow certain matches to be
    ignored.  An example: if we matched say the 3rd regex in a large group but
    decided to ignore it - we'd need to started testing again at the 4th
    regex... but MultiRegex itself gives us no real way to do that.

    So what this class creates MultiRegexs on the fly for whatever search
    position they are needed.

    NOTE: These additional MultiRegex objects are created dynamically.  For most
    grammars most of the time we will never actually need anything more than the
    first MultiRegex - so this shouldn't have too much overhead.

    Say this is our search group, and we match regex3, but wish to ignore it.

      regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0

    What we need is a new MultiRegex that only includes the remaining
    possibilities:

      regex4 | regex5                               ' ie, startAt = 3

    This class wraps all that complexity up in a simple API... `startAt` decides
    where in the array of expressions to start doing the matching. It
    auto-increments, so if a match is found at position 2, then startAt will be
    set to 3.  If the end is reached startAt will return to 0.

    MOST of the time the parser will be setting startAt manually to 0.
  */
  class ResumableMultiRegex {
    constructor() {
      // @ts-ignore
      this.rules = [];
      // @ts-ignore
      this.multiRegexes = [];
      this.count = 0;

      this.lastIndex = 0;
      this.regexIndex = 0;
    }

    // @ts-ignore
    getMatcher(index) {
      if (this.multiRegexes[index]) return this.multiRegexes[index];

      const matcher = new MultiRegex();
      this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
      matcher.compile();
      this.multiRegexes[index] = matcher;
      return matcher;
    }

    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }

    considerAll() {
      this.regexIndex = 0;
    }

    // @ts-ignore
    addRule(re, opts) {
      this.rules.push([re, opts]);
      if (opts.type === "begin") this.count++;
    }

    /** @param {string} s */
    exec(s) {
      const m = this.getMatcher(this.regexIndex);
      m.lastIndex = this.lastIndex;
      let result = m.exec(s);

      // The following is because we have no easy way to say "resume scanning at the
      // existing position but also skip the current rule ONLY". What happens is
      // all prior rules are also skipped which can result in matching the wrong
      // thing. Example of matching "booger":

      // our matcher is [string, "booger", number]
      //
      // ....booger....

      // if "booger" is ignored then we'd really need a regex to scan from the
      // SAME position for only: [string, number] but ignoring "booger" (if it
      // was the first match), a simple resume would scan ahead who knows how
      // far looking only for "number", ignoring potential string matches (or
      // future "booger" matches that might be valid.)

      // So what we do: We execute two matchers, one resuming at the same
      // position, but the second full matcher starting at the position after:

      //     /--- resume first regex match here (for [number])
      //     |/---- full match here for [string, "booger", number]
      //     vv
      // ....booger....

      // Which ever results in a match first is then used. So this 3-4 step
      // process essentially allows us to say "match at this position, excluding
      // a prior rule that was ignored".
      //
      // 1. Match "booger" first, ignore. Also proves that [string] does non match.
      // 2. Resume matching for [number]
      // 3. Match at index + 1 for [string, "booger", number]
      // 4. If #2 and #3 result in matches, which came first?
      if (this.resumingScanAtSamePosition()) {
        if (result && result.index === this.lastIndex) ; else { // use the second matcher result
          const m2 = this.getMatcher(0);
          m2.lastIndex = this.lastIndex + 1;
          result = m2.exec(s);
        }
      }

      if (result) {
        this.regexIndex += result.position + 1;
        if (this.regexIndex === this.count) {
          // wrap-around to considering all matches again
          this.considerAll();
        }
      }

      return result;
    }
  }

  /**
   * Given a mode, builds a huge ResumableMultiRegex that can be used to walk
   * the content and find matches.
   *
   * @param {CompiledMode} mode
   * @returns {ResumableMultiRegex}
   */
  function buildModeRegex(mode) {
    const mm = new ResumableMultiRegex();

    mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: "begin" }));

    if (mode.terminatorEnd) {
      mm.addRule(mode.terminatorEnd, { type: "end" });
    }
    if (mode.illegal) {
      mm.addRule(mode.illegal, { type: "illegal" });
    }

    return mm;
  }

  /** skip vs abort vs ignore
   *
   * @skip   - The mode is still entered and exited normally (and contains rules apply),
   *           but all content is held and added to the parent buffer rather than being
   *           output when the mode ends.  Mostly used with `sublanguage` to build up
   *           a single large buffer than can be parsed by sublanguage.
   *
   *             - The mode begin ands ends normally.
   *             - Content matched is added to the parent mode buffer.
   *             - The parser cursor is moved forward normally.
   *
   * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it
   *           never matched) but DOES NOT continue to match subsequent `contains`
   *           modes.  Abort is bad/suboptimal because it can result in modes
   *           farther down not getting applied because an earlier rule eats the
   *           content but then aborts.
   *
   *             - The mode does not begin.
   *             - Content matched by `begin` is added to the mode buffer.
   *             - The parser cursor is moved forward accordingly.
   *
   * @ignore - Ignores the mode (as if it never matched) and continues to match any
   *           subsequent `contains` modes.  Ignore isn't technically possible with
   *           the current parser implementation.
   *
   *             - The mode does not begin.
   *             - Content matched by `begin` is ignored.
   *             - The parser cursor is not moved forward.
   */

  /**
   * Compiles an individual mode
   *
   * This can raise an error if the mode contains certain detectable known logic
   * issues.
   * @param {Mode} mode
   * @param {CompiledMode | null} [parent]
   * @returns {CompiledMode | never}
   */
  function compileMode(mode, parent) {
    const cmode = /** @type CompiledMode */ (mode);
    if (mode.isCompiled) return cmode;

    [
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      compileMatch
    ].forEach(ext => ext(mode, parent));

    language.compilerExtensions.forEach(ext => ext(mode, parent));

    // __beforeBegin is considered private API, internal use only
    mode.__beforeBegin = null;

    [
      beginKeywords,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      compileIllegal,
      // default to 1 relevance if not specified
      compileRelevance
    ].forEach(ext => ext(mode, parent));

    mode.isCompiled = true;

    let keywordPattern = null;
    if (typeof mode.keywords === "object") {
      keywordPattern = mode.keywords.$pattern;
      delete mode.keywords.$pattern;
    }

    if (mode.keywords) {
      mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
    }

    // both are not allowed
    if (mode.lexemes && keywordPattern) {
      throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
    }

    // `mode.lexemes` was the old standard before we added and now recommend
    // using `keywords.$pattern` to pass the keyword pattern
    keywordPattern = keywordPattern || mode.lexemes || /\w+/;
    cmode.keywordPatternRe = langRe(keywordPattern, true);

    if (parent) {
      if (!mode.begin) mode.begin = /\B|\b/;
      cmode.beginRe = langRe(mode.begin);
      if (mode.endSameAsBegin) mode.end = mode.begin;
      if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
      if (mode.end) cmode.endRe = langRe(mode.end);
      cmode.terminatorEnd = source(mode.end) || '';
      if (mode.endsWithParent && parent.terminatorEnd) {
        cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;
      }
    }
    if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ (mode.illegal));
    if (!mode.contains) mode.contains = [];

    mode.contains = [].concat(...mode.contains.map(function(c) {
      return expandOrCloneMode(c === 'self' ? mode : c);
    }));
    mode.contains.forEach(function(c) { compileMode(/** @type Mode */ (c), cmode); });

    if (mode.starts) {
      compileMode(mode.starts, parent);
    }

    cmode.matcher = buildModeRegex(cmode);
    return cmode;
  }

  if (!language.compilerExtensions) language.compilerExtensions = [];

  // self is not valid at the top-level
  if (language.contains && language.contains.includes('self')) {
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  }

  // we need a null object, which inherit will guarantee
  language.classNameAliases = inherit(language.classNameAliases || {});

  return compileMode(/** @type Mode */ (language));
}

/**
 * Determines if a mode has a dependency on it's parent or not
 *
 * If a mode does have a parent dependency then often we need to clone it if
 * it's used in multiple places so that each copy points to the correct parent,
 * where-as modes without a parent can often safely be re-used at the bottom of
 * a mode chain.
 *
 * @param {Mode | null} mode
 * @returns {boolean} - is there a dependency on the parent?
 * */
function dependencyOnParent(mode) {
  if (!mode) return false;

  return mode.endsWithParent || dependencyOnParent(mode.starts);
}

/**
 * Expands a mode or clones it if necessary
 *
 * This is necessary for modes with parental dependenceis (see notes on
 * `dependencyOnParent`) and for nodes that have `variants` - which must then be
 * exploded into their own individual modes at compile time.
 *
 * @param {Mode} mode
 * @returns {Mode | Mode[]}
 * */
function expandOrCloneMode(mode) {
  if (mode.variants && !mode.cachedVariants) {
    mode.cachedVariants = mode.variants.map(function(variant) {
      return inherit(mode, { variants: null }, variant);
    });
  }

  // EXPAND
  // if we have variants then essentially "replace" the mode with the variants
  // this happens in compileMode, where this function is called from
  if (mode.cachedVariants) {
    return mode.cachedVariants;
  }

  // CLONE
  // if we have dependencies on parents then we need a unique
  // instance of ourselves, so we can be reused with many
  // different parents without issue
  if (dependencyOnParent(mode)) {
    return inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null });
  }

  if (Object.isFrozen(mode)) {
    return inherit(mode);
  }

  // no special dependency issues, just return ourselves
  return mode;
}

var version = "10.7.3";

// @ts-nocheck

function hasValueOrEmptyAttribute(value) {
  return Boolean(value || value === "");
}

function BuildVuePlugin(hljs) {
  const Component = {
    props: ["language", "code", "autodetect"],
    data: function() {
      return {
        detectedLanguage: "",
        unknownLanguage: false
      };
    },
    computed: {
      className() {
        if (this.unknownLanguage) return "";

        return "hljs " + this.detectedLanguage;
      },
      highlighted() {
        // no idea what language to use, return raw code
        if (!this.autoDetect && !hljs.getLanguage(this.language)) {
          console.warn(`The language "${this.language}" you specified could not be found.`);
          this.unknownLanguage = true;
          return escapeHTML(this.code);
        }

        let result = {};
        if (this.autoDetect) {
          result = hljs.highlightAuto(this.code);
          this.detectedLanguage = result.language;
        } else {
          result = hljs.highlight(this.language, this.code, this.ignoreIllegals);
          this.detectedLanguage = this.language;
        }
        return result.value;
      },
      autoDetect() {
        return !this.language || hasValueOrEmptyAttribute(this.autodetect);
      },
      ignoreIllegals() {
        return true;
      }
    },
    // this avoids needing to use a whole Vue compilation pipeline just
    // to build Highlight.js
    render(createElement) {
      return createElement("pre", {}, [
        createElement("code", {
          class: this.className,
          domProps: { innerHTML: this.highlighted }
        })
      ]);
    }
    // template: `<pre><code :class="className" v-html="highlighted"></code></pre>`
  };

  const VuePlugin = {
    install(Vue) {
      Vue.component('highlightjs', Component);
    }
  };

  return { Component, VuePlugin };
}

/* plugin itself */

/** @type {HLJSPlugin} */
const mergeHTMLPlugin = {
  "after:highlightElement": ({ el, result, text }) => {
    const originalStream = nodeStream(el);
    if (!originalStream.length) return;

    const resultNode = document.createElement('div');
    resultNode.innerHTML = result.value;
    result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
  }
};

/* Stream merging support functions */

/**
 * @typedef Event
 * @property {'start'|'stop'} event
 * @property {number} offset
 * @property {Node} node
 */

/**
 * @param {Node} node
 */
function tag(node) {
  return node.nodeName.toLowerCase();
}

/**
 * @param {Node} node
 */
function nodeStream(node) {
  /** @type Event[] */
  const result = [];
  (function _nodeStream(node, offset) {
    for (let child = node.firstChild; child; child = child.nextSibling) {
      if (child.nodeType === 3) {
        offset += child.nodeValue.length;
      } else if (child.nodeType === 1) {
        result.push({
          event: 'start',
          offset: offset,
          node: child
        });
        offset = _nodeStream(child, offset);
        // Prevent void elements from having an end tag that would actually
        // double them in the output. There are more void elements in HTML
        // but we list only those realistically expected in code display.
        if (!tag(child).match(/br|hr|img|input/)) {
          result.push({
            event: 'stop',
            offset: offset,
            node: child
          });
        }
      }
    }
    return offset;
  })(node, 0);
  return result;
}

/**
 * @param {any} original - the original stream
 * @param {any} highlighted - stream of the highlighted source
 * @param {string} value - the original source itself
 */
function mergeStreams(original, highlighted, value) {
  let processed = 0;
  let result = '';
  const nodeStack = [];

  function selectStream() {
    if (!original.length || !highlighted.length) {
      return original.length ? original : highlighted;
    }
    if (original[0].offset !== highlighted[0].offset) {
      return (original[0].offset < highlighted[0].offset) ? original : highlighted;
    }

    /*
    To avoid starting the stream just before it should stop the order is
    ensured that original always starts first and closes last:

    if (event1 == 'start' && event2 == 'start')
      return original;
    if (event1 == 'start' && event2 == 'stop')
      return highlighted;
    if (event1 == 'stop' && event2 == 'start')
      return original;
    if (event1 == 'stop' && event2 == 'stop')
      return highlighted;

    ... which is collapsed to:
    */
    return highlighted[0].event === 'start' ? original : highlighted;
  }

  /**
   * @param {Node} node
   */
  function open(node) {
    /** @param {Attr} attr */
    function attributeString(attr) {
      return ' ' + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
    }
    // @ts-ignore
    result += '<' + tag(node) + [].map.call(node.attributes, attributeString).join('') + '>';
  }

  /**
   * @param {Node} node
   */
  function close(node) {
    result += '</' + tag(node) + '>';
  }

  /**
   * @param {Event} event
   */
  function render(event) {
    (event.event === 'start' ? open : close)(event.node);
  }

  while (original.length || highlighted.length) {
    let stream = selectStream();
    result += escapeHTML(value.substring(processed, stream[0].offset));
    processed = stream[0].offset;
    if (stream === original) {
      /*
      On any opening or closing tag of the original markup we first close
      the entire highlighted node stack, then render the original tag along
      with all the following original tags at the same offset and then
      reopen all the tags on the highlighted stack.
      */
      nodeStack.reverse().forEach(close);
      do {
        render(stream.splice(0, 1)[0]);
        stream = selectStream();
      } while (stream === original && stream.length && stream[0].offset === processed);
      nodeStack.reverse().forEach(open);
    } else {
      if (stream[0].event === 'start') {
        nodeStack.push(stream[0].node);
      } else {
        nodeStack.pop();
      }
      render(stream.splice(0, 1)[0]);
    }
  }
  return result + escapeHTML(value.substr(processed));
}

/*

For the reasoning behind this please see:
https://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419

*/

/**
 * @type {Record<string, boolean>}
 */
const seenDeprecations = {};

/**
 * @param {string} message
 */
const error = (message) => {
  console.error(message);
};

/**
 * @param {string} message
 * @param {any} args
 */
const warn = (message, ...args) => {
  console.log(`WARN: ${message}`, ...args);
};

/**
 * @param {string} version
 * @param {string} message
 */
const deprecated = (version, message) => {
  if (seenDeprecations[`${version}/${message}`]) return;

  console.log(`Deprecated as of ${version}. ${message}`);
  seenDeprecations[`${version}/${message}`] = true;
};

/*
Syntax highlighting with language autodetection.
https://highlightjs.org/
*/

const escape$1 = escapeHTML;
const inherit$1 = inherit;
const NO_MATCH = Symbol("nomatch");

/**
 * @param {any} hljs - object that is extended (legacy)
 * @returns {HLJSApi}
 */
const HLJS = function(hljs) {
  // Global internal variables used within the highlight.js library.
  /** @type {Record<string, Language>} */
  const languages = Object.create(null);
  /** @type {Record<string, string>} */
  const aliases = Object.create(null);
  /** @type {HLJSPlugin[]} */
  const plugins = [];

  // safe/production mode - swallows more errors, tries to keep running
  // even if a single syntax or parse hits a fatal error
  let SAFE_MODE = true;
  const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
  const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
  /** @type {Language} */
  const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };

  // Global options used when within external APIs. This is modified when
  // calling the `hljs.configure` function.
  /** @type HLJSOptions */
  let options = {
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: 'hljs-',
    tabReplace: null,
    useBR: false,
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: TokenTreeEmitter
  };

  /* Utility functions */

  /**
   * Tests a language name to see if highlighting should be skipped
   * @param {string} languageName
   */
  function shouldNotHighlight(languageName) {
    return options.noHighlightRe.test(languageName);
  }

  /**
   * @param {HighlightedHTMLElement} block - the HTML element to determine language for
   */
  function blockLanguage(block) {
    let classes = block.className + ' ';

    classes += block.parentNode ? block.parentNode.className : '';

    // language-* takes precedence over non-prefixed class names.
    const match = options.languageDetectRe.exec(classes);
    if (match) {
      const language = getLanguage(match[1]);
      if (!language) {
        warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
        warn("Falling back to no-highlight mode for this block.", block);
      }
      return language ? match[1] : 'no-highlight';
    }

    return classes
      .split(/\s+/)
      .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
  }

  /**
   * Core highlighting function.
   *
   * OLD API
   * highlight(lang, code, ignoreIllegals, continuation)
   *
   * NEW API
   * highlight(code, {lang, ignoreIllegals})
   *
   * @param {string} codeOrlanguageName - the language to use for highlighting
   * @param {string | HighlightOptions} optionsOrCode - the code to highlight
   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
   * @param {CompiledMode} [continuation] - current continuation mode, if any
   *
   * @returns {HighlightResult} Result - an object that represents the result
   * @property {string} language - the language name
   * @property {number} relevance - the relevance score
   * @property {string} value - the highlighted HTML code
   * @property {string} code - the original raw code
   * @property {CompiledMode} top - top of the current mode stack
   * @property {boolean} illegal - indicates whether any illegal matches were found
  */
  function highlight(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {
    let code = "";
    let languageName = "";
    if (typeof optionsOrCode === "object") {
      code = codeOrlanguageName;
      ignoreIllegals = optionsOrCode.ignoreIllegals;
      languageName = optionsOrCode.language;
      // continuation not supported at all via the new API
      // eslint-disable-next-line no-undefined
      continuation = undefined;
    } else {
      // old API
      deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
      deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
      languageName = codeOrlanguageName;
      code = optionsOrCode;
    }

    /** @type {BeforeHighlightContext} */
    const context = {
      code,
      language: languageName
    };
    // the plugin can change the desired language or the code to be highlighted
    // just be changing the object it was passed
    fire("before:highlight", context);

    // a before plugin can usurp the result completely by providing it's own
    // in which case we don't even need to call highlight
    const result = context.result
      ? context.result
      : _highlight(context.language, context.code, ignoreIllegals, continuation);

    result.code = context.code;
    // the plugin can change anything in result to suite it
    fire("after:highlight", result);

    return result;
  }

  /**
   * private highlight that's used internally and does not fire callbacks
   *
   * @param {string} languageName - the language to use for highlighting
   * @param {string} codeToHighlight - the code to highlight
   * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
   * @param {CompiledMode?} [continuation] - current continuation mode, if any
   * @returns {HighlightResult} - result of the highlight operation
  */
  function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
    /**
     * Return keyword data if a match is a keyword
     * @param {CompiledMode} mode - current mode
     * @param {RegExpMatchArray} match - regexp match data
     * @returns {KeywordData | false}
     */
    function keywordData(mode, match) {
      const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];
      return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
    }

    function processKeywords() {
      if (!top.keywords) {
        emitter.addText(modeBuffer);
        return;
      }

      let lastIndex = 0;
      top.keywordPatternRe.lastIndex = 0;
      let match = top.keywordPatternRe.exec(modeBuffer);
      let buf = "";

      while (match) {
        buf += modeBuffer.substring(lastIndex, match.index);
        const data = keywordData(top, match);
        if (data) {
          const [kind, keywordRelevance] = data;
          emitter.addText(buf);
          buf = "";

          relevance += keywordRelevance;
          if (kind.startsWith("_")) {
            // _ implied for relevance only, do not highlight
            // by applying a class name
            buf += match[0];
          } else {
            const cssClass = language.classNameAliases[kind] || kind;
            emitter.addKeyword(match[0], cssClass);
          }
        } else {
          buf += match[0];
        }
        lastIndex = top.keywordPatternRe.lastIndex;
        match = top.keywordPatternRe.exec(modeBuffer);
      }
      buf += modeBuffer.substr(lastIndex);
      emitter.addText(buf);
    }

    function processSubLanguage() {
      if (modeBuffer === "") return;
      /** @type HighlightResult */
      let result = null;

      if (typeof top.subLanguage === 'string') {
        if (!languages[top.subLanguage]) {
          emitter.addText(modeBuffer);
          return;
        }
        result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
        continuations[top.subLanguage] = /** @type {CompiledMode} */ (result.top);
      } else {
        result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
      }

      // Counting embedded language score towards the host language may be disabled
      // with zeroing the containing mode relevance. Use case in point is Markdown that
      // allows XML everywhere and makes every XML snippet to have a much larger Markdown
      // score.
      if (top.relevance > 0) {
        relevance += result.relevance;
      }
      emitter.addSublanguage(result.emitter, result.language);
    }

    function processBuffer() {
      if (top.subLanguage != null) {
        processSubLanguage();
      } else {
        processKeywords();
      }
      modeBuffer = '';
    }

    /**
     * @param {Mode} mode - new mode to start
     */
    function startNewMode(mode) {
      if (mode.className) {
        emitter.openNode(language.classNameAliases[mode.className] || mode.className);
      }
      top = Object.create(mode, { parent: { value: top } });
      return top;
    }

    /**
     * @param {CompiledMode } mode - the mode to potentially end
     * @param {RegExpMatchArray} match - the latest match
     * @param {string} matchPlusRemainder - match plus remainder of content
     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode
     */
    function endOfMode(mode, match, matchPlusRemainder) {
      let matched = startsWith(mode.endRe, matchPlusRemainder);

      if (matched) {
        if (mode["on:end"]) {
          const resp = new Response(mode);
          mode["on:end"](match, resp);
          if (resp.isMatchIgnored) matched = false;
        }

        if (matched) {
          while (mode.endsParent && mode.parent) {
            mode = mode.parent;
          }
          return mode;
        }
      }
      // even if on:end fires an `ignore` it's still possible
      // that we might trigger the end node because of a parent mode
      if (mode.endsWithParent) {
        return endOfMode(mode.parent, match, matchPlusRemainder);
      }
    }

    /**
     * Handle matching but then ignoring a sequence of text
     *
     * @param {string} lexeme - string containing full match text
     */
    function doIgnore(lexeme) {
      if (top.matcher.regexIndex === 0) {
        // no more regexs to potentially match here, so we move the cursor forward one
        // space
        modeBuffer += lexeme[0];
        return 1;
      } else {
        // no need to move the cursor, we still have additional regexes to try and
        // match at this very spot
        resumeScanAtSamePosition = true;
        return 0;
      }
    }

    /**
     * Handle the start of a new potential mode match
     *
     * @param {EnhancedMatch} match - the current match
     * @returns {number} how far to advance the parse cursor
     */
    function doBeginMatch(match) {
      const lexeme = match[0];
      const newMode = match.rule;

      const resp = new Response(newMode);
      // first internal before callbacks, then the public ones
      const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
      for (const cb of beforeCallbacks) {
        if (!cb) continue;
        cb(match, resp);
        if (resp.isMatchIgnored) return doIgnore(lexeme);
      }

      if (newMode && newMode.endSameAsBegin) {
        newMode.endRe = escape(lexeme);
      }

      if (newMode.skip) {
        modeBuffer += lexeme;
      } else {
        if (newMode.excludeBegin) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (!newMode.returnBegin && !newMode.excludeBegin) {
          modeBuffer = lexeme;
        }
      }
      startNewMode(newMode);
      // if (mode["after:begin"]) {
      //   let resp = new Response(mode);
      //   mode["after:begin"](match, resp);
      // }
      return newMode.returnBegin ? 0 : lexeme.length;
    }

    /**
     * Handle the potential end of mode
     *
     * @param {RegExpMatchArray} match - the current match
     */
    function doEndMatch(match) {
      const lexeme = match[0];
      const matchPlusRemainder = codeToHighlight.substr(match.index);

      const endMode = endOfMode(top, match, matchPlusRemainder);
      if (!endMode) { return NO_MATCH; }

      const origin = top;
      if (origin.skip) {
        modeBuffer += lexeme;
      } else {
        if (!(origin.returnEnd || origin.excludeEnd)) {
          modeBuffer += lexeme;
        }
        processBuffer();
        if (origin.excludeEnd) {
          modeBuffer = lexeme;
        }
      }
      do {
        if (top.className) {
          emitter.closeNode();
        }
        if (!top.skip && !top.subLanguage) {
          relevance += top.relevance;
        }
        top = top.parent;
      } while (top !== endMode.parent);
      if (endMode.starts) {
        if (endMode.endSameAsBegin) {
          endMode.starts.endRe = endMode.endRe;
        }
        startNewMode(endMode.starts);
      }
      return origin.returnEnd ? 0 : lexeme.length;
    }

    function processContinuations() {
      const list = [];
      for (let current = top; current !== language; current = current.parent) {
        if (current.className) {
          list.unshift(current.className);
        }
      }
      list.forEach(item => emitter.openNode(item));
    }

    /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */
    let lastMatch = {};

    /**
     *  Process an individual match
     *
     * @param {string} textBeforeMatch - text preceeding the match (since the last match)
     * @param {EnhancedMatch} [match] - the match itself
     */
    function processLexeme(textBeforeMatch, match) {
      const lexeme = match && match[0];

      // add non-matched text to the current mode buffer
      modeBuffer += textBeforeMatch;

      if (lexeme == null) {
        processBuffer();
        return 0;
      }

      // we've found a 0 width match and we're stuck, so we need to advance
      // this happens when we have badly behaved rules that have optional matchers to the degree that
      // sometimes they can end up matching nothing at all
      // Ref: https://github.com/highlightjs/highlight.js/issues/2140
      if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
        // spit the "skipped" character that our regex choked on back into the output sequence
        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
        if (!SAFE_MODE) {
          /** @type {AnnotatedError} */
          const err = new Error('0 width match regex');
          err.languageName = languageName;
          err.badRule = lastMatch.rule;
          throw err;
        }
        return 1;
      }
      lastMatch = match;

      if (match.type === "begin") {
        return doBeginMatch(match);
      } else if (match.type === "illegal" && !ignoreIllegals) {
        // illegal match, we do not continue processing
        /** @type {AnnotatedError} */
        const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
        err.mode = top;
        throw err;
      } else if (match.type === "end") {
        const processed = doEndMatch(match);
        if (processed !== NO_MATCH) {
          return processed;
        }
      }

      // edge case for when illegal matches $ (end of line) which is technically
      // a 0 width match but not a begin/end match so it's not caught by the
      // first handler (when ignoreIllegals is true)
      if (match.type === "illegal" && lexeme === "") {
        // advance so we aren't stuck in an infinite loop
        return 1;
      }

      // infinite loops are BAD, this is a last ditch catch all. if we have a
      // decent number of iterations yet our index (cursor position in our
      // parsing) still 3x behind our index then something is very wrong
      // so we bail
      if (iterations > 100000 && iterations > match.index * 3) {
        const err = new Error('potential infinite loop, way more iterations than matches');
        throw err;
      }

      /*
      Why might be find ourselves here?  Only one occasion now.  An end match that was
      triggered but could not be completed.  When might this happen?  When an `endSameasBegin`
      rule sets the end rule to a specific match.  Since the overall mode termination rule that's
      being used to scan the text isn't recompiled that means that any match that LOOKS like
      the end (but is not, because it is not an exact match to the beginning) will
      end up here.  A definite end match, but when `doEndMatch` tries to "reapply"
      the end rule and fails to match, we wind up here, and just silently ignore the end.

      This causes no real harm other than stopping a few times too many.
      */

      modeBuffer += lexeme;
      return lexeme.length;
    }

    const language = getLanguage(languageName);
    if (!language) {
      error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
      throw new Error('Unknown language: "' + languageName + '"');
    }

    const md = compileLanguage(language, { plugins });
    let result = '';
    /** @type {CompiledMode} */
    let top = continuation || md;
    /** @type Record<string,CompiledMode> */
    const continuations = {}; // keep continuations for sub-languages
    const emitter = new options.__emitter(options);
    processContinuations();
    let modeBuffer = '';
    let relevance = 0;
    let index = 0;
    let iterations = 0;
    let resumeScanAtSamePosition = false;

    try {
      top.matcher.considerAll();

      for (;;) {
        iterations++;
        if (resumeScanAtSamePosition) {
          // only regexes not matched previously will now be
          // considered for a potential match
          resumeScanAtSamePosition = false;
        } else {
          top.matcher.considerAll();
        }
        top.matcher.lastIndex = index;

        const match = top.matcher.exec(codeToHighlight);
        // console.log("match", match[0], match.rule && match.rule.begin)

        if (!match) break;

        const beforeMatch = codeToHighlight.substring(index, match.index);
        const processedCount = processLexeme(beforeMatch, match);
        index = match.index + processedCount;
      }
      processLexeme(codeToHighlight.substr(index));
      emitter.closeAllNodes();
      emitter.finalize();
      result = emitter.toHTML();

      return {
        // avoid possible breakage with v10 clients expecting
        // this to always be an integer
        relevance: Math.floor(relevance),
        value: result,
        language: languageName,
        illegal: false,
        emitter: emitter,
        top: top
      };
    } catch (err) {
      if (err.message && err.message.includes('Illegal')) {
        return {
          illegal: true,
          illegalBy: {
            msg: err.message,
            context: codeToHighlight.slice(index - 100, index + 100),
            mode: err.mode
          },
          sofar: result,
          relevance: 0,
          value: escape$1(codeToHighlight),
          emitter: emitter
        };
      } else if (SAFE_MODE) {
        return {
          illegal: false,
          relevance: 0,
          value: escape$1(codeToHighlight),
          emitter: emitter,
          language: languageName,
          top: top,
          errorRaised: err
        };
      } else {
        throw err;
      }
    }
  }

  /**
   * returns a valid highlight result, without actually doing any actual work,
   * auto highlight starts with this and it's possible for small snippets that
   * auto-detection may not find a better match
   * @param {string} code
   * @returns {HighlightResult}
   */
  function justTextHighlightResult(code) {
    const result = {
      relevance: 0,
      emitter: new options.__emitter(options),
      value: escape$1(code),
      illegal: false,
      top: PLAINTEXT_LANGUAGE
    };
    result.emitter.addText(code);
    return result;
  }

  /**
  Highlighting with language detection. Accepts a string with the code to
  highlight. Returns an object with the following properties:

  - language (detected language)
  - relevance (int)
  - value (an HTML string with highlighting markup)
  - second_best (object with the same structure for second-best heuristically
    detected language, may be absent)

    @param {string} code
    @param {Array<string>} [languageSubset]
    @returns {AutoHighlightResult}
  */
  function highlightAuto(code, languageSubset) {
    languageSubset = languageSubset || options.languages || Object.keys(languages);
    const plaintext = justTextHighlightResult(code);

    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>
      _highlight(name, code, false)
    );
    results.unshift(plaintext); // plaintext is always an option

    const sorted = results.sort((a, b) => {
      // sort base on relevance
      if (a.relevance !== b.relevance) return b.relevance - a.relevance;

      // always award the tie to the base language
      // ie if C++ and Arduino are tied, it's more likely to be C++
      if (a.language && b.language) {
        if (getLanguage(a.language).supersetOf === b.language) {
          return 1;
        } else if (getLanguage(b.language).supersetOf === a.language) {
          return -1;
        }
      }

      // otherwise say they are equal, which has the effect of sorting on
      // relevance while preserving the original ordering - which is how ties
      // have historically been settled, ie the language that comes first always
      // wins in the case of a tie
      return 0;
    });

    const [best, secondBest] = sorted;

    /** @type {AutoHighlightResult} */
    const result = best;
    result.second_best = secondBest;

    return result;
  }

  /**
  Post-processing of the highlighted markup:

  - replace TABs with something more useful
  - replace real line-breaks with '<br>' for non-pre containers

    @param {string} html
    @returns {string}
  */
  function fixMarkup(html) {
    if (!(options.tabReplace || options.useBR)) {
      return html;
    }

    return html.replace(fixMarkupRe, match => {
      if (match === '\n') {
        return options.useBR ? '<br>' : match;
      } else if (options.tabReplace) {
        return match.replace(/\t/g, options.tabReplace);
      }
      return match;
    });
  }

  /**
   * Builds new class name for block given the language name
   *
   * @param {HTMLElement} element
   * @param {string} [currentLang]
   * @param {string} [resultLang]
   */
  function updateClassName(element, currentLang, resultLang) {
    const language = currentLang ? aliases[currentLang] : resultLang;

    element.classList.add("hljs");
    if (language) element.classList.add(language);
  }

  /** @type {HLJSPlugin} */
  const brPlugin = {
    "before:highlightElement": ({ el }) => {
      if (options.useBR) {
        el.innerHTML = el.innerHTML.replace(/\n/g, '').replace(/<br[ /]*>/g, '\n');
      }
    },
    "after:highlightElement": ({ result }) => {
      if (options.useBR) {
        result.value = result.value.replace(/\n/g, "<br>");
      }
    }
  };

  const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
  /** @type {HLJSPlugin} */
  const tabReplacePlugin = {
    "after:highlightElement": ({ result }) => {
      if (options.tabReplace) {
        result.value = result.value.replace(TAB_REPLACE_RE, (m) =>
          m.replace(/\t/g, options.tabReplace)
        );
      }
    }
  };

  /**
   * Applies highlighting to a DOM node containing code. Accepts a DOM node and
   * two optional parameters for fixMarkup.
   *
   * @param {HighlightedHTMLElement} element - the HTML element to highlight
  */
  function highlightElement(element) {
    /** @type HTMLElement */
    let node = null;
    const language = blockLanguage(element);

    if (shouldNotHighlight(language)) return;

    // support for v10 API
    fire("before:highlightElement",
      { el: element, language: language });

    node = element;
    const text = node.textContent;
    const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);

    // support for v10 API
    fire("after:highlightElement", { el: element, result, text });

    element.innerHTML = result.value;
    updateClassName(element, language, result.language);
    element.result = {
      language: result.language,
      // TODO: remove with version 11.0
      re: result.relevance,
      relavance: result.relevance
    };
    if (result.second_best) {
      element.second_best = {
        language: result.second_best.language,
        // TODO: remove with version 11.0
        re: result.second_best.relevance,
        relavance: result.second_best.relevance
      };
    }
  }

  /**
   * Updates highlight.js global options with the passed options
   *
   * @param {Partial<HLJSOptions>} userOptions
   */
  function configure(userOptions) {
    if (userOptions.useBR) {
      deprecated("10.3.0", "'useBR' will be removed entirely in v11.0");
      deprecated("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
    }
    options = inherit$1(options, userOptions);
  }

  /**
   * Highlights to all <pre><code> blocks on a page
   *
   * @type {Function & {called?: boolean}}
   */
  // TODO: remove v12, deprecated
  const initHighlighting = () => {
    if (initHighlighting.called) return;
    initHighlighting.called = true;

    deprecated("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");

    const blocks = document.querySelectorAll('pre code');
    blocks.forEach(highlightElement);
  };

  // Higlights all when DOMContentLoaded fires
  // TODO: remove v12, deprecated
  function initHighlightingOnLoad() {
    deprecated("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
    wantsHighlight = true;
  }

  let wantsHighlight = false;

  /**
   * auto-highlights all pre>code elements on the page
   */
  function highlightAll() {
    // if we are called too early in the loading process
    if (document.readyState === "loading") {
      wantsHighlight = true;
      return;
    }

    const blocks = document.querySelectorAll('pre code');
    blocks.forEach(highlightElement);
  }

  function boot() {
    // if a highlight was requested before DOM was loaded, do now
    if (wantsHighlight) highlightAll();
  }

  // make sure we are in the browser environment
  if (typeof window !== 'undefined' && window.addEventListener) {
    window.addEventListener('DOMContentLoaded', boot, false);
  }

  /**
   * Register a language grammar module
   *
   * @param {string} languageName
   * @param {LanguageFn} languageDefinition
   */
  function registerLanguage(languageName, languageDefinition) {
    let lang = null;
    try {
      lang = languageDefinition(hljs);
    } catch (error$1) {
      error("Language definition for '{}' could not be registered.".replace("{}", languageName));
      // hard or soft error
      if (!SAFE_MODE) { throw error$1; } else { error(error$1); }
      // languages that have serious errors are replaced with essentially a
      // "plaintext" stand-in so that the code blocks will still get normal
      // css classes applied to them - and one bad language won't break the
      // entire highlighter
      lang = PLAINTEXT_LANGUAGE;
    }
    // give it a temporary name if it doesn't have one in the meta-data
    if (!lang.name) lang.name = languageName;
    languages[languageName] = lang;
    lang.rawDefinition = languageDefinition.bind(null, hljs);

    if (lang.aliases) {
      registerAliases(lang.aliases, { languageName });
    }
  }

  /**
   * Remove a language grammar module
   *
   * @param {string} languageName
   */
  function unregisterLanguage(languageName) {
    delete languages[languageName];
    for (const alias of Object.keys(aliases)) {
      if (aliases[alias] === languageName) {
        delete aliases[alias];
      }
    }
  }

  /**
   * @returns {string[]} List of language internal names
   */
  function listLanguages() {
    return Object.keys(languages);
  }

  /**
    intended usage: When one language truly requires another

    Unlike `getLanguage`, this will throw when the requested language
    is not available.

    @param {string} name - name of the language to fetch/require
    @returns {Language | never}
  */
  function requireLanguage(name) {
    deprecated("10.4.0", "requireLanguage will be removed entirely in v11.");
    deprecated("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");

    const lang = getLanguage(name);
    if (lang) { return lang; }

    const err = new Error('The \'{}\' language is required, but not loaded.'.replace('{}', name));
    throw err;
  }

  /**
   * @param {string} name - name of the language to retrieve
   * @returns {Language | undefined}
   */
  function getLanguage(name) {
    name = (name || '').toLowerCase();
    return languages[name] || languages[aliases[name]];
  }

  /**
   *
   * @param {string|string[]} aliasList - single alias or list of aliases
   * @param {{languageName: string}} opts
   */
  function registerAliases(aliasList, { languageName }) {
    if (typeof aliasList === 'string') {
      aliasList = [aliasList];
    }
    aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });
  }

  /**
   * Determines if a given language has auto-detection enabled
   * @param {string} name - name of the language
   */
  function autoDetection(name) {
    const lang = getLanguage(name);
    return lang && !lang.disableAutodetect;
  }

  /**
   * Upgrades the old highlightBlock plugins to the new
   * highlightElement API
   * @param {HLJSPlugin} plugin
   */
  function upgradePluginAPI(plugin) {
    // TODO: remove with v12
    if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
      plugin["before:highlightElement"] = (data) => {
        plugin["before:highlightBlock"](
          Object.assign({ block: data.el }, data)
        );
      };
    }
    if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
      plugin["after:highlightElement"] = (data) => {
        plugin["after:highlightBlock"](
          Object.assign({ block: data.el }, data)
        );
      };
    }
  }

  /**
   * @param {HLJSPlugin} plugin
   */
  function addPlugin(plugin) {
    upgradePluginAPI(plugin);
    plugins.push(plugin);
  }

  /**
   *
   * @param {PluginEvent} event
   * @param {any} args
   */
  function fire(event, args) {
    const cb = event;
    plugins.forEach(function(plugin) {
      if (plugin[cb]) {
        plugin[cb](args);
      }
    });
  }

  /**
  Note: fixMarkup is deprecated and will be removed entirely in v11

  @param {string} arg
  @returns {string}
  */
  function deprecateFixMarkup(arg) {
    deprecated("10.2.0", "fixMarkup will be removed entirely in v11.0");
    deprecated("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");

    return fixMarkup(arg);
  }

  /**
   *
   * @param {HighlightedHTMLElement} el
   */
  function deprecateHighlightBlock(el) {
    deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
    deprecated("10.7.0", "Please use highlightElement now.");

    return highlightElement(el);
  }

  /* Interface definition */
  Object.assign(hljs, {
    highlight,
    highlightAuto,
    highlightAll,
    fixMarkup: deprecateFixMarkup,
    highlightElement,
    // TODO: Remove with v12 API
    highlightBlock: deprecateHighlightBlock,
    configure,
    initHighlighting,
    initHighlightingOnLoad,
    registerLanguage,
    unregisterLanguage,
    listLanguages,
    getLanguage,
    registerAliases,
    requireLanguage,
    autoDetection,
    inherit: inherit$1,
    addPlugin,
    // plugins for frameworks
    vuePlugin: BuildVuePlugin(hljs).VuePlugin
  });

  hljs.debugMode = function() { SAFE_MODE = false; };
  hljs.safeMode = function() { SAFE_MODE = true; };
  hljs.versionString = version;

  for (const key in MODES) {
    // @ts-ignore
    if (typeof MODES[key] === "object") {
      // @ts-ignore
      deepFreezeEs6(MODES[key]);
    }
  }

  // merge all the modes/regexs into our main object
  Object.assign(hljs, MODES);

  // built-in plugins, likely to be moved out of core in the future
  hljs.addPlugin(brPlugin); // slated to be removed in v11
  hljs.addPlugin(mergeHTMLPlugin);
  hljs.addPlugin(tabReplacePlugin);
  return hljs;
};

// export an "instance" of the highlighter
var highlight = HLJS({});

module.exports = highlight;


/***/ }),

/***/ "107c":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('(?<a>b)', 'g');
  return re.exec('b').groups.a !== 'b' ||
    'b'.replace(re, '$<a>c') !== 'bc';
});


/***/ }),

/***/ "10b2":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("56b3"));
  else {}
})(function(CodeMirror) {
  var defaults = {
    pairs: "()[]{}''\"\"",
    closeBefore: ")]}'\":;>",
    triples: "",
    explode: "[]{}"
  };

  var Pos = CodeMirror.Pos;

  CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.removeKeyMap(keyMap);
      cm.state.closeBrackets = null;
    }
    if (val) {
      ensureBound(getOption(val, "pairs"))
      cm.state.closeBrackets = val;
      cm.addKeyMap(keyMap);
    }
  });

  function getOption(conf, name) {
    if (name == "pairs" && typeof conf == "string") return conf;
    if (typeof conf == "object" && conf[name] != null) return conf[name];
    return defaults[name];
  }

  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};
  function ensureBound(chars) {
    for (var i = 0; i < chars.length; i++) {
      var ch = chars.charAt(i), key = "'" + ch + "'"
      if (!keyMap[key]) keyMap[key] = handler(ch)
    }
  }
  ensureBound(defaults.pairs + "`")

  function handler(ch) {
    return function(cm) { return handleChar(cm, ch); };
  }

  function getConfig(cm) {
    var deflt = cm.state.closeBrackets;
    if (!deflt || deflt.override) return deflt;
    var mode = cm.getModeAt(cm.getCursor());
    return mode.closeBrackets || deflt;
  }

  function handleBackspace(cm) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

    var pairs = getOption(conf, "pairs");
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }
    for (var i = ranges.length - 1; i >= 0; i--) {
      var cur = ranges[i].head;
      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
    }
  }

  function handleEnter(cm) {
    var conf = getConfig(cm);
    var explode = conf && getOption(conf, "explode");
    if (!explode || cm.getOption("disableInput")) return CodeMirror.Pass;

    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;
    }
    cm.operation(function() {
      var linesep = cm.lineSeparator() || "\n";
      cm.replaceSelection(linesep + linesep, null);
      moveSel(cm, -1)
      ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        var line = ranges[i].head.line;
        cm.indentLine(line, null, true);
        cm.indentLine(line + 1, null, true);
      }
    });
  }

  function moveSel(cm, dir) {
    var newRanges = [], ranges = cm.listSelections(), primary = 0
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i]
      if (range.head == cm.getCursor()) primary = i
      var pos = range.head.ch || dir > 0 ? {line: range.head.line, ch: range.head.ch + dir} : {line: range.head.line - 1}
      newRanges.push({anchor: pos, head: pos})
    }
    cm.setSelections(newRanges, primary)
  }

  function contractSelection(sel) {
    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;
    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};
  }

  function handleChar(cm, ch) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror.Pass;

    var pairs = getOption(conf, "pairs");
    var pos = pairs.indexOf(ch);
    if (pos == -1) return CodeMirror.Pass;

    var closeBefore = getOption(conf,"closeBefore");

    var triples = getOption(conf, "triples");

    var identical = pairs.charAt(pos + 1) == ch;
    var ranges = cm.listSelections();
    var opening = pos % 2 == 0;

    var type;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i], cur = range.head, curType;
      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
      if (opening && !range.empty()) {
        curType = "surround";
      } else if ((identical || !opening) && next == ch) {
        if (identical && stringStartsAfter(cm, cur))
          curType = "both";
        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
          curType = "skipThree";
        else
          curType = "skip";
      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&
                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
        if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;
        curType = "addFour";
      } else if (identical) {
        var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur)
        if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = "both";
        else return CodeMirror.Pass;
      } else if (opening && (next.length === 0 || /\s/.test(next) || closeBefore.indexOf(next) > -1)) {
        curType = "both";
      } else {
        return CodeMirror.Pass;
      }
      if (!type) type = curType;
      else if (type != curType) return CodeMirror.Pass;
    }

    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
    cm.operation(function() {
      if (type == "skip") {
        moveSel(cm, 1)
      } else if (type == "skipThree") {
        moveSel(cm, 3)
      } else if (type == "surround") {
        var sels = cm.getSelections();
        for (var i = 0; i < sels.length; i++)
          sels[i] = left + sels[i] + right;
        cm.replaceSelections(sels, "around");
        sels = cm.listSelections().slice();
        for (var i = 0; i < sels.length; i++)
          sels[i] = contractSelection(sels[i]);
        cm.setSelections(sels);
      } else if (type == "both") {
        cm.replaceSelection(left + right, null);
        cm.triggerElectric(left + right);
        moveSel(cm, -1)
      } else if (type == "addFour") {
        cm.replaceSelection(left + left + left + left, "before");
        moveSel(cm, 1)
      }
    });
  }

  function charsAround(cm, pos) {
    var str = cm.getRange(Pos(pos.line, pos.ch - 1),
                          Pos(pos.line, pos.ch + 1));
    return str.length == 2 ? str : null;
  }

  function stringStartsAfter(cm, pos) {
    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))
    return /\bstring/.test(token.type) && token.start == pos.ch &&
      (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)))
  }
});


/***/ }),

/***/ "10d1":
/***/ (function(module, exports, __webpack_require__) {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__("0094");


/***/ }),

/***/ "1148":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIntegerOrInfinity = __webpack_require__("5926");
var toString = __webpack_require__("577e");
var requireObjectCoercible = __webpack_require__("1d80");

var $RangeError = RangeError;

// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = function repeat(count) {
  var str = toString(requireObjectCoercible(this));
  var result = '';
  var n = toIntegerOrInfinity(count);
  if (n < 0 || n == Infinity) throw $RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "1157":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.0
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-05-11T18:29Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.0",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			return elem.textContent;
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (see trac-13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented
// as part of Sizzle so let's maintain them in the 3.x line
// for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is display: block
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "115e":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "1276":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var apply = __webpack_require__("2ba4");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var anObject = __webpack_require__("825a");
var isNullOrUndefined = __webpack_require__("7234");
var isRegExp = __webpack_require__("44e7");
var requireObjectCoercible = __webpack_require__("1d80");
var speciesConstructor = __webpack_require__("4840");
var advanceStringIndex = __webpack_require__("8aa5");
var toLength = __webpack_require__("50c4");
var toString = __webpack_require__("577e");
var getMethod = __webpack_require__("dc4a");
var arraySlice = __webpack_require__("4dae");
var callRegExpExec = __webpack_require__("14c3");
var regexpExec = __webpack_require__("9263");
var stickyHelpers = __webpack_require__("9f7f");
var fails = __webpack_require__("d039");

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var MAX_UINT32 = 0xFFFFFFFF;
var min = Math.min;
var $push = [].push;
var exec = uncurryThis(/./.exec);
var push = uncurryThis($push);
var stringSlice = uncurryThis(''.slice);

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  // eslint-disable-next-line regexp/no-empty-group -- required for testing
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

// @@split logic
fixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = toString(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return call(nativeSplit, string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = call(regexpExec, separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          push(output, stringSlice(string, lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !exec(separatorCopy, '')) push(output, '');
      } else push(output, stringSlice(string, lastLastIndex));
      return output.length > lim ? arraySlice(output, 0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = isNullOrUndefined(separator) ? undefined : getMethod(separator, SPLIT);
      return splitter
        ? call(splitter, separator, O, limit)
        : call(internalSplit, toString(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (string, limit) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);

      if (res.done) return res.value;

      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (UNSUPPORTED_Y ? 'g' : 'y');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          push(A, stringSlice(S, p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            push(A, z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      push(A, stringSlice(S, p));
      return A;
    }
  ];
}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);


/***/ }),

/***/ "129f":
/***/ (function(module, exports) {

// `SameValue` abstract operation
// https://tc39.es/ecma262/#sec-samevalue
// eslint-disable-next-line es/no-object-is -- safe
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare -- NaN check
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "130f":
/***/ (function(module, exports, __webpack_require__) {

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__("e20c");
__webpack_require__("0402");


/***/ }),

/***/ "131a":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var setPrototypeOf = __webpack_require__("d2bb");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ "13d2":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var fails = __webpack_require__("d039");
var isCallable = __webpack_require__("1626");
var hasOwn = __webpack_require__("1a2d");
var DESCRIPTORS = __webpack_require__("83ab");
var CONFIGURABLE_FUNCTION_NAME = __webpack_require__("5e77").CONFIGURABLE;
var inspectSource = __webpack_require__("8925");
var InternalStateModule = __webpack_require__("69f3");

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\)/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ "13d5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $reduce = __webpack_require__("d58f").left;
var arrayMethodIsStrict = __webpack_require__("a640");
var CHROME_VERSION = __webpack_require__("2d00");
var IS_NODE = __webpack_require__("605d");

// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
var FORCED = CHROME_BUG || !arrayMethodIsStrict('reduce');

// `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: FORCED }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    var length = arguments.length;
    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "1448":
/***/ (function(module, exports, __webpack_require__) {

var arrayFromConstructorAndList = __webpack_require__("dfb9");
var typedArraySpeciesConstructor = __webpack_require__("b6b7");

module.exports = function (instance, list) {
  return arrayFromConstructorAndList(typedArraySpeciesConstructor(instance), list);
};


/***/ }),

/***/ "145e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__("7b0b");
var toAbsoluteIndex = __webpack_require__("23cb");
var lengthOfArrayLike = __webpack_require__("07fa");
var deletePropertyOrThrow = __webpack_require__("083a");

var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
// eslint-disable-next-line es/no-array-prototype-copywithin -- safe
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = lengthOfArrayLike(O);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else deletePropertyOrThrow(O, to);
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "14c3":
/***/ (function(module, exports, __webpack_require__) {

var call = __webpack_require__("c65b");
var anObject = __webpack_require__("825a");
var isCallable = __webpack_require__("1626");
var classof = __webpack_require__("c6b6");
var regexpExec = __webpack_require__("9263");

var $TypeError = TypeError;

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (isCallable(exec)) {
    var result = call(exec, R, S);
    if (result !== null) anObject(result);
    return result;
  }
  if (classof(R) === 'RegExp') return call(regexpExec, R, S);
  throw $TypeError('RegExp#exec called on incompatible receiver');
};


/***/ }),

/***/ "14d9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");
var setArrayLength = __webpack_require__("3a34");
var doesNotExceedSafeInteger = __webpack_require__("3511");
var fails = __webpack_require__("d039");

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 and Safari <= 15.4, FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),

/***/ "14e5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var call = __webpack_require__("c65b");
var aCallable = __webpack_require__("59ed");
var newPromiseCapabilityModule = __webpack_require__("f069");
var perform = __webpack_require__("e667");
var iterate = __webpack_require__("2266");
var PROMISE_STATICS_INCORRECT_ITERATION = __webpack_require__("5eed");

// `Promise.all` method
// https://tc39.es/ecma262/#sec-promise.all
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        remaining++;
        call($promiseResolve, C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "159b":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DOMIterables = __webpack_require__("fdbc");
var DOMTokenListPrototype = __webpack_require__("785a");
var forEach = __webpack_require__("17c2");
var createNonEnumerableProperty = __webpack_require__("9112");

var handlePrototype = function (CollectionPrototype) {
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  if (DOMIterables[COLLECTION_NAME]) {
    handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype);
  }
}

handlePrototype(DOMTokenListPrototype);


/***/ }),

/***/ "1626":
/***/ (function(module, exports, __webpack_require__) {

var $documentAll = __webpack_require__("8ea1");

var documentAll = $documentAll.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = $documentAll.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "170b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var toLength = __webpack_require__("50c4");
var toAbsoluteIndex = __webpack_require__("23cb");
var typedArraySpeciesConstructor = __webpack_require__("b6b7");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.subarray` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  var C = typedArraySpeciesConstructor(O);
  return new C(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});


/***/ }),

/***/ "1732":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("25f0");
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("e260");
/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_buffer_slice_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("ace4");
/* harmony import */ var core_js_modules_es_array_buffer_slice_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_buffer_slice_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_typed_array_uint8_array_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("5cc6");
/* harmony import */ var core_js_modules_es_typed_array_uint8_array_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_uint8_array_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_typed_array_at_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("907a");
/* harmony import */ var core_js_modules_es_typed_array_at_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_at_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_typed_array_copy_within_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("9a8c");
/* harmony import */ var core_js_modules_es_typed_array_copy_within_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_copy_within_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_typed_array_every_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("a975");
/* harmony import */ var core_js_modules_es_typed_array_every_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_every_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_typed_array_fill_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("735e");
/* harmony import */ var core_js_modules_es_typed_array_fill_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_fill_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_typed_array_filter_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("c1ac");
/* harmony import */ var core_js_modules_es_typed_array_filter_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_filter_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es_typed_array_find_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("d139");
/* harmony import */ var core_js_modules_es_typed_array_find_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_find_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_es_typed_array_find_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("3a7b");
/* harmony import */ var core_js_modules_es_typed_array_find_index_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_find_index_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_es_typed_array_find_last_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("986a");
/* harmony import */ var core_js_modules_es_typed_array_find_last_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_find_last_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_es_typed_array_find_last_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("1d02");
/* harmony import */ var core_js_modules_es_typed_array_find_last_index_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_find_last_index_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var core_js_modules_es_typed_array_for_each_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("d5d6");
/* harmony import */ var core_js_modules_es_typed_array_for_each_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_for_each_js__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var core_js_modules_es_typed_array_includes_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("82f8");
/* harmony import */ var core_js_modules_es_typed_array_includes_js__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_includes_js__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var core_js_modules_es_typed_array_index_of_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("e91f");
/* harmony import */ var core_js_modules_es_typed_array_index_of_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_index_of_js__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var core_js_modules_es_typed_array_iterator_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__("60bd");
/* harmony import */ var core_js_modules_es_typed_array_iterator_js__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_iterator_js__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var core_js_modules_es_typed_array_join_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__("5f96");
/* harmony import */ var core_js_modules_es_typed_array_join_js__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_join_js__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var core_js_modules_es_typed_array_last_index_of_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__("3280");
/* harmony import */ var core_js_modules_es_typed_array_last_index_of_js__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_last_index_of_js__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var core_js_modules_es_typed_array_map_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__("3fcc");
/* harmony import */ var core_js_modules_es_typed_array_map_js__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_map_js__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var core_js_modules_es_typed_array_reduce_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__("ca91");
/* harmony import */ var core_js_modules_es_typed_array_reduce_js__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_reduce_js__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var core_js_modules_es_typed_array_reduce_right_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__("25a1");
/* harmony import */ var core_js_modules_es_typed_array_reduce_right_js__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_reduce_right_js__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var core_js_modules_es_typed_array_reverse_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__("cd26");
/* harmony import */ var core_js_modules_es_typed_array_reverse_js__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_reverse_js__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var core_js_modules_es_typed_array_set_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__("3c5d");
/* harmony import */ var core_js_modules_es_typed_array_set_js__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_set_js__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var core_js_modules_es_typed_array_slice_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__("2954");
/* harmony import */ var core_js_modules_es_typed_array_slice_js__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_slice_js__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var core_js_modules_es_typed_array_some_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__("649e");
/* harmony import */ var core_js_modules_es_typed_array_some_js__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_some_js__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var core_js_modules_es_typed_array_sort_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__("219c");
/* harmony import */ var core_js_modules_es_typed_array_sort_js__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_sort_js__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var core_js_modules_es_typed_array_subarray_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__("170b");
/* harmony import */ var core_js_modules_es_typed_array_subarray_js__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_subarray_js__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var core_js_modules_es_typed_array_to_locale_string_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__("b39a");
/* harmony import */ var core_js_modules_es_typed_array_to_locale_string_js__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_to_locale_string_js__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var core_js_modules_es_typed_array_to_reversed_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__("6ce5");
/* harmony import */ var core_js_modules_es_typed_array_to_reversed_js__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_to_reversed_js__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var core_js_modules_es_typed_array_to_sorted_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__("2834");
/* harmony import */ var core_js_modules_es_typed_array_to_sorted_js__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_to_sorted_js__WEBPACK_IMPORTED_MODULE_31__);
/* harmony import */ var core_js_modules_es_typed_array_to_string_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__("72f7");
/* harmony import */ var core_js_modules_es_typed_array_to_string_js__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_to_string_js__WEBPACK_IMPORTED_MODULE_32__);
/* harmony import */ var core_js_modules_es_typed_array_with_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__("4ea1");
/* harmony import */ var core_js_modules_es_typed_array_with_js__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_typed_array_with_js__WEBPACK_IMPORTED_MODULE_33__);
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__("14d9");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_34___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_34__);
/* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__("fb6a");
/* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_35___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_35__);




































/**
 * Based on the work of https://github.com/jchook/uuid-random
 */

var buf,
  bufIdx = 0;
var hexBytes = new Array(256);

// Pre-calculate toString(16) for speed
for (var i = 0; i < 256; i++) {
  hexBytes[i] = (i + 0x100).toString(16).substr(1);
}

// Use best available PRNG
var randomBytes = function () {
  // Node & Browser support
  var lib = typeof crypto !== 'undefined' ? crypto : typeof window !== 'undefined' ? window.msCrypto // IE11
  : void 0;
  if (lib !== void 0) {
    if (lib.randomBytes !== void 0) {
      return lib.randomBytes;
    }
    if (lib.getRandomValues !== void 0) {
      return function (n) {
        var bytes = new Uint8Array(n);
        lib.getRandomValues(bytes);
        return bytes;
      };
    }
  }
  return function (n) {
    var r = [];
    for (var _i = n; _i > 0; _i--) {
      r.push(Math.floor(Math.random() * 256));
    }
    return r;
  };
}();

// Buffer random numbers for speed
// Reduce memory usage by decreasing this number (min 16)
// or improve speed by increasing this number (try 16384)
var BUFFER_SIZE = 4096;
/* harmony default export */ __webpack_exports__["a"] = (function () {
  // Buffer some random bytes for speed
  if (buf === void 0 || bufIdx + 16 > BUFFER_SIZE) {
    bufIdx = 0;
    buf = randomBytes(BUFFER_SIZE);
  }
  var b = Array.prototype.slice.call(buf, bufIdx, bufIdx += 16);
  b[6] = b[6] & 0x0f | 0x40;
  b[8] = b[8] & 0x3f | 0x80;
  return hexBytes[b[0]] + hexBytes[b[1]] + hexBytes[b[2]] + hexBytes[b[3]] + '-' + hexBytes[b[4]] + hexBytes[b[5]] + '-' + hexBytes[b[6]] + hexBytes[b[7]] + '-' + hexBytes[b[8]] + hexBytes[b[9]] + '-' + hexBytes[b[10]] + hexBytes[b[11]] + hexBytes[b[12]] + hexBytes[b[13]] + hexBytes[b[14]] + hexBytes[b[15]];
});

/***/ }),

/***/ "17bf":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_AppEditor_vue_vue_type_style_index_0_id_0797aa13_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5cfd");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_AppEditor_vue_vue_type_style_index_0_id_0797aa13_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_AppEditor_vue_vue_type_style_index_0_id_0797aa13_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "17c2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $forEach = __webpack_require__("b727").forEach;
var arrayMethodIsStrict = __webpack_require__("a640");

var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;


/***/ }),

/***/ "182d":
/***/ (function(module, exports, __webpack_require__) {

var toPositiveInteger = __webpack_require__("f8cd");

var $RangeError = RangeError;

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw $RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ "18a5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var createHTML = __webpack_require__("857a");
var forcedStringHTMLMethod = __webpack_require__("af03");

// `String.prototype.anchor` method
// https://tc39.es/ecma262/#sec-string.prototype.anchor
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('anchor') }, {
  anchor: function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  }
});


/***/ }),

/***/ "19aa":
/***/ (function(module, exports, __webpack_require__) {

var isPrototypeOf = __webpack_require__("3a9b");

var $TypeError = TypeError;

module.exports = function (it, Prototype) {
  if (isPrototypeOf(Prototype, it)) return it;
  throw $TypeError('Incorrect invocation');
};


/***/ }),

/***/ "1a2d":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var toObject = __webpack_require__("7b0b");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "1ad7":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "1b40":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ vue_class_component_esm; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ external_commonjs_vue_commonjs2_vue_root_Vue_default.a; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ Prop; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ Watch; });

// UNUSED EXPORTS: Mixins, Emit, Inject, InjectReactive, Model, ModelSync, PropSync, Provide, ProvideReactive, Ref, VModel

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// CONCATENATED MODULE: ./node_modules/vue-class-component/dist/vue-class-component.esm.js
/**
  * vue-class-component v7.2.6
  * (c) 2015-present Evan You
  * @license MIT
  */


function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

// The rational behind the verbose Reflect-feature check below is the fact that there are polyfills
// which add an implementation for Reflect.defineMetadata but not for Reflect.getOwnMetadataKeys.
// Without this check consumers will encounter hard to track down runtime errors.
function reflectionIsSupported() {
  return typeof Reflect !== 'undefined' && Reflect.defineMetadata && Reflect.getOwnMetadataKeys;
}
function copyReflectionMetadata(to, from) {
  forwardMetadata(to, from);
  Object.getOwnPropertyNames(from.prototype).forEach(function (key) {
    forwardMetadata(to.prototype, from.prototype, key);
  });
  Object.getOwnPropertyNames(from).forEach(function (key) {
    forwardMetadata(to, from, key);
  });
}

function forwardMetadata(to, from, propertyKey) {
  var metaKeys = propertyKey ? Reflect.getOwnMetadataKeys(from, propertyKey) : Reflect.getOwnMetadataKeys(from);
  metaKeys.forEach(function (metaKey) {
    var metadata = propertyKey ? Reflect.getOwnMetadata(metaKey, from, propertyKey) : Reflect.getOwnMetadata(metaKey, from);

    if (propertyKey) {
      Reflect.defineMetadata(metaKey, metadata, to, propertyKey);
    } else {
      Reflect.defineMetadata(metaKey, metadata, to);
    }
  });
}

var fakeArray = {
  __proto__: []
};
var hasProto = fakeArray instanceof Array;
function createDecorator(factory) {
  return function (target, key, index) {
    var Ctor = typeof target === 'function' ? target : target.constructor;

    if (!Ctor.__decorators__) {
      Ctor.__decorators__ = [];
    }

    if (typeof index !== 'number') {
      index = undefined;
    }

    Ctor.__decorators__.push(function (options) {
      return factory(options, key, index);
    });
  };
}
function mixins() {
  for (var _len = arguments.length, Ctors = new Array(_len), _key = 0; _key < _len; _key++) {
    Ctors[_key] = arguments[_key];
  }

  return external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
    mixins: Ctors
  });
}
function isPrimitive(value) {
  var type = _typeof(value);

  return value == null || type !== 'object' && type !== 'function';
}
function warn(message) {
  if (typeof console !== 'undefined') {
    console.warn('[vue-class-component] ' + message);
  }
}

function collectDataFromConstructor(vm, Component) {
  // override _init to prevent to init as Vue instance
  var originalInit = Component.prototype._init;

  Component.prototype._init = function () {
    var _this = this;

    // proxy to actual vm
    var keys = Object.getOwnPropertyNames(vm); // 2.2.0 compat (props are no longer exposed as self properties)

    if (vm.$options.props) {
      for (var key in vm.$options.props) {
        if (!vm.hasOwnProperty(key)) {
          keys.push(key);
        }
      }
    }

    keys.forEach(function (key) {
      Object.defineProperty(_this, key, {
        get: function get() {
          return vm[key];
        },
        set: function set(value) {
          vm[key] = value;
        },
        configurable: true
      });
    });
  }; // should be acquired class property values


  var data = new Component(); // restore original _init to avoid memory leak (#209)

  Component.prototype._init = originalInit; // create plain data object

  var plainData = {};
  Object.keys(data).forEach(function (key) {
    if (data[key] !== undefined) {
      plainData[key] = data[key];
    }
  });

  if (false) {}

  return plainData;
}

var $internalHooks = ['data', 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeDestroy', 'destroyed', 'beforeUpdate', 'updated', 'activated', 'deactivated', 'render', 'errorCaptured', 'serverPrefetch' // 2.6
];
function componentFactory(Component) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options.name = options.name || Component._componentTag || Component.name; // prototype props.

  var proto = Component.prototype;
  Object.getOwnPropertyNames(proto).forEach(function (key) {
    if (key === 'constructor') {
      return;
    } // hooks


    if ($internalHooks.indexOf(key) > -1) {
      options[key] = proto[key];
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(proto, key);

    if (descriptor.value !== void 0) {
      // methods
      if (typeof descriptor.value === 'function') {
        (options.methods || (options.methods = {}))[key] = descriptor.value;
      } else {
        // typescript decorated data
        (options.mixins || (options.mixins = [])).push({
          data: function data() {
            return _defineProperty({}, key, descriptor.value);
          }
        });
      }
    } else if (descriptor.get || descriptor.set) {
      // computed properties
      (options.computed || (options.computed = {}))[key] = {
        get: descriptor.get,
        set: descriptor.set
      };
    }
  });
  (options.mixins || (options.mixins = [])).push({
    data: function data() {
      return collectDataFromConstructor(this, Component);
    }
  }); // decorate options

  var decorators = Component.__decorators__;

  if (decorators) {
    decorators.forEach(function (fn) {
      return fn(options);
    });
    delete Component.__decorators__;
  } // find super


  var superProto = Object.getPrototypeOf(Component.prototype);
  var Super = superProto instanceof external_commonjs_vue_commonjs2_vue_root_Vue_default.a ? superProto.constructor : external_commonjs_vue_commonjs2_vue_root_Vue_default.a;
  var Extended = Super.extend(options);
  forwardStaticMembers(Extended, Component, Super);

  if (reflectionIsSupported()) {
    copyReflectionMetadata(Extended, Component);
  }

  return Extended;
}
var reservedPropertyNames = [// Unique id
'cid', // Super Vue constructor
'super', // Component options that will be used by the component
'options', 'superOptions', 'extendOptions', 'sealedOptions', // Private assets
'component', 'directive', 'filter'];
var shouldIgnore = {
  prototype: true,
  arguments: true,
  callee: true,
  caller: true
};

function forwardStaticMembers(Extended, Original, Super) {
  // We have to use getOwnPropertyNames since Babel registers methods as non-enumerable
  Object.getOwnPropertyNames(Original).forEach(function (key) {
    // Skip the properties that should not be overwritten
    if (shouldIgnore[key]) {
      return;
    } // Some browsers does not allow reconfigure built-in properties


    var extendedDescriptor = Object.getOwnPropertyDescriptor(Extended, key);

    if (extendedDescriptor && !extendedDescriptor.configurable) {
      return;
    }

    var descriptor = Object.getOwnPropertyDescriptor(Original, key); // If the user agent does not support `__proto__` or its family (IE <= 10),
    // the sub class properties may be inherited properties from the super class in TypeScript.
    // We need to exclude such properties to prevent to overwrite
    // the component options object which stored on the extended constructor (See #192).
    // If the value is a referenced value (object or function),
    // we can check equality of them and exclude it if they have the same reference.
    // If it is a primitive value, it will be forwarded for safety.

    if (!hasProto) {
      // Only `cid` is explicitly exluded from property forwarding
      // because we cannot detect whether it is a inherited property or not
      // on the no `__proto__` environment even though the property is reserved.
      if (key === 'cid') {
        return;
      }

      var superDescriptor = Object.getOwnPropertyDescriptor(Super, key);

      if (!isPrimitive(descriptor.value) && superDescriptor && superDescriptor.value === descriptor.value) {
        return;
      }
    } // Warn if the users manually declare reserved properties


    if (false) {}

    Object.defineProperty(Extended, key, descriptor);
  });
}

function vue_class_component_esm_Component(options) {
  if (typeof options === 'function') {
    return componentFactory(options);
  }

  return function (Component) {
    return componentFactory(Component, options);
  };
}

vue_class_component_esm_Component.registerHooks = function registerHooks(keys) {
  $internalHooks.push.apply($internalHooks, _toConsumableArray(keys));
};

/* harmony default export */ var vue_class_component_esm = (vue_class_component_esm_Component);


// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Emit.js
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
// Code copied from Vue/src/shared/util.js
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = function (str) { return str.replace(hyphenateRE, '-$1').toLowerCase(); };
/**
 * decorator of an event-emitter function
 * @param  event The name of the event
 * @return MethodDecorator
 */
function Emit(event) {
    return function (_target, propertyKey, descriptor) {
        var key = hyphenate(propertyKey);
        var original = descriptor.value;
        descriptor.value = function emitter() {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var emit = function (returnValue) {
                var emitName = event || key;
                if (returnValue === undefined) {
                    if (args.length === 0) {
                        _this.$emit(emitName);
                    }
                    else if (args.length === 1) {
                        _this.$emit(emitName, args[0]);
                    }
                    else {
                        _this.$emit.apply(_this, __spreadArrays([emitName], args));
                    }
                }
                else {
                    args.unshift(returnValue);
                    _this.$emit.apply(_this, __spreadArrays([emitName], args));
                }
            };
            var returnValue = original.apply(this, args);
            if (isPromise(returnValue)) {
                returnValue.then(emit);
            }
            else {
                emit(returnValue);
            }
            return returnValue;
        };
    };
}
function isPromise(obj) {
    return obj instanceof Promise || (obj && typeof obj.then === 'function');
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Inject.js

/**
 * decorator of an inject
 * @param from key
 * @return PropertyDecorator
 */
function Inject(options) {
    return createDecorator(function (componentOptions, key) {
        if (typeof componentOptions.inject === 'undefined') {
            componentOptions.inject = {};
        }
        if (!Array.isArray(componentOptions.inject)) {
            componentOptions.inject[key] = options || key;
        }
    });
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/helpers/provideInject.js
function needToProduceProvide(original) {
    return (typeof original !== 'function' ||
        (!original.managed && !original.managedReactive));
}
function produceProvide(original) {
    var provide = function () {
        var _this = this;
        var rv = typeof original === 'function' ? original.call(this) : original;
        rv = Object.create(rv || null);
        // set reactive services (propagates previous services if necessary)
        rv[reactiveInjectKey] = Object.create(this[reactiveInjectKey] || {});
        for (var i in provide.managed) {
            rv[provide.managed[i]] = this[i];
        }
        var _loop_1 = function (i) {
            rv[provide.managedReactive[i]] = this_1[i]; // Duplicates the behavior of `@Provide`
            Object.defineProperty(rv[reactiveInjectKey], provide.managedReactive[i], {
                enumerable: true,
                configurable: true,
                get: function () { return _this[i]; },
            });
        };
        var this_1 = this;
        for (var i in provide.managedReactive) {
            _loop_1(i);
        }
        return rv;
    };
    provide.managed = {};
    provide.managedReactive = {};
    return provide;
}
/** Used for keying reactive provide/inject properties */
var reactiveInjectKey = '__reactiveInject__';
function inheritInjected(componentOptions) {
    // inject parent reactive services (if any)
    if (!Array.isArray(componentOptions.inject)) {
        componentOptions.inject = componentOptions.inject || {};
        componentOptions.inject[reactiveInjectKey] = {
            from: reactiveInjectKey,
            default: {},
        };
    }
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/InjectReactive.js


/**
 * decorator of a reactive inject
 * @param from key
 * @return PropertyDecorator
 */
function InjectReactive(options) {
    return createDecorator(function (componentOptions, key) {
        if (typeof componentOptions.inject === 'undefined') {
            componentOptions.inject = {};
        }
        if (!Array.isArray(componentOptions.inject)) {
            var fromKey_1 = !!options ? options.from || options : key;
            var defaultVal_1 = (!!options && options.default) || undefined;
            if (!componentOptions.computed)
                componentOptions.computed = {};
            componentOptions.computed[key] = function () {
                var obj = this[reactiveInjectKey];
                return obj ? obj[fromKey_1] : defaultVal_1;
            };
            componentOptions.inject[reactiveInjectKey] = reactiveInjectKey;
        }
    });
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/helpers/metadata.js
/** @see {@link https://github.com/vuejs/vue-class-component/blob/master/src/reflect.ts} */
var reflectMetadataIsSupported = typeof Reflect !== 'undefined' && typeof Reflect.getMetadata !== 'undefined';
function applyMetadata(options, target, key) {
    if (reflectMetadataIsSupported) {
        if (!Array.isArray(options) &&
            typeof options !== 'function' &&
            !options.hasOwnProperty('type') &&
            typeof options.type === 'undefined') {
            var type = Reflect.getMetadata('design:type', target, key);
            if (type !== Object) {
                options.type = type;
            }
        }
    }
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Model.js


/**
 * decorator of model
 * @param  event event name
 * @param options options
 * @return PropertyDecorator
 */
function Model(event, options) {
    if (options === void 0) { options = {}; }
    return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
            ;
            (componentOptions.props || (componentOptions.props = {}))[k] = options;
            componentOptions.model = { prop: k, event: event || k };
        })(target, key);
    };
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/ModelSync.js


/**
 * decorator of synced model and prop
 * @param propName the name to interface with from outside, must be different from decorated property
 * @param  event event name
 * @param options options
 * @return PropertyDecorator
 */
function ModelSync(propName, event, options) {
    if (options === void 0) { options = {}; }
    return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
            ;
            (componentOptions.props || (componentOptions.props = {}))[propName] = options;
            componentOptions.model = { prop: propName, event: event || k };
            (componentOptions.computed || (componentOptions.computed = {}))[k] = {
                get: function () {
                    return this[propName];
                },
                set: function (value) {
                    // @ts-ignore
                    this.$emit(event, value);
                },
            };
        })(target, key);
    };
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Prop.js


/**
 * decorator of a prop
 * @param  options the options for the prop
 * @return PropertyDecorator | void
 */
function Prop(options) {
    if (options === void 0) { options = {}; }
    return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
            ;
            (componentOptions.props || (componentOptions.props = {}))[k] = options;
        })(target, key);
    };
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/PropSync.js


/**
 * decorator of a synced prop
 * @param propName the name to interface with from outside, must be different from decorated property
 * @param options the options for the synced prop
 * @return PropertyDecorator | void
 */
function PropSync(propName, options) {
    if (options === void 0) { options = {}; }
    return function (target, key) {
        applyMetadata(options, target, key);
        createDecorator(function (componentOptions, k) {
            ;
            (componentOptions.props || (componentOptions.props = {}))[propName] = options;
            (componentOptions.computed || (componentOptions.computed = {}))[k] = {
                get: function () {
                    return this[propName];
                },
                set: function (value) {
                    this.$emit("update:" + propName, value);
                },
            };
        })(target, key);
    };
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Provide.js


/**
 * decorator of a provide
 * @param key key
 * @return PropertyDecorator | void
 */
function Provide(key) {
    return createDecorator(function (componentOptions, k) {
        var provide = componentOptions.provide;
        inheritInjected(componentOptions);
        if (needToProduceProvide(provide)) {
            provide = componentOptions.provide = produceProvide(provide);
        }
        provide.managed[k] = key || k;
    });
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/ProvideReactive.js


/**
 * decorator of a reactive provide
 * @param key key
 * @return PropertyDecorator | void
 */
function ProvideReactive(key) {
    return createDecorator(function (componentOptions, k) {
        var provide = componentOptions.provide;
        inheritInjected(componentOptions);
        if (needToProduceProvide(provide)) {
            provide = componentOptions.provide = produceProvide(provide);
        }
        provide.managedReactive[k] = key || k;
    });
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Ref.js

/**
 * decorator of a ref prop
 * @param refKey the ref key defined in template
 */
function Ref(refKey) {
    return createDecorator(function (options, key) {
        options.computed = options.computed || {};
        options.computed[key] = {
            cache: false,
            get: function () {
                return this.$refs[refKey || key];
            },
        };
    });
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/VModel.js

/**
 * decorator for capturings v-model binding to component
 * @param options the options for the prop
 */
function VModel(options) {
    if (options === void 0) { options = {}; }
    var valueKey = 'value';
    return createDecorator(function (componentOptions, key) {
        ;
        (componentOptions.props || (componentOptions.props = {}))[valueKey] = options;
        (componentOptions.computed || (componentOptions.computed = {}))[key] = {
            get: function () {
                return this[valueKey];
            },
            set: function (value) {
                this.$emit('input', value);
            },
        };
    });
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/decorators/Watch.js

/**
 * decorator of a watch function
 * @param  path the path or the expression to observe
 * @param  WatchOption
 * @return MethodDecorator
 */
function Watch(path, options) {
    if (options === void 0) { options = {}; }
    var _a = options.deep, deep = _a === void 0 ? false : _a, _b = options.immediate, immediate = _b === void 0 ? false : _b;
    return createDecorator(function (componentOptions, handler) {
        if (typeof componentOptions.watch !== 'object') {
            componentOptions.watch = Object.create(null);
        }
        var watch = componentOptions.watch;
        if (typeof watch[path] === 'object' && !Array.isArray(watch[path])) {
            watch[path] = [watch[path]];
        }
        else if (typeof watch[path] === 'undefined') {
            watch[path] = [];
        }
        watch[path].push({ handler: handler, deep: deep, immediate: immediate });
    });
}

// CONCATENATED MODULE: ./node_modules/vue-property-decorator/lib/index.js
/** vue-property-decorator verson 9.1.2 MIT LICENSE copyright 2020 kaorun343 */
/// <reference types='reflect-metadata'/>

















/***/ }),

/***/ "1be4":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "1c16":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function (fn) {
  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
  var immediate = arguments.length > 2 ? arguments[2] : undefined;
  var timeout;
  function debounced( /* ...args */
  ) {
    var _this = this;
    var args = arguments;
    var later = function later() {
      timeout = void 0;
      if (immediate !== true) {
        fn.apply(_this, args);
      }
    };
    clearTimeout(timeout);
    if (immediate === true && timeout === void 0) {
      fn.apply(this, args);
    }
    timeout = setTimeout(later, wait);
  }
  debounced.cancel = function () {
    clearTimeout(timeout);
  };
  return debounced;
});

/***/ }),

/***/ "1c1c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5530");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _mixins_dark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("b7fa");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("87e8");
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("e277");





/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1___default.a.extend({
  name: 'QList',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_dark_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]],
  props: {
    bordered: Boolean,
    dense: Boolean,
    separator: Boolean,
    padding: Boolean,
    tag: {
      type: String,
      default: 'div'
    }
  },
  computed: {
    classes: function classes() {
      return 'q-list' + (this.bordered === true ? ' q-list--bordered' : '') + (this.dense === true ? ' q-list--dense' : '') + (this.separator === true ? ' q-list--separator' : '') + (this.isDark === true ? ' q-list--dark' : '') + (this.padding === true ? ' q-list--padding' : '');
    }
  },
  render: function render(h) {
    return h(this.tag, {
      class: this.classes,
      on: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.qListeners)
    }, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_4__[/* slot */ "c"])(this, 'default'));
  }
}));

/***/ }),

/***/ "1c35":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__("1fb5")
var ieee754 = __webpack_require__("9152")
var isArray = __webpack_require__("e3db")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "1c59":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__("6d61");
var collectionStrong = __webpack_require__("6566");

// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
collection('Set', function (init) {
  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "1c7e":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "1cdc":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");

// eslint-disable-next-line redos/no-vulnerable -- safe
module.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);


/***/ }),

/***/ "1d02":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $findLastIndex = __webpack_require__("a258").findLastIndex;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findLastIndex` method
// https://github.com/tc39/proposal-array-find-from-last
exportTypedArrayMethod('findLastIndex', function findLastIndex(predicate /* , thisArg */) {
  return $findLastIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "1d80":
/***/ (function(module, exports, __webpack_require__) {

var isNullOrUndefined = __webpack_require__("7234");

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "1dba":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "1dde":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "1ec8":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "1f68":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var defineBuiltInAccessor = __webpack_require__("edd0");
var isObject = __webpack_require__("861d");
var toObject = __webpack_require__("7b0b");
var requireObjectCoercible = __webpack_require__("1d80");

// eslint-disable-next-line es/no-object-getprototypeof -- safe
var getPrototypeOf = Object.getPrototypeOf;
// eslint-disable-next-line es/no-object-setprototypeof -- safe
var setPrototypeOf = Object.setPrototypeOf;
var ObjectPrototype = Object.prototype;
var PROTO = '__proto__';

// `Object.prototype.__proto__` accessor
// https://tc39.es/ecma262/#sec-object.prototype.__proto__
if (DESCRIPTORS && getPrototypeOf && setPrototypeOf && !(PROTO in ObjectPrototype)) try {
  defineBuiltInAccessor(ObjectPrototype, PROTO, {
    configurable: true,
    get: function __proto__() {
      return getPrototypeOf(toObject(this));
    },
    set: function __proto__(proto) {
      var O = requireObjectCoercible(this);
      if (!isObject(proto) && proto !== null || !isObject(O)) return;
      setPrototypeOf(O, proto);
    }
  });
} catch (error) { /* empty */ }


/***/ }),

/***/ "1fb5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "20cc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var apply = __webpack_require__("2ba4");
var isCallable = __webpack_require__("1626");
var ENGINE_IS_BUN = __webpack_require__("c6a7");
var USER_AGENT = __webpack_require__("342f");
var arraySlice = __webpack_require__("f36a");
var validateArgumentsLength = __webpack_require__("d6d6");

var Function = global.Function;
// dirty IE9- and Bun 0.3.0- checks
var WRAP = /MSIE .\./.test(USER_AGENT) || ENGINE_IS_BUN && (function () {
  var version = global.Bun.version.split('.');
  return version.length < 3 || version[0] == 0 && (version[1] < 3 || version[1] == 3 && version[2] == 0);
})();

// IE9- / Bun 0.3.0- setTimeout / setInterval / setImmediate additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
// https://github.com/oven-sh/bun/issues/1633
module.exports = function (scheduler, hasTimeArg) {
  var firstParamIndex = hasTimeArg ? 2 : 1;
  return WRAP ? function (handler, timeout /* , ...arguments */) {
    var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
    var fn = isCallable(handler) ? handler : Function(handler);
    var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
    var callback = boundArgs ? function () {
      apply(fn, this, params);
    } : fn;
    return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
  } : scheduler;
};


/***/ }),

/***/ "219c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("4625");
var fails = __webpack_require__("d039");
var aCallable = __webpack_require__("59ed");
var internalSort = __webpack_require__("addb");
var ArrayBufferViewCore = __webpack_require__("ebb5");
var FF = __webpack_require__("04d1");
var IE_OR_EDGE = __webpack_require__("d998");
var V8 = __webpack_require__("2d00");
var WEBKIT = __webpack_require__("512c");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var Uint16Array = global.Uint16Array;
var nativeSort = Uint16Array && uncurryThis(Uint16Array.prototype.sort);

// WebKit
var ACCEPT_INCORRECT_ARGUMENTS = !!nativeSort && !(fails(function () {
  nativeSort(new Uint16Array(2), null);
}) && fails(function () {
  nativeSort(new Uint16Array(2), {});
}));

var STABLE_SORT = !!nativeSort && !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 74;
  if (FF) return FF < 67;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 602;

  var array = new Uint16Array(516);
  var expected = Array(516);
  var index, mod;

  for (index = 0; index < 516; index++) {
    mod = index % 4;
    array[index] = 515 - index;
    expected[index] = index - 2 * mod + 3;
  }

  nativeSort(array, function (a, b) {
    return (a / 4 | 0) - (b / 4 | 0);
  });

  for (index = 0; index < 516; index++) {
    if (array[index] !== expected[index]) return true;
  }
});

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (y !== y) return -1;
    // eslint-disable-next-line no-self-compare -- NaN check
    if (x !== x) return 1;
    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;
    return x > y;
  };
};

// `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
  if (comparefn !== undefined) aCallable(comparefn);
  if (STABLE_SORT) return nativeSort(this, comparefn);

  return internalSort(aTypedArray(this), getSortCompare(comparefn));
}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);


/***/ }),

/***/ "21e1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ac1f");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_regexp_test_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("00b4");
/* harmony import */ var core_js_modules_es_regexp_test_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_test_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("0967");



var isJapanese = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/;
var isChinese = /(?:[\u3300-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF\uFE30-\uFE4F]|[\uD840-\uD868\uD86A-\uD872][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD873[\uDC00-\uDEAF]|\uD87E[\uDC00-\uDE1F])/;
var isKorean = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/;
var isPlainText = /[a-z0-9_ -]$/i;
/* harmony default export */ __webpack_exports__["a"] = ({
  methods: {
    __onComposition: function __onComposition(e) {
      if (e.type === 'compositionend' || e.type === 'change') {
        if (e.target.qComposing !== true) {
          return;
        }
        e.target.qComposing = false;
        this.__onInput(e);
      } else if (e.type === 'compositionupdate' && e.target.qComposing !== true && typeof e.data === 'string') {
        var isComposing = _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_2__[/* client */ "a"].is.firefox === true ? isPlainText.test(e.data) === false : isJapanese.test(e.data) === true || isChinese.test(e.data) === true || isKorean.test(e.data) === true;
        if (isComposing === true) {
          e.target.qComposing = true;
        }
      }
    }
  }
});

/***/ }),

/***/ "2266":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("0366");
var call = __webpack_require__("c65b");
var anObject = __webpack_require__("825a");
var tryToString = __webpack_require__("0d51");
var isArrayIteratorMethod = __webpack_require__("e95a");
var lengthOfArrayLike = __webpack_require__("07fa");
var isPrototypeOf = __webpack_require__("3a9b");
var getIterator = __webpack_require__("9a1f");
var getIteratorMethod = __webpack_require__("35a1");
var iteratorClose = __webpack_require__("2a62");

var $TypeError = TypeError;

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var ResultPrototype = Result.prototype;

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_RECORD = !!(options && options.IS_RECORD);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator, 'normal', condition);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_RECORD) {
    iterator = iterable.iterator;
  } else if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (!iterFn) throw $TypeError(tryToString(iterable) + ' is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && isPrototypeOf(ResultPrototype, result)) return result;
      } return new Result(false);
    }
    iterator = getIterator(iterable, iterFn);
  }

  next = IS_RECORD ? iterable.next : iterator.next;
  while (!(step = call(next, iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator, 'throw', error);
    }
    if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result)) return result;
  } return new Result(false);
};


/***/ }),

/***/ "2351":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("e065");

// `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');


/***/ }),

/***/ "23cb":
/***/ (function(module, exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__("5926");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "23dc":
/***/ (function(module, exports, __webpack_require__) {

var setToStringTag = __webpack_require__("d44e");

// Math[@@toStringTag] property
// https://tc39.es/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);


/***/ }),

/***/ "23e7":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var createNonEnumerableProperty = __webpack_require__("9112");
var defineBuiltIn = __webpack_require__("cb2d");
var defineGlobalProperty = __webpack_require__("6374");
var copyConstructorProperties = __webpack_require__("e893");
var isForced = __webpack_require__("94ca");

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "241c":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "2448":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "24e8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__("ade3");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./node_modules/quasar/src/history.js
var src_history = __webpack_require__("582c");

// CONCATENATED MODULE: ./node_modules/quasar/src/mixins/history.js

/* harmony default export */ var mixins_history = ({
  methods: {
    __addHistory: function __addHistory() {
      var _this = this;
      this.__historyEntry = {
        condition: function condition() {
          return _this.hideOnRouteChange === true;
        },
        handler: this.hide
      };
      src_history["a" /* default */].add(this.__historyEntry);
    },
    __removeHistory: function __removeHistory() {
      if (this.__historyEntry !== void 0) {
        src_history["a" /* default */].remove(this.__historyEntry);
        this.__historyEntry = void 0;
      }
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.showing === true && this.__removeHistory();
  }
});
// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/timeout.js
var timeout = __webpack_require__("463c");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/model-toggle.js
var model_toggle = __webpack_require__("7ee0");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/portal.js
var portal = __webpack_require__("9e62");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("d882");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/scroll.js
var utils_scroll = __webpack_require__("0831");

// EXTERNAL MODULE: ./node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("0967");

// CONCATENATED MODULE: ./node_modules/quasar/src/mixins/prevent-scroll.js



var registered = 0,
  scrollPositionX,
  scrollPositionY,
  maxScrollTop,
  vpPendingUpdate = false,
  bodyLeft,
  bodyTop,
  href,
  closeTimer;
function onWheel(e) {
  if (shouldPreventScroll(e)) {
    Object(utils_event["j" /* stopAndPrevent */])(e);
  }
}
function shouldPreventScroll(e) {
  if (e.target === document.body || e.target.classList.contains('q-layout__backdrop')) {
    return true;
  }
  var path = Object(utils_event["d" /* getEventPath */])(e),
    shift = e.shiftKey && !e.deltaX,
    scrollY = !shift && Math.abs(e.deltaX) <= Math.abs(e.deltaY),
    delta = shift || scrollY ? e.deltaY : e.deltaX;
  for (var index = 0; index < path.length; index++) {
    var el = path[index];
    if (Object(utils_scroll["e" /* hasScrollbar */])(el, scrollY)) {
      return scrollY ? delta < 0 && el.scrollTop === 0 ? true : delta > 0 && el.scrollTop + el.clientHeight === el.scrollHeight : delta < 0 && el.scrollLeft === 0 ? true : delta > 0 && el.scrollLeft + el.clientWidth === el.scrollWidth;
    }
  }
  return true;
}
function onAppleScroll(e) {
  if (e.target === document) {
    // required, otherwise iOS blocks further scrolling
    // until the mobile scrollbar dissappears
    document.scrollingElement.scrollTop = document.scrollingElement.scrollTop; // eslint-disable-line
  }
}

function onAppleResize(evt) {
  if (vpPendingUpdate === true) {
    return;
  }
  vpPendingUpdate = true;
  requestAnimationFrame(function () {
    vpPendingUpdate = false;
    var height = evt.target.height,
      _document$scrollingEl = document.scrollingElement,
      clientHeight = _document$scrollingEl.clientHeight,
      scrollTop = _document$scrollingEl.scrollTop;
    if (maxScrollTop === void 0 || height !== window.innerHeight) {
      maxScrollTop = clientHeight - height;
      document.scrollingElement.scrollTop = scrollTop;
    }
    if (scrollTop > maxScrollTop) {
      document.scrollingElement.scrollTop -= Math.ceil((scrollTop - maxScrollTop) / 8);
    }
  });
}
function apply(action) {
  var body = document.body,
    hasViewport = window.visualViewport !== void 0;
  if (action === 'add') {
    var overflowY = window.getComputedStyle(body).overflowY;
    scrollPositionX = Object(utils_scroll["a" /* getHorizontalScrollPosition */])(window);
    scrollPositionY = Object(utils_scroll["b" /* getScrollPosition */])(window);
    bodyLeft = body.style.left;
    bodyTop = body.style.top;
    href = window.location.href;
    body.style.left = "-".concat(scrollPositionX, "px");
    body.style.top = "-".concat(scrollPositionY, "px");
    if (overflowY !== 'hidden' && (overflowY === 'scroll' || body.scrollHeight > window.innerHeight)) {
      body.classList.add('q-body--force-scrollbar');
    }
    body.classList.add('q-body--prevent-scroll');
    document.qScrollPrevented = true;
    if (Platform["a" /* client */].is.ios === true) {
      if (hasViewport === true) {
        window.scrollTo(0, 0);
        window.visualViewport.addEventListener('resize', onAppleResize, utils_event["e" /* listenOpts */].passiveCapture);
        window.visualViewport.addEventListener('scroll', onAppleResize, utils_event["e" /* listenOpts */].passiveCapture);
        window.scrollTo(0, 0);
      } else {
        window.addEventListener('scroll', onAppleScroll, utils_event["e" /* listenOpts */].passiveCapture);
      }
    }
  }
  if (Platform["a" /* client */].is.desktop === true && Platform["a" /* client */].is.mac === true) {
    // ref. https://developers.google.com/web/updates/2017/01/scrolling-intervention
    window["".concat(action, "EventListener")]('wheel', onWheel, utils_event["e" /* listenOpts */].notPassive);
  }
  if (action === 'remove') {
    if (Platform["a" /* client */].is.ios === true) {
      if (hasViewport === true) {
        window.visualViewport.removeEventListener('resize', onAppleResize, utils_event["e" /* listenOpts */].passiveCapture);
        window.visualViewport.removeEventListener('scroll', onAppleResize, utils_event["e" /* listenOpts */].passiveCapture);
      } else {
        window.removeEventListener('scroll', onAppleScroll, utils_event["e" /* listenOpts */].passiveCapture);
      }
    }
    body.classList.remove('q-body--prevent-scroll');
    body.classList.remove('q-body--force-scrollbar');
    document.qScrollPrevented = false;
    body.style.left = bodyLeft;
    body.style.top = bodyTop;

    // scroll back only if route has not changed
    if (window.location.href === href) {
      window.scrollTo(scrollPositionX, scrollPositionY);
    }
    maxScrollTop = void 0;
  }
}
function preventScroll(state) {
  var action = 'add';
  if (state === true) {
    registered++;
    if (closeTimer !== void 0) {
      clearTimeout(closeTimer);
      closeTimer = void 0;
      return;
    }
    if (registered > 1) {
      return;
    }
  } else {
    if (registered === 0) {
      return;
    }
    registered--;
    if (registered > 0) {
      return;
    }
    action = 'remove';
    if (Platform["a" /* client */].is.ios === true && Platform["a" /* client */].is.nativeMobile === true) {
      clearTimeout(closeTimer);
      closeTimer = setTimeout(function () {
        apply(action);
        closeTimer = void 0;
      }, 100);
      return;
    }
  }
  apply(action);
}
/* harmony default export */ var prevent_scroll = ({
  methods: {
    __preventScroll: function __preventScroll(state) {
      if (state !== this.preventedScroll && (this.preventedScroll !== void 0 || state === true)) {
        this.preventedScroll = state;
        preventScroll(state);
      }
    }
  }
});
// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/attrs.js
var mixins_attrs = __webpack_require__("f376");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/transition.js
var transition = __webpack_require__("7562");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/dom.js
var dom = __webpack_require__("f303");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/escape-key.js
var escape_key = __webpack_require__("aff1");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/slot.js
var slot = __webpack_require__("e277");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/cache.js
var cache = __webpack_require__("d54d");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/focus-manager.js
var focus_manager = __webpack_require__("f6ba");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/dialog/QDialog.js



















var maximizedModals = 0;
var positionClass = {
  standard: 'fixed-full flex-center',
  top: 'fixed-top justify-center',
  bottom: 'fixed-bottom justify-center',
  right: 'fixed-right items-center',
  left: 'fixed-left items-center'
};
var defaultTransitions = {
  standard: ['scale', 'scale'],
  top: ['slide-down', 'slide-up'],
  bottom: ['slide-up', 'slide-down'],
  right: ['slide-left', 'slide-right'],
  left: ['slide-right', 'slide-left']
};
var backdropAttrs = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, mixins_attrs["a" /* ariaHidden */]), {}, {
  tabindex: -1
});
/* harmony default export */ var QDialog = __webpack_exports__["a"] = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QDialog',
  mixins: [mixins_attrs["b" /* default */], transition["a" /* default */], mixins_history, timeout["a" /* default */], model_toggle["a" /* default */], portal["b" /* default */], prevent_scroll],
  props: {
    persistent: Boolean,
    autoClose: Boolean,
    allowFocusOutside: Boolean,
    noEscDismiss: Boolean,
    noBackdropDismiss: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    noShake: Boolean,
    seamless: Boolean,
    maximized: Boolean,
    fullWidth: Boolean,
    fullHeight: Boolean,
    square: Boolean,
    position: {
      type: String,
      default: 'standard',
      validator: function validator(val) {
        return val === 'standard' || ['top', 'bottom', 'left', 'right'].includes(val);
      }
    },
    transitionShow: String,
    transitionHide: String
  },
  data: function data() {
    return {
      animating: false
    };
  },
  watch: {
    maximized: function maximized(state) {
      this.showing === true && this.__updateMaximized(state);
    },
    useBackdrop: function useBackdrop(v) {
      this.__preventScroll(v);
      this.__preventFocusout(v);
    }
  },
  computed: {
    classes: function classes() {
      return "q-dialog__inner--".concat(this.maximized === true ? 'maximized' : 'minimized', " ") + "q-dialog__inner--".concat(this.position, " ").concat(positionClass[this.position]) + (this.animating === true ? ' q-dialog__inner--animating' : '') + (this.fullWidth === true ? ' q-dialog__inner--fullwidth' : '') + (this.fullHeight === true ? ' q-dialog__inner--fullheight' : '') + (this.square === true ? ' q-dialog__inner--square' : '');
    },
    defaultTransitionShow: function defaultTransitionShow() {
      return defaultTransitions[this.position][0];
    },
    defaultTransitionHide: function defaultTransitionHide() {
      return defaultTransitions[this.position][1];
    },
    useBackdrop: function useBackdrop() {
      return this.showing === true && this.seamless !== true;
    },
    hideOnRouteChange: function hideOnRouteChange() {
      return this.persistent !== true && this.noRouteDismiss !== true && this.seamless !== true;
    },
    onEvents: function onEvents() {
      var on = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.qListeners), {}, {
        // stop propagating these events from children
        input: utils_event["i" /* stop */],
        'popup-show': utils_event["i" /* stop */],
        'popup-hide': utils_event["i" /* stop */]
      });
      if (this.autoClose === true) {
        on.click = this.__onAutoClose;
      }
      return on;
    },
    attrs: function attrs() {
      return Object(objectSpread2["a" /* default */])({
        role: 'dialog',
        'aria-modal': this.useBackdrop === true ? 'true' : 'false'
      }, this.qAttrs);
    }
  },
  methods: {
    focus: function focus(selector) {
      var _this = this;
      Object(focus_manager["a" /* addFocusFn */])(function () {
        var node = _this.__getInnerNode();
        if (node === void 0 || node.contains(document.activeElement) === true) {
          return;
        }
        node = (selector !== '' ? node.querySelector(selector) : null) || node.querySelector('[autofocus][tabindex], [data-autofocus][tabindex]') || node.querySelector('[autofocus] [tabindex], [data-autofocus] [tabindex]') || node.querySelector('[autofocus], [data-autofocus]') || node;
        node.focus({
          preventScroll: true
        });
      });
    },
    shake: function shake(focusTarget) {
      if (focusTarget && typeof focusTarget.focus === 'function') {
        focusTarget.focus({
          preventScroll: true
        });
      } else {
        this.focus();
      }
      this.$emit('shake');
      var node = this.__getInnerNode();
      if (node !== void 0) {
        node.classList.remove('q-animate--scale');
        node.classList.add('q-animate--scale');
        clearTimeout(this.shakeTimeout);
        this.shakeTimeout = setTimeout(function () {
          node.classList.remove('q-animate--scale');
        }, 170);
      }
    },
    __getInnerNode: function __getInnerNode() {
      return this.__portal !== void 0 && this.__portal.$refs !== void 0 ? this.__portal.$refs.inner : void 0;
    },
    __show: function __show(evt) {
      var _this2 = this;
      this.__addHistory();

      // IE can have null document.activeElement
      this.__refocusTarget = Platform["a" /* client */].is.mobile !== true && this.noRefocus === false && document.activeElement !== null ? document.activeElement : void 0;
      this.$el.dispatchEvent(Object(utils_event["c" /* create */])('popup-show', {
        bubbles: true
      }));
      this.__updateMaximized(this.maximized);
      escape_key["a" /* default */].register(this, function (escEvt) {
        if (_this2.seamless !== true) {
          if (_this2.persistent === true || _this2.noEscDismiss === true) {
            _this2.maximized !== true && _this2.noShake !== true && _this2.shake();
          } else {
            _this2.$emit('escape-key');
            _this2.hide(escEvt);
          }
        }
      });
      this.__showPortal();
      this.animating = true;
      if (this.noFocus !== true) {
        // IE can have null document.activeElement
        document.activeElement !== null && document.activeElement.blur();
        this.__registerTick(this.focus);
      } else {
        this.__removeTick();
      }

      // should __removeTimeout() if this gets removed
      this.__registerTimeout(function () {
        if (_this2.$q.platform.is.ios === true) {
          if (_this2.seamless !== true && document.activeElement) {
            var _document$activeEleme = document.activeElement.getBoundingClientRect(),
              top = _document$activeEleme.top,
              bottom = _document$activeEleme.bottom,
              _window = window,
              innerHeight = _window.innerHeight,
              height = window.visualViewport !== void 0 ? window.visualViewport.height : innerHeight;
            if (top > 0 && bottom > height / 2) {
              document.scrollingElement.scrollTop = Math.min(document.scrollingElement.scrollHeight - height, bottom >= innerHeight ? Infinity : Math.ceil(document.scrollingElement.scrollTop + bottom - height / 2));
            }
            document.activeElement.scrollIntoView();
          }

          // required in order to avoid the "double-tap needed" issue
          _this2.__portal.$el.click();
        }
        _this2.animating = false;
        _this2.__showPortal(true); // done showing
        _this2.$emit('show', evt);
      }, 300);
    },
    __hide: function __hide(evt) {
      var _this3 = this;
      this.__removeTick();
      this.__removeHistory();
      this.__cleanup(true);
      this.__hidePortal();
      this.animating = true;

      // check null for IE
      if (this.__refocusTarget !== void 0 && this.__refocusTarget !== null) {
        ((evt && evt.type.indexOf('key') === 0 ? this.__refocusTarget.closest('[tabindex]:not([tabindex^="-"])') : void 0) || this.__refocusTarget).focus();
        this.__refocusTarget = void 0;
      }
      this.$el.dispatchEvent(Object(utils_event["c" /* create */])('popup-hide', {
        bubbles: true
      }));

      // should __removeTimeout() if this gets removed
      this.__registerTimeout(function () {
        _this3.__hidePortal(true); // done hiding, now destroy
        _this3.animating = false;
        _this3.$emit('hide', evt);
      }, 300);
    },
    __cleanup: function __cleanup(hiding) {
      clearTimeout(this.shakeTimeout);
      if (hiding === true || this.showing === true) {
        escape_key["a" /* default */].pop(this);
        this.__updateMaximized(false);
        if (this.seamless !== true) {
          this.__preventScroll(false);
          this.__preventFocusout(false);
        }
      }
    },
    __updateMaximized: function __updateMaximized(active) {
      if (active === true) {
        if (this.isMaximized !== true) {
          maximizedModals < 1 && document.body.classList.add('q-body--dialog');
          maximizedModals++;
          this.isMaximized = true;
        }
      } else if (this.isMaximized === true) {
        if (maximizedModals < 2) {
          document.body.classList.remove('q-body--dialog');
        }
        maximizedModals--;
        this.isMaximized = false;
      }
    },
    __preventFocusout: function __preventFocusout(state) {
      if (this.$q.platform.is.desktop === true) {
        var action = "".concat(state === true ? 'add' : 'remove', "EventListener");
        document.body[action]('focusin', this.__onFocusChange);
      }
    },
    __onAutoClose: function __onAutoClose(e) {
      this.hide(e);
      this.qListeners.click !== void 0 && this.$emit('click', e);
    },
    __onBackdropClick: function __onBackdropClick(e) {
      if (this.persistent !== true && this.noBackdropDismiss !== true) {
        this.hide(e);
      } else if (this.noShake !== true) {
        this.shake(e.relatedTarget);
      }
    },
    __onFocusChange: function __onFocusChange(e) {
      // the focus is not in a vue child component
      if (this.allowFocusOutside !== true && this.__portalIsAccessible === true && Object(dom["a" /* childHasFocus */])(this.__portal.$el, e.target) !== true) {
        this.focus('[tabindex]:not([tabindex="-1"])');
      }
    },
    __renderPortal: function __renderPortal(h) {
      return h('div', {
        staticClass: "q-dialog fullscreen no-pointer-events q-dialog--".concat(this.useBackdrop === true ? 'modal' : 'seamless'),
        class: this.contentClass,
        style: this.contentStyle,
        attrs: this.attrs
      }, [h('transition', {
        props: {
          name: 'q-transition--fade'
        }
      }, this.useBackdrop === true ? [h('div', {
        staticClass: 'q-dialog__backdrop fixed-full',
        attrs: backdropAttrs,
        on: Object(cache["a" /* default */])(this, 'bkdrop', Object(defineProperty["a" /* default */])({}, this.backdropEvt, this.__onBackdropClick))
      })] : null), h('transition', {
        props: Object(objectSpread2["a" /* default */])({}, this.transitionProps)
      }, [this.showing === true ? h('div', {
        ref: 'inner',
        staticClass: 'q-dialog__inner flex no-pointer-events',
        class: this.classes,
        attrs: {
          tabindex: -1
        },
        on: this.onEvents
      }, Object(slot["c" /* slot */])(this, 'default')) : null])]);
    }
  },
  created: function created() {
    this.__useTick('__registerTick', '__removeTick');
    this.__useTimeout('__registerTimeout');
    this.backdropEvt = this.$q.platform.is.ios === true || this.$q.platform.is.safari ? 'click' : 'focusin';
  },
  mounted: function mounted() {
    this.__processModelChange(this.value);
  },
  beforeDestroy: function beforeDestroy() {
    this.__cleanup();
    this.__refocusTarget = void 0;
  }
}));

/***/ }),

/***/ "2532":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("e330");
var notARegExp = __webpack_require__("5a34");
var requireObjectCoercible = __webpack_require__("1d80");
var toString = __webpack_require__("577e");
var correctIsRegExpLogic = __webpack_require__("ab13");

var stringIndexOf = uncurryThis(''.indexOf);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~stringIndexOf(
      toString(requireObjectCoercible(this)),
      toString(notARegExp(searchString)),
      arguments.length > 1 ? arguments[1] : undefined
    );
  }
});


/***/ }),

/***/ "2541":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ColorThemeSelection; });
/* unused harmony export ColorHues */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return PredefinedBlockTypes; });
/* unused harmony export ColorSelection */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ColorSelectionWithNone; });
/* unused harmony export PredefinedArgumentTypes */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return blockStyles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return categoryStyles; });
/* unused harmony export BlocklyHelper */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return blocklyHelper; });
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d4ec");
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("bee2");
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("2909");
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("d81d");
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("b64b");
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("99af");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("a15b");
/* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("b0c0");
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("cca6");
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_json_stringify_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("e9c4");
/* harmony import */ var core_js_modules_es_json_stringify_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_json_stringify_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("ac1f");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("5319");
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("159b");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _styles_blockly_styl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("4723");
/* harmony import */ var _styles_blockly_styl__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_styles_blockly_styl__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("b3e9");

















var ColorThemeSelection = [{
  label: 'Colors',
  value: '{!PrimaryColors.Colour}'
}, {
  label: 'Arrays',
  value: '{!PrimaryColors.List}'
}, {
  label: 'Logic',
  value: '{!PrimaryColors.Logic}'
}, {
  label: 'Loops',
  value: '{!PrimaryColors.Loop}'
}, {
  label: 'Math',
  value: '{!PrimaryColors.Math}'
}, {
  label: 'Procedures',
  value: '{!PrimaryColors.Procedure}'
}, {
  label: 'String',
  value: '{!PrimaryColors.Text}'
}, {
  label: 'Variables',
  value: '{!PrimaryColors.Variable}'
}, {
  label: 'Variables (dynamic)',
  value: '{!PrimaryColors.Variable_dynamic}'
}];
var ColorHues = [{
  label: '0°',
  value: '0'
}, {
  label: '15°',
  value: '15'
}, {
  label: '30°',
  value: '30'
}, {
  label: '45°',
  value: '45'
}, {
  label: '60°',
  value: '60'
}, {
  label: '75°',
  value: '75'
}, {
  label: '90°',
  value: '90'
}, {
  label: '105°',
  value: '105'
}, {
  label: '120°',
  value: '120'
}, {
  label: '135°',
  value: '135'
}, {
  label: '150°',
  value: '150'
}, {
  label: '165°',
  value: '165'
}, {
  label: '180°',
  value: '180'
}, {
  label: '195°',
  value: '195'
}, {
  label: '210°',
  value: '210'
}, {
  label: '225°',
  value: '225'
}, {
  label: '240°',
  value: '240'
}, {
  label: '255°',
  value: '255'
}, {
  label: '270°',
  value: '270'
}, {
  label: '285°',
  value: '285'
}, {
  label: '300°',
  value: '300'
}, {
  label: '315°',
  value: '315'
}, {
  label: '330°',
  value: '330'
}, {
  label: '345°',
  value: '345'
}];
var PredefinedBlockTypes = Object.keys(_lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* KnownBlocklyTypes */ "e"]).map(function (key) {
  var ret = {
    label: vue__WEBPACK_IMPORTED_MODULE_14___default.a.$l("Blockly.BlockTypeNames.".concat(key)),
    value: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* KnownBlocklyTypes */ "e"][key]
  };
  return ret;
});
var ColorSelection = [].concat(ColorThemeSelection, ColorHues);
var ColorSelectionWithNone = [{
  label: 'None',
  value: ''
}].concat(Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(ColorSelection));
var PredefinedArgumentTypes = Object.keys(_lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockArgumentTypes */ "a"]).map(function (key) {
  var ret = {
    label: vue__WEBPACK_IMPORTED_MODULE_14___default.a.$l("Blockly.ArgumentTypeNames.".concat(key)),
    value: key
  };
  return ret;
});
var blockStyles = {
  colour_blocks: {
    colourPrimary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"].Colour,
    colourSecondary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockSecondaryColors */ "c"].Colour,
    colourTertiary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockTertiaryColors */ "d"].Colour,
    hat: 'cap'
  },
  list_blocks: {
    colourPrimary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"].List,
    colourSecondary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockSecondaryColors */ "c"].List,
    colourTertiary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockTertiaryColors */ "d"].List,
    hat: 'cap'
  },
  logic_blocks: {
    colourPrimary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"].Logic,
    colourSecondary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockSecondaryColors */ "c"].Logic,
    colourTertiary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockTertiaryColors */ "d"].Logic,
    hat: 'cap'
  },
  loop_blocks: {
    colourPrimary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"].Loop,
    colourSecondary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockSecondaryColors */ "c"].Loop,
    colourTertiary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockTertiaryColors */ "d"].Loop,
    hat: 'cap'
  },
  math_blocks: {
    colourPrimary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"].Math,
    colourSecondary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockSecondaryColors */ "c"].Math,
    colourTertiary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockTertiaryColors */ "d"].Math,
    hat: 'cap'
  },
  procedure_blocks: {
    colourPrimary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"].Procedure,
    colourSecondary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockSecondaryColors */ "c"].Procedure,
    colourTertiary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockTertiaryColors */ "d"].Procedure,
    hat: 'cap'
  },
  text_blocks: {
    colourPrimary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"].Text,
    colourSecondary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockSecondaryColors */ "c"].Text,
    colourTertiary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockTertiaryColors */ "d"].Text,
    hat: 'cap'
  },
  variable_blocks: {
    colourPrimary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"].Variable,
    colourSecondary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockSecondaryColors */ "c"].Variable,
    colourTertiary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockTertiaryColors */ "d"].Variable,
    hat: 'cap'
  },
  variable_dynamic_blocks: {
    colourPrimary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"].Variable_dynamic,
    colourSecondary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockSecondaryColors */ "c"].Variable_dynamic,
    colourTertiary: _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockTertiaryColors */ "d"].Variable_dynamic,
    hat: 'cap'
  },
  hat_blocks: {
    colourPrimary: '330',
    colourSecondary: '330',
    colourTertiary: '330',
    hat: 'cap'
  }
};
var categoryStyles = {
  colour_category: {
    colour: blockStyles.colour_blocks.colourPrimary
  },
  list_category: {
    colour: blockStyles.list_blocks.colourPrimary
  },
  logic_category: {
    colour: blockStyles.logic_blocks.colourPrimary
  },
  loop_category: {
    colour: blockStyles.loop_blocks.colourPrimary
  },
  math_category: {
    colour: blockStyles.math_blocks.colourPrimary
  },
  procedure_category: {
    colour: blockStyles.procedure_blocks.colourPrimary
  },
  text_category: {
    colour: blockStyles.text_blocks.colourPrimary
  },
  variable_category: {
    colour: blockStyles.variable_blocks.colourPrimary
  },
  variable_dynamic_category: {
    colour: blockStyles.variable_dynamic_blocks.colourPrimary
  }
};
//export const theme = new Blockly.Theme('CodeBlocks', blockStyles as any, categoryStyles)
var BlocklyHelper = /*#__PURE__*/function () {
  function BlocklyHelper() {
    Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, BlocklyHelper);
  }
  Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(BlocklyHelper, [{
    key: "toArgumentDescription",
    value: function toArgumentDescription(a) {
      var n = vue__WEBPACK_IMPORTED_MODULE_14___default.a.$l("Blockly.ArgumentTypeNames.".concat(a));
      return n ? "".concat(n, " (").concat(a, ")") : a;
    }
  }, {
    key: "serializeToolboxItem",
    value: function serializeToolboxItem(i) {
      return "<block type=\"".concat(i.type, "\"></block>");
    }
  }, {
    key: "serializeToolboxItems",
    value: function serializeToolboxItems(items) {
      var _this = this;
      return items.map(function (item) {
        return _this.serializeToolboxItem(item);
      }).join('\n');
    }
  }, {
    key: "serializeToolboxCategory",
    value: function serializeToolboxCategory(i) {
      var res = "<category name=\"".concat(i.name, "\"");
      if (i.color && i.color != '') {
        res += " colour=\"".concat(i.color, "\"");
      }
      if (i.custom && i.custom != '') {
        res += " custom=\"".concat(i.custom, "\"");
      }
      res += ">".concat(this.serializeToolboxItems(i.items), "</category>");
      return res;
    }
  }, {
    key: "serializeToolboxCategories",
    value: function serializeToolboxCategories(items) {
      var _this2 = this;
      return items.map(function (item) {
        return _this2.serializeToolboxCategory(item);
      }).join('\n');
    }
  }, {
    key: "serializeToolbox",
    value: function serializeToolbox(toolbox) {
      var catCount = toolbox.categories.length;
      if (toolbox.categories && catCount > 1) {
        return "".concat(this.serializeToolboxCategories(toolbox.categories));
      } else if (catCount === 1) {
        var cat = toolbox.categories[0];
        if (cat.color === undefined || cat.color == '' || cat.name == '') {
          return '' + this.serializeToolboxItems(cat.items);
        } else {
          return '' + this.serializeToolboxCategories(toolbox.categories);
        }
      } else {
        return '';
      }
    }
  }, {
    key: "getBlockDescription",
    value: function getBlockDescription(bl) {
      var cp = Object.assign({}, bl.JSON);
      cp.colour = this.toHTMLColor(cp.colour);
      return cp;
    }
  }, {
    key: "serializeCustomBlock",
    value: function serializeCustomBlock(bl) {
      return JSON.stringify(this.getBlockDescription(bl));
    }
  }, {
    key: "serializeCustomBlocks",
    value: function serializeCustomBlocks(bls) {
      var _this3 = this;
      return JSON.stringify(bls.map(function (bl) {
        return _this3.getBlockDescription(bl);
      }));
    }
  }, {
    key: "codeUndefines",
    get: function get() {
      return 'const window = undefined; const Window = undefined; const document = undefined;const $ = undefined;const _ = undefined;';
    }
  }, {
    key: "removeSelfClosingTags",
    value: function removeSelfClosingTags(xml) {
      //console.log(xml, '\n', xml.replace(/<(\w+)([^<]*)\/>/g, '<$1$2></$1>'))
      return xml.replace(/<(\w+)([^<]*)\/>/g, '<$1$2></$1>');
    }
  }, {
    key: "prepareCode",
    value: function prepareCode(cc) {
      return "\"use strict\"; ".concat(this.codeUndefines, " return function(){ return {o: ").concat(cc, "}.o}.call({})");
    }
  }, {
    key: "prepareBlocklyCode",
    value: function prepareBlocklyCode(cc) {
      return "var Blockly = B;".concat(this.codeUndefines, "return { o:function(block) { ").concat(cc, " }}.o");
    }
  }, {
    key: "compile",
    value: function compile(bl, Blockly) {
      var cc = this.prepareBlocklyCode(bl.codeString);
      bl._code = undefined;
      try {
        //console.log(cc, Blockly)
        var code = new Function('B', cc);
        bl._code = code(Blockly);
      } catch (e) {
        bl._code = undefined;
        console.error('Error Compiling', cc, e);
        return e + '';
      }
      return undefined;
    }
  }, {
    key: "itemForValue",
    value: function itemForValue(items, value) {
      return vue__WEBPACK_IMPORTED_MODULE_14___default.a.$CodeBlock.itemForValue(items, value);
    }
  }, {
    key: "toColorCode",
    value: function toColorCode(color) {
      if (color === '') {
        return undefined;
      }
      return color;
    }
  }, {
    key: "toColor",
    value: function toColor(color) {
      if (color === undefined) {
        return '';
      }
      Object.keys(_lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"]).forEach(function (key) {
        if (color == "{!PrimaryColors.".concat(key, "}")) {
          color = _lib_IBlocklyHelper__WEBPACK_IMPORTED_MODULE_16__[/* BlockPrimaryColors */ "b"][key];
        }
      });
      return color;
    }
  }, {
    key: "toHTMLColor",
    value: function toHTMLColor(color) {
      var cl = this.toColor(color);
      if (cl.length > 0 && cl[0] != '#' && cl[0] != 'h' && cl[0] != 'r') {
        return "hsl(".concat(cl, ", 100%, 50%)");
      }
      return cl;
    }
  }, {
    key: "mounted",
    value: function mounted() {}
  }]);
  return BlocklyHelper;
}();
var blocklyHelper = new BlocklyHelper();

/***/ }),

/***/ "25a1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $reduceRight = __webpack_require__("d58f").right;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduceRight` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  var length = arguments.length;
  return $reduceRight(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "25f0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var PROPER_FUNCTION_NAME = __webpack_require__("5e77").PROPER;
var defineBuiltIn = __webpack_require__("cb2d");
var anObject = __webpack_require__("825a");
var $toString = __webpack_require__("577e");
var fails = __webpack_require__("d039");
var getRegExpFlags = __webpack_require__("90d8");

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  defineBuiltIn(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var pattern = $toString(R.source);
    var flags = $toString(getRegExpFlags(R));
    return '/' + pattern + '/' + flags;
  }, { unsafe: true });
}


/***/ }),

/***/ "2626":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__("d066");
var defineBuiltInAccessor = __webpack_require__("edd0");
var wellKnownSymbol = __webpack_require__("b622");
var DESCRIPTORS = __webpack_require__("83ab");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineBuiltInAccessor(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "262e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _inherits; });
/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d9e2");
/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("b380");


function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) Object(_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(subClass, superClass);
}

/***/ }),

/***/ "26bc":
/***/ (function(module, exports) {

/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function lookahead(re) {
  return concat('(?=', re, ')');
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}

/*
Language: R
Description: R is a free software environment for statistical computing and graphics.
Author: Joe Cheng <joe@rstudio.org>
Contributors: Konrad Rudolph <konrad.rudolph@gmail.com>
Website: https://www.r-project.org
Category: common,scientific
*/

/** @type LanguageFn */
function r(hljs) {
  // Identifiers in R cannot start with `_`, but they can start with `.` if it
  // is not immediately followed by a digit.
  // R also supports quoted identifiers, which are near-arbitrary sequences
  // delimited by backticks (`…`), which may contain escape sequences. These are
  // handled in a separate mode. See `test/markup/r/names.txt` for examples.
  // FIXME: Support Unicode identifiers.
  const IDENT_RE = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/;
  const SIMPLE_IDENT = /[a-zA-Z][a-zA-Z_0-9]*/;

  return {
    name: 'R',

    // only in Haskell, not R
    illegal: /->/,
    keywords: {
      $pattern: IDENT_RE,
      keyword:
        'function if in break next repeat else for while',
      literal:
        'NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 ' +
        'NA_character_|10 NA_complex_|10',
      built_in:
        // Builtin constants
        'LETTERS letters month.abb month.name pi T F ' +
        // Primitive functions
        // These are all the functions in `base` that are implemented as a
        // `.Primitive`, minus those functions that are also keywords.
        'abs acos acosh all any anyNA Arg as.call as.character ' +
        'as.complex as.double as.environment as.integer as.logical ' +
        'as.null.default as.numeric as.raw asin asinh atan atanh attr ' +
        'attributes baseenv browser c call ceiling class Conj cos cosh ' +
        'cospi cummax cummin cumprod cumsum digamma dim dimnames ' +
        'emptyenv exp expression floor forceAndCall gamma gc.time ' +
        'globalenv Im interactive invisible is.array is.atomic is.call ' +
        'is.character is.complex is.double is.environment is.expression ' +
        'is.finite is.function is.infinite is.integer is.language ' +
        'is.list is.logical is.matrix is.na is.name is.nan is.null ' +
        'is.numeric is.object is.pairlist is.raw is.recursive is.single ' +
        'is.symbol lazyLoadDBfetch length lgamma list log max min ' +
        'missing Mod names nargs nzchar oldClass on.exit pos.to.env ' +
        'proc.time prod quote range Re rep retracemem return round ' +
        'seq_along seq_len seq.int sign signif sin sinh sinpi sqrt ' +
        'standardGeneric substitute sum switch tan tanh tanpi tracemem ' +
        'trigamma trunc unclass untracemem UseMethod xtfrm',
    },
    compilerExtensions: [
      // allow beforeMatch to act as a "qualifier" for the match
      // the full match begin must be [beforeMatch][begin]
      (mode, parent) => {
        if (!mode.beforeMatch) return;
        // starts conflicts with endsParent which we need to make sure the child
        // rule is not matched multiple times
        if (mode.starts) throw new Error("beforeMatch cannot be used with starts");

        const originalMode = Object.assign({}, mode);
        Object.keys(mode).forEach((key) => { delete mode[key]; });

        mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));
        mode.starts = {
          relevance: 0,
          contains: [
            Object.assign(originalMode, { endsParent: true })
          ]
        };
        mode.relevance = 0;

        delete originalMode.beforeMatch;
      }
    ],
    contains: [
      // Roxygen comments
      hljs.COMMENT(
        /#'/,
        /$/,
        {
          contains: [
            {
              // Handle `@examples` separately to cause all subsequent code
              // until the next `@`-tag on its own line to be kept as-is,
              // preventing highlighting. This code is example R code, so nested
              // doctags shouldn’t be treated as such. See
              // `test/markup/r/roxygen.txt` for an example.
              className: 'doctag',
              begin: '@examples',
              starts: {
                contains: [
                  { begin: /\n/ },
                  {
                    begin: /#'\s*(?=@[a-zA-Z]+)/,
                    endsParent: true,
                  },
                  {
                    begin: /#'/,
                    end: /$/,
                    excludeBegin: true,
                  }
                ]
              }
            },
            {
              // Handle `@param` to highlight the parameter name following
              // after.
              className: 'doctag',
              begin: '@param',
              end: /$/,
              contains: [
                {
                  className: 'variable',
                  variants: [
                    { begin: IDENT_RE },
                    { begin: /`(?:\\.|[^`\\])+`/ }
                  ],
                  endsParent: true
                }
              ]
            },
            {
              className: 'doctag',
              begin: /@[a-zA-Z]+/
            },
            {
              className: 'meta-keyword',
              begin: /\\[a-zA-Z]+/,
            }
          ]
        }
      ),

      hljs.HASH_COMMENT_MODE,

      {
        className: 'string',
        contains: [hljs.BACKSLASH_ESCAPE],
        variants: [
          hljs.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\(/, end: /\)(-*)"/ }),
          hljs.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\{/, end: /\}(-*)"/ }),
          hljs.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\[/, end: /\](-*)"/ }),
          hljs.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\(/, end: /\)(-*)'/ }),
          hljs.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\{/, end: /\}(-*)'/ }),
          hljs.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\[/, end: /\](-*)'/ }),
          {begin: '"', end: '"', relevance: 0},
          {begin: "'", end: "'", relevance: 0}
        ],
      },
      {
        className: 'number',
        relevance: 0,
        beforeMatch: /([^a-zA-Z0-9._])/, // not part of an identifier
        variants: [
          // TODO: replace with negative look-behind when available
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
          // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
          // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
          {
            // Special case: only hexadecimal binary powers can contain fractions.
            match: /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
          },
          {
            match: /0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/
          },
          {
            match: /(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/,
          }
        ],
      },
      {
        // infix operator
        begin: '%',
        end: '%'
      },
      // relevance boost for assignment
      {
        begin: concat(SIMPLE_IDENT, "\\s+<-\\s+")
      },
      {
        // escaped identifier
        begin: '`',
        end: '`',
        contains: [
          { begin: /\\./ }
        ]
      }
    ]
  };
}

module.exports = r;


/***/ }),

/***/ "27f9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./node_modules/quasar/src/components/field/QField.js + 2 modules
var QField = __webpack_require__("8572");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/form.js
var mixins_form = __webpack_require__("f89c");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__("d81d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
var es_string_trim = __webpack_require__("498a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.ends-with.js
var es_string_ends_with = __webpack_require__("8a79");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__("fb6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.from.js
var es_array_from = __webpack_require__("a630");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.starts-with.js
var es_string_starts_with = __webpack_require__("2ca0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__("b0c0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.includes.js
var es_string_includes = __webpack_require__("2532");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("13d5");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
var es_array_filter = __webpack_require__("4de4");

// EXTERNAL MODULE: ./node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("0967");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("d882");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/cache.js
var cache = __webpack_require__("d54d");

// CONCATENATED MODULE: ./node_modules/quasar/src/mixins/file.js



















function filterFiles(files, rejectedFiles, failedPropValidation, filterFn) {
  var acceptedFiles = [];
  files.forEach(function (file) {
    if (filterFn(file) === true) {
      acceptedFiles.push(file);
    } else {
      rejectedFiles.push({
        failedPropValidation: failedPropValidation,
        file: file
      });
    }
  });
  return acceptedFiles;
}
function stopAndPreventDrag(e) {
  e && e.dataTransfer && (e.dataTransfer.dropEffect = 'copy');
  Object(utils_event["j" /* stopAndPrevent */])(e);
}
/* harmony default export */ var file = ({
  props: {
    multiple: Boolean,
    accept: String,
    capture: String,
    maxFileSize: [Number, String],
    maxTotalSize: [Number, String],
    maxFiles: [Number, String],
    filter: Function
  },
  computed: {
    extensions: function extensions() {
      if (this.accept !== void 0) {
        return this.accept.split(',').map(function (ext) {
          ext = ext.trim();
          if (ext === '*') {
            // support "*"
            return '*/';
          } else if (ext.endsWith('/*')) {
            // support "image/*" or "*/*"
            ext = ext.slice(0, ext.length - 1);
          }
          return ext.toUpperCase();
        });
      }
    },
    maxFilesNumber: function maxFilesNumber() {
      return parseInt(this.maxFiles, 10);
    },
    maxTotalSizeNumber: function maxTotalSizeNumber() {
      return parseInt(this.maxTotalSize, 10);
    }
  },
  methods: {
    pickFiles: function pickFiles(ev) {
      if (this.editable === true) {
        if (ev !== Object(ev)) {
          ev = {
            target: null
          };
        }
        if (ev.target !== null && ev.target.matches('input[type="file"]') === true) {
          // stop propagation if it's not a real pointer event
          ev.clientX === 0 && ev.clientY === 0 && Object(utils_event["i" /* stop */])(ev);
        } else {
          var input = this.__getFileInput();
          input && input !== ev.target && input.click(ev);
        }
      }
    },
    addFiles: function addFiles(files) {
      if (this.editable && files) {
        this.__addFiles(null, files);
      }
    },
    __processFiles: function __processFiles(e, filesToProcess, currentFileList, append) {
      var _this = this;
      var files = Array.from(filesToProcess || e.target.files);
      var rejectedFiles = [];
      var done = function done() {
        if (rejectedFiles.length > 0) {
          _this.$emit('rejected', rejectedFiles);
        }
      };

      // filter file types
      if (this.accept !== void 0 && this.extensions.indexOf('*/') === -1) {
        files = filterFiles(files, rejectedFiles, 'accept', function (file) {
          return _this.extensions.some(function (ext) {
            return file.type.toUpperCase().startsWith(ext) || file.name.toUpperCase().endsWith(ext);
          });
        });
        if (files.length === 0) {
          return done();
        }
      }

      // filter max file size
      if (this.maxFileSize !== void 0) {
        var maxFileSize = parseInt(this.maxFileSize, 10);
        files = filterFiles(files, rejectedFiles, 'max-file-size', function (file) {
          return file.size <= maxFileSize;
        });
        if (files.length === 0) {
          return done();
        }
      }

      // Cordova/iOS allows selecting multiple files even when the
      // multiple attribute is not specified. We also normalize drag'n'dropped
      // files here:
      if (this.multiple !== true && files.length > 0) {
        files = [files[0]];
      }
      files.forEach(function (file) {
        file.__key = file.webkitRelativePath + file.lastModified + file.name + file.size;
      });
      if (append === true) {
        // Avoid duplicate files
        var filenameMap = currentFileList.map(function (entry) {
          return entry.__key;
        });
        files = filterFiles(files, rejectedFiles, 'duplicate', function (file) {
          return filenameMap.includes(file.__key) === false;
        });
      }
      if (files.length === 0) {
        return done();
      }
      if (this.maxTotalSize !== void 0) {
        var size = append === true ? currentFileList.reduce(function (total, file) {
          return total + file.size;
        }, 0) : 0;
        files = filterFiles(files, rejectedFiles, 'max-total-size', function (file) {
          size += file.size;
          return size <= _this.maxTotalSizeNumber;
        });
        if (files.length === 0) {
          return done();
        }
      }

      // do we have custom filter function?
      if (typeof this.filter === 'function') {
        var filteredFiles = this.filter(files);
        files = filterFiles(files, rejectedFiles, 'filter', function (file) {
          return filteredFiles.includes(file);
        });
      }
      if (this.maxFiles !== void 0) {
        var filesNumber = append === true ? currentFileList.length : 0;
        files = filterFiles(files, rejectedFiles, 'max-files', function () {
          filesNumber++;
          return filesNumber <= _this.maxFilesNumber;
        });
        if (files.length === 0) {
          return done();
        }
      }
      done();
      if (files.length > 0) {
        return files;
      }
    },
    __onDragOver: function __onDragOver(e) {
      stopAndPreventDrag(e);
      this.dnd !== true && (this.dnd = true);
    },
    __onDragLeave: function __onDragLeave(e) {
      Object(utils_event["j" /* stopAndPrevent */])(e);

      // Safari bug: relatedTarget is null for over 10 years
      // https://bugs.webkit.org/show_bug.cgi?id=66547
      var gone = e.relatedTarget !== null || Platform["b" /* default */].is.safari !== true ? e.relatedTarget !== this.$refs.dnd : document.elementsFromPoint(e.clientX, e.clientY).includes(this.$refs.dnd) === false;
      gone === true && (this.dnd = false);
    },
    __onDrop: function __onDrop(e) {
      stopAndPreventDrag(e);
      var files = e.dataTransfer.files;
      if (files.length > 0) {
        this.__addFiles(null, files);
      }
      this.dnd = false;
    },
    __getDnd: function __getDnd(h, type) {
      if (this.dnd === true) {
        return h('div', {
          staticClass: "q-".concat(type, "__dnd absolute-full"),
          ref: 'dnd',
          on: Object(cache["a" /* default */])(this, 'dnd', {
            dragenter: stopAndPreventDrag,
            dragover: stopAndPreventDrag,
            dragleave: this.__onDragLeave,
            drop: this.__onDrop
          })
        });
      }
    }
  }
});
var FileValueMixin = {
  computed: {
    formDomProps: function formDomProps() {
      if (this.type !== 'file') {
        return;
      }
      try {
        var dt = 'DataTransfer' in window ? new DataTransfer() : 'ClipboardEvent' in window ? new ClipboardEvent('').clipboardData : void 0;
        if (Object(this.value) === this.value) {
          ('length' in this.value ? Array.from(this.value) : [this.value]).forEach(function (file) {
            dt.items.add(file);
          });
        }
        return {
          files: dt.files
        };
      } catch (e) {
        return {
          files: void 0
        };
      }
    }
  }
};
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules
var toConsumableArray = __webpack_require__("2909");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.keys.js
var es_object_keys = __webpack_require__("b64b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.constructor.js
var es_regexp_constructor = __webpack_require__("4d63");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.dot-all.js
var es_regexp_dot_all = __webpack_require__("c607");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.sticky.js
var es_regexp_sticky = __webpack_require__("2c3e");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__("25f0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.join.js
var es_array_join = __webpack_require__("a15b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("5319");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
var es_string_split = __webpack_require__("1276");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.test.js
var es_regexp_test = __webpack_require__("00b4");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/key-composition.js
var key_composition = __webpack_require__("dc8a");

// CONCATENATED MODULE: ./node_modules/quasar/src/mixins/mask.js



















// leave NAMED_MASKS at top of file (code referenced from docs)
var NAMED_MASKS = {
  date: '####/##/##',
  datetime: '####/##/## ##:##',
  time: '##:##',
  fulltime: '##:##:##',
  phone: '(###) ### - ####',
  card: '#### #### #### ####'
};
var TOKENS = {
  '#': {
    pattern: '[\\d]',
    negate: '[^\\d]'
  },
  S: {
    pattern: '[a-zA-Z]',
    negate: '[^a-zA-Z]'
  },
  N: {
    pattern: '[0-9a-zA-Z]',
    negate: '[^0-9a-zA-Z]'
  },
  A: {
    pattern: '[a-zA-Z]',
    negate: '[^a-zA-Z]',
    transform: function transform(v) {
      return v.toLocaleUpperCase();
    }
  },
  a: {
    pattern: '[a-zA-Z]',
    negate: '[^a-zA-Z]',
    transform: function transform(v) {
      return v.toLocaleLowerCase();
    }
  },
  X: {
    pattern: '[0-9a-zA-Z]',
    negate: '[^0-9a-zA-Z]',
    transform: function transform(v) {
      return v.toLocaleUpperCase();
    }
  },
  x: {
    pattern: '[0-9a-zA-Z]',
    negate: '[^0-9a-zA-Z]',
    transform: function transform(v) {
      return v.toLocaleLowerCase();
    }
  }
};
var KEYS = Object.keys(TOKENS);
KEYS.forEach(function (key) {
  TOKENS[key].regex = new RegExp(TOKENS[key].pattern);
});
var tokenRegexMask = new RegExp('\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([' + KEYS.join('') + '])|(.)', 'g'),
  escRegex = /[.*+?^${}()|[\]\\]/g;
var MARKER = String.fromCharCode(1);
/* harmony default export */ var mixins_mask = ({
  props: {
    mask: String,
    reverseFillMask: Boolean,
    fillMask: [Boolean, String],
    unmaskedValue: Boolean
  },
  watch: {
    type: function type() {
      this.__updateMaskInternals();
    },
    autogrow: function autogrow() {
      this.__updateMaskInternals();
    },
    mask: function mask(v) {
      if (v !== void 0) {
        this.__updateMaskValue(this.innerValue, true);
      } else {
        var val = this.__unmask(this.innerValue);
        this.__updateMaskInternals();
        this.value !== val && this.$emit('input', val);
      }
    },
    fillMask: function fillMask() {
      this.hasMask === true && this.__updateMaskValue(this.innerValue, true);
    },
    reverseFillMask: function reverseFillMask() {
      this.hasMask === true && this.__updateMaskValue(this.innerValue, true);
    },
    unmaskedValue: function unmaskedValue() {
      this.hasMask === true && this.__updateMaskValue(this.innerValue);
    }
  },
  methods: {
    __getInitialMaskedValue: function __getInitialMaskedValue() {
      this.__updateMaskInternals();
      if (this.hasMask === true) {
        var masked = this.__mask(this.__unmask(this.value));
        return this.fillMask !== false ? this.__fillWithMask(masked) : masked;
      }
      return this.value;
    },
    __getPaddedMaskMarked: function __getPaddedMaskMarked(size) {
      if (size < this.maskMarked.length) {
        return this.maskMarked.slice(-size);
      }
      var maskMarked = this.maskMarked,
        pad = '';
      var padPos = maskMarked.indexOf(MARKER);
      if (padPos > -1) {
        for (var i = size - maskMarked.length; i > 0; i--) {
          pad += MARKER;
        }
        maskMarked = maskMarked.slice(0, padPos) + pad + maskMarked.slice(padPos);
      }
      return maskMarked;
    },
    __updateMaskInternals: function __updateMaskInternals() {
      var _this = this;
      this.hasMask = this.mask !== void 0 && this.mask.length > 0 && (this.autogrow === true || ['textarea', 'text', 'search', 'url', 'tel', 'password'].includes(this.type));
      if (this.hasMask === false) {
        this.computedUnmask = void 0;
        this.maskMarked = '';
        this.maskReplaced = '';
        return;
      }
      var computedMask = NAMED_MASKS[this.mask] === void 0 ? this.mask : NAMED_MASKS[this.mask],
        fillChar = typeof this.fillMask === 'string' && this.fillMask.length > 0 ? this.fillMask.slice(0, 1) : '_',
        fillCharEscaped = fillChar.replace(escRegex, '\\$&'),
        unmask = [],
        extract = [],
        mask = [];
      var firstMatch = this.reverseFillMask === true,
        unmaskChar = '',
        negateChar = '';
      computedMask.replace(tokenRegexMask, function (_, char1, esc, token, char2) {
        if (token !== void 0) {
          var c = TOKENS[token];
          mask.push(c);
          negateChar = c.negate;
          if (firstMatch === true) {
            extract.push('(?:' + negateChar + '+)?(' + c.pattern + '+)?(?:' + negateChar + '+)?(' + c.pattern + '+)?');
            firstMatch = false;
          }
          extract.push('(?:' + negateChar + '+)?(' + c.pattern + ')?');
        } else if (esc !== void 0) {
          unmaskChar = '\\' + (esc === '\\' ? '' : esc);
          mask.push(esc);
          unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');
        } else {
          var _c = char1 !== void 0 ? char1 : char2;
          unmaskChar = _c === '\\' ? '\\\\\\\\' : _c.replace(escRegex, '\\\\$&');
          mask.push(_c);
          unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');
        }
      });
      var unmaskMatcher = new RegExp('^' + unmask.join('') + '(' + (unmaskChar === '' ? '.' : '[^' + unmaskChar + ']') + '+)?' + (unmaskChar === '' ? '' : '[' + unmaskChar + ']*') + '$'),
        extractLast = extract.length - 1,
        extractMatcher = extract.map(function (re, index) {
          if (index === 0 && _this.reverseFillMask === true) {
            return new RegExp('^' + fillCharEscaped + '*' + re);
          } else if (index === extractLast) {
            return new RegExp('^' + re + '(' + (negateChar === '' ? '.' : negateChar) + '+)?' + (_this.reverseFillMask === true ? '$' : fillCharEscaped + '*'));
          }
          return new RegExp('^' + re);
        });
      this.computedMask = mask;
      this.computedUnmask = function (val) {
        var unmaskMatch = unmaskMatcher.exec(_this.reverseFillMask === true ? val : val.slice(0, mask.length + 1));
        if (unmaskMatch !== null) {
          val = unmaskMatch.slice(1).join('');
        }
        var extractMatch = [],
          extractMatcherLength = extractMatcher.length;
        for (var i = 0, str = val; i < extractMatcherLength; i++) {
          var m = extractMatcher[i].exec(str);
          if (m === null) {
            break;
          }
          str = str.slice(m.shift().length);
          extractMatch.push.apply(extractMatch, Object(toConsumableArray["a" /* default */])(m));
        }
        if (extractMatch.length > 0) {
          return extractMatch.join('');
        }
        return val;
      };
      this.maskMarked = mask.map(function (v) {
        return typeof v === 'string' ? v : MARKER;
      }).join('');
      this.maskReplaced = this.maskMarked.split(MARKER).join(fillChar);
    },
    __updateMaskValue: function __updateMaskValue(rawVal, updateMaskInternals, inputType) {
      var _this2 = this;
      var inp = this.$refs.input,
        end = inp.selectionEnd,
        endReverse = inp.value.length - end,
        unmasked = this.__unmask(rawVal);

      // Update here so unmask uses the original fillChar
      updateMaskInternals === true && this.__updateMaskInternals();
      var preMasked = this.__mask(unmasked),
        masked = this.fillMask !== false ? this.__fillWithMask(preMasked) : preMasked,
        changed = this.innerValue !== masked;

      // We want to avoid "flickering" so we set value immediately
      inp.value !== masked && (inp.value = masked);
      changed === true && (this.innerValue = masked);
      document.activeElement === inp && this.$nextTick(function () {
        if (masked === _this2.maskReplaced) {
          var cursor = _this2.reverseFillMask === true ? _this2.maskReplaced.length : 0;
          inp.setSelectionRange(cursor, cursor, 'forward');
          return;
        }
        if (inputType === 'insertFromPaste' && _this2.reverseFillMask !== true) {
          var maxEnd = inp.selectionEnd;
          var _cursor = end - 1;
          // each non-marker char means we move once to right
          for (var i = _this2.__pastedTextStart; i <= _cursor && i < maxEnd; i++) {
            if (_this2.maskMarked[i] !== MARKER) {
              _cursor++;
            }
          }
          _this2.__moveCursorRight(inp, _cursor);
          return;
        }
        if (['deleteContentBackward', 'deleteContentForward'].indexOf(inputType) > -1) {
          var _cursor2 = _this2.reverseFillMask === true ? end === 0 ? masked.length > preMasked.length ? 1 : 0 : Math.max(0, masked.length - (masked === _this2.maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1 : end;
          inp.setSelectionRange(_cursor2, _cursor2, 'forward');
          return;
        }
        if (_this2.reverseFillMask === true) {
          if (changed === true) {
            var _cursor3 = Math.max(0, masked.length - (masked === _this2.maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));
            if (_cursor3 === 1 && end === 1) {
              inp.setSelectionRange(_cursor3, _cursor3, 'forward');
            } else {
              _this2.__moveCursorRightReverse(inp, _cursor3);
            }
          } else {
            var _cursor4 = masked.length - endReverse;
            inp.setSelectionRange(_cursor4, _cursor4, 'backward');
          }
        } else {
          if (changed === true) {
            var _cursor5 = Math.max(0, _this2.maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);
            _this2.__moveCursorRight(inp, _cursor5);
          } else {
            var _cursor6 = end - 1;
            _this2.__moveCursorRight(inp, _cursor6);
          }
        }
      });
      var val = this.unmaskedValue === true ? this.__unmask(masked) : masked;
      String(this.value) !== val && this.__emitValue(val, true);
    },
    __moveCursorForPaste: function __moveCursorForPaste(inp, start, end) {
      var preMasked = this.__mask(this.__unmask(inp.value));
      start = Math.max(0, this.maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));
      this.__pastedTextStart = start;
      inp.setSelectionRange(start, end, 'forward');
    },
    __moveCursorLeft: function __moveCursorLeft(inp, cursor) {
      var noMarkBefore = this.maskMarked.slice(cursor - 1).indexOf(MARKER) === -1;
      var i = Math.max(0, cursor - 1);
      for (; i >= 0; i--) {
        if (this.maskMarked[i] === MARKER) {
          cursor = i;
          noMarkBefore === true && cursor++;
          break;
        }
      }
      if (i < 0 && this.maskMarked[cursor] !== void 0 && this.maskMarked[cursor] !== MARKER) {
        return this.__moveCursorRight(inp, 0);
      }
      cursor >= 0 && inp.setSelectionRange(cursor, cursor, 'backward');
    },
    __moveCursorRight: function __moveCursorRight(inp, cursor) {
      var limit = inp.value.length;
      var i = Math.min(limit, cursor + 1);
      for (; i <= limit; i++) {
        if (this.maskMarked[i] === MARKER) {
          cursor = i;
          break;
        } else if (this.maskMarked[i - 1] === MARKER) {
          cursor = i;
        }
      }
      if (i > limit && this.maskMarked[cursor - 1] !== void 0 && this.maskMarked[cursor - 1] !== MARKER) {
        return this.__moveCursorLeft(inp, limit);
      }
      inp.setSelectionRange(cursor, cursor, 'forward');
    },
    __moveCursorLeftReverse: function __moveCursorLeftReverse(inp, cursor) {
      var maskMarked = this.__getPaddedMaskMarked(inp.value.length);
      var i = Math.max(0, cursor - 1);
      for (; i >= 0; i--) {
        if (maskMarked[i - 1] === MARKER) {
          cursor = i;
          break;
        } else if (maskMarked[i] === MARKER) {
          cursor = i;
          if (i === 0) {
            break;
          }
        }
      }
      if (i < 0 && maskMarked[cursor] !== void 0 && maskMarked[cursor] !== MARKER) {
        return this.__moveCursorRightReverse(inp, 0);
      }
      cursor >= 0 && inp.setSelectionRange(cursor, cursor, 'backward');
    },
    __moveCursorRightReverse: function __moveCursorRightReverse(inp, cursor) {
      var limit = inp.value.length,
        maskMarked = this.__getPaddedMaskMarked(limit),
        noMarkBefore = maskMarked.slice(0, cursor + 1).indexOf(MARKER) === -1;
      var i = Math.min(limit, cursor + 1);
      for (; i <= limit; i++) {
        if (maskMarked[i - 1] === MARKER) {
          cursor = i;
          cursor > 0 && noMarkBefore === true && cursor--;
          break;
        }
      }
      if (i > limit && maskMarked[cursor - 1] !== void 0 && maskMarked[cursor - 1] !== MARKER) {
        return this.__moveCursorLeftReverse(inp, limit);
      }
      inp.setSelectionRange(cursor, cursor, 'forward');
    },
    __onMaskedClick: function __onMaskedClick(e) {
      this.qListeners.click !== void 0 && this.$emit('click', e);
      this.__selectionAnchor = void 0;
    },
    __onMaskedKeydown: function __onMaskedKeydown(e) {
      this.qListeners.keydown !== void 0 && this.$emit('keydown', e);
      if (Object(key_composition["c" /* shouldIgnoreKey */])(e) === true) {
        return;
      }
      var inp = this.$refs.input,
        start = inp.selectionStart,
        end = inp.selectionEnd;
      if (!e.shiftKey) {
        this.__selectionAnchor = void 0;
      }
      if (e.keyCode === 37 || e.keyCode === 39) {
        // Left / Right
        if (e.shiftKey && this.__selectionAnchor === void 0) {
          this.__selectionAnchor = inp.selectionDirection === 'forward' ? start : end;
        }
        var fn = this['__moveCursor' + (e.keyCode === 39 ? 'Right' : 'Left') + (this.reverseFillMask === true ? 'Reverse' : '')];
        e.preventDefault();
        fn(inp, this.__selectionAnchor === start ? end : start);
        if (e.shiftKey) {
          var anchor = this.__selectionAnchor;
          var cursor = inp.selectionStart;
          inp.setSelectionRange(Math.min(anchor, cursor), Math.max(anchor, cursor), 'forward');
        }
      } else if (e.keyCode === 8 &&
      // Backspace
      this.reverseFillMask !== true && start === end) {
        this.__moveCursorLeft(inp, start);
        inp.setSelectionRange(inp.selectionStart, end, 'backward');
      } else if (e.keyCode === 46 &&
      // Delete
      this.reverseFillMask === true && start === end) {
        this.__moveCursorRightReverse(inp, end);
        inp.setSelectionRange(start, inp.selectionEnd, 'forward');
      }
      this.$emit('keydown', e);
    },
    __mask: function __mask(val) {
      if (val === void 0 || val === null || val === '') {
        return '';
      }
      if (this.reverseFillMask === true) {
        return this.__maskReverse(val);
      }
      var mask = this.computedMask;
      var valIndex = 0,
        output = '';
      for (var maskIndex = 0; maskIndex < mask.length; maskIndex++) {
        var valChar = val[valIndex],
          maskDef = mask[maskIndex];
        if (typeof maskDef === 'string') {
          output += maskDef;
          valChar === maskDef && valIndex++;
        } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
          output += maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar;
          valIndex++;
        } else {
          return output;
        }
      }
      return output;
    },
    __maskReverse: function __maskReverse(val) {
      var mask = this.computedMask,
        firstTokenIndex = this.maskMarked.indexOf(MARKER);
      var valIndex = val.length - 1,
        output = '';
      for (var maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {
        var maskDef = mask[maskIndex];
        var valChar = val[valIndex];
        if (typeof maskDef === 'string') {
          output = maskDef + output;
          valChar === maskDef && valIndex--;
        } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {
          do {
            output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;
            valIndex--;
            valChar = val[valIndex];
            // eslint-disable-next-line no-unmodified-loop-condition
          } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar));
        } else {
          return output;
        }
      }
      return output;
    },
    __unmask: function __unmask(val) {
      return typeof val !== 'string' || this.computedUnmask === void 0 ? typeof val === 'number' ? this.computedUnmask('' + val) : val : this.computedUnmask(val);
    },
    __fillWithMask: function __fillWithMask(val) {
      if (this.maskReplaced.length - val.length <= 0) {
        return val;
      }
      return this.reverseFillMask === true && val.length > 0 ? this.maskReplaced.slice(0, -val.length) + val : val + this.maskReplaced.slice(val.length);
    }
  }
});
// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/composition.js
var composition = __webpack_require__("21e1");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("87e8");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/focus-manager.js
var focus_manager = __webpack_require__("f6ba");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/input/QInput.js












/* harmony default export */ var QInput = __webpack_exports__["a"] = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QInput',
  mixins: [QField["a" /* default */], mixins_mask, composition["a" /* default */], mixins_form["a" /* FormFieldMixin */], FileValueMixin, listeners["a" /* default */]],
  props: {
    value: {
      required: false
    },
    shadowText: String,
    type: {
      type: String,
      default: 'text'
    },
    debounce: [String, Number],
    autogrow: Boolean,
    // makes a textarea

    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object]
  },
  watch: {
    value: function value(v) {
      if (this.hasMask === true) {
        if (this.stopValueWatcher === true) {
          this.stopValueWatcher = false;
          if (String(v) === this.emitCachedValue) {
            return;
          }
        }
        this.__updateMaskValue(v);
      } else if (this.innerValue !== v) {
        this.innerValue = v;
        if (this.type === 'number' && this.hasOwnProperty('tempValue') === true) {
          if (this.typedNumber === true) {
            this.typedNumber = false;
          } else {
            delete this.tempValue;
          }
        }
      }

      // textarea only
      this.autogrow === true && this.$nextTick(this.__adjustHeight);
    },
    // some browsers lose the native input value
    // so we need to reattach it dynamically
    // (like type="password" <-> type="text"; see #12078)
    type: function type() {
      if (this.$refs.input) {
        this.$refs.input.value = this.value;
      }
    },
    autogrow: function autogrow(_autogrow) {
      // textarea only
      if (_autogrow === true) {
        this.$nextTick(this.__adjustHeight);
      }
      // if it has a number of rows set respect it
      else if (this.qAttrs.rows > 0 && this.$refs.input !== void 0) {
        var inp = this.$refs.input;
        inp.style.height = 'auto';
      }
    },
    dense: function dense() {
      this.autogrow === true && this.$nextTick(this.__adjustHeight);
    }
  },
  data: function data() {
    return {
      innerValue: this.__getInitialMaskedValue()
    };
  },
  computed: {
    isTextarea: function isTextarea() {
      return this.type === 'textarea' || this.autogrow === true;
    },
    isTypeText: function isTypeText() {
      return this.isTextarea === true || ['text', 'search', 'url', 'tel', 'password'].includes(this.type);
    },
    fieldClass: function fieldClass() {
      return "q-".concat(this.isTextarea === true ? 'textarea' : 'input') + (this.autogrow === true ? ' q-textarea--autogrow' : '');
    },
    hasShadow: function hasShadow() {
      return this.type !== 'file' && typeof this.shadowText === 'string' && this.shadowText.length > 0;
    },
    onEvents: function onEvents() {
      var on = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.qListeners), {}, {
        input: this.__onInput,
        paste: this.__onPaste,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        change: this.__onChange,
        blur: this.__onFinishEditing,
        focus: utils_event["i" /* stop */]
      });
      on.compositionstart = on.compositionupdate = on.compositionend = this.__onComposition;
      if (this.hasMask === true) {
        on.keydown = this.__onMaskedKeydown;
        // reset selection anchor on pointer selection
        on.click = this.__onMaskedClick;
      }
      if (this.autogrow === true) {
        on.animationend = this.__onAnimationend;
      }
      return on;
    },
    inputAttrs: function inputAttrs() {
      var attrs = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
        tabindex: 0,
        'data-autofocus': this.autofocus || void 0,
        rows: this.type === 'textarea' ? 6 : void 0,
        'aria-label': this.label,
        name: this.nameProp
      }, this.qAttrs), {}, {
        id: this.targetUid,
        type: this.type,
        maxlength: this.maxlength,
        disabled: this.disable === true,
        readonly: this.readonly === true
      });
      if (this.autogrow === true) {
        attrs.rows = 1;
      }
      return attrs;
    }
  },
  methods: {
    focus: function focus() {
      var _this = this;
      Object(focus_manager["a" /* addFocusFn */])(function () {
        var el = document.activeElement;
        if (_this.$refs.input !== void 0 && _this.$refs.input !== el && (
        // IE can have null document.activeElement
        el === null || el.id !== _this.targetUid)) {
          _this.$refs.input.focus({
            preventScroll: true
          });
        }
      });
    },
    select: function select() {
      this.$refs.input !== void 0 && this.$refs.input.select();
    },
    getNativeElement: function getNativeElement() {
      return this.$refs.input;
    },
    __onPaste: function __onPaste(e) {
      if (this.hasMask === true && this.reverseFillMask !== true) {
        var inp = e.target;
        this.__moveCursorForPaste(inp, inp.selectionStart, inp.selectionEnd);
      }
      this.$emit('paste', e);
    },
    __onInput: function __onInput(e) {
      if (!e || !e.target || e.target.qComposing === true) {
        return;
      }
      if (this.type === 'file') {
        this.$emit('input', e.target.files);
        return;
      }
      var val = e.target.value;
      if (this.hasMask === true) {
        this.__updateMaskValue(val, false, e.inputType);
      } else {
        this.__emitValue(val);
        if (this.isTypeText === true && e.target === document.activeElement) {
          var _e$target = e.target,
            selectionStart = _e$target.selectionStart,
            selectionEnd = _e$target.selectionEnd;
          if (selectionStart !== void 0 && selectionEnd !== void 0) {
            this.$nextTick(function () {
              if (e.target === document.activeElement && val.indexOf(e.target.value) === 0) {
                e.target.setSelectionRange(selectionStart, selectionEnd);
              }
            });
          }
        }
      }

      // we need to trigger it immediately too,
      // to avoid "flickering"
      this.autogrow === true && this.__adjustHeight();
    },
    __onAnimationend: function __onAnimationend(e) {
      this.qListeners.animationend !== void 0 && this.$emit('animationend', e);
      this.__adjustHeight();
    },
    __emitValue: function __emitValue(val, stopWatcher) {
      var _this2 = this;
      this.emitValueFn = function () {
        if (_this2.type !== 'number' && _this2.hasOwnProperty('tempValue') === true) {
          delete _this2.tempValue;
        }
        if (_this2.value !== val && _this2.emitCachedValue !== val) {
          _this2.emitCachedValue = val;
          stopWatcher === true && (_this2.stopValueWatcher = true);
          _this2.$emit('input', val);
          _this2.$nextTick(function () {
            _this2.emitCachedValue === val && (_this2.emitCachedValue = NaN);
          });
        }
        _this2.emitValueFn = void 0;
      };
      if (this.type === 'number') {
        this.typedNumber = true;
        this.tempValue = val;
      }
      if (this.debounce !== void 0) {
        clearTimeout(this.emitTimer);
        this.tempValue = val;
        this.emitTimer = setTimeout(this.emitValueFn, this.debounce);
      } else {
        this.emitValueFn();
      }
    },
    // textarea only
    __adjustHeight: function __adjustHeight() {
      var _this3 = this;
      requestAnimationFrame(function () {
        var inp = _this3.$refs.input;
        if (inp !== void 0) {
          var parentStyle = inp.parentNode.style;
          // chrome does not keep scroll #15498
          var scrollTop = inp.scrollTop;
          // chrome calculates a smaller scrollHeight when in a .column container
          var _ref = _this3.$q.platform.is.firefox === true ? {} : window.getComputedStyle(inp),
            overflowY = _ref.overflowY,
            maxHeight = _ref.maxHeight;
          // on firefox or if overflowY is specified as scroll #14263, #14344
          // we don't touch overflow
          // firefox is not so bad in the end
          var changeOverflow = overflowY !== void 0 && overflowY !== 'scroll';

          // reset height of textarea to a small size to detect the real height
          // but keep the total control size the same
          changeOverflow === true && (inp.style.overflowY = 'hidden');
          parentStyle.marginBottom = inp.scrollHeight - 1 + 'px';
          inp.style.height = '1px';
          inp.style.height = inp.scrollHeight + 'px';
          // we should allow scrollbars only
          // if there is maxHeight and content is taller than maxHeight
          changeOverflow === true && (inp.style.overflowY = parseInt(maxHeight, 10) < inp.scrollHeight ? 'auto' : 'hidden');
          parentStyle.marginBottom = '';
          inp.scrollTop = scrollTop;
        }
      });
    },
    __onChange: function __onChange(e) {
      this.__onComposition(e);
      clearTimeout(this.emitTimer);
      this.emitValueFn !== void 0 && this.emitValueFn();
      this.$emit('change', e);
    },
    __onFinishEditing: function __onFinishEditing(e) {
      var _this4 = this;
      e !== void 0 && Object(utils_event["i" /* stop */])(e);
      clearTimeout(this.emitTimer);
      this.emitValueFn !== void 0 && this.emitValueFn();
      this.typedNumber = false;
      this.stopValueWatcher = false;
      delete this.tempValue;

      // we need to use setTimeout instead of this.$nextTick
      // to avoid a bug where focusout is not emitted for type date/time/week/...
      this.type !== 'file' && setTimeout(function () {
        if (_this4.$refs.input !== void 0) {
          _this4.$refs.input.value = _this4.innerValue !== void 0 ? _this4.innerValue : '';
        }
      });
    },
    __getCurValue: function __getCurValue() {
      return this.hasOwnProperty('tempValue') === true ? this.tempValue : this.innerValue !== void 0 ? this.innerValue : '';
    },
    __getShadowControl: function __getShadowControl(h) {
      return h('div', {
        staticClass: 'q-field__native q-field__shadow absolute-bottom no-pointer-events' + (this.isTextarea === true ? '' : ' text-no-wrap')
      }, [h('span', {
        staticClass: 'invisible'
      }, this.__getCurValue()), h('span', this.shadowText)]);
    },
    __getControl: function __getControl(h) {
      return h(this.isTextarea === true ? 'textarea' : 'input', {
        ref: 'input',
        staticClass: 'q-field__native q-placeholder',
        style: this.inputStyle,
        class: this.inputClass,
        attrs: this.inputAttrs,
        on: this.onEvents,
        domProps: this.type !== 'file' ? {
          value: this.__getCurValue()
        } : this.formDomProps
      });
    }
  },
  created: function created() {
    this.emitCachedValue = NaN;
  },
  mounted: function mounted() {
    // textarea only
    this.autogrow === true && this.__adjustHeight();
  },
  beforeDestroy: function beforeDestroy() {
    this.__onFinishEditing();
  }
}));

/***/ }),

/***/ "2834":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var uncurryThis = __webpack_require__("e330");
var aCallable = __webpack_require__("59ed");
var arrayFromConstructorAndList = __webpack_require__("dfb9");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var sort = uncurryThis(ArrayBufferViewCore.TypedArrayPrototype.sort);

// `%TypedArray%.prototype.toSorted` method
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toSorted
exportTypedArrayMethod('toSorted', function toSorted(compareFn) {
  if (compareFn !== undefined) aCallable(compareFn);
  var O = aTypedArray(this);
  var A = arrayFromConstructorAndList(getTypedArrayConstructor(O), O);
  return sort(A, compareFn);
});


/***/ }),

/***/ "2877":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent(
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */,
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options =
    typeof scriptExports === 'function' ? scriptExports.options : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) {
    // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
          injectStyles.call(
            this,
            (options.functional ? this.parent : this).$root.$options.shadowRoot
          )
        }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "2907":
/***/ (function(module, exports) {

/*
Language: PHP
Author: Victor Karamzin <Victor.Karamzin@enterra-inc.com>
Contributors: Evgeny Stepanischev <imbolk@gmail.com>, Ivan Sagalaev <maniac@softwaremaniacs.org>
Website: https://www.php.net
Category: common
*/

/**
 * @param {HLJSApi} hljs
 * @returns {LanguageDetail}
 * */
function php(hljs) {
  const VARIABLE = {
    className: 'variable',
    begin: '\\$+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*' +
      // negative look-ahead tries to avoid matching patterns that are not
      // Perl at all like $ident$, @ident@, etc.
      `(?![A-Za-z0-9])(?![$])`
  };
  const PREPROCESSOR = {
    className: 'meta',
    variants: [
      { begin: /<\?php/, relevance: 10 }, // boost for obvious PHP
      { begin: /<\?[=]?/ },
      { begin: /\?>/ } // end php tag
    ]
  };
  const SUBST = {
    className: 'subst',
    variants: [
      { begin: /\$\w+/ },
      { begin: /\{\$/, end: /\}/ }
    ]
  };
  const SINGLE_QUOTED = hljs.inherit(hljs.APOS_STRING_MODE, {
    illegal: null,
  });
  const DOUBLE_QUOTED = hljs.inherit(hljs.QUOTE_STRING_MODE, {
    illegal: null,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
  });
  const HEREDOC = hljs.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*(\w+)\n/,
    end: /[ \t]*(\w+)\b/,
    contains: hljs.QUOTE_STRING_MODE.contains.concat(SUBST),
  });
  const STRING = {
    className: 'string',
    contains: [hljs.BACKSLASH_ESCAPE, PREPROCESSOR],
    variants: [
      hljs.inherit(SINGLE_QUOTED, {
        begin: "b'", end: "'",
      }),
      hljs.inherit(DOUBLE_QUOTED, {
        begin: 'b"', end: '"',
      }),
      DOUBLE_QUOTED,
      SINGLE_QUOTED,
      HEREDOC
    ]
  };
  const NUMBER = {
    className: 'number',
    variants: [
      { begin: `\\b0b[01]+(?:_[01]+)*\\b` }, // Binary w/ underscore support
      { begin: `\\b0o[0-7]+(?:_[0-7]+)*\\b` }, // Octals w/ underscore support
      { begin: `\\b0x[\\da-f]+(?:_[\\da-f]+)*\\b` }, // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: `(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:e[+-]?\\d+)?` }
    ],
    relevance: 0
  };
  const KEYWORDS = {
    keyword:
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    '__CLASS__ __DIR__ __FILE__ __FUNCTION__ __LINE__ __METHOD__ __NAMESPACE__ __TRAIT__ ' +
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    'die echo exit include include_once print require require_once ' +
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    'array abstract and as binary bool boolean break callable case catch class clone const continue declare ' +
    'default do double else elseif empty enddeclare endfor endforeach endif endswitch endwhile enum eval extends ' +
    'final finally float for foreach from global goto if implements instanceof insteadof int integer interface ' +
    'isset iterable list match|0 mixed new object or private protected public real return string switch throw trait ' +
    'try unset use var void while xor yield',
    literal: 'false null true',
    built_in:
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    'Error|0 ' + // error is too common a name esp since PHP is case in-sensitive
    'AppendIterator ArgumentCountError ArithmeticError ArrayIterator ArrayObject AssertionError BadFunctionCallException BadMethodCallException CachingIterator CallbackFilterIterator CompileError Countable DirectoryIterator DivisionByZeroError DomainException EmptyIterator ErrorException Exception FilesystemIterator FilterIterator GlobIterator InfiniteIterator InvalidArgumentException IteratorIterator LengthException LimitIterator LogicException MultipleIterator NoRewindIterator OutOfBoundsException OutOfRangeException OuterIterator OverflowException ParentIterator ParseError RangeException RecursiveArrayIterator RecursiveCachingIterator RecursiveCallbackFilterIterator RecursiveDirectoryIterator RecursiveFilterIterator RecursiveIterator RecursiveIteratorIterator RecursiveRegexIterator RecursiveTreeIterator RegexIterator RuntimeException SeekableIterator SplDoublyLinkedList SplFileInfo SplFileObject SplFixedArray SplHeap SplMaxHeap SplMinHeap SplObjectStorage SplObserver SplObserver SplPriorityQueue SplQueue SplStack SplSubject SplSubject SplTempFileObject TypeError UnderflowException UnexpectedValueException UnhandledMatchError ' +
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    'ArrayAccess Closure Generator Iterator IteratorAggregate Serializable Stringable Throwable Traversable WeakReference WeakMap ' +
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    'Directory __PHP_Incomplete_Class parent php_user_filter self static stdClass'
  };
  return {
    aliases: ['php3', 'php4', 'php5', 'php6', 'php7', 'php8'],
    case_insensitive: true,
    keywords: KEYWORDS,
    contains: [
      hljs.HASH_COMMENT_MODE,
      hljs.COMMENT('//', '$', {contains: [PREPROCESSOR]}),
      hljs.COMMENT(
        '/\\*',
        '\\*/',
        {
          contains: [
            {
              className: 'doctag',
              begin: '@[A-Za-z]+'
            }
          ]
        }
      ),
      hljs.COMMENT(
        '__halt_compiler.+?;',
        false,
        {
          endsWithParent: true,
          keywords: '__halt_compiler'
        }
      ),
      PREPROCESSOR,
      {
        className: 'keyword', begin: /\$this\b/
      },
      VARIABLE,
      {
        // swallow composed identifiers to avoid parsing them as keywords
        begin: /(::|->)+[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/
      },
      {
        className: 'function',
        relevance: 0,
        beginKeywords: 'fn function', end: /[;{]/, excludeEnd: true,
        illegal: '[$%\\[]',
        contains: [
          {
            beginKeywords: 'use',
          },
          hljs.UNDERSCORE_TITLE_MODE,
          {
            begin: '=>', // No markup, just a relevance booster
            endsParent: true
          },
          {
            className: 'params',
            begin: '\\(', end: '\\)',
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS,
            contains: [
              'self',
              VARIABLE,
              hljs.C_BLOCK_COMMENT_MODE,
              STRING,
              NUMBER
            ]
          }
        ]
      },
      {
        className: 'class',
        variants: [
          { beginKeywords: "enum", illegal: /[($"]/ },
          { beginKeywords: "class interface trait", illegal: /[:($"]/ }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: true,
        contains: [
          {beginKeywords: 'extends implements'},
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      {
        beginKeywords: 'namespace',
        relevance: 0,
        end: ';',
        illegal: /[.']/,
        contains: [hljs.UNDERSCORE_TITLE_MODE]
      },
      {
        beginKeywords: 'use',
        relevance: 0,
        end: ';',
        contains: [hljs.UNDERSCORE_TITLE_MODE]
      },
      STRING,
      NUMBER
    ]
  };
}

module.exports = php;


/***/ }),

/***/ "2909":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ _toConsumableArray; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
var arrayLikeToArray = __webpack_require__("6b75");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return Object(arrayLikeToArray["a" /* default */])(arr);
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__("a4d3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("e01a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __webpack_require__("d28b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__("e260");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.from.js
var es_array_from = __webpack_require__("a630");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js








function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
var unsupportedIterableToArray = __webpack_require__("06c5");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.error.cause.js
var es_error_cause = __webpack_require__("d9e2");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || Object(unsupportedIterableToArray["a" /* default */])(arr) || _nonIterableSpread();
}

/***/ }),

/***/ "2954":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var typedArraySpeciesConstructor = __webpack_require__("b6b7");
var fails = __webpack_require__("d039");
var arraySlice = __webpack_require__("f36a");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var FORCED = fails(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod('slice', function slice(start, end) {
  var list = arraySlice(aTypedArray(this), start, end);
  var C = typedArraySpeciesConstructor(this);
  var index = 0;
  var length = list.length;
  var result = new C(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);


/***/ }),

/***/ "2a1b":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("e065");

// `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');


/***/ }),

/***/ "2a62":
/***/ (function(module, exports, __webpack_require__) {

var call = __webpack_require__("c65b");
var anObject = __webpack_require__("825a");
var getMethod = __webpack_require__("dc4a");

module.exports = function (iterator, kind, value) {
  var innerResult, innerError;
  anObject(iterator);
  try {
    innerResult = getMethod(iterator, 'return');
    if (!innerResult) {
      if (kind === 'throw') throw value;
      return value;
    }
    innerResult = call(innerResult, iterator);
  } catch (error) {
    innerError = true;
    innerResult = error;
  }
  if (kind === 'throw') throw value;
  if (innerError) throw innerResult;
  anObject(innerResult);
  return value;
};


/***/ }),

/***/ "2b3d":
/***/ (function(module, exports, __webpack_require__) {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__("4002");


/***/ }),

/***/ "2b69":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  computed: {
    __refocusTargetEl: function __refocusTargetEl() {
      if (this.disable !== true) {
        return this.$createElement('span', {
          ref: 'refocusTarget',
          staticClass: 'no-outline',
          attrs: {
            tabindex: -1
          }
        });
      }
    }
  },
  methods: {
    __refocusTarget: function __refocusTarget(e) {
      if (e !== void 0 && e.type.indexOf('key') === 0) {
        if (document.activeElement !== this.$el && this.$el.contains(document.activeElement) === true) {
          this.$el.focus();
        }
      } else if ((e === void 0 || this.$el.contains(e.target) === true) && this.$refs.refocusTarget !== void 0) {
        this.$refs.refocusTarget.focus();
      }
    }
  }
});

/***/ }),

/***/ "2ba4":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__("40d5");

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ "2c3e":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var MISSED_STICKY = __webpack_require__("9f7f").MISSED_STICKY;
var classof = __webpack_require__("c6b6");
var defineBuiltInAccessor = __webpack_require__("edd0");
var getInternalState = __webpack_require__("69f3").get;

var RegExpPrototype = RegExp.prototype;
var $TypeError = TypeError;

// `RegExp.prototype.sticky` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.sticky
if (DESCRIPTORS && MISSED_STICKY) {
  defineBuiltInAccessor(RegExpPrototype, 'sticky', {
    configurable: true,
    get: function sticky() {
      if (this === RegExpPrototype) return;
      // We can't use InternalStateModule.getterFor because
      // we don't add metadata for regexps created by a literal.
      if (classof(this) === 'RegExp') {
        return !!getInternalState(this).sticky;
      }
      throw $TypeError('Incompatible receiver, RegExp required');
    }
  });
}


/***/ }),

/***/ "2ca0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("4625");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var toLength = __webpack_require__("50c4");
var toString = __webpack_require__("577e");
var notARegExp = __webpack_require__("5a34");
var requireObjectCoercible = __webpack_require__("1d80");
var correctIsRegExpLogic = __webpack_require__("ab13");
var IS_PURE = __webpack_require__("c430");

// eslint-disable-next-line es/no-string-prototype-startswith -- safe
var nativeStartsWith = uncurryThis(''.startsWith);
var stringSlice = uncurryThis(''.slice);
var min = Math.min;

var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith
$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = toString(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = toString(searchString);
    return nativeStartsWith
      ? nativeStartsWith(that, search, index)
      : stringSlice(that, index, index + search.length) === search;
  }
});


/***/ }),

/***/ "2caf":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ _createSuper; });

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.reflect.construct.js
var es_reflect_construct = __webpack_require__("4ae1");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.reflect.to-string-tag.js
var es_reflect_to_string_tag = __webpack_require__("f8c9");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__("7e84");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
var isNativeReflectConstruct = __webpack_require__("d967");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.error.cause.js
var es_error_cause = __webpack_require__("d9e2");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__("53ca");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js



function _possibleConstructorReturn(self, call) {
  if (call && (Object(esm_typeof["a" /* default */])(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js






function _createSuper(Derived) {
  var hasNativeReflectConstruct = Object(isNativeReflectConstruct["a" /* default */])();
  return function _createSuperInternal() {
    var Super = Object(getPrototypeOf["a" /* default */])(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = Object(getPrototypeOf["a" /* default */])(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

/***/ }),

/***/ "2cf4":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var apply = __webpack_require__("2ba4");
var bind = __webpack_require__("0366");
var isCallable = __webpack_require__("1626");
var hasOwn = __webpack_require__("1a2d");
var fails = __webpack_require__("d039");
var html = __webpack_require__("1be4");
var arraySlice = __webpack_require__("f36a");
var createElement = __webpack_require__("cc12");
var validateArgumentsLength = __webpack_require__("d6d6");
var IS_IOS = __webpack_require__("1cdc");
var IS_NODE = __webpack_require__("605d");

var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var Dispatch = global.Dispatch;
var Function = global.Function;
var MessageChannel = global.MessageChannel;
var String = global.String;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var $location, defer, channel, port;

fails(function () {
  // Deno throws a ReferenceError on `location` access without `--location` flag
  $location = global.location;
});

var run = function (id) {
  if (hasOwn(queue, id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var eventListener = function (event) {
  run(event.data);
};

var globalPostMessageDefer = function (id) {
  // old engines have not location.origin
  global.postMessage(String(id), $location.protocol + '//' + $location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(handler) {
    validateArgumentsLength(arguments.length, 1);
    var fn = isCallable(handler) ? handler : Function(handler);
    var args = arraySlice(arguments, 1);
    queue[++counter] = function () {
      apply(fn, undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = eventListener;
    defer = bind(port.postMessage, port);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    isCallable(global.postMessage) &&
    !global.importScripts &&
    $location && $location.protocol !== 'file:' &&
    !fails(globalPostMessageDefer)
  ) {
    defer = globalPostMessageDefer;
    global.addEventListener('message', eventListener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "2d00":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var userAgent = __webpack_require__("342f");

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "2f79":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return validatePosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return validateOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return parsePosition; });
/* unused harmony export getAnchorProps */
/* unused harmony export getTargetProps */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return setPosition; });
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("caad");
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("99af");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("cca6");
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _scroll_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("0831");
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("0967");






var vpLeft, vpTop;
function validatePosition(pos) {
  var parts = pos.split(' ');
  if (parts.length !== 2) {
    return false;
  }
  if (['top', 'center', 'bottom'].includes(parts[0]) !== true) {
    console.error('Anchor/Self position must start with one of top/center/bottom');
    return false;
  }
  if (['left', 'middle', 'right', 'start', 'end'].includes(parts[1]) !== true) {
    console.error('Anchor/Self position must end with one of left/middle/right/start/end');
    return false;
  }
  return true;
}
function validateOffset(val) {
  if (!val) {
    return true;
  }
  if (val.length !== 2) {
    return false;
  }
  if (typeof val[0] !== 'number' || typeof val[1] !== 'number') {
    return false;
  }
  return true;
}
var horizontalPos = {
  'start#ltr': 'left',
  'start#rtl': 'right',
  'end#ltr': 'right',
  'end#rtl': 'left'
};
['left', 'middle', 'right'].forEach(function (pos) {
  horizontalPos["".concat(pos, "#ltr")] = pos;
  horizontalPos["".concat(pos, "#rtl")] = pos;
});
function parsePosition(pos, rtl) {
  var parts = pos.split(' ');
  return {
    vertical: parts[0],
    horizontal: horizontalPos["".concat(parts[1], "#").concat(rtl === true ? 'rtl' : 'ltr')]
  };
}
function getAnchorProps(el, offset) {
  var _el$getBoundingClient = el.getBoundingClientRect(),
    top = _el$getBoundingClient.top,
    left = _el$getBoundingClient.left,
    right = _el$getBoundingClient.right,
    bottom = _el$getBoundingClient.bottom,
    width = _el$getBoundingClient.width,
    height = _el$getBoundingClient.height;
  if (offset !== void 0) {
    top -= offset[1];
    left -= offset[0];
    bottom += offset[1];
    right += offset[0];
    width += offset[0];
    height += offset[1];
  }
  return {
    top: top,
    bottom: bottom,
    height: height,
    left: left,
    right: right,
    width: width,
    middle: left + (right - left) / 2,
    center: top + (bottom - top) / 2
  };
}
function getAbsoluteAnchorProps(el, absoluteOffset, offset) {
  var _el$getBoundingClient2 = el.getBoundingClientRect(),
    top = _el$getBoundingClient2.top,
    left = _el$getBoundingClient2.left;
  top += absoluteOffset.top;
  left += absoluteOffset.left;
  if (offset !== void 0) {
    top += offset[1];
    left += offset[0];
  }
  return {
    top: top,
    bottom: top + 1,
    height: 1,
    left: left,
    right: left + 1,
    width: 1,
    middle: left,
    center: top
  };
}
function getTargetProps(el) {
  return {
    top: 0,
    center: el.offsetHeight / 2,
    bottom: el.offsetHeight,
    left: 0,
    middle: el.offsetWidth / 2,
    right: el.offsetWidth
  };
}
function getTopLeftProps(anchorProps, targetProps, cfg) {
  return {
    top: anchorProps[cfg.anchorOrigin.vertical] - targetProps[cfg.selfOrigin.vertical],
    left: anchorProps[cfg.anchorOrigin.horizontal] - targetProps[cfg.selfOrigin.horizontal]
  };
}

// cfg: { el, anchorEl, anchorOrigin, selfOrigin, offset, absoluteOffset, cover, fit, maxHeight, maxWidth }
function setPosition(cfg) {
  if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_5__[/* client */ "a"].is.ios === true && window.visualViewport !== void 0) {
    // uses the q-position-engine CSS class

    var el = document.body.style;
    var _window$visualViewpor = window.visualViewport,
      left = _window$visualViewpor.offsetLeft,
      top = _window$visualViewpor.offsetTop;
    if (left !== vpLeft) {
      el.setProperty('--q-pe-left', left + 'px');
      vpLeft = left;
    }
    if (top !== vpTop) {
      el.setProperty('--q-pe-top', top + 'px');
      vpTop = top;
    }
  }

  // scroll position might change
  // if max-height/-width changes, so we
  // need to restore it after we calculate
  // the new positioning
  var _cfg$el = cfg.el,
    scrollLeft = _cfg$el.scrollLeft,
    scrollTop = _cfg$el.scrollTop;
  var anchorProps = cfg.absoluteOffset === void 0 ? getAnchorProps(cfg.anchorEl, cfg.cover === true ? [0, 0] : cfg.offset) : getAbsoluteAnchorProps(cfg.anchorEl, cfg.absoluteOffset, cfg.offset);
  var elStyle = {
    maxHeight: cfg.maxHeight,
    maxWidth: cfg.maxWidth,
    visibility: 'visible'
  };
  if (cfg.fit === true || cfg.cover === true) {
    elStyle.minWidth = anchorProps.width + 'px';
    if (cfg.cover === true) {
      elStyle.minHeight = anchorProps.height + 'px';
    }
  }
  Object.assign(cfg.el.style, elStyle);
  var targetProps = getTargetProps(cfg.el);
  var props = getTopLeftProps(anchorProps, targetProps, cfg);
  if (cfg.absoluteOffset === void 0 || cfg.offset === void 0) {
    applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);
  } else {
    // we have touch position or context menu with offset
    var _props = props,
      _top = _props.top,
      _left = _props.left; // cache initial values

    // apply initial boundaries
    applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);
    var hasChanged = false;

    // did it flip vertically?
    if (props.top !== _top) {
      hasChanged = true;
      var offsetY = 2 * cfg.offset[1];
      anchorProps.center = anchorProps.top -= offsetY;
      anchorProps.bottom -= offsetY + 2;
    }

    // did it flip horizontally?
    if (props.left !== _left) {
      hasChanged = true;
      var offsetX = 2 * cfg.offset[0];
      anchorProps.middle = anchorProps.left -= offsetX;
      anchorProps.right -= offsetX + 2;
    }
    if (hasChanged === true) {
      // re-calculate props with the new anchor
      props = getTopLeftProps(anchorProps, targetProps, cfg);

      // and re-apply boundaries
      applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);
    }
  }
  elStyle = {
    top: props.top + 'px',
    left: props.left + 'px'
  };
  if (props.maxHeight !== void 0) {
    elStyle.maxHeight = props.maxHeight + 'px';
    if (anchorProps.height > props.maxHeight) {
      elStyle.minHeight = elStyle.maxHeight;
    }
  }
  if (props.maxWidth !== void 0) {
    elStyle.maxWidth = props.maxWidth + 'px';
    if (anchorProps.width > props.maxWidth) {
      elStyle.minWidth = elStyle.maxWidth;
    }
  }
  Object.assign(cfg.el.style, elStyle);

  // restore scroll position
  if (cfg.el.scrollTop !== scrollTop) {
    cfg.el.scrollTop = scrollTop;
  }
  if (cfg.el.scrollLeft !== scrollLeft) {
    cfg.el.scrollLeft = scrollLeft;
  }
}
function applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin) {
  var currentHeight = targetProps.bottom,
    currentWidth = targetProps.right,
    margin = Object(_scroll_js__WEBPACK_IMPORTED_MODULE_4__[/* getScrollbarWidth */ "d"])(),
    innerHeight = window.innerHeight - margin,
    innerWidth = document.body.clientWidth;
  if (props.top < 0 || props.top + currentHeight > innerHeight) {
    if (selfOrigin.vertical === 'center') {
      props.top = anchorProps[anchorOrigin.vertical] > innerHeight / 2 ? Math.max(0, innerHeight - currentHeight) : 0;
      props.maxHeight = Math.min(currentHeight, innerHeight);
    } else if (anchorProps[anchorOrigin.vertical] > innerHeight / 2) {
      var anchorY = Math.min(innerHeight, anchorOrigin.vertical === 'center' ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top);
      props.maxHeight = Math.min(currentHeight, anchorY);
      props.top = Math.max(0, anchorY - currentHeight);
    } else {
      props.top = Math.max(0, anchorOrigin.vertical === 'center' ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom);
      props.maxHeight = Math.min(currentHeight, innerHeight - props.top);
    }
  }
  if (props.left < 0 || props.left + currentWidth > innerWidth) {
    props.maxWidth = Math.min(currentWidth, innerWidth);
    if (selfOrigin.horizontal === 'middle') {
      props.left = anchorProps[anchorOrigin.horizontal] > innerWidth / 2 ? Math.max(0, innerWidth - currentWidth) : 0;
    } else if (anchorProps[anchorOrigin.horizontal] > innerWidth / 2) {
      var anchorX = Math.min(innerWidth, anchorOrigin.horizontal === 'middle' ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left);
      props.maxWidth = Math.min(currentWidth, anchorX);
      props.left = Math.max(0, anchorX - props.maxWidth);
    } else {
      props.left = Math.max(0, anchorOrigin.horizontal === 'middle' ? anchorProps.middle : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right);
      props.maxWidth = Math.min(currentWidth, innerWidth - props.left);
    }
  }
}

/***/ }),

/***/ "3280":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var apply = __webpack_require__("2ba4");
var $lastIndexOf = __webpack_require__("e58c");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  var length = arguments.length;
  return apply($lastIndexOf, aTypedArray(this), length > 1 ? [searchElement, arguments[1]] : [searchElement]);
});


/***/ }),

/***/ "32e7":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "332f":
/***/ (function(module, exports) {

// https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10
var decimalDigits = '[0-9](_*[0-9])*';
var frac = `\\.(${decimalDigits})`;
var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';
var NUMERIC = {
  className: 'number',
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))` +
      `[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${frac})[fFdD]?\\b` },
    { begin: `\\b(${decimalDigits})[fFdD]\\b` },

    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))` +
      `[pP][+-]?(${decimalDigits})[fFdD]?\\b` },

    // DecimalIntegerLiteral
    { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },

    // HexIntegerLiteral
    { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },

    // OctalIntegerLiteral
    { begin: '\\b0(_*[0-7])*[lL]?\\b' },

    // BinaryIntegerLiteral
    { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
  ],
  relevance: 0
};

/*
Language: Java
Author: Vsevolod Solovyov <vsevolod.solovyov@gmail.com>
Category: common, enterprise
Website: https://www.java.com/
*/

function java(hljs) {
  var JAVA_IDENT_RE = '[\u00C0-\u02B8a-zA-Z_$][\u00C0-\u02B8a-zA-Z_$0-9]*';
  var GENERIC_IDENT_RE = JAVA_IDENT_RE + '(<' + JAVA_IDENT_RE + '(\\s*,\\s*' + JAVA_IDENT_RE + ')*>)?';
  var KEYWORDS = 'false synchronized int abstract float private char boolean var static null if const ' +
    'for true while long strictfp finally protected import native final void ' +
    'enum else break transient catch instanceof byte super volatile case assert short ' +
    'package default double public try this switch continue throws protected public private ' +
    'module requires exports do';

  var ANNOTATION = {
    className: 'meta',
    begin: '@' + JAVA_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"] // allow nested () inside our annotation
      },
    ]
  };
  const NUMBER = NUMERIC;

  return {
    name: 'Java',
    aliases: ['jsp'],
    keywords: KEYWORDS,
    illegal: /<\/|#/,
    contains: [
      hljs.COMMENT(
        '/\\*\\*',
        '\\*/',
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/, relevance: 0
            },
            {
              className: 'doctag',
              begin: '@[A-Za-z]+'
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      {
        className: 'class',
        beginKeywords: 'class interface enum', end: /[{;=]/, excludeEnd: true,
        // TODO: can this be removed somehow?
        // an extra boost because Java is more popular than other languages with
        // this same syntax feature (this is just to preserve our tests passing
        // for now)
        relevance: 1,
        keywords: 'class interface enum',
        illegal: /[:"\[\]]/,
        contains: [
          { beginKeywords: 'extends implements' },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: 'new throw return else',
        relevance: 0
      },
      {
        className: 'class',
        begin: 'record\\s+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
        returnBegin: true,
        excludeEnd: true,
        end: /[{;=]/,
        keywords: KEYWORDS,
        contains: [
          { beginKeywords: "record" },
          {
            begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
            returnBegin: true,
            relevance: 0,
            contains: [hljs.UNDERSCORE_TITLE_MODE]
          },
          {
            className: 'params',
            begin: /\(/, end: /\)/,
            keywords: KEYWORDS,
            relevance: 0,
            contains: [
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: 'function',
        begin: '(' + GENERIC_IDENT_RE + '\\s+)+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true, end: /[{;=]/,
        excludeEnd: true,
        keywords: KEYWORDS,
        contains: [
          {
            begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true,
            relevance: 0,
            contains: [hljs.UNDERSCORE_TITLE_MODE]
          },
          {
            className: 'params',
            begin: /\(/, end: /\)/,
            keywords: KEYWORDS,
            relevance: 0,
            contains: [
              ANNOTATION,
              hljs.APOS_STRING_MODE,
              hljs.QUOTE_STRING_MODE,
              NUMBER,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      NUMBER,
      ANNOTATION
    ]
  };
}

module.exports = java;


/***/ }),

/***/ "33d1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");
var toIntegerOrInfinity = __webpack_require__("5926");
var addToUnscopables = __webpack_require__("44d2");

// `Array.prototype.at` method
// https://github.com/tc39/proposal-relative-indexing-method
$({ target: 'Array', proto: true }, {
  at: function at(index) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var relativeIndex = toIntegerOrInfinity(index);
    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return (k < 0 || k >= len) ? undefined : O[k];
  }
});

addToUnscopables('at');


/***/ }),

/***/ "3410":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var toObject = __webpack_require__("7b0b");
var nativeGetPrototypeOf = __webpack_require__("e163");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ "342f":
/***/ (function(module, exports) {

module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ "3511":
/***/ (function(module, exports) {

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ "3529":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var call = __webpack_require__("c65b");
var aCallable = __webpack_require__("59ed");
var newPromiseCapabilityModule = __webpack_require__("f069");
var perform = __webpack_require__("e667");
var iterate = __webpack_require__("2266");
var PROMISE_STATICS_INCORRECT_ITERATION = __webpack_require__("5eed");

// `Promise.race` method
// https://tc39.es/ecma262/#sec-promise.race
$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aCallable(C.resolve);
      iterate(iterable, function (promise) {
        call($promiseResolve, C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "35a1":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("f5df");
var getMethod = __webpack_require__("dc4a");
var isNullOrUndefined = __webpack_require__("7234");
var Iterators = __webpack_require__("3f8c");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR)
    || getMethod(it, '@@iterator')
    || Iterators[classof(it)];
};


/***/ }),

/***/ "37e8":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__("aed9");
var definePropertyModule = __webpack_require__("9bf2");
var anObject = __webpack_require__("825a");
var toIndexedObject = __webpack_require__("fc6a");
var objectKeys = __webpack_require__("df75");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ "3835":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ _slicedToArray; });

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__("a4d3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("e01a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __webpack_require__("d28b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__("e260");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js








function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s,
      _e,
      _x,
      _r,
      _arr = [],
      _n = !0,
      _d = !1;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
var unsupportedIterableToArray = __webpack_require__("06c5");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.error.cause.js
var es_error_cause = __webpack_require__("d9e2");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || Object(unsupportedIterableToArray["a" /* default */])(arr, i) || _nonIterableRest();
}

/***/ }),

/***/ "3a34":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var isArray = __webpack_require__("e8b5");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ "3a7b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $findIndex = __webpack_require__("b727").findIndex;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "3a9b":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "3bbe":
/***/ (function(module, exports, __webpack_require__) {

var isCallable = __webpack_require__("1626");

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ "3c5d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var ArrayBufferViewCore = __webpack_require__("ebb5");
var lengthOfArrayLike = __webpack_require__("07fa");
var toOffset = __webpack_require__("182d");
var toIndexedObject = __webpack_require__("7b0b");
var fails = __webpack_require__("d039");

var RangeError = global.RangeError;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var $set = Int8ArrayPrototype && Int8ArrayPrototype.set;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  var array = new Uint8ClampedArray(2);
  call($set, array, { length: 1, 0: 3 }, 1);
  return array[1] !== 3;
});

// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other
var TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {
  var array = new Int8Array(2);
  array.set(1);
  array.set('2', 1);
  return array[0] !== 0 || array[1] !== 2;
});

// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var src = toIndexedObject(arrayLike);
  if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS) return call($set, this, src, offset);
  var length = this.length;
  var len = lengthOfArrayLike(src);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);


/***/ }),

/***/ "3ca3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;
var toString = __webpack_require__("577e");
var InternalStateModule = __webpack_require__("69f3");
var defineIterator = __webpack_require__("c6d2");
var createIterResultObject = __webpack_require__("4754");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject(point, false);
});


/***/ }),

/***/ "3d69":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
var es_array_splice = __webpack_require__("a434");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.assign.js
var es_object_assign = __webpack_require__("cca6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/dom.js
var dom = __webpack_require__("f303");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("d882");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/key-composition.js
var key_composition = __webpack_require__("dc8a");

// EXTERNAL MODULE: ./node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("0967");

// CONCATENATED MODULE: ./node_modules/quasar/src/utils/throttle.js
/* harmony default export */ var throttle = (function (fn) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
  var wait = false,
    result;
  return function /* ...args */
  () {
    if (wait === false) {
      wait = true;
      setTimeout(function () {
        wait = false;
      }, limit);
      result = fn.apply(this, arguments);
    }
    return result;
  };
});
// EXTERNAL MODULE: ./node_modules/quasar/src/install.js + 4 modules
var install = __webpack_require__("81e7");

// CONCATENATED MODULE: ./node_modules/quasar/src/directives/Ripple.js












function showRipple(evt, el, ctx, forceCenter) {
  ctx.modifiers.stop === true && Object(utils_event["i" /* stop */])(evt);
  var color = ctx.modifiers.color;
  var center = ctx.modifiers.center;
  center = center === true || forceCenter === true;
  var node = document.createElement('span'),
    innerNode = document.createElement('span'),
    pos = Object(utils_event["g" /* position */])(evt),
    _el$getBoundingClient = el.getBoundingClientRect(),
    left = _el$getBoundingClient.left,
    top = _el$getBoundingClient.top,
    width = _el$getBoundingClient.width,
    height = _el$getBoundingClient.height,
    diameter = Math.sqrt(width * width + height * height),
    radius = diameter / 2,
    centerX = "".concat((width - diameter) / 2, "px"),
    x = center ? centerX : "".concat(pos.left - left - radius, "px"),
    centerY = "".concat((height - diameter) / 2, "px"),
    y = center ? centerY : "".concat(pos.top - top - radius, "px");
  innerNode.className = 'q-ripple__inner';
  Object(dom["b" /* css */])(innerNode, {
    height: "".concat(diameter, "px"),
    width: "".concat(diameter, "px"),
    transform: "translate3d(".concat(x, ",").concat(y, ",0) scale3d(.2,.2,1)"),
    opacity: 0
  });
  node.className = "q-ripple".concat(color ? ' text-' + color : '');
  node.setAttribute('dir', 'ltr');
  node.appendChild(innerNode);
  el.appendChild(node);
  var abort = function abort() {
    node.remove();
    clearTimeout(timer);
  };
  ctx.abort.push(abort);
  var timer = setTimeout(function () {
    innerNode.classList.add('q-ripple__inner--enter');
    innerNode.style.transform = "translate3d(".concat(centerX, ",").concat(centerY, ",0) scale3d(1,1,1)");
    innerNode.style.opacity = 0.2;
    timer = setTimeout(function () {
      innerNode.classList.remove('q-ripple__inner--enter');
      innerNode.classList.add('q-ripple__inner--leave');
      innerNode.style.opacity = 0;
      timer = setTimeout(function () {
        node.remove();
        ctx.abort.splice(ctx.abort.indexOf(abort), 1);
      }, 275);
    }, 250);
  }, 50);
}
function updateModifiers(ctx, _ref) {
  var modifiers = _ref.modifiers,
    value = _ref.value,
    arg = _ref.arg;
  var cfg = Object.assign({}, install["a" /* $q */].config.ripple, modifiers, value);
  ctx.modifiers = {
    early: cfg.early === true,
    stop: cfg.stop === true,
    center: cfg.center === true,
    color: cfg.color || arg,
    keyCodes: [].concat(cfg.keyCodes || 13)
  };
}
function destroy(el) {
  var ctx = el.__qripple;
  if (ctx !== void 0) {
    ctx.abort.forEach(function (fn) {
      fn();
    });
    Object(utils_event["b" /* cleanEvt */])(ctx, 'main');
    delete el._qripple;
  }
}
/* harmony default export */ var Ripple = ({
  name: 'ripple',
  inserted: function inserted(el, binding) {
    if (el.__qripple !== void 0) {
      destroy(el);
      el.__qripple_destroyed = true;
    }
    var ctx = {
      enabled: binding.value !== false,
      modifiers: {},
      abort: [],
      start: function start(evt) {
        if (ctx.enabled === true && evt.qSkipRipple !== true && (
        // on ENTER in form IE emits a PointerEvent with negative client cordinates
        Platform["a" /* client */].is.ie !== true || evt.clientX >= 0) && evt.type === (ctx.modifiers.early === true ? 'pointerdown' : 'click')) {
          showRipple(evt, el, ctx, evt.qKeyEvent === true);
        }
      },
      keystart: throttle(function (evt) {
        if (ctx.enabled === true && evt.qSkipRipple !== true && Object(key_composition["a" /* isKeyCode */])(evt, ctx.modifiers.keyCodes) === true && evt.type === "key".concat(ctx.modifiers.early === true ? 'down' : 'up')) {
          showRipple(evt, el, ctx, true);
        }
      }, 300)
    };
    updateModifiers(ctx, binding);
    el.__qripple = ctx;
    Object(utils_event["a" /* addEvt */])(ctx, 'main', [[el, 'pointerdown', 'start', 'passive'], [el, 'click', 'start', 'passive'], [el, 'keydown', 'keystart', 'passive'], [el, 'keyup', 'keystart', 'passive']]);
  },
  update: function update(el, binding) {
    var ctx = el.__qripple;
    if (ctx !== void 0 && binding.oldValue !== binding.value) {
      ctx.enabled = binding.value !== false;
      if (ctx.enabled === true && Object(binding.value) === binding.value) {
        updateModifiers(ctx, binding);
      }
    }
  },
  unbind: function unbind(el) {
    if (el.__qripple_destroyed === void 0) {
      destroy(el);
    } else {
      delete el.__qripple_destroyed;
    }
  }
});
// CONCATENATED MODULE: ./node_modules/quasar/src/mixins/ripple.js

/* harmony default export */ var ripple = __webpack_exports__["a"] = ({
  directives: {
    Ripple: Ripple
  },
  props: {
    ripple: {
      type: [Boolean, Object],
      default: true
    }
  }
});

/***/ }),

/***/ "3f8c":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "3fcc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $map = __webpack_require__("b727").map;
var typedArraySpeciesConstructor = __webpack_require__("b6b7");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.map` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (typedArraySpeciesConstructor(O))(length);
  });
});


/***/ }),

/***/ "4002":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__("3ca3");
var $ = __webpack_require__("23e7");
var DESCRIPTORS = __webpack_require__("83ab");
var USE_NATIVE_URL = __webpack_require__("f354");
var global = __webpack_require__("da84");
var bind = __webpack_require__("0366");
var uncurryThis = __webpack_require__("e330");
var defineBuiltIn = __webpack_require__("cb2d");
var defineBuiltInAccessor = __webpack_require__("edd0");
var anInstance = __webpack_require__("19aa");
var hasOwn = __webpack_require__("1a2d");
var assign = __webpack_require__("60da");
var arrayFrom = __webpack_require__("4df4");
var arraySlice = __webpack_require__("4dae");
var codeAt = __webpack_require__("6547").codeAt;
var toASCII = __webpack_require__("5fb2");
var $toString = __webpack_require__("577e");
var setToStringTag = __webpack_require__("d44e");
var validateArgumentsLength = __webpack_require__("d6d6");
var URLSearchParamsModule = __webpack_require__("5352");
var InternalStateModule = __webpack_require__("69f3");

var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;

var NativeURL = global.URL;
var TypeError = global.TypeError;
var parseInt = global.parseInt;
var floor = Math.floor;
var pow = Math.pow;
var charAt = uncurryThis(''.charAt);
var exec = uncurryThis(/./.exec);
var join = uncurryThis([].join);
var numberToString = uncurryThis(1.0.toString);
var pop = uncurryThis([].pop);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);
var toLowerCase = uncurryThis(''.toLowerCase);
var unshift = uncurryThis([].unshift);

var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';

var ALPHA = /[a-z]/i;
// eslint-disable-next-line regexp/no-obscure-range -- safe
var ALPHANUMERIC = /[\d+-.a-z]/i;
var DIGIT = /\d/;
var HEX_START = /^0x/i;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\da-f]+$/i;
/* eslint-disable regexp/no-control-character -- safe */
var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
var LEADING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+/;
var TRAILING_C0_CONTROL_OR_SPACE = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/;
var TAB_AND_NEW_LINE = /[\t\n\r]/g;
/* eslint-enable regexp/no-control-character -- safe */
var EOF;

// https://url.spec.whatwg.org/#ipv4-number-parser
var parseIPv4 = function (input) {
  var parts = split(input, '.');
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] == '') {
    parts.length--;
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part == '') return input;
    radix = 10;
    if (part.length > 1 && charAt(part, 0) == '0') {
      radix = exec(HEX_START, part) ? 16 : 8;
      part = stringSlice(part, radix == 8 ? 1 : 2);
    }
    if (part === '') {
      number = 0;
    } else {
      if (!exec(radix == 10 ? DEC : radix == 8 ? OCT : HEX, part)) return input;
      number = parseInt(part, radix);
    }
    push(numbers, number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index == partsLength - 1) {
      if (number >= pow(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }
  ipv4 = pop(numbers);
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};

// https://url.spec.whatwg.org/#concept-ipv6-parser
// eslint-disable-next-line max-statements -- TODO
var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var chr = function () {
    return charAt(input, pointer);
  };

  if (chr() == ':') {
    if (charAt(input, 1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (chr()) {
    if (pieceIndex == 8) return;
    if (chr() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && exec(HEX, chr())) {
      value = value * 16 + parseInt(chr(), 16);
      pointer++;
      length++;
    }
    if (chr() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (chr()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (chr() == '.' && numbersSeen < 4) pointer++;
          else return;
        }
        if (!exec(DIGIT, chr())) return;
        while (exec(DIGIT, chr())) {
          number = parseInt(chr(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece == 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }
      if (numbersSeen != 4) return;
      break;
    } else if (chr() == ':') {
      pointer++;
      if (!chr()) return;
    } else if (chr()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;
  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }
  return maxIndex;
};

// https://url.spec.whatwg.org/#host-serializing
var serializeHost = function (host) {
  var result, index, compress, ignore0;
  // ipv4
  if (typeof host == 'number') {
    result = [];
    for (index = 0; index < 4; index++) {
      unshift(result, host % 256);
      host = floor(host / 256);
    } return join(result, '.');
  // ipv6
  } else if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? ':' : '::';
        ignore0 = true;
      } else {
        result += numberToString(host[index], 16);
        if (index < 7) result += ':';
      }
    }
    return '[' + result + ']';
  } return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  '#': 1, '?': 1, '{': 1, '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
});

var percentEncode = function (chr, set) {
  var code = codeAt(chr, 0);
  return code > 0x20 && code < 0x7F && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
};

// https://url.spec.whatwg.org/#special-scheme
var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

// https://url.spec.whatwg.org/#windows-drive-letter
var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length == 2 && exec(ALPHA, charAt(string, 0))
    && ((second = charAt(string, 1)) == ':' || (!normalized && second == '|'));
};

// https://url.spec.whatwg.org/#start-with-a-windows-drive-letter
var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(stringSlice(string, 0, 2)) && (
    string.length == 2 ||
    ((third = charAt(string, 2)) === '/' || third === '\\' || third === '?' || third === '#')
  );
};

// https://url.spec.whatwg.org/#single-dot-path-segment
var isSingleDot = function (segment) {
  return segment === '.' || toLowerCase(segment) === '%2e';
};

// https://url.spec.whatwg.org/#double-dot-path-segment
var isDoubleDot = function (segment) {
  segment = toLowerCase(segment);
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

var URLState = function (url, isBase, base) {
  var urlString = $toString(url);
  var baseState, failure, searchParams;
  if (isBase) {
    failure = this.parse(urlString);
    if (failure) throw TypeError(failure);
    this.searchParams = null;
  } else {
    if (base !== undefined) baseState = new URLState(base, true);
    failure = this.parse(urlString, null, baseState);
    if (failure) throw TypeError(failure);
    searchParams = getInternalSearchParamsState(new URLSearchParams());
    searchParams.bindURL(this);
    this.searchParams = searchParams;
  }
};

URLState.prototype = {
  type: 'URL',
  // https://url.spec.whatwg.org/#url-parsing
  // eslint-disable-next-line max-statements -- TODO
  parse: function (input, stateOverride, base) {
    var url = this;
    var state = stateOverride || SCHEME_START;
    var pointer = 0;
    var buffer = '';
    var seenAt = false;
    var seenBracket = false;
    var seenPasswordToken = false;
    var codePoints, chr, bufferCodePoints, failure;

    input = $toString(input);

    if (!stateOverride) {
      url.scheme = '';
      url.username = '';
      url.password = '';
      url.host = null;
      url.port = null;
      url.path = [];
      url.query = null;
      url.fragment = null;
      url.cannotBeABaseURL = false;
      input = replace(input, LEADING_C0_CONTROL_OR_SPACE, '');
      input = replace(input, TRAILING_C0_CONTROL_OR_SPACE, '$1');
    }

    input = replace(input, TAB_AND_NEW_LINE, '');

    codePoints = arrayFrom(input);

    while (pointer <= codePoints.length) {
      chr = codePoints[pointer];
      switch (state) {
        case SCHEME_START:
          if (chr && exec(ALPHA, chr)) {
            buffer += toLowerCase(chr);
            state = SCHEME;
          } else if (!stateOverride) {
            state = NO_SCHEME;
            continue;
          } else return INVALID_SCHEME;
          break;

        case SCHEME:
          if (chr && (exec(ALPHANUMERIC, chr) || chr == '+' || chr == '-' || chr == '.')) {
            buffer += toLowerCase(chr);
          } else if (chr == ':') {
            if (stateOverride && (
              (url.isSpecial() != hasOwn(specialSchemes, buffer)) ||
              (buffer == 'file' && (url.includesCredentials() || url.port !== null)) ||
              (url.scheme == 'file' && !url.host)
            )) return;
            url.scheme = buffer;
            if (stateOverride) {
              if (url.isSpecial() && specialSchemes[url.scheme] == url.port) url.port = null;
              return;
            }
            buffer = '';
            if (url.scheme == 'file') {
              state = FILE;
            } else if (url.isSpecial() && base && base.scheme == url.scheme) {
              state = SPECIAL_RELATIVE_OR_AUTHORITY;
            } else if (url.isSpecial()) {
              state = SPECIAL_AUTHORITY_SLASHES;
            } else if (codePoints[pointer + 1] == '/') {
              state = PATH_OR_AUTHORITY;
              pointer++;
            } else {
              url.cannotBeABaseURL = true;
              push(url.path, '');
              state = CANNOT_BE_A_BASE_URL_PATH;
            }
          } else if (!stateOverride) {
            buffer = '';
            state = NO_SCHEME;
            pointer = 0;
            continue;
          } else return INVALID_SCHEME;
          break;

        case NO_SCHEME:
          if (!base || (base.cannotBeABaseURL && chr != '#')) return INVALID_SCHEME;
          if (base.cannotBeABaseURL && chr == '#') {
            url.scheme = base.scheme;
            url.path = arraySlice(base.path);
            url.query = base.query;
            url.fragment = '';
            url.cannotBeABaseURL = true;
            state = FRAGMENT;
            break;
          }
          state = base.scheme == 'file' ? FILE : RELATIVE;
          continue;

        case SPECIAL_RELATIVE_OR_AUTHORITY:
          if (chr == '/' && codePoints[pointer + 1] == '/') {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
            pointer++;
          } else {
            state = RELATIVE;
            continue;
          } break;

        case PATH_OR_AUTHORITY:
          if (chr == '/') {
            state = AUTHORITY;
            break;
          } else {
            state = PATH;
            continue;
          }

        case RELATIVE:
          url.scheme = base.scheme;
          if (chr == EOF) {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = base.query;
          } else if (chr == '/' || (chr == '\\' && url.isSpecial())) {
            state = RELATIVE_SLASH;
          } else if (chr == '?') {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = '';
            state = QUERY;
          } else if (chr == '#') {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            url.path = arraySlice(base.path);
            url.path.length--;
            state = PATH;
            continue;
          } break;

        case RELATIVE_SLASH:
          if (url.isSpecial() && (chr == '/' || chr == '\\')) {
            state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          } else if (chr == '/') {
            state = AUTHORITY;
          } else {
            url.username = base.username;
            url.password = base.password;
            url.host = base.host;
            url.port = base.port;
            state = PATH;
            continue;
          } break;

        case SPECIAL_AUTHORITY_SLASHES:
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          if (chr != '/' || charAt(buffer, pointer + 1) != '/') continue;
          pointer++;
          break;

        case SPECIAL_AUTHORITY_IGNORE_SLASHES:
          if (chr != '/' && chr != '\\') {
            state = AUTHORITY;
            continue;
          } break;

        case AUTHORITY:
          if (chr == '@') {
            if (seenAt) buffer = '%40' + buffer;
            seenAt = true;
            bufferCodePoints = arrayFrom(buffer);
            for (var i = 0; i < bufferCodePoints.length; i++) {
              var codePoint = bufferCodePoints[i];
              if (codePoint == ':' && !seenPasswordToken) {
                seenPasswordToken = true;
                continue;
              }
              var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
              if (seenPasswordToken) url.password += encodedCodePoints;
              else url.username += encodedCodePoints;
            }
            buffer = '';
          } else if (
            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
            (chr == '\\' && url.isSpecial())
          ) {
            if (seenAt && buffer == '') return INVALID_AUTHORITY;
            pointer -= arrayFrom(buffer).length + 1;
            buffer = '';
            state = HOST;
          } else buffer += chr;
          break;

        case HOST:
        case HOSTNAME:
          if (stateOverride && url.scheme == 'file') {
            state = FILE_HOST;
            continue;
          } else if (chr == ':' && !seenBracket) {
            if (buffer == '') return INVALID_HOST;
            failure = url.parseHost(buffer);
            if (failure) return failure;
            buffer = '';
            state = PORT;
            if (stateOverride == HOSTNAME) return;
          } else if (
            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
            (chr == '\\' && url.isSpecial())
          ) {
            if (url.isSpecial() && buffer == '') return INVALID_HOST;
            if (stateOverride && buffer == '' && (url.includesCredentials() || url.port !== null)) return;
            failure = url.parseHost(buffer);
            if (failure) return failure;
            buffer = '';
            state = PATH_START;
            if (stateOverride) return;
            continue;
          } else {
            if (chr == '[') seenBracket = true;
            else if (chr == ']') seenBracket = false;
            buffer += chr;
          } break;

        case PORT:
          if (exec(DIGIT, chr)) {
            buffer += chr;
          } else if (
            chr == EOF || chr == '/' || chr == '?' || chr == '#' ||
            (chr == '\\' && url.isSpecial()) ||
            stateOverride
          ) {
            if (buffer != '') {
              var port = parseInt(buffer, 10);
              if (port > 0xFFFF) return INVALID_PORT;
              url.port = (url.isSpecial() && port === specialSchemes[url.scheme]) ? null : port;
              buffer = '';
            }
            if (stateOverride) return;
            state = PATH_START;
            continue;
          } else return INVALID_PORT;
          break;

        case FILE:
          url.scheme = 'file';
          if (chr == '/' || chr == '\\') state = FILE_SLASH;
          else if (base && base.scheme == 'file') {
            if (chr == EOF) {
              url.host = base.host;
              url.path = arraySlice(base.path);
              url.query = base.query;
            } else if (chr == '?') {
              url.host = base.host;
              url.path = arraySlice(base.path);
              url.query = '';
              state = QUERY;
            } else if (chr == '#') {
              url.host = base.host;
              url.path = arraySlice(base.path);
              url.query = base.query;
              url.fragment = '';
              state = FRAGMENT;
            } else {
              if (!startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
                url.host = base.host;
                url.path = arraySlice(base.path);
                url.shortenPath();
              }
              state = PATH;
              continue;
            }
          } else {
            state = PATH;
            continue;
          } break;

        case FILE_SLASH:
          if (chr == '/' || chr == '\\') {
            state = FILE_HOST;
            break;
          }
          if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(join(arraySlice(codePoints, pointer), ''))) {
            if (isWindowsDriveLetter(base.path[0], true)) push(url.path, base.path[0]);
            else url.host = base.host;
          }
          state = PATH;
          continue;

        case FILE_HOST:
          if (chr == EOF || chr == '/' || chr == '\\' || chr == '?' || chr == '#') {
            if (!stateOverride && isWindowsDriveLetter(buffer)) {
              state = PATH;
            } else if (buffer == '') {
              url.host = '';
              if (stateOverride) return;
              state = PATH_START;
            } else {
              failure = url.parseHost(buffer);
              if (failure) return failure;
              if (url.host == 'localhost') url.host = '';
              if (stateOverride) return;
              buffer = '';
              state = PATH_START;
            } continue;
          } else buffer += chr;
          break;

        case PATH_START:
          if (url.isSpecial()) {
            state = PATH;
            if (chr != '/' && chr != '\\') continue;
          } else if (!stateOverride && chr == '?') {
            url.query = '';
            state = QUERY;
          } else if (!stateOverride && chr == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr != EOF) {
            state = PATH;
            if (chr != '/') continue;
          } break;

        case PATH:
          if (
            chr == EOF || chr == '/' ||
            (chr == '\\' && url.isSpecial()) ||
            (!stateOverride && (chr == '?' || chr == '#'))
          ) {
            if (isDoubleDot(buffer)) {
              url.shortenPath();
              if (chr != '/' && !(chr == '\\' && url.isSpecial())) {
                push(url.path, '');
              }
            } else if (isSingleDot(buffer)) {
              if (chr != '/' && !(chr == '\\' && url.isSpecial())) {
                push(url.path, '');
              }
            } else {
              if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
                if (url.host) url.host = '';
                buffer = charAt(buffer, 0) + ':'; // normalize windows drive letter
              }
              push(url.path, buffer);
            }
            buffer = '';
            if (url.scheme == 'file' && (chr == EOF || chr == '?' || chr == '#')) {
              while (url.path.length > 1 && url.path[0] === '') {
                shift(url.path);
              }
            }
            if (chr == '?') {
              url.query = '';
              state = QUERY;
            } else if (chr == '#') {
              url.fragment = '';
              state = FRAGMENT;
            }
          } else {
            buffer += percentEncode(chr, pathPercentEncodeSet);
          } break;

        case CANNOT_BE_A_BASE_URL_PATH:
          if (chr == '?') {
            url.query = '';
            state = QUERY;
          } else if (chr == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr != EOF) {
            url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
          } break;

        case QUERY:
          if (!stateOverride && chr == '#') {
            url.fragment = '';
            state = FRAGMENT;
          } else if (chr != EOF) {
            if (chr == "'" && url.isSpecial()) url.query += '%27';
            else if (chr == '#') url.query += '%23';
            else url.query += percentEncode(chr, C0ControlPercentEncodeSet);
          } break;

        case FRAGMENT:
          if (chr != EOF) url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
          break;
      }

      pointer++;
    }
  },
  // https://url.spec.whatwg.org/#host-parsing
  parseHost: function (input) {
    var result, codePoints, index;
    if (charAt(input, 0) == '[') {
      if (charAt(input, input.length - 1) != ']') return INVALID_HOST;
      result = parseIPv6(stringSlice(input, 1, -1));
      if (!result) return INVALID_HOST;
      this.host = result;
    // opaque host
    } else if (!this.isSpecial()) {
      if (exec(FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT, input)) return INVALID_HOST;
      result = '';
      codePoints = arrayFrom(input);
      for (index = 0; index < codePoints.length; index++) {
        result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
      }
      this.host = result;
    } else {
      input = toASCII(input);
      if (exec(FORBIDDEN_HOST_CODE_POINT, input)) return INVALID_HOST;
      result = parseIPv4(input);
      if (result === null) return INVALID_HOST;
      this.host = result;
    }
  },
  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port
  cannotHaveUsernamePasswordPort: function () {
    return !this.host || this.cannotBeABaseURL || this.scheme == 'file';
  },
  // https://url.spec.whatwg.org/#include-credentials
  includesCredentials: function () {
    return this.username != '' || this.password != '';
  },
  // https://url.spec.whatwg.org/#is-special
  isSpecial: function () {
    return hasOwn(specialSchemes, this.scheme);
  },
  // https://url.spec.whatwg.org/#shorten-a-urls-path
  shortenPath: function () {
    var path = this.path;
    var pathSize = path.length;
    if (pathSize && (this.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
      path.length--;
    }
  },
  // https://url.spec.whatwg.org/#concept-url-serializer
  serialize: function () {
    var url = this;
    var scheme = url.scheme;
    var username = url.username;
    var password = url.password;
    var host = url.host;
    var port = url.port;
    var path = url.path;
    var query = url.query;
    var fragment = url.fragment;
    var output = scheme + ':';
    if (host !== null) {
      output += '//';
      if (url.includesCredentials()) {
        output += username + (password ? ':' + password : '') + '@';
      }
      output += serializeHost(host);
      if (port !== null) output += ':' + port;
    } else if (scheme == 'file') output += '//';
    output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
    if (query !== null) output += '?' + query;
    if (fragment !== null) output += '#' + fragment;
    return output;
  },
  // https://url.spec.whatwg.org/#dom-url-href
  setHref: function (href) {
    var failure = this.parse(href);
    if (failure) throw TypeError(failure);
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-origin
  getOrigin: function () {
    var scheme = this.scheme;
    var port = this.port;
    if (scheme == 'blob') try {
      return new URLConstructor(scheme.path[0]).origin;
    } catch (error) {
      return 'null';
    }
    if (scheme == 'file' || !this.isSpecial()) return 'null';
    return scheme + '://' + serializeHost(this.host) + (port !== null ? ':' + port : '');
  },
  // https://url.spec.whatwg.org/#dom-url-protocol
  getProtocol: function () {
    return this.scheme + ':';
  },
  setProtocol: function (protocol) {
    this.parse($toString(protocol) + ':', SCHEME_START);
  },
  // https://url.spec.whatwg.org/#dom-url-username
  getUsername: function () {
    return this.username;
  },
  setUsername: function (username) {
    var codePoints = arrayFrom($toString(username));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.username = '';
    for (var i = 0; i < codePoints.length; i++) {
      this.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-password
  getPassword: function () {
    return this.password;
  },
  setPassword: function (password) {
    var codePoints = arrayFrom($toString(password));
    if (this.cannotHaveUsernamePasswordPort()) return;
    this.password = '';
    for (var i = 0; i < codePoints.length; i++) {
      this.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
    }
  },
  // https://url.spec.whatwg.org/#dom-url-host
  getHost: function () {
    var host = this.host;
    var port = this.port;
    return host === null ? ''
      : port === null ? serializeHost(host)
      : serializeHost(host) + ':' + port;
  },
  setHost: function (host) {
    if (this.cannotBeABaseURL) return;
    this.parse(host, HOST);
  },
  // https://url.spec.whatwg.org/#dom-url-hostname
  getHostname: function () {
    var host = this.host;
    return host === null ? '' : serializeHost(host);
  },
  setHostname: function (hostname) {
    if (this.cannotBeABaseURL) return;
    this.parse(hostname, HOSTNAME);
  },
  // https://url.spec.whatwg.org/#dom-url-port
  getPort: function () {
    var port = this.port;
    return port === null ? '' : $toString(port);
  },
  setPort: function (port) {
    if (this.cannotHaveUsernamePasswordPort()) return;
    port = $toString(port);
    if (port == '') this.port = null;
    else this.parse(port, PORT);
  },
  // https://url.spec.whatwg.org/#dom-url-pathname
  getPathname: function () {
    var path = this.path;
    return this.cannotBeABaseURL ? path[0] : path.length ? '/' + join(path, '/') : '';
  },
  setPathname: function (pathname) {
    if (this.cannotBeABaseURL) return;
    this.path = [];
    this.parse(pathname, PATH_START);
  },
  // https://url.spec.whatwg.org/#dom-url-search
  getSearch: function () {
    var query = this.query;
    return query ? '?' + query : '';
  },
  setSearch: function (search) {
    search = $toString(search);
    if (search == '') {
      this.query = null;
    } else {
      if ('?' == charAt(search, 0)) search = stringSlice(search, 1);
      this.query = '';
      this.parse(search, QUERY);
    }
    this.searchParams.update();
  },
  // https://url.spec.whatwg.org/#dom-url-searchparams
  getSearchParams: function () {
    return this.searchParams.facade;
  },
  // https://url.spec.whatwg.org/#dom-url-hash
  getHash: function () {
    var fragment = this.fragment;
    return fragment ? '#' + fragment : '';
  },
  setHash: function (hash) {
    hash = $toString(hash);
    if (hash == '') {
      this.fragment = null;
      return;
    }
    if ('#' == charAt(hash, 0)) hash = stringSlice(hash, 1);
    this.fragment = '';
    this.parse(hash, FRAGMENT);
  },
  update: function () {
    this.query = this.searchParams.serialize() || null;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLPrototype);
  var base = validateArgumentsLength(arguments.length, 1) > 1 ? arguments[1] : undefined;
  var state = setInternalState(that, new URLState(url, false, base));
  if (!DESCRIPTORS) {
    that.href = state.serialize();
    that.origin = state.getOrigin();
    that.protocol = state.getProtocol();
    that.username = state.getUsername();
    that.password = state.getPassword();
    that.host = state.getHost();
    that.hostname = state.getHostname();
    that.port = state.getPort();
    that.pathname = state.getPathname();
    that.search = state.getSearch();
    that.searchParams = state.getSearchParams();
    that.hash = state.getHash();
  }
};

var URLPrototype = URLConstructor.prototype;

var accessorDescriptor = function (getter, setter) {
  return {
    get: function () {
      return getInternalURLState(this)[getter]();
    },
    set: setter && function (value) {
      return getInternalURLState(this)[setter](value);
    },
    configurable: true,
    enumerable: true
  };
};

if (DESCRIPTORS) {
  // `URL.prototype.href` accessors pair
  // https://url.spec.whatwg.org/#dom-url-href
  defineBuiltInAccessor(URLPrototype, 'href', accessorDescriptor('serialize', 'setHref'));
  // `URL.prototype.origin` getter
  // https://url.spec.whatwg.org/#dom-url-origin
  defineBuiltInAccessor(URLPrototype, 'origin', accessorDescriptor('getOrigin'));
  // `URL.prototype.protocol` accessors pair
  // https://url.spec.whatwg.org/#dom-url-protocol
  defineBuiltInAccessor(URLPrototype, 'protocol', accessorDescriptor('getProtocol', 'setProtocol'));
  // `URL.prototype.username` accessors pair
  // https://url.spec.whatwg.org/#dom-url-username
  defineBuiltInAccessor(URLPrototype, 'username', accessorDescriptor('getUsername', 'setUsername'));
  // `URL.prototype.password` accessors pair
  // https://url.spec.whatwg.org/#dom-url-password
  defineBuiltInAccessor(URLPrototype, 'password', accessorDescriptor('getPassword', 'setPassword'));
  // `URL.prototype.host` accessors pair
  // https://url.spec.whatwg.org/#dom-url-host
  defineBuiltInAccessor(URLPrototype, 'host', accessorDescriptor('getHost', 'setHost'));
  // `URL.prototype.hostname` accessors pair
  // https://url.spec.whatwg.org/#dom-url-hostname
  defineBuiltInAccessor(URLPrototype, 'hostname', accessorDescriptor('getHostname', 'setHostname'));
  // `URL.prototype.port` accessors pair
  // https://url.spec.whatwg.org/#dom-url-port
  defineBuiltInAccessor(URLPrototype, 'port', accessorDescriptor('getPort', 'setPort'));
  // `URL.prototype.pathname` accessors pair
  // https://url.spec.whatwg.org/#dom-url-pathname
  defineBuiltInAccessor(URLPrototype, 'pathname', accessorDescriptor('getPathname', 'setPathname'));
  // `URL.prototype.search` accessors pair
  // https://url.spec.whatwg.org/#dom-url-search
  defineBuiltInAccessor(URLPrototype, 'search', accessorDescriptor('getSearch', 'setSearch'));
  // `URL.prototype.searchParams` getter
  // https://url.spec.whatwg.org/#dom-url-searchparams
  defineBuiltInAccessor(URLPrototype, 'searchParams', accessorDescriptor('getSearchParams'));
  // `URL.prototype.hash` accessors pair
  // https://url.spec.whatwg.org/#dom-url-hash
  defineBuiltInAccessor(URLPrototype, 'hash', accessorDescriptor('getHash', 'setHash'));
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
defineBuiltIn(URLPrototype, 'toJSON', function toJSON() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
defineBuiltIn(URLPrototype, 'toString', function toString() {
  return getInternalURLState(this).serialize();
}, { enumerable: true });

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  if (nativeCreateObjectURL) defineBuiltIn(URLConstructor, 'createObjectURL', bind(nativeCreateObjectURL, NativeURL));
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  if (nativeRevokeObjectURL) defineBuiltIn(URLConstructor, 'revokeObjectURL', bind(nativeRevokeObjectURL, NativeURL));
}

setToStringTag(URLConstructor, 'URL');

$({ global: true, constructor: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
  URL: URLConstructor
});


/***/ }),

/***/ "4069":
/***/ (function(module, exports, __webpack_require__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__("44d2");

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flat');


/***/ }),

/***/ "4074":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5530");
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("ade3");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("87e8");
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("e277");





/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_2___default.a.extend({
  name: 'QItemSection',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]],
  props: {
    avatar: Boolean,
    thumbnail: Boolean,
    side: Boolean,
    top: Boolean,
    noWrap: Boolean
  },
  computed: {
    classes: function classes() {
      var side = this.avatar || this.side || this.thumbnail;
      return Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({
        'q-item__section--top': this.top,
        'q-item__section--avatar': this.avatar,
        'q-item__section--thumbnail': this.thumbnail,
        'q-item__section--side': side,
        'q-item__section--nowrap': this.noWrap,
        'q-item__section--main': !side
      }, "justify-".concat(this.top ? 'start' : 'center'), true);
    }
  },
  render: function render(h) {
    return h('div', {
      staticClass: 'q-item__section column',
      class: this.classes,
      on: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.qListeners)
    }, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_4__[/* slot */ "c"])(this, 'default'));
  }
}));

/***/ }),

/***/ "408a":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = uncurryThis(1.0.valueOf);


/***/ }),

/***/ "40d5":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ "428f":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = global;


/***/ }),

/***/ "4362":
/***/ (function(module, exports, __webpack_require__) {

exports.nextTick = function nextTick(fn) {
    var args = Array.prototype.slice.call(arguments);
    args.shift();
    setTimeout(function () {
        fn.apply(null, args);
    }, 0);
};

exports.platform = exports.arch = 
exports.execPath = exports.title = 'browser';
exports.pid = 1;
exports.browser = true;
exports.env = {};
exports.argv = [];

exports.binding = function (name) {
	throw new Error('No such module. (Possibly not yet loaded)')
};

(function () {
    var cwd = '/';
    var path;
    exports.cwd = function () { return cwd };
    exports.chdir = function (dir) {
        if (!path) path = __webpack_require__("df7c");
        cwd = path.resolve(dir, cwd);
    };
})();

exports.exit = exports.kill = 
exports.umask = exports.dlopen = 
exports.uptime = exports.memoryUsage = 
exports.uvCounters = function() {};
exports.features = {};


/***/ }),

/***/ "44ad":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var fails = __webpack_require__("d039");
var classof = __webpack_require__("c6b6");

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ "44d2":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var create = __webpack_require__("7c73");
var defineProperty = __webpack_require__("9bf2").f;

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "44de":
/***/ (function(module, exports) {

module.exports = function (a, b) {
  try {
    // eslint-disable-next-line no-console -- safe
    arguments.length == 1 ? console.error(a) : console.error(a, b);
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "44e7":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var classof = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ "4625":
/***/ (function(module, exports, __webpack_require__) {

var classofRaw = __webpack_require__("c6b6");
var uncurryThis = __webpack_require__("e330");

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ "463c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("159b");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("14d9");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_2__);



/* harmony default export */ __webpack_exports__["a"] = ({
  created: function created() {
    this.__tickFnList = [];
    this.__timeoutFnList = [];
  },
  deactivated: function deactivated() {
    this.__tickFnList.forEach(function (tick) {
      tick.removeTick();
    });
    this.__timeoutFnList.forEach(function (tick) {
      tick.removeTimeout();
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.__tickFnList.forEach(function (tick) {
      tick.removeTick();
    });
    this.__tickFnList = void 0;
    this.__timeoutFnList.forEach(function (tick) {
      tick.removeTimeout();
    });
    this.__timeoutFnList = void 0;
  },
  methods: {
    __useTick: function __useTick(registerFnName, removeFnName) {
      var _this = this;
      var tick = {
        removeTick: function removeTick() {
          tick.fn = void 0;
        },
        registerTick: function registerTick(fn) {
          tick.fn = fn;
          _this.$nextTick(function () {
            if (tick.fn === fn) {
              // we also check if VM is destroyed, since if it
              // got to trigger one nextTick() we cannot stop it
              _this._isDestroyed === false && tick.fn();
              tick.fn = void 0;
            }
          });
        }
      };
      this.__tickFnList.push(tick);
      this[registerFnName] = tick.registerTick;
      removeFnName !== void 0 && (this[removeFnName] = tick.removeTick);
    },
    __useTimeout: function __useTimeout(registerFnName, removeFnName) {
      var _this2 = this;
      var timeout = {
        removeTimeout: function removeTimeout() {
          clearTimeout(timeout.timer);
        },
        registerTimeout: function registerTimeout(fn, delay) {
          clearTimeout(timeout.timer);
          if (_this2._isDestroyed === false) {
            timeout.timer = setTimeout(fn, delay);
          }
        }
      };
      this.__timeoutFnList.push(timeout);
      this[registerFnName] = timeout.registerTimeout;
      removeFnName !== void 0 && (this[removeFnName] = timeout.removeTimeout);
    }
  }
});

/***/ }),

/***/ "466d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var call = __webpack_require__("c65b");
var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var anObject = __webpack_require__("825a");
var isNullOrUndefined = __webpack_require__("7234");
var toLength = __webpack_require__("50c4");
var toString = __webpack_require__("577e");
var requireObjectCoercible = __webpack_require__("1d80");
var getMethod = __webpack_require__("dc4a");
var advanceStringIndex = __webpack_require__("8aa5");
var regExpExec = __webpack_require__("14c3");

// @@match logic
fixRegExpWellKnownSymbolLogic('match', function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = isNullOrUndefined(regexp) ? undefined : getMethod(regexp, MATCH);
      return matcher ? call(matcher, regexp, O) : new RegExp(regexp)[MATCH](toString(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function (string) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(nativeMatch, rx, S);

      if (res.done) return res.value;

      if (!rx.global) return regExpExec(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = toString(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "4723":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "4738":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var NativePromiseConstructor = __webpack_require__("d256");
var isCallable = __webpack_require__("1626");
var isForced = __webpack_require__("94ca");
var inspectSource = __webpack_require__("8925");
var wellKnownSymbol = __webpack_require__("b622");
var IS_BROWSER = __webpack_require__("6069");
var IS_DENO = __webpack_require__("6c59");
var IS_PURE = __webpack_require__("c430");
var V8_VERSION = __webpack_require__("2d00");

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var SPECIES = wellKnownSymbol('species');
var SUBCLASSING = false;
var NATIVE_PROMISE_REJECTION_EVENT = isCallable(global.PromiseRejectionEvent);

var FORCED_PROMISE_CONSTRUCTOR = isForced('Promise', function () {
  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor);
  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
  // We can't detect it synchronously, so just check versions
  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
  // We need Promise#{ catch, finally } in the pure version for preventing prototype pollution
  if (IS_PURE && !(NativePromisePrototype['catch'] && NativePromisePrototype['finally'])) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
    // Detect correctness of subclassing with @@species support
    var promise = new NativePromiseConstructor(function (resolve) { resolve(1); });
    var FakePromise = function (exec) {
      exec(function () { /* empty */ }, function () { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES] = FakePromise;
    SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;
    if (!SUBCLASSING) return true;
  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  } return !GLOBAL_CORE_JS_PROMISE && (IS_BROWSER || IS_DENO) && !NATIVE_PROMISE_REJECTION_EVENT;
});

module.exports = {
  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
  SUBCLASSING: SUBCLASSING
};


/***/ }),

/***/ "4754":
/***/ (function(module, exports) {

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ "4840":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var aConstructor = __webpack_require__("5087");
var isNullOrUndefined = __webpack_require__("7234");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || isNullOrUndefined(S = anObject(C)[SPECIES]) ? defaultConstructor : aConstructor(S);
};


/***/ }),

/***/ "4848":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "485a":
/***/ (function(module, exports, __webpack_require__) {

var call = __webpack_require__("c65b");
var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "485f":
/***/ (function(module, exports) {

/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}

/*
Language: Fortran
Author: Anthony Scemama <scemama@irsamc.ups-tlse.fr>
Website: https://en.wikipedia.org/wiki/Fortran
Category: scientific
*/

/** @type LanguageFn */
function fortran(hljs) {
  const PARAMS = {
    className: 'params',
    begin: '\\(',
    end: '\\)'
  };

  const COMMENT = {
    variants: [
      hljs.COMMENT('!', '$', {
        relevance: 0
      }),
      // allow FORTRAN 77 style comments
      hljs.COMMENT('^C[ ]', '$', {
        relevance: 0
      }),
      hljs.COMMENT('^C$', '$', {
        relevance: 0
      })
    ]
  };

  // regex in both fortran and irpf90 should match
  const OPTIONAL_NUMBER_SUFFIX = /(_[a-z_\d]+)?/;
  const OPTIONAL_NUMBER_EXP = /([de][+-]?\d+)?/;
  const NUMBER = {
    className: 'number',
    variants: [
      {
        begin: concat(/\b\d+/, /\.(\d*)/, OPTIONAL_NUMBER_EXP, OPTIONAL_NUMBER_SUFFIX)
      },
      {
        begin: concat(/\b\d+/, OPTIONAL_NUMBER_EXP, OPTIONAL_NUMBER_SUFFIX)
      },
      {
        begin: concat(/\.\d+/, OPTIONAL_NUMBER_EXP, OPTIONAL_NUMBER_SUFFIX)
      }
    ],
    relevance: 0
  };

  const FUNCTION_DEF = {
    className: 'function',
    beginKeywords: 'subroutine function program',
    illegal: '[${=\\n]',
    contains: [
      hljs.UNDERSCORE_TITLE_MODE,
      PARAMS
    ]
  };

  const STRING = {
    className: 'string',
    relevance: 0,
    variants: [
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE
    ]
  };

  const KEYWORDS = {
    literal: '.False. .True.',
    keyword: 'kind do concurrent local shared while private call intrinsic where elsewhere ' +
      'type endtype endmodule endselect endinterface end enddo endif if forall endforall only contains default return stop then block endblock endassociate ' +
      'public subroutine|10 function program .and. .or. .not. .le. .eq. .ge. .gt. .lt. ' +
      'goto save else use module select case ' +
      'access blank direct exist file fmt form formatted iostat name named nextrec number opened rec recl sequential status unformatted unit ' +
      'continue format pause cycle exit ' +
      'c_null_char c_alert c_backspace c_form_feed flush wait decimal round iomsg ' +
      'synchronous nopass non_overridable pass protected volatile abstract extends import ' +
      'non_intrinsic value deferred generic final enumerator class associate bind enum ' +
      'c_int c_short c_long c_long_long c_signed_char c_size_t c_int8_t c_int16_t c_int32_t c_int64_t c_int_least8_t c_int_least16_t ' +
      'c_int_least32_t c_int_least64_t c_int_fast8_t c_int_fast16_t c_int_fast32_t c_int_fast64_t c_intmax_t C_intptr_t c_float c_double ' +
      'c_long_double c_float_complex c_double_complex c_long_double_complex c_bool c_char c_null_ptr c_null_funptr ' +
      'c_new_line c_carriage_return c_horizontal_tab c_vertical_tab iso_c_binding c_loc c_funloc c_associated  c_f_pointer ' +
      'c_ptr c_funptr iso_fortran_env character_storage_size error_unit file_storage_size input_unit iostat_end iostat_eor ' +
      'numeric_storage_size output_unit c_f_procpointer ieee_arithmetic ieee_support_underflow_control ' +
      'ieee_get_underflow_mode ieee_set_underflow_mode newunit contiguous recursive ' +
      'pad position action delim readwrite eor advance nml interface procedure namelist include sequence elemental pure impure ' +
      'integer real character complex logical codimension dimension allocatable|10 parameter ' +
      'external implicit|10 none double precision assign intent optional pointer ' +
      'target in out common equivalence data',
    built_in: 'alog alog10 amax0 amax1 amin0 amin1 amod cabs ccos cexp clog csin csqrt dabs dacos dasin datan datan2 dcos dcosh ddim dexp dint ' +
      'dlog dlog10 dmax1 dmin1 dmod dnint dsign dsin dsinh dsqrt dtan dtanh float iabs idim idint idnint ifix isign max0 max1 min0 min1 sngl ' +
      'algama cdabs cdcos cdexp cdlog cdsin cdsqrt cqabs cqcos cqexp cqlog cqsin cqsqrt dcmplx dconjg derf derfc dfloat dgamma dimag dlgama ' +
      'iqint qabs qacos qasin qatan qatan2 qcmplx qconjg qcos qcosh qdim qerf qerfc qexp qgamma qimag qlgama qlog qlog10 qmax1 qmin1 qmod ' +
      'qnint qsign qsin qsinh qsqrt qtan qtanh abs acos aimag aint anint asin atan atan2 char cmplx conjg cos cosh exp ichar index int log ' +
      'log10 max min nint sign sin sinh sqrt tan tanh print write dim lge lgt lle llt mod nullify allocate deallocate ' +
      'adjustl adjustr all allocated any associated bit_size btest ceiling count cshift date_and_time digits dot_product ' +
      'eoshift epsilon exponent floor fraction huge iand ibclr ibits ibset ieor ior ishft ishftc lbound len_trim matmul ' +
      'maxexponent maxloc maxval merge minexponent minloc minval modulo mvbits nearest pack present product ' +
      'radix random_number random_seed range repeat reshape rrspacing scale scan selected_int_kind selected_real_kind ' +
      'set_exponent shape size spacing spread sum system_clock tiny transpose trim ubound unpack verify achar iachar transfer ' +
      'dble entry dprod cpu_time command_argument_count get_command get_command_argument get_environment_variable is_iostat_end ' +
      'ieee_arithmetic ieee_support_underflow_control ieee_get_underflow_mode ieee_set_underflow_mode ' +
      'is_iostat_eor move_alloc new_line selected_char_kind same_type_as extends_type_of ' +
      'acosh asinh atanh bessel_j0 bessel_j1 bessel_jn bessel_y0 bessel_y1 bessel_yn erf erfc erfc_scaled gamma log_gamma hypot norm2 ' +
      'atomic_define atomic_ref execute_command_line leadz trailz storage_size merge_bits ' +
      'bge bgt ble blt dshiftl dshiftr findloc iall iany iparity image_index lcobound ucobound maskl maskr ' +
      'num_images parity popcnt poppar shifta shiftl shiftr this_image sync change team co_broadcast co_max co_min co_sum co_reduce'
  };
  return {
    name: 'Fortran',
    case_insensitive: true,
    aliases: [
      'f90',
      'f95'
    ],
    keywords: KEYWORDS,
    illegal: /\/\*/,
    contains: [
      STRING,
      FUNCTION_DEF,
      // allow `C = value` for assignments so they aren't misdetected
      // as Fortran 77 style comments
      {
        begin: /^C\s*=(?!=)/,
        relevance: 0
      },
      COMMENT,
      NUMBER
    ]
  };
}

module.exports = fortran;


/***/ }),

/***/ "4949":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlocksSettings_vue_vue_type_style_index_0_id_644cb51f_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("681b");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlocksSettings_vue_vue_type_style_index_0_id_644cb51f_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlocksSettings_vue_vue_type_style_index_0_id_644cb51f_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "4953":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "498a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $trim = __webpack_require__("58a8").trim;
var forcedStringTrimMethod = __webpack_require__("c8d2");

// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});


/***/ }),

/***/ "49f8":
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./de.json": "6ce2",
	"./en.json": "edd4"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "49f8";

/***/ }),

/***/ "4ae1":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var getBuiltIn = __webpack_require__("d066");
var apply = __webpack_require__("2ba4");
var bind = __webpack_require__("0538");
var aConstructor = __webpack_require__("5087");
var anObject = __webpack_require__("825a");
var isObject = __webpack_require__("861d");
var create = __webpack_require__("7c73");
var fails = __webpack_require__("d039");

var nativeConstruct = getBuiltIn('Reflect', 'construct');
var ObjectPrototype = Object.prototype;
var push = [].push;

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});

var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});

var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aConstructor(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      apply(push, $args, args);
      return new (apply(bind, Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : ObjectPrototype);
    var result = apply(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "4b11":
/***/ (function(module, exports) {

// eslint-disable-next-line es/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';


/***/ }),

/***/ "4ba6":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("56b3"));
  else {}
})(function(CodeMirror) {
"use strict";

function Context(indented, column, type, info, align, prev) {
  this.indented = indented;
  this.column = column;
  this.type = type;
  this.info = info;
  this.align = align;
  this.prev = prev;
}
function pushContext(state, col, type, info) {
  var indent = state.indented;
  if (state.context && state.context.type == "statement" && type != "statement")
    indent = state.context.indented;
  return state.context = new Context(indent, col, type, info, null, state.context);
}
function popContext(state) {
  var t = state.context.type;
  if (t == ")" || t == "]" || t == "}")
    state.indented = state.context.indented;
  return state.context = state.context.prev;
}

function typeBefore(stream, state, pos) {
  if (state.prevToken == "variable" || state.prevToken == "type") return true;
  if (/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(stream.string.slice(0, pos))) return true;
  if (state.typeAtEndOfLine && stream.column() == stream.indentation()) return true;
}

function isTopScope(context) {
  for (;;) {
    if (!context || context.type == "top") return true;
    if (context.type == "}" && context.prev.info != "namespace") return false;
    context = context.prev;
  }
}

CodeMirror.defineMode("clike", function(config, parserConfig) {
  var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      keywords = parserConfig.keywords || {},
      types = parserConfig.types || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      defKeywords = parserConfig.defKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings,
      indentStatements = parserConfig.indentStatements !== false,
      indentSwitch = parserConfig.indentSwitch !== false,
      namespaceSeparator = parserConfig.namespaceSeparator,
      isPunctuationChar = parserConfig.isPunctuationChar || /[\[\]{}\(\),;\:\.]/,
      numberStart = parserConfig.numberStart || /[\d\.]/,
      number = parserConfig.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,
      isOperatorChar = parserConfig.isOperatorChar || /[+\-*&%=<>!?|\/]/,
      isIdentifierChar = parserConfig.isIdentifierChar || /[\w\$_\xa1-\uffff]/,
      // An optional function that takes a {string} token and returns true if it
      // should be treated as a builtin.
      isReservedIdentifier = parserConfig.isReservedIdentifier || false;

  var curPunc, isDefKeyword;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (numberStart.test(ch)) {
      stream.backUp(1)
      if (stream.match(number)) return "number"
      stream.next()
    }
    if (isPunctuationChar.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      while (!stream.match(/^\/[\/*]/, false) && stream.eat(isOperatorChar)) {}
      return "operator";
    }
    stream.eatWhile(isIdentifierChar);
    if (namespaceSeparator) while (stream.match(namespaceSeparator))
      stream.eatWhile(isIdentifierChar);

    var cur = stream.current();
    if (contains(keywords, cur)) {
      if (contains(blockKeywords, cur)) curPunc = "newstatement";
      if (contains(defKeywords, cur)) isDefKeyword = true;
      return "keyword";
    }
    if (contains(types, cur)) return "type";
    if (contains(builtin, cur)
        || (isReservedIdentifier && isReservedIdentifier(cur))) {
      if (contains(blockKeywords, cur)) curPunc = "newstatement";
      return "builtin";
    }
    if (contains(atoms, cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {end = true; break;}
        escaped = !escaped && next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function maybeEOL(stream, state) {
    if (parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context))
      state.typeAtEndOfLine = typeBefore(stream, state, stream.pos)
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", null, false),
        indented: 0,
        startOfLine: true,
        prevToken: null
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) { maybeEOL(stream, state); return null; }
      curPunc = isDefKeyword = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      if (ctx.align == null) ctx.align = true;

      if (curPunc == ";" || curPunc == ":" || (curPunc == "," && stream.match(/^\s*(?:\/\/.*)?$/, false)))
        while (state.context.type == "statement") popContext(state);
      else if (curPunc == "{") pushContext(state, stream.column(), "}");
      else if (curPunc == "[") pushContext(state, stream.column(), "]");
      else if (curPunc == "(") pushContext(state, stream.column(), ")");
      else if (curPunc == "}") {
        while (ctx.type == "statement") ctx = popContext(state);
        if (ctx.type == "}") ctx = popContext(state);
        while (ctx.type == "statement") ctx = popContext(state);
      }
      else if (curPunc == ctx.type) popContext(state);
      else if (indentStatements &&
               (((ctx.type == "}" || ctx.type == "top") && curPunc != ";") ||
                (ctx.type == "statement" && curPunc == "newstatement"))) {
        pushContext(state, stream.column(), "statement", stream.current());
      }

      if (style == "variable" &&
          ((state.prevToken == "def" ||
            (parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) &&
             isTopScope(state.context) && stream.match(/^\s*\(/, false)))))
        style = "def";

      if (hooks.token) {
        var result = hooks.token(stream, state, style);
        if (result !== undefined) style = result;
      }

      if (style == "def" && parserConfig.styleDefs === false) style = "variable";

      state.startOfLine = false;
      state.prevToken = isDefKeyword ? "def" : style || curPunc;
      maybeEOL(stream, state);
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase && state.tokenize != null || state.typeAtEndOfLine) return CodeMirror.Pass;
      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);
      var closing = firstChar == ctx.type;
      if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
      if (parserConfig.dontIndentStatements)
        while (ctx.type == "statement" && parserConfig.dontIndentStatements.test(ctx.info))
          ctx = ctx.prev
      if (hooks.indent) {
        var hook = hooks.indent(state, ctx, textAfter, indentUnit);
        if (typeof hook == "number") return hook
      }
      var switchBlock = ctx.prev && ctx.prev.info == "switch";
      if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {
        while (ctx.type != "top" && ctx.type != "}") ctx = ctx.prev
        return ctx.indented
      }
      if (ctx.type == "statement")
        return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);
      if (ctx.align && (!dontAlignCalls || ctx.type != ")"))
        return ctx.column + (closing ? 0 : 1);
      if (ctx.type == ")" && !closing)
        return ctx.indented + statementIndentUnit;

      return ctx.indented + (closing ? 0 : indentUnit) +
        (!closing && switchBlock && !/^(?:case|default)\b/.test(textAfter) ? indentUnit : 0);
    },

    electricInput: indentSwitch ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    blockCommentContinue: " * ",
    lineComment: "//",
    fold: "brace"
  };
});

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  function contains(words, word) {
    if (typeof words === "function") {
      return words(word);
    } else {
      return words.propertyIsEnumerable(word);
    }
  }
  var cKeywords = "auto if break case register continue return default do sizeof " +
    "static else struct switch extern typedef union for goto while enum const " +
    "volatile inline restrict asm fortran";

  // Keywords from https://en.cppreference.com/w/cpp/keyword includes C++20.
  var cppKeywords = "alignas alignof and and_eq audit axiom bitand bitor catch " +
  "class compl concept constexpr const_cast decltype delete dynamic_cast " +
  "explicit export final friend import module mutable namespace new noexcept " +
  "not not_eq operator or or_eq override private protected public " +
  "reinterpret_cast requires static_assert static_cast template this " +
  "thread_local throw try typeid typename using virtual xor xor_eq";

  var objCKeywords = "bycopy byref in inout oneway out self super atomic nonatomic retain copy " +
  "readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd " +
  "@interface @implementation @end @protocol @encode @property @synthesize @dynamic @class " +
  "@public @package @private @protected @required @optional @try @catch @finally @import " +
  "@selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available";

  var objCBuiltins = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION " +
  " NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER " +
  "NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION " +
  "NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT"

  // Do not use this. Use the cTypes function below. This is global just to avoid
  // excessive calls when cTypes is being called multiple times during a parse.
  var basicCTypes = words("int long char short double float unsigned signed " +
    "void bool");

  // Do not use this. Use the objCTypes function below. This is global just to avoid
  // excessive calls when objCTypes is being called multiple times during a parse.
  var basicObjCTypes = words("SEL instancetype id Class Protocol BOOL");

  // Returns true if identifier is a "C" type.
  // C type is defined as those that are reserved by the compiler (basicTypes),
  // and those that end in _t (Reserved by POSIX for types)
  // http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html
  function cTypes(identifier) {
    return contains(basicCTypes, identifier) || /.+_t$/.test(identifier);
  }

  // Returns true if identifier is a "Objective C" type.
  function objCTypes(identifier) {
    return cTypes(identifier) || contains(basicObjCTypes, identifier);
  }

  var cBlockKeywords = "case do else for if switch while struct enum union";
  var cDefKeywords = "struct enum union";

  function cppHook(stream, state) {
    if (!state.startOfLine) return false
    for (var ch, next = null; ch = stream.peek();) {
      if (ch == "\\" && stream.match(/^.$/)) {
        next = cppHook
        break
      } else if (ch == "/" && stream.match(/^\/[\/\*]/, false)) {
        break
      }
      stream.next()
    }
    state.tokenize = next
    return "meta"
  }

  function pointerHook(_stream, state) {
    if (state.prevToken == "type") return "type";
    return false;
  }

  // For C and C++ (and ObjC): identifiers starting with __
  // or _ followed by a capital letter are reserved for the compiler.
  function cIsReservedIdentifier(token) {
    if (!token || token.length < 2) return false;
    if (token[0] != '_') return false;
    return (token[1] == '_') || (token[1] !== token[1].toLowerCase());
  }

  function cpp14Literal(stream) {
    stream.eatWhile(/[\w\.']/);
    return "number";
  }

  function cpp11StringHook(stream, state) {
    stream.backUp(1);
    // Raw strings.
    if (stream.match(/^(?:R|u8R|uR|UR|LR)/)) {
      var match = stream.match(/^"([^\s\\()]{0,16})\(/);
      if (!match) {
        return false;
      }
      state.cpp11RawStringDelim = match[1];
      state.tokenize = tokenRawString;
      return tokenRawString(stream, state);
    }
    // Unicode strings/chars.
    if (stream.match(/^(?:u8|u|U|L)/)) {
      if (stream.match(/^["']/, /* eat */ false)) {
        return "string";
      }
      return false;
    }
    // Ignore this hook.
    stream.next();
    return false;
  }

  function cppLooksLikeConstructor(word) {
    var lastTwo = /(\w+)::~?(\w+)$/.exec(word);
    return lastTwo && lastTwo[1] == lastTwo[2];
  }

  // C#-style strings where "" escapes a quote.
  function tokenAtString(stream, state) {
    var next;
    while ((next = stream.next()) != null) {
      if (next == '"' && !stream.eat('"')) {
        state.tokenize = null;
        break;
      }
    }
    return "string";
  }

  // C++11 raw string literal is <prefix>"<delim>( anything )<delim>", where
  // <delim> can be a string up to 16 characters long.
  function tokenRawString(stream, state) {
    // Escape characters that have special regex meanings.
    var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, '\\$&');
    var match = stream.match(new RegExp(".*?\\)" + delim + '"'));
    if (match)
      state.tokenize = null;
    else
      stream.skipToEnd();
    return "string";
  }

  function def(mimes, mode) {
    if (typeof mimes == "string") mimes = [mimes];
    var words = [];
    function add(obj) {
      if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop))
        words.push(prop);
    }
    add(mode.keywords);
    add(mode.types);
    add(mode.builtin);
    add(mode.atoms);
    if (words.length) {
      mode.helperType = mimes[0];
      CodeMirror.registerHelper("hintWords", mimes[0], words);
    }

    for (var i = 0; i < mimes.length; ++i)
      CodeMirror.defineMIME(mimes[i], mode);
  }

  def(["text/x-csrc", "text/x-c", "text/x-chdr"], {
    name: "clike",
    keywords: words(cKeywords),
    types: cTypes,
    blockKeywords: words(cBlockKeywords),
    defKeywords: words(cDefKeywords),
    typeFirstDefinitions: true,
    atoms: words("NULL true false"),
    isReservedIdentifier: cIsReservedIdentifier,
    hooks: {
      "#": cppHook,
      "*": pointerHook,
    },
    modeProps: {fold: ["brace", "include"]}
  });

  def(["text/x-c++src", "text/x-c++hdr"], {
    name: "clike",
    keywords: words(cKeywords + " " + cppKeywords),
    types: cTypes,
    blockKeywords: words(cBlockKeywords + " class try catch"),
    defKeywords: words(cDefKeywords + " class namespace"),
    typeFirstDefinitions: true,
    atoms: words("true false NULL nullptr"),
    dontIndentStatements: /^template$/,
    isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
    isReservedIdentifier: cIsReservedIdentifier,
    hooks: {
      "#": cppHook,
      "*": pointerHook,
      "u": cpp11StringHook,
      "U": cpp11StringHook,
      "L": cpp11StringHook,
      "R": cpp11StringHook,
      "0": cpp14Literal,
      "1": cpp14Literal,
      "2": cpp14Literal,
      "3": cpp14Literal,
      "4": cpp14Literal,
      "5": cpp14Literal,
      "6": cpp14Literal,
      "7": cpp14Literal,
      "8": cpp14Literal,
      "9": cpp14Literal,
      token: function(stream, state, style) {
        if (style == "variable" && stream.peek() == "(" &&
            (state.prevToken == ";" || state.prevToken == null ||
             state.prevToken == "}") &&
            cppLooksLikeConstructor(stream.current()))
          return "def";
      }
    },
    namespaceSeparator: "::",
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-java", {
    name: "clike",
    keywords: words("abstract assert break case catch class const continue default " +
                    "do else enum extends final finally for goto if implements import " +
                    "instanceof interface native new package private protected public " +
                    "return static strictfp super switch synchronized this throw throws transient " +
                    "try volatile while @interface"),
    types: words("var byte short int long float double boolean char void Boolean Byte Character Double Float " +
                 "Integer Long Number Object Short String StringBuffer StringBuilder Void"),
    blockKeywords: words("catch class do else finally for if switch try while"),
    defKeywords: words("class interface enum @interface"),
    typeFirstDefinitions: true,
    atoms: words("true false null"),
    number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
    hooks: {
      "@": function(stream) {
        // Don't match the @interface keyword.
        if (stream.match('interface', false)) return false;

        stream.eatWhile(/[\w\$_]/);
        return "meta";
      },
      '"': function(stream, state) {
        if (!stream.match(/""$/)) return false;
        state.tokenize = tokenTripleString;
        return state.tokenize(stream, state);
      }
    },
    modeProps: {fold: ["brace", "import"]}
  });

  def("text/x-csharp", {
    name: "clike",
    keywords: words("abstract as async await base break case catch checked class const continue" +
                    " default delegate do else enum event explicit extern finally fixed for" +
                    " foreach goto if implicit in init interface internal is lock namespace new" +
                    " operator out override params private protected public readonly record ref required return sealed" +
                    " sizeof stackalloc static struct switch this throw try typeof unchecked" +
                    " unsafe using virtual void volatile while add alias ascending descending dynamic from get" +
                    " global group into join let orderby partial remove select set value var yield"),
    types: words("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func" +
                 " Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32" +
                 " UInt64 bool byte char decimal double short int long object"  +
                 " sbyte float string ushort uint ulong"),
    blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
    defKeywords: words("class interface namespace record struct var"),
    typeFirstDefinitions: true,
    atoms: words("true false null"),
    hooks: {
      "@": function(stream, state) {
        if (stream.eat('"')) {
          state.tokenize = tokenAtString;
          return tokenAtString(stream, state);
        }
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      }
    }
  });

  function tokenTripleString(stream, state) {
    var escaped = false;
    while (!stream.eol()) {
      if (!escaped && stream.match('"""')) {
        state.tokenize = null;
        break;
      }
      escaped = stream.next() == "\\" && !escaped;
    }
    return "string";
  }

  function tokenNestedComment(depth) {
    return function (stream, state) {
      var ch
      while (ch = stream.next()) {
        if (ch == "*" && stream.eat("/")) {
          if (depth == 1) {
            state.tokenize = null
            break
          } else {
            state.tokenize = tokenNestedComment(depth - 1)
            return state.tokenize(stream, state)
          }
        } else if (ch == "/" && stream.eat("*")) {
          state.tokenize = tokenNestedComment(depth + 1)
          return state.tokenize(stream, state)
        }
      }
      return "comment"
    }
  }

  def("text/x-scala", {
    name: "clike",
    keywords: words(
      /* scala */
      "abstract case catch class def do else extends final finally for forSome if " +
      "implicit import lazy match new null object override package private protected return " +
      "sealed super this throw trait try type val var while with yield _ " +

      /* package scala */
      "assert assume require print println printf readLine readBoolean readByte readShort " +
      "readChar readInt readLong readFloat readDouble"
    ),
    types: words(
      "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either " +
      "Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable " +
      "Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering " +
      "Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder " +
      "StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector " +

      /* package java.lang */
      "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
    ),
    multiLineStrings: true,
    blockKeywords: words("catch class enum do else finally for forSome if match switch try while"),
    defKeywords: words("class enum def object package trait type val var"),
    atoms: words("true false null"),
    indentStatements: false,
    indentSwitch: false,
    isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      },
      '"': function(stream, state) {
        if (!stream.match('""')) return false;
        state.tokenize = tokenTripleString;
        return state.tokenize(stream, state);
      },
      "'": function(stream) {
        if (stream.match(/^(\\[^'\s]+|[^\\'])'/)) return "string-2"
        stream.eatWhile(/[\w\$_\xa1-\uffff]/);
        return "atom";
      },
      "=": function(stream, state) {
        var cx = state.context
        if (cx.type == "}" && cx.align && stream.eat(">")) {
          state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev)
          return "operator"
        } else {
          return false
        }
      },

      "/": function(stream, state) {
        if (!stream.eat("*")) return false
        state.tokenize = tokenNestedComment(1)
        return state.tokenize(stream, state)
      }
    },
    modeProps: {closeBrackets: {pairs: '()[]{}""', triples: '"'}}
  });

  function tokenKotlinString(tripleString){
    return function (stream, state) {
      var escaped = false, next, end = false;
      while (!stream.eol()) {
        if (!tripleString && !escaped && stream.match('"') ) {end = true; break;}
        if (tripleString && stream.match('"""')) {end = true; break;}
        next = stream.next();
        if(!escaped && next == "$" && stream.match('{'))
          stream.skipTo("}");
        escaped = !escaped && next == "\\" && !tripleString;
      }
      if (end || !tripleString)
        state.tokenize = null;
      return "string";
    }
  }

  def("text/x-kotlin", {
    name: "clike",
    keywords: words(
      /*keywords*/
      "package as typealias class interface this super val operator " +
      "var fun for is in This throw return annotation " +
      "break continue object if else while do try when !in !is as? " +

      /*soft keywords*/
      "file import where by get set abstract enum open inner override private public internal " +
      "protected catch finally out final vararg reified dynamic companion constructor init " +
      "sealed field property receiver param sparam lateinit data inline noinline tailrec " +
      "external annotation crossinline const operator infix suspend actual expect setparam value"
    ),
    types: words(
      /* package java.lang */
      "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable " +
      "Compiler Double Exception Float Integer Long Math Number Object Package Pair Process " +
      "Runtime Runnable SecurityManager Short StackTraceElement StrictMath String " +
      "StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray " +
      "ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy " +
      "LazyThreadSafetyMode LongArray Nothing ShortArray Unit"
    ),
    intendSwitch: false,
    indentStatements: false,
    multiLineStrings: true,
    number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
    blockKeywords: words("catch class do else finally for if where try while enum"),
    defKeywords: words("class val var object interface fun"),
    atoms: words("true false null this"),
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      },
      '*': function(_stream, state) {
        return state.prevToken == '.' ? 'variable' : 'operator';
      },
      '"': function(stream, state) {
        state.tokenize = tokenKotlinString(stream.match('""'));
        return state.tokenize(stream, state);
      },
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenNestedComment(1);
        return state.tokenize(stream, state)
      },
      indent: function(state, ctx, textAfter, indentUnit) {
        var firstChar = textAfter && textAfter.charAt(0);
        if ((state.prevToken == "}" || state.prevToken == ")") && textAfter == "")
          return state.indented;
        if ((state.prevToken == "operator" && textAfter != "}" && state.context.type != "}") ||
          state.prevToken == "variable" && firstChar == "." ||
          (state.prevToken == "}" || state.prevToken == ")") && firstChar == ".")
          return indentUnit * 2 + ctx.indented;
        if (ctx.align && ctx.type == "}")
          return ctx.indented + (state.context.type == (textAfter || "").charAt(0) ? 0 : indentUnit);
      }
    },
    modeProps: {closeBrackets: {triples: '"'}}
  });

  def(["x-shader/x-vertex", "x-shader/x-fragment"], {
    name: "clike",
    keywords: words("sampler1D sampler2D sampler3D samplerCube " +
                    "sampler1DShadow sampler2DShadow " +
                    "const attribute uniform varying " +
                    "break continue discard return " +
                    "for while do if else struct " +
                    "in out inout"),
    types: words("float int bool void " +
                 "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " +
                 "mat2 mat3 mat4"),
    blockKeywords: words("for while do if else struct"),
    builtin: words("radians degrees sin cos tan asin acos atan " +
                    "pow exp log exp2 sqrt inversesqrt " +
                    "abs sign floor ceil fract mod min max clamp mix step smoothstep " +
                    "length distance dot cross normalize ftransform faceforward " +
                    "reflect refract matrixCompMult " +
                    "lessThan lessThanEqual greaterThan greaterThanEqual " +
                    "equal notEqual any all not " +
                    "texture1D texture1DProj texture1DLod texture1DProjLod " +
                    "texture2D texture2DProj texture2DLod texture2DProjLod " +
                    "texture3D texture3DProj texture3DLod texture3DProjLod " +
                    "textureCube textureCubeLod " +
                    "shadow1D shadow2D shadow1DProj shadow2DProj " +
                    "shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod " +
                    "dFdx dFdy fwidth " +
                    "noise1 noise2 noise3 noise4"),
    atoms: words("true false " +
                "gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex " +
                "gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 " +
                "gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 " +
                "gl_FogCoord gl_PointCoord " +
                "gl_Position gl_PointSize gl_ClipVertex " +
                "gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor " +
                "gl_TexCoord gl_FogFragCoord " +
                "gl_FragCoord gl_FrontFacing " +
                "gl_FragData gl_FragDepth " +
                "gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix " +
                "gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse " +
                "gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse " +
                "gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose " +
                "gl_ProjectionMatrixInverseTranspose " +
                "gl_ModelViewProjectionMatrixInverseTranspose " +
                "gl_TextureMatrixInverseTranspose " +
                "gl_NormalScale gl_DepthRange gl_ClipPlane " +
                "gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel " +
                "gl_FrontLightModelProduct gl_BackLightModelProduct " +
                "gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ " +
                "gl_FogParameters " +
                "gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords " +
                "gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats " +
                "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " +
                "gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits " +
                "gl_MaxDrawBuffers"),
    indentSwitch: false,
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-nesc", {
    name: "clike",
    keywords: words(cKeywords + " as atomic async call command component components configuration event generic " +
                    "implementation includes interface module new norace nx_struct nx_union post provides " +
                    "signal task uses abstract extends"),
    types: cTypes,
    blockKeywords: words(cBlockKeywords),
    atoms: words("null true false"),
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-objectivec", {
    name: "clike",
    keywords: words(cKeywords + " " + objCKeywords),
    types: objCTypes,
    builtin: words(objCBuiltins),
    blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
    defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class"),
    dontIndentStatements: /^@.*$/,
    typeFirstDefinitions: true,
    atoms: words("YES NO NULL Nil nil true false nullptr"),
    isReservedIdentifier: cIsReservedIdentifier,
    hooks: {
      "#": cppHook,
      "*": pointerHook,
    },
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-objectivec++", {
    name: "clike",
    keywords: words(cKeywords + " " + objCKeywords + " " + cppKeywords),
    types: objCTypes,
    builtin: words(objCBuiltins),
    blockKeywords: words(cBlockKeywords + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),
    defKeywords: words(cDefKeywords + " @interface @implementation @protocol @class class namespace"),
    dontIndentStatements: /^@.*$|^template$/,
    typeFirstDefinitions: true,
    atoms: words("YES NO NULL Nil nil true false nullptr"),
    isReservedIdentifier: cIsReservedIdentifier,
    hooks: {
      "#": cppHook,
      "*": pointerHook,
      "u": cpp11StringHook,
      "U": cpp11StringHook,
      "L": cpp11StringHook,
      "R": cpp11StringHook,
      "0": cpp14Literal,
      "1": cpp14Literal,
      "2": cpp14Literal,
      "3": cpp14Literal,
      "4": cpp14Literal,
      "5": cpp14Literal,
      "6": cpp14Literal,
      "7": cpp14Literal,
      "8": cpp14Literal,
      "9": cpp14Literal,
      token: function(stream, state, style) {
        if (style == "variable" && stream.peek() == "(" &&
            (state.prevToken == ";" || state.prevToken == null ||
             state.prevToken == "}") &&
            cppLooksLikeConstructor(stream.current()))
          return "def";
      }
    },
    namespaceSeparator: "::",
    modeProps: {fold: ["brace", "include"]}
  });

  def("text/x-squirrel", {
    name: "clike",
    keywords: words("base break clone continue const default delete enum extends function in class" +
                    " foreach local resume return this throw typeof yield constructor instanceof static"),
    types: cTypes,
    blockKeywords: words("case catch class else for foreach if switch try while"),
    defKeywords: words("function local class"),
    typeFirstDefinitions: true,
    atoms: words("true false null"),
    hooks: {"#": cppHook},
    modeProps: {fold: ["brace", "include"]}
  });

  // Ceylon Strings need to deal with interpolation
  var stringTokenizer = null;
  function tokenCeylonString(type) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while (!stream.eol()) {
        if (!escaped && stream.match('"') &&
              (type == "single" || stream.match('""'))) {
          end = true;
          break;
        }
        if (!escaped && stream.match('``')) {
          stringTokenizer = tokenCeylonString(type);
          end = true;
          break;
        }
        next = stream.next();
        escaped = type == "single" && !escaped && next == "\\";
      }
      if (end)
          state.tokenize = null;
      return "string";
    }
  }

  def("text/x-ceylon", {
    name: "clike",
    keywords: words("abstracts alias assembly assert assign break case catch class continue dynamic else" +
                    " exists extends finally for function given if import in interface is let module new" +
                    " nonempty object of out outer package return satisfies super switch then this throw" +
                    " try value void while"),
    types: function(word) {
        // In Ceylon all identifiers that start with an uppercase are types
        var first = word.charAt(0);
        return (first === first.toUpperCase() && first !== first.toLowerCase());
    },
    blockKeywords: words("case catch class dynamic else finally for function if interface module new object switch try while"),
    defKeywords: words("class dynamic function interface module object package value"),
    builtin: words("abstract actual aliased annotation by default deprecated doc final formal late license" +
                   " native optional sealed see serializable shared suppressWarnings tagged throws variable"),
    isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
    isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
    numberStart: /[\d#$]/,
    number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
    multiLineStrings: true,
    typeFirstDefinitions: true,
    atoms: words("true false null larger smaller equal empty finished"),
    indentSwitch: false,
    styleDefs: false,
    hooks: {
      "@": function(stream) {
        stream.eatWhile(/[\w\$_]/);
        return "meta";
      },
      '"': function(stream, state) {
          state.tokenize = tokenCeylonString(stream.match('""') ? "triple" : "single");
          return state.tokenize(stream, state);
        },
      '`': function(stream, state) {
          if (!stringTokenizer || !stream.match('`')) return false;
          state.tokenize = stringTokenizer;
          stringTokenizer = null;
          return state.tokenize(stream, state);
        },
      "'": function(stream) {
        stream.eatWhile(/[\w\$_\xa1-\uffff]/);
        return "atom";
      },
      token: function(_stream, state, style) {
          if ((style == "variable" || style == "type") &&
              state.prevToken == ".") {
            return "variable-2";
          }
        }
    },
    modeProps: {
        fold: ["brace", "import"],
        closeBrackets: {triples: '"'}
    }
  });

});


/***/ }),

/***/ "4bf9":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "4c53":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var createHTML = __webpack_require__("857a");
var forcedStringHTMLMethod = __webpack_require__("af03");

// `String.prototype.sub` method
// https://tc39.es/ecma262/#sec-string.prototype.sub
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('sub') }, {
  sub: function sub() {
    return createHTML(this, 'sub', '', '');
  }
});


/***/ }),

/***/ "4d63":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var isForced = __webpack_require__("94ca");
var inheritIfRequired = __webpack_require__("7156");
var createNonEnumerableProperty = __webpack_require__("9112");
var getOwnPropertyNames = __webpack_require__("241c").f;
var isPrototypeOf = __webpack_require__("3a9b");
var isRegExp = __webpack_require__("44e7");
var toString = __webpack_require__("577e");
var getRegExpFlags = __webpack_require__("90d8");
var stickyHelpers = __webpack_require__("9f7f");
var proxyAccessor = __webpack_require__("aeb0");
var defineBuiltIn = __webpack_require__("cb2d");
var fails = __webpack_require__("d039");
var hasOwn = __webpack_require__("1a2d");
var enforceInternalState = __webpack_require__("69f3").enforce;
var setSpecies = __webpack_require__("2626");
var wellKnownSymbol = __webpack_require__("b622");
var UNSUPPORTED_DOT_ALL = __webpack_require__("fce3");
var UNSUPPORTED_NCG = __webpack_require__("107c");

var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var SyntaxError = global.SyntaxError;
var exec = uncurryThis(RegExpPrototype.exec);
var charAt = uncurryThis(''.charAt);
var replace = uncurryThis(''.replace);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);
// TODO: Use only proper RegExpIdentifierName
var IS_NCG = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var MISSED_STICKY = stickyHelpers.MISSED_STICKY;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;

var BASE_FORCED = DESCRIPTORS &&
  (!CORRECT_NEW || MISSED_STICKY || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG || fails(function () {
    re2[MATCH] = false;
    // RegExp constructor can alter flags and IsRegExp works correct with @@match
    return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
  }));

var handleDotAll = function (string) {
  var length = string.length;
  var index = 0;
  var result = '';
  var brackets = false;
  var chr;
  for (; index <= length; index++) {
    chr = charAt(string, index);
    if (chr === '\\') {
      result += chr + charAt(string, ++index);
      continue;
    }
    if (!brackets && chr === '.') {
      result += '[\\s\\S]';
    } else {
      if (chr === '[') {
        brackets = true;
      } else if (chr === ']') {
        brackets = false;
      } result += chr;
    }
  } return result;
};

var handleNCG = function (string) {
  var length = string.length;
  var index = 0;
  var result = '';
  var named = [];
  var names = {};
  var brackets = false;
  var ncg = false;
  var groupid = 0;
  var groupname = '';
  var chr;
  for (; index <= length; index++) {
    chr = charAt(string, index);
    if (chr === '\\') {
      chr = chr + charAt(string, ++index);
    } else if (chr === ']') {
      brackets = false;
    } else if (!brackets) switch (true) {
      case chr === '[':
        brackets = true;
        break;
      case chr === '(':
        if (exec(IS_NCG, stringSlice(string, index + 1))) {
          index += 2;
          ncg = true;
        }
        result += chr;
        groupid++;
        continue;
      case chr === '>' && ncg:
        if (groupname === '' || hasOwn(names, groupname)) {
          throw new SyntaxError('Invalid capture group name');
        }
        names[groupname] = true;
        named[named.length] = [groupname, groupid];
        ncg = false;
        groupname = '';
        continue;
    }
    if (ncg) groupname += chr;
    else result += chr;
  } return [result, named];
};

// `RegExp` constructor
// https://tc39.es/ecma262/#sec-regexp-constructor
if (isForced('RegExp', BASE_FORCED)) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = isPrototypeOf(RegExpPrototype, this);
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    var groups = [];
    var rawPattern = pattern;
    var rawFlags, dotAll, sticky, handled, result, state;

    if (!thisIsRegExp && patternIsRegExp && flagsAreUndefined && pattern.constructor === RegExpWrapper) {
      return pattern;
    }

    if (patternIsRegExp || isPrototypeOf(RegExpPrototype, pattern)) {
      pattern = pattern.source;
      if (flagsAreUndefined) flags = getRegExpFlags(rawPattern);
    }

    pattern = pattern === undefined ? '' : toString(pattern);
    flags = flags === undefined ? '' : toString(flags);
    rawPattern = pattern;

    if (UNSUPPORTED_DOT_ALL && 'dotAll' in re1) {
      dotAll = !!flags && stringIndexOf(flags, 's') > -1;
      if (dotAll) flags = replace(flags, /s/g, '');
    }

    rawFlags = flags;

    if (MISSED_STICKY && 'sticky' in re1) {
      sticky = !!flags && stringIndexOf(flags, 'y') > -1;
      if (sticky && UNSUPPORTED_Y) flags = replace(flags, /y/g, '');
    }

    if (UNSUPPORTED_NCG) {
      handled = handleNCG(pattern);
      pattern = handled[0];
      groups = handled[1];
    }

    result = inheritIfRequired(NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);

    if (dotAll || sticky || groups.length) {
      state = enforceInternalState(result);
      if (dotAll) {
        state.dotAll = true;
        state.raw = RegExpWrapper(handleDotAll(pattern), rawFlags);
      }
      if (sticky) state.sticky = true;
      if (groups.length) state.groups = groups;
    }

    if (pattern !== rawPattern) try {
      // fails in old engines, but we have no alternatives for unsupported regex syntax
      createNonEnumerableProperty(result, 'source', rawPattern === '' ? '(?:)' : rawPattern);
    } catch (error) { /* empty */ }

    return result;
  };

  for (var keys = getOwnPropertyNames(NativeRegExp), index = 0; keys.length > index;) {
    proxyAccessor(RegExpWrapper, NativeRegExp, keys[index++]);
  }

  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  defineBuiltIn(global, 'RegExp', RegExpWrapper, { constructor: true });
}

// https://tc39.es/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');


/***/ }),

/***/ "4d64":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("fc6a");
var toAbsoluteIndex = __webpack_require__("23cb");
var lengthOfArrayLike = __webpack_require__("07fa");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "4dae":
/***/ (function(module, exports, __webpack_require__) {

var toAbsoluteIndex = __webpack_require__("23cb");
var lengthOfArrayLike = __webpack_require__("07fa");
var createProperty = __webpack_require__("8418");

var $Array = Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ "4dd1":
/***/ (function(module, exports) {

const IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
const KEYWORDS = [
  "as", // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
const LITERALS = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];

const TYPES = [
  "Intl",
  "DataView",
  "Number",
  "Math",
  "Date",
  "String",
  "RegExp",
  "Object",
  "Function",
  "Boolean",
  "Error",
  "Symbol",
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  "Proxy",
  "Reflect",
  "JSON",
  "Promise",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Float32Array",
  "Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "ArrayBuffer",
  "BigInt64Array",
  "BigUint64Array",
  "BigInt"
];

const ERROR_TYPES = [
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];

const BUILT_IN_GLOBALS = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",

  "require",
  "exports",

  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];

const BUILT_IN_VARIABLES = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "module",
  "global" // Node.js
];

const BUILT_INS = [].concat(
  BUILT_IN_GLOBALS,
  BUILT_IN_VARIABLES,
  TYPES,
  ERROR_TYPES
);

/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function lookahead(re) {
  return concat('(?=', re, ')');
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}

/*
Language: JavaScript
Description: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.
Category: common, scripting
Website: https://developer.mozilla.org/en-US/docs/Web/JavaScript
*/

/** @type LanguageFn */
function javascript(hljs) {
  /**
   * Takes a string like "<Booger" and checks to see
   * if we can find a matching "</Booger" later in the
   * content.
   * @param {RegExpMatchArray} match
   * @param {{after:number}} param1
   */
  const hasClosingTag = (match, { after }) => {
    const tag = "</" + match[0].slice(1);
    const pos = match.input.indexOf(tag, after);
    return pos !== -1;
  };

  const IDENT_RE$1 = IDENT_RE;
  const FRAGMENT = {
    begin: '<>',
    end: '</>'
  };
  const XML_TAG = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (match, response) => {
      const afterMatchIndex = match[0].length + match.index;
      const nextChar = match.input[afterMatchIndex];
      // nested type?
      // HTML should not include another raw `<` inside a tag
      // But a type might: `<Array<Array<number>>`, etc.
      if (nextChar === "<") {
        response.ignoreMatch();
        return;
      }
      // <something>
      // This is now either a tag or a type.
      if (nextChar === ">") {
        // if we cannot find a matching closing tag, then we
        // will ignore it
        if (!hasClosingTag(match, { after: afterMatchIndex })) {
          response.ignoreMatch();
        }
      }
    }
  };
  const KEYWORDS$1 = {
    $pattern: IDENT_RE,
    keyword: KEYWORDS,
    literal: LITERALS,
    built_in: BUILT_INS
  };

  // https://tc39.es/ecma262/#sec-literals-numeric-literals
  const decimalDigits = '[0-9](_?[0-9])*';
  const frac = `\\.(${decimalDigits})`;
  // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral
  // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
  const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
  const NUMBER = {
    className: 'number',
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))` +
        `[eE][+-]?(${decimalDigits})\\b` },
      { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },

      // DecimalBigIntegerLiteral
      { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },

      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },

      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" },
    ],
    relevance: 0
  };

  const SUBST = {
    className: 'subst',
    begin: '\\$\\{',
    end: '\\}',
    keywords: KEYWORDS$1,
    contains: [] // defined later
  };
  const HTML_TEMPLATE = {
    begin: 'html`',
    end: '',
    starts: {
      end: '`',
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: 'xml'
    }
  };
  const CSS_TEMPLATE = {
    begin: 'css`',
    end: '',
    starts: {
      end: '`',
      returnEnd: false,
      contains: [
        hljs.BACKSLASH_ESCAPE,
        SUBST
      ],
      subLanguage: 'css'
    }
  };
  const TEMPLATE_STRING = {
    className: 'string',
    begin: '`',
    end: '`',
    contains: [
      hljs.BACKSLASH_ESCAPE,
      SUBST
    ]
  };
  const JSDOC_COMMENT = hljs.COMMENT(
    /\/\*\*(?!\/)/,
    '\\*/',
    {
      relevance: 0,
      contains: [
        {
          className: 'doctag',
          begin: '@[A-Za-z]+',
          contains: [
            {
              className: 'type',
              begin: '\\{',
              end: '\\}',
              relevance: 0
            },
            {
              className: 'variable',
              begin: IDENT_RE$1 + '(?=\\s*(-)|$)',
              endsParent: true,
              relevance: 0
            },
            // eat spaces (not newlines) so we can find
            // types or variables
            {
              begin: /(?=[^\n])\s/,
              relevance: 0
            }
          ]
        }
      ]
    }
  );
  const COMMENT = {
    className: "comment",
    variants: [
      JSDOC_COMMENT,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_LINE_COMMENT_MODE
    ]
  };
  const SUBST_INTERNALS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    HTML_TEMPLATE,
    CSS_TEMPLATE,
    TEMPLATE_STRING,
    NUMBER,
    hljs.REGEXP_MODE
  ];
  SUBST.contains = SUBST_INTERNALS
    .concat({
      // we need to pair up {} inside our subst to prevent
      // it from ending too early by matching another }
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS$1,
      contains: [
        "self"
      ].concat(SUBST_INTERNALS)
    });
  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: KEYWORDS$1,
      contains: ["self"].concat(SUBST_AND_COMMENTS)
    }
  ]);
  const PARAMS = {
    className: 'params',
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: KEYWORDS$1,
    contains: PARAMS_CONTAINS
  };

  return {
    name: 'Javascript',
    aliases: ['js', 'jsx', 'mjs', 'cjs'],
    keywords: KEYWORDS$1,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS },
    illegal: /#(?![$_A-z])/,
    contains: [
      hljs.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      {
        label: "use_strict",
        className: 'meta',
        relevance: 10,
        begin: /^\s*['"]use (strict|asm)['"]/
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      COMMENT,
      NUMBER,
      { // object attr container
        begin: concat(/[{,\n]\s*/,
          // we need to look ahead to make sure that we actually have an
          // attribute coming up so we don't steal a comma from a potential
          // "value" container
          //
          // NOTE: this might not work how you think.  We don't actually always
          // enter this mode and stay.  Instead it might merely match `,
          // <comments up next>` and then immediately end after the , because it
          // fails to find any actual attrs. But this still does the job because
          // it prevents the value contain rule from grabbing this instead and
          // prevening this rule from firing when we actually DO have keys.
          lookahead(concat(
            // we also need to allow for multiple possible comments inbetween
            // the first key:value pairing
            /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
            IDENT_RE$1 + '\\s*:'))),
        relevance: 0,
        contains: [
          {
            className: 'attr',
            begin: IDENT_RE$1 + lookahead('\\s*:'),
            relevance: 0
          }
        ]
      },
      { // "value" container
        begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
        keywords: 'return throw case',
        contains: [
          COMMENT,
          hljs.REGEXP_MODE,
          {
            className: 'function',
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: '(\\(' +
            '[^()]*(\\(' +
            '[^()]*(\\(' +
            '[^()]*' +
            '\\)[^()]*)*' +
            '\\)[^()]*)*' +
            '\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>',
            returnBegin: true,
            end: '\\s*=>',
            contains: [
              {
                className: 'params',
                variants: [
                  {
                    begin: hljs.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: KEYWORDS$1,
                    contains: PARAMS_CONTAINS
                  }
                ]
              }
            ]
          },
          { // could be a comma delimited list of params to a function call
            begin: /,/, relevance: 0
          },
          {
            className: '',
            begin: /\s/,
            end: /\s*/,
            skip: true
          },
          { // JSX
            variants: [
              { begin: FRAGMENT.begin, end: FRAGMENT.end },
              {
                begin: XML_TAG.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                'on:begin': XML_TAG.isTrulyOpeningTag,
                end: XML_TAG.end
              }
            ],
            subLanguage: 'xml',
            contains: [
              {
                begin: XML_TAG.begin,
                end: XML_TAG.end,
                skip: true,
                contains: ['self']
              }
            ]
          }
        ],
        relevance: 0
      },
      {
        className: 'function',
        beginKeywords: 'function',
        end: /[{;]/,
        excludeEnd: true,
        keywords: KEYWORDS$1,
        contains: [
          'self',
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
          PARAMS
        ],
        illegal: /%/
      },
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        className: 'function',
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: hljs.UNDERSCORE_IDENT_RE +
          '\\(' + // first parens
          '[^()]*(\\(' +
            '[^()]*(\\(' +
              '[^()]*' +
            '\\)[^()]*)*' +
          '\\)[^()]*)*' +
          '\\)\\s*\\{', // end parens
        returnBegin:true,
        contains: [
          PARAMS,
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
        ]
      },
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        variants: [
          { begin: '\\.' + IDENT_RE$1 },
          { begin: '\\$' + IDENT_RE$1 }
        ],
        relevance: 0
      },
      { // ES6 class
        className: 'class',
        beginKeywords: 'class',
        end: /[{;=]/,
        excludeEnd: true,
        illegal: /[:"[\]]/,
        contains: [
          { beginKeywords: 'extends' },
          hljs.UNDERSCORE_TITLE_MODE
        ]
      },
      {
        begin: /\b(?=constructor)/,
        end: /[{;]/,
        excludeEnd: true,
        contains: [
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
          'self',
          PARAMS
        ]
      },
      {
        begin: '(get|set)\\s+(?=' + IDENT_RE$1 + '\\()',
        end: /\{/,
        keywords: "get set",
        contains: [
          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
          { begin: /\(\)/ }, // eat to avoid empty params
          PARAMS
        ]
      },
      {
        begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}

module.exports = javascript;


/***/ }),

/***/ "4de4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $filter = __webpack_require__("b727").filter;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "4df4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__("0366");
var call = __webpack_require__("c65b");
var toObject = __webpack_require__("7b0b");
var callWithSafeIterationClosing = __webpack_require__("9bdd");
var isArrayIteratorMethod = __webpack_require__("e95a");
var isConstructor = __webpack_require__("68ee");
var lengthOfArrayLike = __webpack_require__("07fa");
var createProperty = __webpack_require__("8418");
var getIterator = __webpack_require__("9a1f");
var getIteratorMethod = __webpack_require__("35a1");

var $Array = Array;

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var IS_CONSTRUCTOR = isConstructor(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod && !(this === $Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];
    for (;!(step = call(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = lengthOfArrayLike(O);
    result = IS_CONSTRUCTOR ? new this(length) : $Array(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "4e73":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.anchor.js
var es_string_anchor = __webpack_require__("18a5");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/anchor.js
var mixins_anchor = __webpack_require__("c474");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/timeout.js
var timeout = __webpack_require__("463c");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/model-toggle.js
var model_toggle = __webpack_require__("7ee0");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/dark.js
var dark = __webpack_require__("b7fa");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/portal.js
var portal = __webpack_require__("9e62");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/transition.js
var transition = __webpack_require__("7562");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/attrs.js
var mixins_attrs = __webpack_require__("f376");

// EXTERNAL MODULE: ./node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("0967");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find-index.js
var es_array_find_index = __webpack_require__("c740");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
var es_array_splice = __webpack_require__("a434");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("d882");

// CONCATENATED MODULE: ./node_modules/quasar/src/utils/private/vm.js
function getVmOfNode(el) {
  for (var node = el; node !== null; node = node.parentNode) {
    // node.__vue__ can be null if the instance was destroyed
    if (node.__vue__ !== void 0) {
      return node.__vue__;
    }
  }
}
function isVmChildOf(childVm, parentVm) {
  // node.__vue__ can be null if the instance was destroyed
  if (childVm === null || parentVm === null) {
    return null;
  }
  for (var vm = childVm; vm !== void 0; vm = vm.$parent) {
    if (vm === parentVm) {
      return true;
    }
  }
  return false;
}
// CONCATENATED MODULE: ./node_modules/quasar/src/components/menu/ClickOutside.js






var timer;
var notPassiveCapture = utils_event["e" /* listenOpts */].notPassiveCapture,
  passiveCapture = utils_event["e" /* listenOpts */].passiveCapture,
  handlers = {
    click: [],
    focus: []
  };
function hasModalsAbove(node) {
  while ((node = node.nextElementSibling) !== null) {
    if (node.classList.contains('q-dialog--modal')) {
      return true;
    }
  }
  return false;
}
function execHandlers(list, evt) {
  for (var i = list.length - 1; i >= 0; i--) {
    if (list[i](evt) === void 0) {
      return;
    }
  }
}
function globalHandler(evt) {
  clearTimeout(timer);

  // prevent autofocus on body resulting from blur
  if (evt.type === 'focusin' && (Platform["a" /* client */].is.ie === true && evt.target === document.body || evt.target.hasAttribute('tabindex') === true)) {
    timer = setTimeout(function () {
      execHandlers(handlers.focus, evt);
    }, Platform["a" /* client */].is.ie === true ? 500 : 200);
  } else {
    execHandlers(handlers.click, evt);
  }
}
/* harmony default export */ var ClickOutside = ({
  name: 'click-outside',
  bind: function bind(el, _ref, vnode) {
    var value = _ref.value,
      arg = _ref.arg;
    var vmEl = vnode.componentInstance || vnode.context;
    var ctx = {
      trigger: value,
      toggleEl: arg,
      handler: function handler(evt) {
        var target = evt.target;
        if (evt.qClickOutside !== true && document.body.contains(target) === true && target.nodeType !== 8 &&
        // directives that prevent click by using pointer-events none generate click on html element
        target !== document.documentElement && target.classList.contains('no-pointer-events') === false && hasModalsAbove(el) !== true && (ctx.toggleEl === void 0 || ctx.toggleEl.contains(target) === false) && (target === document.body || isVmChildOf(getVmOfNode(target), vmEl) === false)) {
          // mark the event as being processed by clickOutside
          // used to prevent refocus after menu close
          evt.qClickOutside = true;
          return ctx.trigger(evt);
        }
      }
    };
    if (el.__qclickoutside) {
      el.__qclickoutside_old = el.__qclickoutside;
    }
    el.__qclickoutside = ctx;
    if (handlers.click.length === 0) {
      document.addEventListener('mousedown', globalHandler, notPassiveCapture);
      document.addEventListener('touchstart', globalHandler, notPassiveCapture);
      document.addEventListener('focusin', globalHandler, passiveCapture);
    }
    handlers.click.push(ctx.handler);
    ctx.timerFocusin = setTimeout(function () {
      handlers.focus.push(ctx.handler);
    }, 500);
  },
  update: function update(el, _ref2) {
    var value = _ref2.value,
      oldValue = _ref2.oldValue,
      arg = _ref2.arg;
    var ctx = el.__qclickoutside;
    if (value !== oldValue) {
      ctx.trigger = value;
    }
    if (arg !== ctx.arg) {
      ctx.toggleEl = arg;
    }
  },
  unbind: function unbind(el) {
    var ctx = el.__qclickoutside_old || el.__qclickoutside;
    if (ctx !== void 0) {
      clearTimeout(ctx.timerFocusin);
      var indexClick = handlers.click.findIndex(function (h) {
          return h === ctx.handler;
        }),
        indexFocus = handlers.focus.findIndex(function (h) {
          return h === ctx.handler;
        });
      indexClick > -1 && handlers.click.splice(indexClick, 1);
      indexFocus > -1 && handlers.focus.splice(indexFocus, 1);
      if (handlers.click.length === 0) {
        clearTimeout(timer);
        document.removeEventListener('mousedown', globalHandler, notPassiveCapture);
        document.removeEventListener('touchstart', globalHandler, notPassiveCapture);
        document.removeEventListener('focusin', globalHandler, passiveCapture);
      }
      delete el[el.__qclickoutside_old ? '__qclickoutside_old' : '__qclickoutside'];
    }
  }
});
// EXTERNAL MODULE: ./node_modules/quasar/src/utils/scroll.js
var utils_scroll = __webpack_require__("0831");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/escape-key.js
var escape_key = __webpack_require__("aff1");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/slot.js
var slot = __webpack_require__("e277");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/focus-manager.js
var focus_manager = __webpack_require__("f6ba");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/position-engine.js
var position_engine = __webpack_require__("2f79");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/menu/QMenu.js


















/* harmony default export */ var QMenu = __webpack_exports__["a"] = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QMenu',
  mixins: [mixins_attrs["b" /* default */], dark["a" /* default */], mixins_anchor["a" /* default */], timeout["a" /* default */], model_toggle["a" /* default */], portal["b" /* default */], transition["a" /* default */]],
  directives: {
    ClickOutside: ClickOutside
  },
  props: {
    persistent: Boolean,
    autoClose: Boolean,
    separateClosePopup: Boolean,
    noRouteDismiss: Boolean,
    noRefocus: Boolean,
    noFocus: Boolean,
    fit: Boolean,
    cover: Boolean,
    square: Boolean,
    anchor: {
      type: String,
      validator: position_engine["d" /* validatePosition */]
    },
    self: {
      type: String,
      validator: position_engine["d" /* validatePosition */]
    },
    offset: {
      type: Array,
      validator: position_engine["c" /* validateOffset */]
    },
    scrollTarget: {
      default: void 0
    },
    touchPosition: Boolean,
    maxHeight: {
      type: String,
      default: null
    },
    maxWidth: {
      type: String,
      default: null
    }
  },
  computed: {
    anchorOrigin: function anchorOrigin() {
      return Object(position_engine["a" /* parsePosition */])(this.anchor || (this.cover === true ? 'center middle' : 'bottom start'), this.$q.lang.rtl);
    },
    selfOrigin: function selfOrigin() {
      return this.cover === true ? this.anchorOrigin : Object(position_engine["a" /* parsePosition */])(this.self || 'top start', this.$q.lang.rtl);
    },
    menuClass: function menuClass() {
      return (this.square === true ? ' q-menu--square' : '') + (this.isDark === true ? ' q-menu--dark q-dark' : '');
    },
    hideOnRouteChange: function hideOnRouteChange() {
      return this.persistent !== true && this.noRouteDismiss !== true;
    },
    onEvents: function onEvents() {
      var on = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.qListeners), {}, {
        // stop propagating these events from children
        input: utils_event["i" /* stop */],
        'popup-show': utils_event["i" /* stop */],
        'popup-hide': utils_event["i" /* stop */]
      });
      if (this.autoClose === true) {
        on.click = this.__onAutoClose;
      }
      return on;
    },
    attrs: function attrs() {
      return Object(objectSpread2["a" /* default */])({
        tabindex: -1,
        role: 'menu'
      }, this.qAttrs);
    }
  },
  methods: {
    focus: function focus() {
      var _this = this;
      Object(focus_manager["a" /* addFocusFn */])(function () {
        var node = _this.__portal !== void 0 && _this.__portal.$refs !== void 0 ? _this.__portal.$refs.inner : void 0;
        if (node !== void 0 && node.contains(document.activeElement) !== true) {
          node = node.querySelector('[autofocus][tabindex], [data-autofocus][tabindex]') || node.querySelector('[autofocus] [tabindex], [data-autofocus] [tabindex]') || node.querySelector('[autofocus], [data-autofocus]') || node;
          node.focus({
            preventScroll: true
          });
        }
      });
    },
    __show: function __show(evt) {
      var _this2 = this;
      // IE can have null document.activeElement
      this.__refocusTarget = Platform["a" /* client */].is.mobile !== true && this.noRefocus === false && document.activeElement !== null ? document.activeElement : void 0;
      escape_key["a" /* default */].register(this, function (escEvt) {
        if (_this2.persistent !== true) {
          _this2.$emit('escape-key');
          _this2.hide(escEvt);
        }
      });
      this.__showPortal();
      this.__configureScrollTarget();
      this.absoluteOffset = void 0;
      if (evt !== void 0 && (this.touchPosition || this.contextMenu)) {
        var pos = Object(utils_event["g" /* position */])(evt);
        if (pos.left !== void 0) {
          var _this$anchorEl$getBou = this.anchorEl.getBoundingClientRect(),
            top = _this$anchorEl$getBou.top,
            left = _this$anchorEl$getBou.left;
          this.absoluteOffset = {
            left: pos.left - left,
            top: pos.top - top
          };
        }
      }
      if (this.unwatch === void 0) {
        this.unwatch = this.$watch(function () {
          return _this2.$q.screen.width + '|' + _this2.$q.screen.height + '|' + _this2.self + '|' + _this2.anchor + '|' + _this2.$q.lang.rtl;
        }, this.updatePosition);
      }
      this.$el.dispatchEvent(Object(utils_event["c" /* create */])('popup-show', {
        bubbles: true
      }));

      // IE can have null document.activeElement
      if (this.noFocus !== true && document.activeElement !== null) {
        document.activeElement.blur();
      }
      this.__registerTick(function () {
        _this2.updatePosition();
        _this2.noFocus !== true && _this2.focus();
      });
      this.__registerTimeout(function () {
        // required in order to avoid the "double-tap needed" issue
        if (_this2.$q.platform.is.ios === true) {
          // if auto-close, then this click should
          // not close the menu
          _this2.__avoidAutoClose = _this2.autoClose;
          _this2.__portal.$el.click();
        }
        _this2.updatePosition();
        _this2.__showPortal(true); // done showing
        _this2.$emit('show', evt);
      }, 300);
    },
    __hide: function __hide(evt) {
      var _this3 = this;
      this.__removeTick();
      this.__anchorCleanup(true);
      this.__hidePortal();

      // check null for IE
      if (this.__refocusTarget !== void 0 && this.__refocusTarget !== null && (
      // menu was hidden from code or ESC plugin
      evt === void 0 ||
      // menu was not closed from a mouse or touch clickOutside
      evt.qClickOutside !== true)) {
        ((evt && evt.type.indexOf('key') === 0 ? this.__refocusTarget.closest('[tabindex]:not([tabindex^="-"])') : void 0) || this.__refocusTarget).focus();
        this.__refocusTarget = void 0;
      }
      this.$el.dispatchEvent(Object(utils_event["c" /* create */])('popup-hide', {
        bubbles: true
      }));

      // should __removeTimeout() if this gets removed
      this.__registerTimeout(function () {
        _this3.__hidePortal(true); // done hiding, now destroy
        _this3.$emit('hide', evt);
      }, 300);
    },
    __anchorCleanup: function __anchorCleanup(hiding) {
      this.absoluteOffset = void 0;
      if (this.unwatch !== void 0) {
        this.unwatch();
        this.unwatch = void 0;
      }
      if (hiding === true || this.showing === true) {
        escape_key["a" /* default */].pop(this);
        this.__unconfigureScrollTarget();
      }
    },
    __unconfigureScrollTarget: function __unconfigureScrollTarget() {
      if (this.__scrollTarget !== void 0) {
        this.__changeScrollEvent(this.__scrollTarget);
        this.__scrollTarget = void 0;
      }
    },
    __configureScrollTarget: function __configureScrollTarget() {
      if (this.anchorEl !== void 0 || this.scrollTarget !== void 0) {
        this.__scrollTarget = Object(utils_scroll["c" /* getScrollTarget */])(this.anchorEl, this.scrollTarget);
        this.__changeScrollEvent(this.__scrollTarget, this.updatePosition);
      }
    },
    __onAutoClose: function __onAutoClose(e) {
      // if auto-close, then the ios double-tap fix which
      // issues a click should not close the menu
      if (this.__avoidAutoClose !== true) {
        Object(portal["a" /* closePortalMenus */])(this, e);
        this.qListeners.click !== void 0 && this.$emit('click', e);
      } else {
        this.__avoidAutoClose = false;
      }
    },
    updatePosition: function updatePosition() {
      if (this.anchorEl === void 0 || this.__portal === void 0) {
        return;
      }
      var el = this.__portal.$el;
      if (el.nodeType === 8) {
        // IE replaces the comment with delay
        setTimeout(this.updatePosition, 25);
        return;
      }
      Object(position_engine["b" /* setPosition */])({
        el: el,
        offset: this.offset,
        anchorEl: this.anchorEl,
        anchorOrigin: this.anchorOrigin,
        selfOrigin: this.selfOrigin,
        absoluteOffset: this.absoluteOffset,
        fit: this.fit,
        cover: this.cover,
        maxHeight: this.maxHeight,
        maxWidth: this.maxWidth
      });
    },
    __onClickOutside: function __onClickOutside(e) {
      if (this.persistent !== true && this.showing === true) {
        var targetClassList = e.target.classList;
        Object(portal["a" /* closePortalMenus */])(this, e);
        if (
        // always prevent touch event
        e.type === 'touchstart' ||
        // prevent click if it's on a dialog backdrop
        targetClassList.contains('q-dialog__backdrop')) {
          Object(utils_event["k" /* stopAndPreventClick */])(e);
        }
        return true;
      }
    },
    __renderPortal: function __renderPortal(h) {
      return h('transition', {
        props: Object(objectSpread2["a" /* default */])({}, this.transitionProps)
      }, [this.showing === true ? h('div', {
        ref: 'inner',
        staticClass: 'q-menu q-position-engine scroll' + this.menuClass,
        class: this.contentClass,
        style: this.contentStyle,
        attrs: this.attrs,
        on: this.onEvents,
        directives: [{
          name: 'click-outside',
          value: this.__onClickOutside,
          arg: this.anchorEl
        }]
      }, Object(slot["c" /* slot */])(this, 'default')) : null]);
    }
  },
  created: function created() {
    this.__useTick('__registerTick', '__removeTick');
    this.__useTimeout('__registerTimeout');
  },
  mounted: function mounted() {
    this.__processModelChange(this.value);
  },
  beforeDestroy: function beforeDestroy() {
    this.__refocusTarget = void 0;

    // When the menu is destroyed while open we can only emit the event on anchorEl
    if (this.showing === true && this.anchorEl !== void 0) {
      this.anchorEl.dispatchEvent(Object(utils_event["c" /* create */])('popup-hide', {
        bubbles: true
      }));
    }
  }
}));

/***/ }),

/***/ "4e82":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("e330");
var aCallable = __webpack_require__("59ed");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");
var deletePropertyOrThrow = __webpack_require__("083a");
var toString = __webpack_require__("577e");
var fails = __webpack_require__("d039");
var internalSort = __webpack_require__("addb");
var arrayMethodIsStrict = __webpack_require__("a640");
var FF = __webpack_require__("04d1");
var IE_OR_EDGE = __webpack_require__("d998");
var V8 = __webpack_require__("2d00");
var WEBKIT = __webpack_require__("512c");

var test = [];
var nativeSort = uncurryThis(test.sort);
var push = uncurryThis(test.push);

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var STABLE_SORT = !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;

  var result = '';
  var code, chr, value, index;

  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66: case 69: case 70: case 72: value = 3; break;
      case 68: case 71: value = 4; break;
      default: value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }

  test.sort(function (a, b) { return b.v - a.v; });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString(x) > toString(y) ? 1 : -1;
  };
};

// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);

    var array = toObject(this);

    if (STABLE_SORT) return comparefn === undefined ? nativeSort(array) : nativeSort(array, comparefn);

    var items = [];
    var arrayLength = lengthOfArrayLike(array);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) push(items, array[index]);
    }

    internalSort(items, getSortCompare(comparefn));

    itemsLength = lengthOfArrayLike(items);
    index = 0;

    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) deletePropertyOrThrow(array, index++);

    return array;
  }
});


/***/ }),

/***/ "4ea1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayWith = __webpack_require__("d429");
var ArrayBufferViewCore = __webpack_require__("ebb5");
var isBigIntArray = __webpack_require__("bcbf");
var toIntegerOrInfinity = __webpack_require__("5926");
var toBigInt = __webpack_require__("f495");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var PROPER_ORDER = !!function () {
  try {
    // eslint-disable-next-line no-throw-literal, es/no-typed-arrays, es/no-array-prototype-with -- required for testing
    new Int8Array(1)['with'](2, { valueOf: function () { throw 8; } });
  } catch (error) {
    // some early implementations, like WebKit, does not follow the final semantic
    // https://github.com/tc39/proposal-change-array-by-copy/pull/86
    return error === 8;
  }
}();

// `%TypedArray%.prototype.with` method
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with
exportTypedArrayMethod('with', { 'with': function (index, value) {
  var O = aTypedArray(this);
  var relativeIndex = toIntegerOrInfinity(index);
  var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;
  return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);
} }['with'], !PROPER_ORDER);


/***/ }),

/***/ "4ec9":
/***/ (function(module, exports, __webpack_require__) {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__("6f48");


/***/ }),

/***/ "4fad":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var isObject = __webpack_require__("861d");
var classof = __webpack_require__("c6b6");
var ARRAY_BUFFER_NON_EXTENSIBLE = __webpack_require__("d86b");

// eslint-disable-next-line es/no-object-isextensible -- safe
var $isExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { $isExtensible(1); });

// `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible
module.exports = (FAILS_ON_PRIMITIVES || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {
  if (!isObject(it)) return false;
  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof(it) == 'ArrayBuffer') return false;
  return $isExtensible ? $isExtensible(it) : true;
} : $isExtensible;


/***/ }),

/***/ "5087":
/***/ (function(module, exports, __webpack_require__) {

var isConstructor = __webpack_require__("68ee");
var tryToString = __webpack_require__("0d51");

var $TypeError = TypeError;

// `Assert: IsConstructor(argument) is true`
module.exports = function (argument) {
  if (isConstructor(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a constructor');
};


/***/ }),

/***/ "50c4":
/***/ (function(module, exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__("5926");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "512c":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");

var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

module.exports = !!webkit && +webkit[1];


/***/ }),

/***/ "518b":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("56b3"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("fortran", function() {
  function words(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i]] = true;
    }
    return keys;
  }

  var keywords = words([
                  "abstract", "accept", "allocatable", "allocate",
                  "array", "assign", "asynchronous", "backspace",
                  "bind", "block", "byte", "call", "case",
                  "class", "close", "common", "contains",
                  "continue", "cycle", "data", "deallocate",
                  "decode", "deferred", "dimension", "do",
                  "elemental", "else", "encode", "end",
                  "endif", "entry", "enumerator", "equivalence",
                  "exit", "external", "extrinsic", "final",
                  "forall", "format", "function", "generic",
                  "go", "goto", "if", "implicit", "import", "include",
                  "inquire", "intent", "interface", "intrinsic",
                  "module", "namelist", "non_intrinsic",
                  "non_overridable", "none", "nopass",
                  "nullify", "open", "optional", "options",
                  "parameter", "pass", "pause", "pointer",
                  "print", "private", "program", "protected",
                  "public", "pure", "read", "recursive", "result",
                  "return", "rewind", "save", "select", "sequence",
                  "stop", "subroutine", "target", "then", "to", "type",
                  "use", "value", "volatile", "where", "while",
                  "write"]);
  var builtins = words(["abort", "abs", "access", "achar", "acos",
                          "adjustl", "adjustr", "aimag", "aint", "alarm",
                          "all", "allocated", "alog", "amax", "amin",
                          "amod", "and", "anint", "any", "asin",
                          "associated", "atan", "besj", "besjn", "besy",
                          "besyn", "bit_size", "btest", "cabs", "ccos",
                          "ceiling", "cexp", "char", "chdir", "chmod",
                          "clog", "cmplx", "command_argument_count",
                          "complex", "conjg", "cos", "cosh", "count",
                          "cpu_time", "cshift", "csin", "csqrt", "ctime",
                          "c_funloc", "c_loc", "c_associated", "c_null_ptr",
                          "c_null_funptr", "c_f_pointer", "c_null_char",
                          "c_alert", "c_backspace", "c_form_feed",
                          "c_new_line", "c_carriage_return",
                          "c_horizontal_tab", "c_vertical_tab", "dabs",
                          "dacos", "dasin", "datan", "date_and_time",
                          "dbesj", "dbesj", "dbesjn", "dbesy", "dbesy",
                          "dbesyn", "dble", "dcos", "dcosh", "ddim", "derf",
                          "derfc", "dexp", "digits", "dim", "dint", "dlog",
                          "dlog", "dmax", "dmin", "dmod", "dnint",
                          "dot_product", "dprod", "dsign", "dsinh",
                          "dsin", "dsqrt", "dtanh", "dtan", "dtime",
                          "eoshift", "epsilon", "erf", "erfc", "etime",
                          "exit", "exp", "exponent", "extends_type_of",
                          "fdate", "fget", "fgetc", "float", "floor",
                          "flush", "fnum", "fputc", "fput", "fraction",
                          "fseek", "fstat", "ftell", "gerror", "getarg",
                          "get_command", "get_command_argument",
                          "get_environment_variable", "getcwd",
                          "getenv", "getgid", "getlog", "getpid",
                          "getuid", "gmtime", "hostnm", "huge", "iabs",
                          "iachar", "iand", "iargc", "ibclr", "ibits",
                          "ibset", "ichar", "idate", "idim", "idint",
                          "idnint", "ieor", "ierrno", "ifix", "imag",
                          "imagpart", "index", "int", "ior", "irand",
                          "isatty", "ishft", "ishftc", "isign",
                          "iso_c_binding", "is_iostat_end", "is_iostat_eor",
                          "itime", "kill", "kind", "lbound", "len", "len_trim",
                          "lge", "lgt", "link", "lle", "llt", "lnblnk", "loc",
                          "log", "logical", "long", "lshift", "lstat", "ltime",
                          "matmul", "max", "maxexponent", "maxloc", "maxval",
                          "mclock", "merge", "move_alloc", "min", "minexponent",
                          "minloc", "minval", "mod", "modulo", "mvbits",
                          "nearest", "new_line", "nint", "not", "or", "pack",
                          "perror", "precision", "present", "product", "radix",
                          "rand", "random_number", "random_seed", "range",
                          "real", "realpart", "rename", "repeat", "reshape",
                          "rrspacing", "rshift", "same_type_as", "scale",
                          "scan", "second", "selected_int_kind",
                          "selected_real_kind", "set_exponent", "shape",
                          "short", "sign", "signal", "sinh", "sin", "sleep",
                          "sngl", "spacing", "spread", "sqrt", "srand", "stat",
                          "sum", "symlnk", "system", "system_clock", "tan",
                          "tanh", "time", "tiny", "transfer", "transpose",
                          "trim", "ttynam", "ubound", "umask", "unlink",
                          "unpack", "verify", "xor", "zabs", "zcos", "zexp",
                          "zlog", "zsin", "zsqrt"]);

    var dataTypes =  words(["c_bool", "c_char", "c_double", "c_double_complex",
                     "c_float", "c_float_complex", "c_funptr", "c_int",
                     "c_int16_t", "c_int32_t", "c_int64_t", "c_int8_t",
                     "c_int_fast16_t", "c_int_fast32_t", "c_int_fast64_t",
                     "c_int_fast8_t", "c_int_least16_t", "c_int_least32_t",
                     "c_int_least64_t", "c_int_least8_t", "c_intmax_t",
                     "c_intptr_t", "c_long", "c_long_double",
                     "c_long_double_complex", "c_long_long", "c_ptr",
                     "c_short", "c_signed_char", "c_size_t", "character",
                     "complex", "double", "integer", "logical", "real"]);
  var isOperatorChar = /[+\-*&=<>\/\:]/;
  var litOperator = /^\.(and|or|eq|lt|le|gt|ge|ne|not|eqv|neqv)\./i;

  function tokenBase(stream, state) {

    if (stream.match(litOperator)){
        return 'operator';
    }

    var ch = stream.next();
    if (ch == "!") {
      stream.skipToEnd();
      return "comment";
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]\(\),]/.test(ch)) {
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    var word = stream.current().toLowerCase();

    if (keywords.hasOwnProperty(word)){
            return 'keyword';
    }
    if (builtins.hasOwnProperty(word) || dataTypes.hasOwnProperty(word)) {
            return 'builtin';
    }
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) {
            end = true;
            break;
        }
        escaped = !escaped && next == "\\";
      }
      if (end || !escaped) state.tokenize = null;
      return "string";
    };
  }

  // Interface

  return {
    startState: function() {
      return {tokenize: null};
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      return style;
    }
  };
});

CodeMirror.defineMIME("text/x-fortran", "fortran");

});


/***/ }),

/***/ "51eb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__("825a");
var ordinaryToPrimitive = __webpack_require__("485a");

var $TypeError = TypeError;

// `Date.prototype[@@toPrimitive](hint)` method implementation
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
module.exports = function (hint) {
  anObject(this);
  if (hint === 'string' || hint === 'default') hint = 'string';
  else if (hint !== 'number') throw $TypeError('Incorrect hint');
  return ordinaryToPrimitive(this, hint);
};


/***/ }),

/***/ "5319":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var apply = __webpack_require__("2ba4");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var fails = __webpack_require__("d039");
var anObject = __webpack_require__("825a");
var isCallable = __webpack_require__("1626");
var isNullOrUndefined = __webpack_require__("7234");
var toIntegerOrInfinity = __webpack_require__("5926");
var toLength = __webpack_require__("50c4");
var toString = __webpack_require__("577e");
var requireObjectCoercible = __webpack_require__("1d80");
var advanceStringIndex = __webpack_require__("8aa5");
var getMethod = __webpack_require__("dc4a");
var getSubstitution = __webpack_require__("0cb2");
var regExpExec = __webpack_require__("14c3");
var wellKnownSymbol = __webpack_require__("b622");

var REPLACE = wellKnownSymbol('replace');
var max = Math.max;
var min = Math.min;
var concat = uncurryThis([].concat);
var push = uncurryThis([].push);
var stringIndexOf = uncurryThis(''.indexOf);
var stringSlice = uncurryThis(''.slice);

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  // eslint-disable-next-line regexp/no-useless-dollar-replacements -- false positive
  return ''.replace(re, '$<a>') !== '7';
});

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = isNullOrUndefined(searchValue) ? undefined : getMethod(searchValue, REPLACE);
      return replacer
        ? call(replacer, searchValue, O, replaceValue)
        : call(nativeReplace, toString(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (string, replaceValue) {
      var rx = anObject(this);
      var S = toString(string);

      if (
        typeof replaceValue == 'string' &&
        stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 &&
        stringIndexOf(replaceValue, '$<') === -1
      ) {
        var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
        if (res.done) return res.value;
      }

      var functionalReplace = isCallable(replaceValue);
      if (!functionalReplace) replaceValue = toString(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        push(results, result);
        if (!global) break;

        var matchStr = toString(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = toString(result[0]);
        var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) push(captures, maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = concat([matched], captures, position, S);
          if (namedCaptures !== undefined) push(replacerArgs, namedCaptures);
          var replacement = toString(apply(replaceValue, undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + stringSlice(S, nextSourcePosition);
    }
  ];
}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);


/***/ }),

/***/ "5352":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__("e260");
var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var DESCRIPTORS = __webpack_require__("83ab");
var USE_NATIVE_URL = __webpack_require__("f354");
var defineBuiltIn = __webpack_require__("cb2d");
var defineBuiltInAccessor = __webpack_require__("edd0");
var defineBuiltIns = __webpack_require__("6964");
var setToStringTag = __webpack_require__("d44e");
var createIteratorConstructor = __webpack_require__("dcc3");
var InternalStateModule = __webpack_require__("69f3");
var anInstance = __webpack_require__("19aa");
var isCallable = __webpack_require__("1626");
var hasOwn = __webpack_require__("1a2d");
var bind = __webpack_require__("0366");
var classof = __webpack_require__("f5df");
var anObject = __webpack_require__("825a");
var isObject = __webpack_require__("861d");
var $toString = __webpack_require__("577e");
var create = __webpack_require__("7c73");
var createPropertyDescriptor = __webpack_require__("5c6c");
var getIterator = __webpack_require__("9a1f");
var getIteratorMethod = __webpack_require__("35a1");
var validateArgumentsLength = __webpack_require__("d6d6");
var wellKnownSymbol = __webpack_require__("b622");
var arraySort = __webpack_require__("addb");

var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Avoid NodeJS experimental warning
var safeGetBuiltIn = function (name) {
  if (!DESCRIPTORS) return global[name];
  var descriptor = getOwnPropertyDescriptor(global, name);
  return descriptor && descriptor.value;
};

var nativeFetch = safeGetBuiltIn('fetch');
var NativeRequest = safeGetBuiltIn('Request');
var Headers = safeGetBuiltIn('Headers');
var RequestPrototype = NativeRequest && NativeRequest.prototype;
var HeadersPrototype = Headers && Headers.prototype;
var RegExp = global.RegExp;
var TypeError = global.TypeError;
var decodeURIComponent = global.decodeURIComponent;
var encodeURIComponent = global.encodeURIComponent;
var charAt = uncurryThis(''.charAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var shift = uncurryThis([].shift);
var splice = uncurryThis([].splice);
var split = uncurryThis(''.split);
var stringSlice = uncurryThis(''.slice);

var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function (bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function (sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function (it) {
  var result = replace(it, plus, ' ');
  var bytes = 4;
  try {
    return decodeURIComponent(result);
  } catch (error) {
    while (bytes) {
      result = replace(result, percentSequence(bytes--), percentDecode);
    }
    return result;
  }
};

var find = /[!'()~]|%20/g;

var replacements = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replacements[match];
};

var serialize = function (it) {
  return replace(encodeURIComponent(it), find, replacer);
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  } return step;
}, true);

var URLSearchParamsState = function (init) {
  this.entries = [];
  this.url = null;

  if (init !== undefined) {
    if (isObject(init)) this.parseObject(init);
    else this.parseQuery(typeof init == 'string' ? charAt(init, 0) === '?' ? stringSlice(init, 1) : init : $toString(init));
  }
};

URLSearchParamsState.prototype = {
  type: URL_SEARCH_PARAMS,
  bindURL: function (url) {
    this.url = url;
    this.update();
  },
  parseObject: function (object) {
    var iteratorMethod = getIteratorMethod(object);
    var iterator, next, step, entryIterator, entryNext, first, second;

    if (iteratorMethod) {
      iterator = getIterator(object, iteratorMethod);
      next = iterator.next;
      while (!(step = call(next, iterator)).done) {
        entryIterator = getIterator(anObject(step.value));
        entryNext = entryIterator.next;
        if (
          (first = call(entryNext, entryIterator)).done ||
          (second = call(entryNext, entryIterator)).done ||
          !call(entryNext, entryIterator).done
        ) throw TypeError('Expected sequence with length 2');
        push(this.entries, { key: $toString(first.value), value: $toString(second.value) });
      }
    } else for (var key in object) if (hasOwn(object, key)) {
      push(this.entries, { key: key, value: $toString(object[key]) });
    }
  },
  parseQuery: function (query) {
    if (query) {
      var attributes = split(query, '&');
      var index = 0;
      var attribute, entry;
      while (index < attributes.length) {
        attribute = attributes[index++];
        if (attribute.length) {
          entry = split(attribute, '=');
          push(this.entries, {
            key: deserialize(shift(entry)),
            value: deserialize(join(entry, '='))
          });
        }
      }
    }
  },
  serialize: function () {
    var entries = this.entries;
    var result = [];
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      push(result, serialize(entry.key) + '=' + serialize(entry.value));
    } return join(result, '&');
  },
  update: function () {
    this.entries.length = 0;
    this.parseQuery(this.url.query);
  },
  updateURL: function () {
    if (this.url) this.url.update();
  }
};

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsPrototype);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var state = setInternalState(this, new URLSearchParamsState(init));
  if (!DESCRIPTORS) this.size = state.entries.length;
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

defineBuiltIns(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.append` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength(arguments.length, 2);
    push(state.entries, { key: $toString(name), value: $toString(value) });
    if (!DESCRIPTORS) this.length++;
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name /* , value */) {
    var state = getInternalParamsState(this);
    var length = validateArgumentsLength(arguments.length, 1);
    var entries = state.entries;
    var key = $toString(name);
    var $value = length < 2 ? undefined : arguments[1];
    var value = $value === undefined ? $value : $toString($value);
    var index = 0;
    while (index < entries.length) {
      var entry = entries[index];
      if (entry.key === key && (value === undefined || entry.value === value)) {
        splice(entries, index, 1);
        if (value !== undefined) break;
      } else index++;
    }
    if (!DESCRIPTORS) this.size = entries.length;
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    var entries = getInternalParamsState(this).entries;
    validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    var entries = getInternalParamsState(this).entries;
    validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var result = [];
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) push(result, entries[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name /* , value */) {
    var entries = getInternalParamsState(this).entries;
    var length = validateArgumentsLength(arguments.length, 1);
    var key = $toString(name);
    var $value = length < 2 ? undefined : arguments[1];
    var value = $value === undefined ? $value : $toString($value);
    var index = 0;
    while (index < entries.length) {
      var entry = entries[index++];
      if (entry.key === key && (value === undefined || entry.value === value)) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    var state = getInternalParamsState(this);
    validateArgumentsLength(arguments.length, 1);
    var entries = state.entries;
    var found = false;
    var key = $toString(name);
    var val = $toString(value);
    var index = 0;
    var entry;
    for (; index < entries.length; index++) {
      entry = entries[index];
      if (entry.key === key) {
        if (found) splice(entries, index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) push(entries, { key: key, value: val });
    if (!DESCRIPTORS) this.size = entries.length;
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    arraySort(state.entries, function (a, b) {
      return a.key > b.key ? 1 : -1;
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined);
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
defineBuiltIn(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: 'entries' });

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
defineBuiltIn(URLSearchParamsPrototype, 'toString', function toString() {
  return getInternalParamsState(this).serialize();
}, { enumerable: true });

// `URLSearchParams.prototype.size` getter
// https://github.com/whatwg/url/pull/734
if (DESCRIPTORS) defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
  get: function size() {
    return getInternalParamsState(this).entries.length;
  },
  configurable: true,
  enumerable: true
});

setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

$({ global: true, constructor: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});

// Wrap `fetch` and `Request` for correct work with polyfilled `URLSearchParams`
if (!USE_NATIVE_URL && isCallable(Headers)) {
  var headersHas = uncurryThis(HeadersPrototype.has);
  var headersSet = uncurryThis(HeadersPrototype.set);

  var wrapRequestOptions = function (init) {
    if (isObject(init)) {
      var body = init.body;
      var headers;
      if (classof(body) === URL_SEARCH_PARAMS) {
        headers = init.headers ? new Headers(init.headers) : new Headers();
        if (!headersHas(headers, 'content-type')) {
          headersSet(headers, 'content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
        return create(init, {
          body: createPropertyDescriptor(0, $toString(body)),
          headers: createPropertyDescriptor(0, headers)
        });
      }
    } return init;
  };

  if (isCallable(nativeFetch)) {
    $({ global: true, enumerable: true, dontCallGetSet: true, forced: true }, {
      fetch: function fetch(input /* , init */) {
        return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
      }
    });
  }

  if (isCallable(NativeRequest)) {
    var RequestConstructor = function Request(input /* , init */) {
      anInstance(this, RequestPrototype);
      return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
    };

    RequestPrototype.constructor = RequestConstructor;
    RequestConstructor.prototype = RequestPrototype;

    $({ global: true, constructor: true, dontCallGetSet: true, forced: true }, {
      Request: RequestConstructor
    });
  }
}

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};


/***/ }),

/***/ "5377":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DESCRIPTORS = __webpack_require__("83ab");
var defineBuiltInAccessor = __webpack_require__("edd0");
var regExpFlags = __webpack_require__("ad6d");
var fails = __webpack_require__("d039");

// babel-minify and Closure Compiler transpiles RegExp('.', 'd') -> /./d and it causes SyntaxError
var RegExp = global.RegExp;
var RegExpPrototype = RegExp.prototype;

var FORCED = DESCRIPTORS && fails(function () {
  var INDICES_SUPPORT = true;
  try {
    RegExp('.', 'd');
  } catch (error) {
    INDICES_SUPPORT = false;
  }

  var O = {};
  // modern V8 bug
  var calls = '';
  var expected = INDICES_SUPPORT ? 'dgimsy' : 'gimsy';

  var addGetter = function (key, chr) {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(O, key, { get: function () {
      calls += chr;
      return true;
    } });
  };

  var pairs = {
    dotAll: 's',
    global: 'g',
    ignoreCase: 'i',
    multiline: 'm',
    sticky: 'y'
  };

  if (INDICES_SUPPORT) pairs.hasIndices = 'd';

  for (var key in pairs) addGetter(key, pairs[key]);

  // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
  var result = Object.getOwnPropertyDescriptor(RegExpPrototype, 'flags').get.call(O);

  return result !== expected || calls !== expected;
});

// `RegExp.prototype.flags` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
if (FORCED) defineBuiltInAccessor(RegExpPrototype, 'flags', {
  configurable: true,
  get: regExpFlags
});


/***/ }),

/***/ "53ca":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _typeof; });
/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a4d3");
/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("e01a");
/* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("d28b");
/* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("e260");
/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("3ca3");
/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("ddb0");
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__);







function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

/***/ }),

/***/ "5494":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var uncurryThis = __webpack_require__("e330");
var defineBuiltInAccessor = __webpack_require__("edd0");

var URLSearchParamsPrototype = URLSearchParams.prototype;
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);

// `URLSearchParams.prototype.size` getter
// https://github.com/whatwg/url/pull/734
if (DESCRIPTORS && !('size' in URLSearchParamsPrototype)) {
  defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
    get: function size() {
      var count = 0;
      forEach(this, function () { count++; });
      return count;
    },
    configurable: true,
    enumerable: true
  });
}


/***/ }),

/***/ "54e1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5530");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("14d9");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _mixins_dark_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("b7fa");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("87e8");
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("e277");






var attrs = {
  role: 'alert'
};
/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_2___default.a.extend({
  name: 'QBanner',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], _mixins_dark_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]],
  props: {
    inlineActions: Boolean,
    dense: Boolean,
    rounded: Boolean
  },
  render: function render(h) {
    var actions = Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_5__[/* slot */ "c"])(this, 'action');
    var child = [h('div', {
      staticClass: 'q-banner__avatar col-auto row items-center self-start'
    }, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_5__[/* slot */ "c"])(this, 'avatar')), h('div', {
      staticClass: 'q-banner__content col text-body2'
    }, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_5__[/* slot */ "c"])(this, 'default'))];
    actions !== void 0 && child.push(h('div', {
      staticClass: 'q-banner__actions row items-center justify-end',
      class: "col-".concat(this.inlineActions === true ? 'auto' : 'all')
    }, actions));
    return h('div', {
      staticClass: 'q-banner row items-center',
      class: {
        'q-banner--top-padding': actions !== void 0 && !this.inlineActions,
        'q-banner--dense': this.dense,
        'q-banner--dark q-dark': this.isDark,
        'rounded-borders': this.rounded
      },
      attrs: attrs,
      on: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.qListeners)
    }, child);
  }
}));

/***/ }),

/***/ "5530":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _objectSpread2; });
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("b64b");
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("a4d3");
/* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("4de4");
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("e439");
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptor_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("14d9");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("159b");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("dbb4");
/* harmony import */ var core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptors_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _defineProperty_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("ade3");









function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      Object(_defineProperty_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

/***/ }),

/***/ "5531":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePlayground_vue_vue_type_style_index_0_id_0fa31c20_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("60f9");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePlayground_vue_vue_type_style_index_0_id_0fa31c20_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePlayground_vue_vue_type_style_index_0_id_0fa31c20_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "5692":
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__("c430");
var store = __webpack_require__("c6cd");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.31.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.31.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ "56b3":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

// This is CodeMirror (https://codemirror.net/5), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, (function () { 'use strict';

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\/(\d+)/.exec(userAgent);
  var chrome_version = chrome && +chrome[1];
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt(doc) {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = doc.activeElement;
    } catch(e) {
      activeElement = doc.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function doc(cm) { return cm.display.wrapper.ownerDocument }

  function win(cm) { return doc(cm).defaultView }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind(this.onTimeout, this);
  };
  Delayed.prototype.onTimeout = function (self) {
    self.id = 0;
    if (self.time <= +new Date) {
      self.f();
    } else {
      setTimeout(self.handler, self.time - +new Date);
    }
  };
  Delayed.prototype.set = function (ms, f) {
    this.f = f;
    var time = +new Date + ms;
    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 50;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              at += isRTL;
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map = emitter._handlers || (emitter._handlers = {});
      map[type] = (map[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map = emitter._handlers, arr = map && map[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range;
    try {range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) { return false }
    return range.compareEndPoints("StartToEnd", range) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }

  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }

  // Add a span to a line.
  function addMarkedSpan(line, span, op) {
    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));
    if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
      line.markedSpans.push(span);
    } else {
      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
      if (inThisOp) { inThisOp.add(line.markedSpans); }
    }
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css || attributes) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      gutterWrap.setAttribute("aria-hidden", "true");
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    var isWidget = classTest("CodeMirror-linewidget");
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    if (lineView.rest) {
      for (var i = 0; i < lineView.rest.length; i++)
        { if (lineView.rest[i] == line)
          { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
      for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
        { if (lineNo(lineView.rest[i$1]) > lineN)
          { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
    }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      mStart = map[i];
      mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX(doc) {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(doc.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc.body).marginLeft)) }
    return doc.defaultView.pageXOffset || (doc.documentElement || doc.body).scrollLeft
  }
  function pageScrollY(doc) {
    if (chrome && android) { return -(doc.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc.body).marginTop)) }
    return doc.defaultView.pageYOffset || (doc.documentElement || doc.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var ref = visualLine(lineObj);
    var widgets = ref.widgets;
    var height = 0;
    if (widgets) { for (var i = 0; i < widgets.length; ++i) { if (widgets[i].above)
      { height += widgetHeight(widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY(doc(cm)));
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX(doc(cm)));
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX(doc(cm));
      top -= pageScrollY(doc(cm));
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = outside; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight; box.bottom += widgetHeight;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e$1) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    var customCursor = cm.options.$customCursor;
    if (customCursor) { primary = true; }
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range = doc.sel.ranges[i];
      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
      var collapsed = range.empty();
      if (customCursor) {
        var head = customCursor(cm, range);
        if (head) { drawSelectionCursor(cm, head, curFragment); }
      } else if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range.head, curFragment);
      }
      if (!collapsed)
        { drawSelectionRange(cm, range, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
      var charPos = charCoords(cm, head, "div", null, null);
      var width = charPos.right - charPos.left;
      cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
    }

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () {
        if (!cm.hasFocus()) { onBlur(cm); }
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.hasFocus()) {
      cm.display.input.focus();
      if (!cm.state.focused) { onFocus(cm); }
    }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      if (cm.state.focused) { onBlur(cm); }
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
    var oldHeight = display.lineDiv.getBoundingClientRect().top;
    var mustScroll = 0;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      oldHeight += cur.line.height;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        if (oldHeight < viewTop) { mustScroll -= diff; }
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
    if (Math.abs(mustScroll) > 2) { display.scroller.scrollTop += mustScroll; }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    var doc = display.wrapper.ownerDocument;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (doc.defaultView.innerHeight || doc.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
    var screenw = displayWidth(cm) - display.gutters.offsetWidth;
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      scrollToCoordsRange(cm, from, to, range.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.scrollTop = 0;
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.visibility = this.vert.style.visibility = "hidden";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.visibility = "";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt != bar) { bar.style.visibility = "hidden"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId,          // Unique ID
      markArrays: null         // Used by addMarkedSpan
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt(doc(cm));
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt(doc(cm));
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = win(cm).getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(snapshot.activeElt.ownerDocument)) { return }
    snapshot.activeElt.focus();
    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&
        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var doc = snapshot.activeElt.ownerDocument;
      var sel = doc.defaultView.getSelection(), range = doc.createRange();
      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      } else if (first) {
        update.visible = visibleLines(cm.display, cm.doc, viewport);
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
    // Send an event to consumers responding to changes in gutter width.
    signalLater(display, "gutterChanged", display);
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({className: name, style: style});
    }
    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
    // See #6982. FIXME remove when this has been fixed for a while in Chrome
    if (chrome && chrome_version >= 105) { d.wrapper.style.clipPath = "inset(0px)"; }

    // This attribute is respected by automatic translation systems such as Google Translate,
    // and may also be respected by tools used by human translators.
    d.wrapper.setAttribute('translate', 'no');

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    // On Chrome 102, viewport updates somehow stop wheel-based
    // scrolling. Turning off pointer events during the scroll seems
    // to avoid the issue.
    if (chrome && chrome_version == 102) {
      if (cm.display.chromeScrollHack == null) { cm.display.sizer.style.pointerEvents = "none"; }
      else { clearTimeout(cm.display.chromeScrollHack); }
      cm.display.chromeScrollHack = setTimeout(function () {
        cm.display.chromeScrollHack = null;
        cm.display.sizer.style.pointerEvents = "";
      }, 100);
    }
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
    var pixelsPerUnit = wheelPixelsPerUnit;
    if (e.deltaMode === 0) {
      dx = e.deltaX;
      dy = e.deltaY;
      pixelsPerUnit = 1;
    }

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && pixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && pixelsPerUnit != null) {
      var pixels = dy * pixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20 && e.deltaMode !== 0) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
    for (var i = 0; i < this.ranges.length; i++)
      { if (!this.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    cm.options.direction = doc.direction;
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(prev) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = prev ? prev.undoDepth : Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor")
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = range.head == range.anchor ? newAnchor : skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;

      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
      // is with selectLeft/Right
      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? preventCursorRight : preventCursorLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? preventCursorLeft : preventCursorRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
      { doc.cantEdit = false; }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        { if (op(this.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this; }
  };

  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      if (lineSep === '') { return lines.join('') }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range.head; }
      else if (start == "anchor") { pos = range.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }
      else { pos = range.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head || ranges[i].anchor)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {
      var this$1 = this;

      this.history = new History(this.history);
      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);
    },

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
                span.from == null && lineNo != from.line ||
                span.from != null && lineNo == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) { continue }
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var markAsReadAndPasteIfAllFilesAreRead = function () {
        if (++read == n) {
          operation(cm, function () {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(
                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
          })();
        }
      };
      var readTextFromFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          markAsReadAndPasteIfAllFilesAreRead();
          return
        }
        var reader = new FileReader;
        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };
        reader.onload = function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            markAsReadAndPasteIfAllFilesAreRead();
            return
          }
          text[i] = content;
          markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e$1){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars", "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        { return lookupKey(key, map.fallthrough, handle, context) }
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      if (cm.doc.direction == "rtl") { dir = -dir; }
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "codepoint"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    cm.curOp.focus = activeElt(doc(cm));
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }
    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)
      { document.execCommand("cut"); }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    win(cm).focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(doc(cm)); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      if (cm.state.delayingBlurEvent) {
        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }
        else { delayBlurEvent(cm); }
      }
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if ((webkit && !safari) || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    cm.state.delayingBlurEvent = true;
    setTimeout(function () { return display.input.focus(); }, 20);
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    if (ie) { delayBlurEvent(cm); }
    var display = cm.display, doc$1 = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc$1.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc$1.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc$1.sel.primary();
      ourIndex = doc$1.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }
      else
        { ourRange = range; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc$1, new Selection([ourRange], 0), sel_mouse);
      startSel = doc$1.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc$1, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc$1, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc$1.sel;
    } else {
      replaceOneSelection(doc$1, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc$1, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc$1, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc$1, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc$1, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range.anchor, anchor) > 0) {
          head = range.head;
          anchor = minPos(oldRange.from(), range.anchor);
        } else {
          head = range.anchor;
          anchor = maxPos(oldRange.to(), range.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc$1, anchor), head));
        setSelection(doc$1, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt(doc(cm));
        extendTo(cur);
        var visible = visibleLines(display, doc$1);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc$1.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range) {
    var anchor = range.anchor;
    var head = range.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
    var order = getOrder(anchorLine);
    if (!order) { return range }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e$1) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });

    option("screenReaderLabel", null, function (cm, val) {
      val = (val === '') ? null : val;
      cm.display.input.screenReaderLabelChanged(val);
    });

    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(function () {
        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }
      }, 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });
    on(d.input.getField(), "contextmenu", function (e) {
      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }
    });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range = sel.ranges[i$1];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n"))
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus())
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          { indented = indentLine(cm, range.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "on" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "on" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){win(this).focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
      },
      removeKeyMap: function(map) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map || maps[i].name == map) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this.state.modeGen++;
            regChange(this);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (!range.empty()) {
            var from = range.from(), to = range.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this, j, how); }
            var newRanges = this.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range.head.line > end) {
            indentLine(this, range.head.line, how, true);
            end = range.head.line;
            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range = this.doc.sel.primary();
        if (start == null) { pos = range.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range.from() : range.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range) {
          if (this$1.display.shift || this$1.doc.extend || range.empty())
            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range.from() : range.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range) {
            var other = findPosH(doc, range.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range) {
          if (collapse)
            { return dir < 0 ? range.from() : range.to() }
          var headPos = cursorCoords(this$1, range.head, "div");
          if (range.goalColumn != null) { headPos.left = range.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt(doc(this)) },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range, margin) {
        if (range == null) {
          range = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range == "number") {
          range = {from: Pos(range, 0), to: null};
        } else if (range.from == null) {
          range = {from: range, to: null};
        }
        if (!range.to) { range.to = range.from; }
        range.margin = margin || 0;

        if (range.from.line != null) {
          scrollToRange(this, range);
        } else {
          scrollToCoordsRange(this, range.from, range.to, range.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo = this.display.viewFrom;
        this.doc.iter(lineNo, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
          ++lineNo;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "codepoint", "char", "column" (like char, but
  // doesn't cross line boundaries), "word" (across next word), or
  // "group" (to the start of next group of word or
  // non-word-non-whitespace chars). The visually param controls
  // whether, in right-to-left text, direction 1 means to move towards
  // the next index in the string, or towards the character to the right
  // of the current position. The resulting position will have a
  // hitSide=true property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
    function findNextLine() {
      var l = pos.line + lineDir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (unit == "codepoint") {
        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
        if (isNaN(ch)) {
          next = null;
        } else {
          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;
          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
        }
      } else if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char" || unit == "codepoint") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc(cm).documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    div.contentEditable = true;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    function belongsToInput(e) {
      for (var t = e.target; t; t = t.parentNode) {
        if (t == div) { return true }
        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) { break }
      }
      return false
    }

    on(div, "paste", function (e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      disableBrowserMagic(te);
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = activeElt(div.ownerDocument);
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.div.setAttribute('aria-label', label);
    } else {
      this.div.removeAttribute('aria-label');
    }
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = activeElt(this.div.ownerDocument) == this.div;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || activeElt(this.div.ownerDocument) != this.div)
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
      var this$1 = this;

    var input = this;
    if (this.selectionInEditor())
      { setTimeout(function () { return this$1.pollSelection(); }, 20); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find(0)))
            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
    this.resetting = false;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
    var opts = this.cm.options;
    disableBrowserMagic(this.textarea, opts.spellcheck, opts.autocorrect, opts.autocapitalize);
  };

  TextareaInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.textarea.setAttribute('aria-label', label);
    } else {
      this.textarea.removeAttribute('aria-label');
    }
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing && typing) { return }
    var cm = this.cm;
    this.resetting = true;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
    this.resetting = false;
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt(this.textarea.ownerDocument) != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || this.resetting || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = te.ownerDocument.defaultView.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { te.ownerDocument.defaultView.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
    this.textarea.readOnly = !!val;
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt(textarea.ownerDocument);
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, …*/) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.65.13";

  return CodeMirror;

})));


/***/ }),

/***/ "56ef":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");
var uncurryThis = __webpack_require__("e330");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var anObject = __webpack_require__("825a");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "577e":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("f5df");

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ "57b9":
/***/ (function(module, exports, __webpack_require__) {

var call = __webpack_require__("c65b");
var getBuiltIn = __webpack_require__("d066");
var wellKnownSymbol = __webpack_require__("b622");
var defineBuiltIn = __webpack_require__("cb2d");

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    }, { arity: 1 });
  }
};


/***/ }),

/***/ "582c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("2909");
/* harmony import */ var core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("2ca0");
/* harmony import */ var core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_string_ends_with_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("8a79");
/* harmony import */ var core_js_modules_es_string_ends_with_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_ends_with_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("14d9");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("d81d");
/* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("4de4");
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("caad");
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("a434");
/* harmony import */ var core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("cca6");
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("0967");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("d882");












var getTrue = function getTrue() {
  return true;
};
function filterInvalidPath(path) {
  return typeof path === 'string' && path !== '' && path !== '/' && path !== '#/';
}
function normalizeExitPath(path) {
  path.startsWith('#') === true && (path = path.substr(1));
  path.startsWith('/') === false && (path = '/' + path);
  path.endsWith('/') === true && (path = path.substr(0, path.length - 1));
  return '#' + path;
}
function getShouldExitFn(cfg) {
  if (cfg.backButtonExit === false) {
    return function () {
      return false;
    };
  }
  if (cfg.backButtonExit === '*') {
    return getTrue;
  }

  // Add default root path
  var exitPaths = ['#/'];

  // Add custom exit paths
  Array.isArray(cfg.backButtonExit) === true && exitPaths.push.apply(exitPaths, Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(cfg.backButtonExit.filter(filterInvalidPath).map(normalizeExitPath)));
  return function () {
    return exitPaths.includes(window.location.hash);
  };
}
/* harmony default export */ __webpack_exports__["a"] = ({
  __history: [],
  add: _utils_event_js__WEBPACK_IMPORTED_MODULE_11__[/* noop */ "f"],
  remove: _utils_event_js__WEBPACK_IMPORTED_MODULE_11__[/* noop */ "f"],
  install: function install(cfg) {
    var _this = this;
    if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_10__[/* isSSR */ "e"] === true) {
      return;
    }
    var _client$is = _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_10__[/* client */ "a"].is,
      cordova = _client$is.cordova,
      capacitor = _client$is.capacitor;
    if (cordova !== true && capacitor !== true) {
      return;
    }
    var qConf = cfg[cordova === true ? 'cordova' : 'capacitor'];
    if (qConf !== void 0 && qConf.backButton === false) {
      return;
    }

    // if the '@capacitor/app' plugin is not installed
    // then we got nothing to do
    if (
    // if we're on Capacitor mode
    capacitor === true && (
    // and it's also not in Capacitor's main instance
    window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0)) {
      return;
    }
    this.add = function (entry) {
      if (entry.condition === void 0) {
        entry.condition = getTrue;
      }
      _this.__history.push(entry);
    };
    this.remove = function (entry) {
      var index = _this.__history.indexOf(entry);
      if (index >= 0) {
        _this.__history.splice(index, 1);
      }
    };
    var shouldExit = getShouldExitFn(Object.assign({
      backButtonExit: true
    }, qConf));
    var backHandler = function backHandler() {
      if (_this.__history.length) {
        var entry = _this.__history[_this.__history.length - 1];
        if (entry.condition() === true) {
          _this.__history.pop();
          entry.handler();
        }
      } else if (shouldExit() === true) {
        navigator.app.exitApp();
      } else {
        window.history.back();
      }
    };
    if (cordova === true) {
      document.addEventListener('deviceready', function () {
        document.addEventListener('backbutton', backHandler, false);
      });
    } else {
      window.Capacitor.Plugins.App.addListener('backButton', backHandler);
    }
  }
});

/***/ }),

/***/ "5899":
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "58a8":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var requireObjectCoercible = __webpack_require__("1d80");
var toString = __webpack_require__("577e");
var whitespaces = __webpack_require__("5899");

var replace = uncurryThis(''.replace);
var ltrim = RegExp('^[' + whitespaces + ']+');
var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = toString(requireObjectCoercible($this));
    if (TYPE & 1) string = replace(string, ltrim, '');
    if (TYPE & 2) string = replace(string, rtrim, '$1');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "5926":
/***/ (function(module, exports, __webpack_require__) {

var trunc = __webpack_require__("b42e");

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ "59ed":
/***/ (function(module, exports, __webpack_require__) {

var isCallable = __webpack_require__("1626");
var tryToString = __webpack_require__("0d51");

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "5a34":
/***/ (function(module, exports, __webpack_require__) {

var isRegExp = __webpack_require__("44e7");

var $TypeError = TypeError;

module.exports = function (it) {
  if (isRegExp(it)) {
    throw $TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ "5a47":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var NATIVE_SYMBOL = __webpack_require__("04f8");
var fails = __webpack_require__("d039");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var toObject = __webpack_require__("7b0b");

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});


/***/ }),

/***/ "5c6c":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "5cc6":
/***/ (function(module, exports, __webpack_require__) {

var createTypedArrayConstructor = __webpack_require__("74e8");

// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "5cfd":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "5df4":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_ErrorTip_vue_vue_type_style_index_0_id_67eb593e_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("6a66");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_ErrorTip_vue_vue_type_style_index_0_id_67eb593e_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_ErrorTip_vue_vue_type_style_index_0_id_67eb593e_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "5e77":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var hasOwn = __webpack_require__("1a2d");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "5e79":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = __webpack_require__("7037").default;
__webpack_require__("ac1f");
__webpack_require__("00b4");
__webpack_require__("466d");
__webpack_require__("5319");
__webpack_require__("4d63");
__webpack_require__("c607");
__webpack_require__("2c3e");
__webpack_require__("25f0");
__webpack_require__("14d9");
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function (mod) {
  if (( false ? undefined : _typeof(exports)) == "object" && ( false ? undefined : _typeof(module)) == "object")
    // CommonJS
    mod(__webpack_require__("56b3"));else if (true)
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("56b3")], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else
    // Plain browser env
    {}
})(function (CodeMirror) {
  "use strict";

  CodeMirror.defineMode("clike", function (config, parserConfig) {
    var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      keywords = parserConfig.keywords || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings,
      indentStatements = parserConfig.indentStatements !== false;
    var isOperatorChar = /[+\-*&%=<>!?|\/]/;
    var curPunc;
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (hooks[ch]) {
        var result = hooks[ch](stream, state);
        if (result !== false) return result;
      }
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      }
      if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        curPunc = ch;
        return null;
      }
      if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        }
        if (stream.eat("/")) {
          stream.skipToEnd();
          return "comment";
        }
      }
      if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
      stream.eatWhile(/[\w\$_\xa1-\uffff]/);
      var cur = stream.current();
      if (keywords.propertyIsEnumerable(cur)) {
        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
        return "keyword";
      }
      if (builtin.propertyIsEnumerable(cur)) {
        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
        return "builtin";
      }
      if (atoms.propertyIsEnumerable(cur)) return "atom";
      return "variable";
    }
    function tokenString(quote) {
      return function (stream, state) {
        var escaped = false,
          next,
          end = false;
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) {
            end = true;
            break;
          }
          escaped = !escaped && next == "\\";
        }
        if (end || !(escaped || multiLineStrings)) state.tokenize = null;
        return "string";
      };
    }
    function tokenComment(stream, state) {
      var maybeEnd = false,
        ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = null;
          break;
        }
        maybeEnd = ch == "*";
      }
      return "comment";
    }
    function Context(indented, column, type, align, prev) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.align = align;
      this.prev = prev;
    }
    function pushContext(state, col, type) {
      var indent = state.indented;
      if (state.context && state.context.type == "statement") indent = state.context.indented;
      return state.context = new Context(indent, col, type, null, state.context);
    }
    function popContext(state) {
      var t = state.context.type;
      if (t == ")" || t == "]" || t == "}") state.indented = state.context.indented;
      return state.context = state.context.prev;
    }

    // Interface

    return {
      startState: function startState(basecolumn) {
        return {
          tokenize: null,
          context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
          indented: 0,
          startOfLine: true
        };
      },
      token: function token(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
          if (ctx.align == null) ctx.align = false;
          state.indented = stream.indentation();
          state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;
        curPunc = null;
        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment" || style == "meta") return style;
        if (ctx.align == null) ctx.align = true;
        if ((curPunc == ";" || curPunc == ":" || curPunc == ",") && ctx.type == "statement") popContext(state);else if (curPunc == "{") pushContext(state, stream.column(), "}");else if (curPunc == "[") pushContext(state, stream.column(), "]");else if (curPunc == "(") pushContext(state, stream.column(), ")");else if (curPunc == "}") {
          while (ctx.type == "statement") ctx = popContext(state);
          if (ctx.type == "}") ctx = popContext(state);
          while (ctx.type == "statement") ctx = popContext(state);
        } else if (curPunc == ctx.type) popContext(state);else if (indentStatements && ((ctx.type == "}" || ctx.type == "top") && curPunc != ';' || ctx.type == "statement" && curPunc == "newstatement")) pushContext(state, stream.column(), "statement");
        state.startOfLine = false;
        return style;
      },
      indent: function indent(state, textAfter) {
        if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;
        var ctx = state.context,
          firstChar = textAfter && textAfter.charAt(0);
        if (ctx.type == "statement" && firstChar == "}") ctx = ctx.prev;
        var closing = firstChar == ctx.type;
        if (ctx.type == "statement") return ctx.indented + (firstChar == "{" ? 0 : statementIndentUnit);else if (ctx.align && (!dontAlignCalls || ctx.type != ")")) return ctx.column + (closing ? 0 : 1);else if (ctx.type == ")" && !closing) return ctx.indented + statementIndentUnit;else return ctx.indented + (closing ? 0 : indentUnit);
      },
      electricChars: "{}",
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      lineComment: "//",
      fold: "brace"
    };
  });
  function words(str) {
    var obj = {},
      words = str.split(" ");
    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var cKeywords = "auto if break int case long char register continue return default short do sizeof " + "double static else struct entry switch extern typedef float union for unsigned " + "goto while enum void const signed volatile";
  function cppHook(stream, state) {
    if (!state.startOfLine) return false;
    for (;;) {
      if (stream.skipTo("\\")) {
        stream.next();
        if (stream.eol()) {
          state.tokenize = cppHook;
          break;
        }
      } else {
        stream.skipToEnd();
        state.tokenize = null;
        break;
      }
    }
    return "meta";
  }
  function cpp11StringHook(stream, state) {
    stream.backUp(1);
    // Raw strings.
    if (stream.match(/(R|u8R|uR|UR|LR)/)) {
      var match = stream.match(/"([^\s\\()]{0,16})\(/);
      if (!match) {
        return false;
      }
      state.cpp11RawStringDelim = match[1];
      state.tokenize = tokenRawString;
      return tokenRawString(stream, state);
    }
    // Unicode strings/chars.
    if (stream.match(/(u8|u|U|L)/)) {
      if (stream.match(/["']/, /* eat */false)) {
        return "string";
      }
      return false;
    }
    // Ignore this hook.
    stream.next();
    return false;
  }

  // C#-style strings where "" escapes a quote.
  function tokenAtString(stream, state) {
    var next;
    while ((next = stream.next()) != null) {
      if (next == '"' && !stream.eat('"')) {
        state.tokenize = null;
        break;
      }
    }
    return "string";
  }

  // C++11 raw string literal is <prefix>"<delim>( anything )<delim>", where
  // <delim> can be a string up to 16 characters long.
  function tokenRawString(stream, state) {
    // Escape characters that have special regex meanings.
    var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, '\\$&');
    var match = stream.match(new RegExp(".*?\\)" + delim + '"'));
    if (match) state.tokenize = null;else stream.skipToEnd();
    return "string";
  }
  function def(mimes, mode) {
    if (typeof mimes == "string") mimes = [mimes];
    var words = [];
    function add(obj) {
      if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop)) words.push(prop);
    }
    add(mode.keywords);
    add(mode.builtin);
    add(mode.atoms);
    if (words.length) {
      mode.helperType = mimes[0];
      CodeMirror.registerHelper("hintWords", mimes[0], words);
    }
    for (var i = 0; i < mimes.length; ++i) CodeMirror.defineMIME(mimes[i], mode);
  }
  def(["x-shader/x-vertex", "x-shader/x-fragment", "text/x-glsl"], {
    name: "clike",
    keywords: words("float int bool void " + "vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 " + "mat2 mat3 mat4 " + "sampler2D sampler3D samplerCube " + "const attribute uniform varying " + "break continue discard return " + "for while do if else struct " + "in out inout"),
    blockKeywords: words("for while do if else struct"),
    builtin: words("radians degrees sin cos tan asin acos atan " + "pow exp log exp2 sqrt inversesqrt " + "abs sign floor ceil fract mod min max clamp mix step smoothstep " + "length distance dot cross normalize faceforward " + "reflect refract matrixCompMult " + "lessThan lessThanEqual greaterThan greaterThanEqual " + "equal notEqual any all not " + "texture2D texture2DLod texture2DProjLod " + "textureCube textureCubeLod "),
    atoms: words("true false " + "gl_FragColor " + "gl_PointCoord " + "gl_Position gl_PointSize " + "gl_FragCoord gl_FrontFacing " + "gl_FragData " + "gl_DepthRangeParameters " + "gl_MaxVertexAttribs gl_MaxVaryingVectors gl_MaxVertexUniformVectors" + "gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits " + "gl_MaxFragmentUniformVectors " + "gl_MaxDrawBuffers"),
    hooks: {
      "#": cppHook
    },
    modeProps: {
      fold: ["brace", "include"]
    }
  });
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("62e4")(module)))

/***/ }),

/***/ "5e7e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var IS_PURE = __webpack_require__("c430");
var IS_NODE = __webpack_require__("605d");
var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var defineBuiltIn = __webpack_require__("cb2d");
var setPrototypeOf = __webpack_require__("d2bb");
var setToStringTag = __webpack_require__("d44e");
var setSpecies = __webpack_require__("2626");
var aCallable = __webpack_require__("59ed");
var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");
var anInstance = __webpack_require__("19aa");
var speciesConstructor = __webpack_require__("4840");
var task = __webpack_require__("2cf4").set;
var microtask = __webpack_require__("b575");
var hostReportErrors = __webpack_require__("44de");
var perform = __webpack_require__("e667");
var Queue = __webpack_require__("01b4");
var InternalStateModule = __webpack_require__("69f3");
var NativePromiseConstructor = __webpack_require__("d256");
var PromiseConstructorDetection = __webpack_require__("4738");
var newPromiseCapabilityModule = __webpack_require__("f069");

var PROMISE = 'Promise';
var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var setInternalState = InternalStateModule.set;
var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
var PromiseConstructor = NativePromiseConstructor;
var PromisePrototype = NativePromisePrototype;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;

var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;

var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && isCallable(then = it.then) ? then : false;
};

var callReaction = function (reaction, state) {
  var value = state.value;
  var ok = state.state == FULFILLED;
  var handler = ok ? reaction.ok : reaction.fail;
  var resolve = reaction.resolve;
  var reject = reaction.reject;
  var domain = reaction.domain;
  var result, then, exited;
  try {
    if (handler) {
      if (!ok) {
        if (state.rejection === UNHANDLED) onHandleUnhandled(state);
        state.rejection = HANDLED;
      }
      if (handler === true) result = value;
      else {
        if (domain) domain.enter();
        result = handler(value); // can throw
        if (domain) {
          domain.exit();
          exited = true;
        }
      }
      if (result === reaction.promise) {
        reject(TypeError('Promise-chain cycle'));
      } else if (then = isThenable(result)) {
        call(then, result, resolve, reject);
      } else resolve(result);
    } else reject(value);
  } catch (error) {
    if (domain && !exited) domain.exit();
    reject(error);
  }
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  microtask(function () {
    var reactions = state.reactions;
    var reaction;
    while (reaction = reactions.get()) {
      callReaction(reaction, state);
    }
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  call(task, global, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          call(then, value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED_PROMISE_CONSTRUCTOR) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromisePrototype);
    aCallable(executor);
    call(Internal, this);
    var state = getInternalPromiseState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };

  PromisePrototype = PromiseConstructor.prototype;

  // eslint-disable-next-line no-unused-vars -- required for `.length`
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: new Queue(),
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  // `Promise.prototype.then` method
  // https://tc39.es/ecma262/#sec-promise.prototype.then
  Internal.prototype = defineBuiltIn(PromisePrototype, 'then', function then(onFulfilled, onRejected) {
    var state = getInternalPromiseState(this);
    var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
    state.parent = true;
    reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
    reaction.fail = isCallable(onRejected) && onRejected;
    reaction.domain = IS_NODE ? process.domain : undefined;
    if (state.state == PENDING) state.reactions.add(reaction);
    else microtask(function () {
      callReaction(reaction, state);
    });
    return reaction.promise;
  });

  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalPromiseState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
    nativeThen = NativePromisePrototype.then;

    if (!NATIVE_PROMISE_SUBCLASSING) {
      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
      defineBuiltIn(NativePromisePrototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          call(nativeThen, that, resolve, reject);
        }).then(onFulfilled, onRejected);
      // https://github.com/zloirock/core-js/issues/640
      }, { unsafe: true });
    }

    // make `.constructor === Promise` work for native promise-based APIs
    try {
      delete NativePromisePrototype.constructor;
    } catch (error) { /* empty */ }

    // make `instanceof Promise` work for native promise-based APIs
    if (setPrototypeOf) {
      setPrototypeOf(NativePromisePrototype, PromisePrototype);
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);


/***/ }),

/***/ "5eed":
/***/ (function(module, exports, __webpack_require__) {

var NativePromiseConstructor = __webpack_require__("d256");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var FORCED_PROMISE_CONSTRUCTOR = __webpack_require__("4738").CONSTRUCTOR;

module.exports = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration(function (iterable) {
  NativePromiseConstructor.all(iterable).then(undefined, function () { /* empty */ });
});


/***/ }),

/***/ "5f96":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var uncurryThis = __webpack_require__("e330");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = uncurryThis([].join);

// `%TypedArray%.prototype.join` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
exportTypedArrayMethod('join', function join(separator) {
  return $join(aTypedArray(this), separator);
});


/***/ }),

/***/ "5fb2":
/***/ (function(module, exports, __webpack_require__) {

// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var uncurryThis = __webpack_require__("e330");

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;

var $RangeError = RangeError;
var exec = uncurryThis(regexSeparators.exec);
var floor = Math.floor;
var fromCharCode = String.fromCharCode;
var charCodeAt = uncurryThis(''.charCodeAt);
var join = uncurryThis([].join);
var push = uncurryThis([].push);
var replace = uncurryThis(''.replace);
var split = uncurryThis(''.split);
var toLowerCase = uncurryThis(''.toLowerCase);

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */
var ucs2decode = function (string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = charCodeAt(string, counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = charCodeAt(string, counter++);
      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
        push(output, ((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        push(output, value);
        counter--;
      }
    } else {
      push(output, value);
    }
  }
  return output;
};

/**
 * Converts a digit/integer into a basic code point.
 */
var digitToBasic = function (digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */
var adapt = function (delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  while (delta > baseMinusTMin * tMax >> 1) {
    delta = floor(delta / baseMinusTMin);
    k += base;
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
var encode = function (input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;

  // Handle the basic code points.
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 0x80) {
      push(output, fromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.
  var handledCPCount = basicLength; // number of code points that have been handled;

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    push(output, delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      throw $RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw $RangeError(OVERFLOW_ERROR);
      }
      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;
        var k = base;
        while (true) {
          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          push(output, fromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor(qMinusT / baseMinusT);
          k += base;
        }

        push(output, fromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        handledCPCount++;
      }
    }

    delta++;
    n++;
  }
  return join(output, '');
};

module.exports = function (input) {
  var encoded = [];
  var labels = split(replace(toLowerCase(input), regexSeparators, '\u002E'), '.');
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    push(encoded, exec(regexNonASCII, label) ? 'xn--' + encode(label) : label);
  }
  return join(encoded, '.');
};


/***/ }),

/***/ "5ff7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isDeepEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isObject; });
/* unused harmony export isDate */
/* unused harmony export isRegexp */
/* unused harmony export isNumber */
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("53ca");
/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("e260");
/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("4ec9");
/* harmony import */ var core_js_modules_es_map_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_map_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("3ca3");
/* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("ddb0");
/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_set_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("6062");
/* harmony import */ var core_js_modules_es_set_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_set_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var core_js_modules_es_array_buffer_constructor_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("c19f");
/* harmony import */ var core_js_modules_es_array_buffer_constructor_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_buffer_constructor_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var core_js_modules_es_array_buffer_slice_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("ace4");
/* harmony import */ var core_js_modules_es_array_buffer_slice_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_buffer_slice_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("4d63");
/* harmony import */ var core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_constructor_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var core_js_modules_es_regexp_dot_all_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("c607");
/* harmony import */ var core_js_modules_es_regexp_dot_all_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_dot_all_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("ac1f");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var core_js_modules_es_regexp_sticky_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("2c3e");
/* harmony import */ var core_js_modules_es_regexp_sticky_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_sticky_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("25f0");
/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__("5377");
/* harmony import */ var core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_flags_js__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__("4de4");
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__("b64b");
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_16__);

















var hasMap = typeof Map === 'function',
  hasSet = typeof Set === 'function',
  hasArrayBuffer = typeof ArrayBuffer === 'function';
function isDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (a !== null && b !== null && Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_typeof_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(a) === 'object' && Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_typeof_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(b) === 'object') {
    if (a.constructor !== b.constructor) {
      return false;
    }
    var length, i;
    if (a.constructor === Array) {
      length = a.length;
      if (length !== b.length) {
        return false;
      }
      for (i = length; i-- !== 0;) {
        if (isDeepEqual(a[i], b[i]) !== true) {
          return false;
        }
      }
      return true;
    }
    if (hasMap === true && a.constructor === Map) {
      if (a.size !== b.size) {
        return false;
      }
      var iter = a.entries();
      i = iter.next();
      while (i.done !== true) {
        if (b.has(i.value[0]) !== true) {
          return false;
        }
        i = iter.next();
      }
      iter = a.entries();
      i = iter.next();
      while (i.done !== true) {
        if (isDeepEqual(i.value[1], b.get(i.value[0])) !== true) {
          return false;
        }
        i = iter.next();
      }
      return true;
    }
    if (hasSet === true && a.constructor === Set) {
      if (a.size !== b.size) {
        return false;
      }
      var _iter = a.entries();
      i = _iter.next();
      while (i.done !== true) {
        if (b.has(i.value[0]) !== true) {
          return false;
        }
        i = _iter.next();
      }
      return true;
    }
    if (hasArrayBuffer === true && a.buffer != null && a.buffer.constructor === ArrayBuffer) {
      length = a.length;
      if (length !== b.length) {
        return false;
      }
      for (i = length; i-- !== 0;) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    if (a.constructor === RegExp) {
      return a.source === b.source && a.flags === b.flags;
    }
    if (a.valueOf !== Object.prototype.valueOf) {
      return a.valueOf() === b.valueOf();
    }
    if (a.toString !== Object.prototype.toString) {
      return a.toString() === b.toString();
    }
    var keys = Object.keys(a).filter(function (key) {
      return a[key] !== void 0;
    });
    length = keys.length;
    if (length !== Object.keys(b).filter(function (key) {
      return b[key] !== void 0;
    }).length) {
      return false;
    }
    for (i = length; i-- !== 0;) {
      var key = keys[i];
      if (isDeepEqual(a[key], b[key]) !== true) {
        return false;
      }
    }
    return true;
  }

  // true if both NaN, false otherwise
  return a !== a && b !== b; // eslint-disable-line no-self-compare
}

// not perfect, but what we ARE interested is for Arrays not to slip in
// as spread operator will mess things up in various areas
// see https://jsbench.me/tbl0iliyax/1
function isObject(v) {
  return v !== null && Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_typeof_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(v) === 'object' && Array.isArray(v) !== true;
}
function isDate(v) {
  return Object.prototype.toString.call(v) === '[object Date]';
}
function isRegexp(v) {
  return Object.prototype.toString.call(v) === '[object RegExp]';
}
function isNumber(v) {
  return typeof v === 'number' && isFinite(v);
}
/* unused harmony default export */ var _unused_webpack_default_export = ({
  deepEqual: isDeepEqual,
  object: isObject,
  date: isDate,
  regexp: isRegexp,
  number: isNumber
});

/***/ }),

/***/ "6022":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "605d":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var classof = __webpack_require__("c6b6");

module.exports = typeof process != 'undefined' && classof(process) == 'process';

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362")))

/***/ }),

/***/ "6062":
/***/ (function(module, exports, __webpack_require__) {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__("1c59");


/***/ }),

/***/ "6069":
/***/ (function(module, exports, __webpack_require__) {

var IS_DENO = __webpack_require__("6c59");
var IS_NODE = __webpack_require__("605d");

module.exports = !IS_DENO && !IS_NODE
  && typeof window == 'object'
  && typeof document == 'object';


/***/ }),

/***/ "60bd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var fails = __webpack_require__("d039");
var uncurryThis = __webpack_require__("e330");
var ArrayBufferViewCore = __webpack_require__("ebb5");
var ArrayIterators = __webpack_require__("e260");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = uncurryThis(ArrayIterators.values);
var arrayKeys = uncurryThis(ArrayIterators.keys);
var arrayEntries = uncurryThis(ArrayIterators.entries);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var TypedArrayPrototype = Uint8Array && Uint8Array.prototype;

var GENERIC = !fails(function () {
  TypedArrayPrototype[ITERATOR].call([1]);
});

var ITERATOR_IS_VALUES = !!TypedArrayPrototype
  && TypedArrayPrototype.values
  && TypedArrayPrototype[ITERATOR] === TypedArrayPrototype.values
  && TypedArrayPrototype.values.name === 'values';

var typedArrayValues = function values() {
  return arrayValues(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod('entries', function entries() {
  return arrayEntries(aTypedArray(this));
}, GENERIC);
// `%TypedArray%.prototype.keys` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod('keys', function keys() {
  return arrayKeys(aTypedArray(this));
}, GENERIC);
// `%TypedArray%.prototype.values` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod('values', typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod(ITERATOR, typedArrayValues, GENERIC || !ITERATOR_IS_VALUES, { name: 'values' });


/***/ }),

/***/ "60da":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var uncurryThis = __webpack_require__("e330");
var call = __webpack_require__("c65b");
var fails = __webpack_require__("d039");
var objectKeys = __webpack_require__("df75");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var toObject = __webpack_require__("7b0b");
var IndexedObject = __webpack_require__("44ad");

// eslint-disable-next-line es/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis([].concat);

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !$assign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line es/no-symbol -- safe
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "60f9":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "621a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var DESCRIPTORS = __webpack_require__("83ab");
var NATIVE_ARRAY_BUFFER = __webpack_require__("4b11");
var FunctionName = __webpack_require__("5e77");
var createNonEnumerableProperty = __webpack_require__("9112");
var defineBuiltInAccessor = __webpack_require__("edd0");
var defineBuiltIns = __webpack_require__("6964");
var fails = __webpack_require__("d039");
var anInstance = __webpack_require__("19aa");
var toIntegerOrInfinity = __webpack_require__("5926");
var toLength = __webpack_require__("50c4");
var toIndex = __webpack_require__("0b25");
var IEEE754 = __webpack_require__("77a7");
var getPrototypeOf = __webpack_require__("e163");
var setPrototypeOf = __webpack_require__("d2bb");
var getOwnPropertyNames = __webpack_require__("241c").f;
var arrayFill = __webpack_require__("81d5");
var arraySlice = __webpack_require__("4dae");
var setToStringTag = __webpack_require__("d44e");
var InternalStateModule = __webpack_require__("69f3");

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var getInternalArrayBufferState = InternalStateModule.getterFor(ARRAY_BUFFER);
var getInternalDataViewState = InternalStateModule.getterFor(DATA_VIEW);
var setInternalState = InternalStateModule.set;
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var ArrayBufferPrototype = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];
var $DataView = global[DATA_VIEW];
var DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var Array = global.Array;
var RangeError = global.RangeError;
var fill = uncurryThis(arrayFill);
var reverse = uncurryThis([].reverse);

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key, getInternalState) {
  defineBuiltInAccessor(Constructor[PROTOTYPE], key, {
    configurable: true,
    get: function () {
      return getInternalState(this)[key];
    }
  });
};

var get = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalDataViewState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = store.bytes;
  var start = intIndex + store.byteOffset;
  var pack = arraySlice(bytes, start, start + count);
  return isLittleEndian ? pack : reverse(pack);
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalDataViewState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = store.bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, ArrayBufferPrototype);
    var byteLength = toIndex(length);
    setInternalState(this, {
      type: ARRAY_BUFFER,
      bytes: fill(Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) {
      this.byteLength = byteLength;
      this.detached = false;
    }
  };

  ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE];

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, DataViewPrototype);
    anInstance(buffer, ArrayBufferPrototype);
    var bufferState = getInternalArrayBufferState(buffer);
    var bufferLength = bufferState.byteLength;
    var offset = toIntegerOrInfinity(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      type: DATA_VIEW,
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset,
      bytes: bufferState.bytes
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  DataViewPrototype = $DataView[PROTOTYPE];

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength', getInternalArrayBufferState);
    addGetter($DataView, 'buffer', getInternalDataViewState);
    addGetter($DataView, 'byteLength', getInternalDataViewState);
    addGetter($DataView, 'byteOffset', getInternalDataViewState);
  }

  defineBuiltIns(DataViewPrototype, {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;
  /* eslint-disable no-new -- required for testing */
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1);
  }) || fails(function () {
    new NativeArrayBuffer();
    new NativeArrayBuffer(1.5);
    new NativeArrayBuffer(NaN);
    return NativeArrayBuffer.length != 1 || INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;
  })) {
    /* eslint-enable no-new -- required for testing */
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, ArrayBufferPrototype);
      return new NativeArrayBuffer(toIndex(length));
    };

    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype;

    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }

    ArrayBufferPrototype.constructor = $ArrayBuffer;
  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {
    createNonEnumerableProperty(NativeArrayBuffer, 'name', ARRAY_BUFFER);
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf(DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = uncurryThis(DataViewPrototype.setInt8);
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};


/***/ }),

/***/ "62e4":
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "6374":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "649e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $some = __webpack_require__("b727").some;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.some` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "6547":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var toIntegerOrInfinity = __webpack_require__("5926");
var toString = __webpack_require__("577e");
var requireObjectCoercible = __webpack_require__("1d80");

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "6566":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__("7c73");
var defineBuiltInAccessor = __webpack_require__("edd0");
var defineBuiltIns = __webpack_require__("6964");
var bind = __webpack_require__("0366");
var anInstance = __webpack_require__("19aa");
var isNullOrUndefined = __webpack_require__("7234");
var iterate = __webpack_require__("2266");
var defineIterator = __webpack_require__("c6d2");
var createIterResultObject = __webpack_require__("4754");
var setSpecies = __webpack_require__("2626");
var DESCRIPTORS = __webpack_require__("83ab");
var fastKey = __webpack_require__("f183").fastKey;
var InternalStateModule = __webpack_require__("69f3");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    defineBuiltIns(Prototype, {
      // `{ Map, Set }.prototype.clear()` methods
      // https://tc39.es/ecma262/#sec-map.prototype.clear
      // https://tc39.es/ecma262/#sec-set.prototype.clear
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // `{ Map, Set }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.delete
      // https://tc39.es/ecma262/#sec-set.prototype.delete
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.foreach
      // https://tc39.es/ecma262/#sec-set.prototype.foreach
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // `{ Map, Set}.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-map.prototype.has
      // https://tc39.es/ecma262/#sec-set.prototype.has
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `Map.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-map.prototype.get
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // `Map.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-map.prototype.set
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // `Set.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-set.prototype.add
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineBuiltInAccessor(Prototype, 'size', {
      configurable: true,
      get: function () {
        return getInternalState(this).size;
      }
    });
    return Constructor;
  },
  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
    // https://tc39.es/ecma262/#sec-map.prototype.entries
    // https://tc39.es/ecma262/#sec-map.prototype.keys
    // https://tc39.es/ecma262/#sec-map.prototype.values
    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator
    // https://tc39.es/ecma262/#sec-set.prototype.entries
    // https://tc39.es/ecma262/#sec-set.prototype.keys
    // https://tc39.es/ecma262/#sec-set.prototype.values
    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator
    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return createIterResultObject(undefined, true);
      }
      // return step by kind
      if (kind == 'keys') return createIterResultObject(entry.key, false);
      if (kind == 'values') return createIterResultObject(entry.value, false);
      return createIterResultObject([entry.key, entry.value], false);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // `{ Map, Set }.prototype[@@species]` accessors
    // https://tc39.es/ecma262/#sec-get-map-@@species
    // https://tc39.es/ecma262/#sec-get-set-@@species
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ "65f0":
/***/ (function(module, exports, __webpack_require__) {

var arraySpeciesConstructor = __webpack_require__("0b42");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "6642":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return sizes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getSizeMixin; });
var sizes = {
  xs: 18,
  sm: 24,
  md: 32,
  lg: 38,
  xl: 46
};
function getSizeMixin(sizes) {
  return {
    props: {
      size: String
    },
    computed: {
      sizeStyle: function sizeStyle() {
        if (this.size !== void 0) {
          return {
            fontSize: this.size in sizes ? "".concat(sizes[this.size], "px") : this.size
          };
        }
      }
    }
  };
}
/* harmony default export */ __webpack_exports__["a"] = (getSizeMixin(sizes));

/***/ }),

/***/ "66e5":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5530");
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("ade3");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("a9e3");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("cca6");
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _mixins_dark_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("b7fa");
/* harmony import */ var _mixins_tag_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("e2fa");
/* harmony import */ var _mixins_router_link_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("8716");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("87e8");
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("e277");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("d882");
/* harmony import */ var _utils_private_key_composition_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("dc8a");












/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_4___default.a.extend({
  name: 'QItem',
  mixins: [_mixins_dark_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"], _mixins_router_link_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"], _mixins_tag_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"], _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"]],
  props: {
    active: {
      type: Boolean,
      default: null
    },
    clickable: Boolean,
    dense: Boolean,
    insetLevel: Number,
    tabindex: [String, Number],
    focused: Boolean,
    manualFocus: Boolean
  },
  computed: {
    isActionable: function isActionable() {
      return this.clickable === true || this.hasLink === true || this.tag === 'label';
    },
    isClickable: function isClickable() {
      return this.disable !== true && this.isActionable === true;
    },
    classes: function classes() {
      return 'q-item q-item-type row no-wrap' + (this.dense === true ? ' q-item--dense' : '') + (this.isDark === true ? ' q-item--dark' : '') + (this.hasLink === true && this.active === null ? this.linkClass : this.active === true ? " q-item--active".concat(this.activeClass !== void 0 ? " ".concat(this.activeClass) : '', " ") : '') + (this.disable === true ? ' disabled' : '') + (this.isClickable === true ? ' q-item--clickable q-link cursor-pointer ' + (this.manualFocus === true ? 'q-manual-focusable' : 'q-focusable q-hoverable') + (this.focused === true ? ' q-manual-focusable--focused' : '') : '');
    },
    style: function style() {
      if (this.insetLevel !== void 0) {
        var dir = this.$q.lang.rtl === true ? 'Right' : 'Left';
        return Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({}, 'padding' + dir, 16 + this.insetLevel * 56 + 'px');
      }
    },
    onEvents: function onEvents() {
      return Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.qListeners), {}, {
        click: this.__onClick,
        keyup: this.__onKeyup
      });
    }
  },
  methods: {
    __onClick: function __onClick(e) {
      if (this.isClickable === true) {
        if (this.$refs.blurTarget !== void 0) {
          if (e.qKeyEvent !== true && document.activeElement === this.$el) {
            this.$refs.blurTarget.focus();
          } else if (document.activeElement === this.$refs.blurTarget) {
            this.$el.focus();
          }
        }
        this.__navigateOnClick(e);
      }
    },
    __onKeyup: function __onKeyup(e) {
      if (this.isClickable === true && Object(_utils_private_key_composition_js__WEBPACK_IMPORTED_MODULE_11__[/* isKeyCode */ "a"])(e, 13) === true) {
        Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_10__[/* stopAndPrevent */ "j"])(e);

        // for ripple
        e.qKeyEvent = true;

        // for click trigger
        var evt = new MouseEvent('click', e);
        evt.qKeyEvent = true;
        this.$el.dispatchEvent(evt);
      }
      this.$emit('keyup', e);
    },
    __getContent: function __getContent(h) {
      var child = Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_9__[/* uniqueSlot */ "d"])(this, 'default', []);
      this.isClickable === true && child.unshift(h('div', {
        staticClass: 'q-focus-helper',
        attrs: {
          tabindex: -1
        },
        ref: 'blurTarget'
      }));
      return child;
    }
  },
  render: function render(h) {
    var data = {
      class: this.classes,
      style: this.style,
      attrs: {
        role: 'listitem'
      },
      on: this.onEvents
    };
    if (this.isClickable === true) {
      data.attrs.tabindex = this.tabindex || '0';
      Object.assign(data.attrs, this.linkAttrs);
    } else if (this.isActionable === true) {
      data.attrs['aria-disabled'] = 'true';
    }
    return h(this.linkTag, data, this.__getContent(h));
  }
}));

/***/ }),

/***/ "681b":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "68ee":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var fails = __webpack_require__("d039");
var isCallable = __webpack_require__("1626");
var classof = __webpack_require__("f5df");
var getBuiltIn = __webpack_require__("d066");
var inspectSource = __webpack_require__("8925");

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "6964":
/***/ (function(module, exports, __webpack_require__) {

var defineBuiltIn = __webpack_require__("cb2d");

module.exports = function (target, src, options) {
  for (var key in src) defineBuiltIn(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "69f3":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__("cdce");
var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");
var createNonEnumerableProperty = __webpack_require__("9112");
var hasOwn = __webpack_require__("1a2d");
var shared = __webpack_require__("c6cd");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "6a51":
/***/ (function(module, exports) {

/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}

/**
 * Any of the passed expresssions may match
 *
 * Creates a huge this | this | that | that match
 * @param {(RegExp | string)[] } args
 * @returns {string}
 */
function either(...args) {
  const joined = '(' + args.map((x) => source(x)).join("|") + ")";
  return joined;
}

/*
Language: Perl
Author: Peter Leonov <gojpeg@yandex.ru>
Website: https://www.perl.org
Category: common
*/

/** @type LanguageFn */
function perl(hljs) {
  const KEYWORDS = [
    'abs',
    'accept',
    'alarm',
    'and',
    'atan2',
    'bind',
    'binmode',
    'bless',
    'break',
    'caller',
    'chdir',
    'chmod',
    'chomp',
    'chop',
    'chown',
    'chr',
    'chroot',
    'close',
    'closedir',
    'connect',
    'continue',
    'cos',
    'crypt',
    'dbmclose',
    'dbmopen',
    'defined',
    'delete',
    'die',
    'do',
    'dump',
    'each',
    'else',
    'elsif',
    'endgrent',
    'endhostent',
    'endnetent',
    'endprotoent',
    'endpwent',
    'endservent',
    'eof',
    'eval',
    'exec',
    'exists',
    'exit',
    'exp',
    'fcntl',
    'fileno',
    'flock',
    'for',
    'foreach',
    'fork',
    'format',
    'formline',
    'getc',
    'getgrent',
    'getgrgid',
    'getgrnam',
    'gethostbyaddr',
    'gethostbyname',
    'gethostent',
    'getlogin',
    'getnetbyaddr',
    'getnetbyname',
    'getnetent',
    'getpeername',
    'getpgrp',
    'getpriority',
    'getprotobyname',
    'getprotobynumber',
    'getprotoent',
    'getpwent',
    'getpwnam',
    'getpwuid',
    'getservbyname',
    'getservbyport',
    'getservent',
    'getsockname',
    'getsockopt',
    'given',
    'glob',
    'gmtime',
    'goto',
    'grep',
    'gt',
    'hex',
    'if',
    'index',
    'int',
    'ioctl',
    'join',
    'keys',
    'kill',
    'last',
    'lc',
    'lcfirst',
    'length',
    'link',
    'listen',
    'local',
    'localtime',
    'log',
    'lstat',
    'lt',
    'ma',
    'map',
    'mkdir',
    'msgctl',
    'msgget',
    'msgrcv',
    'msgsnd',
    'my',
    'ne',
    'next',
    'no',
    'not',
    'oct',
    'open',
    'opendir',
    'or',
    'ord',
    'our',
    'pack',
    'package',
    'pipe',
    'pop',
    'pos',
    'print',
    'printf',
    'prototype',
    'push',
    'q|0',
    'qq',
    'quotemeta',
    'qw',
    'qx',
    'rand',
    'read',
    'readdir',
    'readline',
    'readlink',
    'readpipe',
    'recv',
    'redo',
    'ref',
    'rename',
    'require',
    'reset',
    'return',
    'reverse',
    'rewinddir',
    'rindex',
    'rmdir',
    'say',
    'scalar',
    'seek',
    'seekdir',
    'select',
    'semctl',
    'semget',
    'semop',
    'send',
    'setgrent',
    'sethostent',
    'setnetent',
    'setpgrp',
    'setpriority',
    'setprotoent',
    'setpwent',
    'setservent',
    'setsockopt',
    'shift',
    'shmctl',
    'shmget',
    'shmread',
    'shmwrite',
    'shutdown',
    'sin',
    'sleep',
    'socket',
    'socketpair',
    'sort',
    'splice',
    'split',
    'sprintf',
    'sqrt',
    'srand',
    'stat',
    'state',
    'study',
    'sub',
    'substr',
    'symlink',
    'syscall',
    'sysopen',
    'sysread',
    'sysseek',
    'system',
    'syswrite',
    'tell',
    'telldir',
    'tie',
    'tied',
    'time',
    'times',
    'tr',
    'truncate',
    'uc',
    'ucfirst',
    'umask',
    'undef',
    'unless',
    'unlink',
    'unpack',
    'unshift',
    'untie',
    'until',
    'use',
    'utime',
    'values',
    'vec',
    'wait',
    'waitpid',
    'wantarray',
    'warn',
    'when',
    'while',
    'write',
    'x|0',
    'xor',
    'y|0'
  ];

  // https://perldoc.perl.org/perlre#Modifiers
  const REGEX_MODIFIERS = /[dualxmsipngr]{0,12}/; // aa and xx are valid, making max length 12
  const PERL_KEYWORDS = {
    $pattern: /[\w.]+/,
    keyword: KEYWORDS.join(" ")
  };
  const SUBST = {
    className: 'subst',
    begin: '[$@]\\{',
    end: '\\}',
    keywords: PERL_KEYWORDS
  };
  const METHOD = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  };
  const VAR = {
    variants: [
      {
        begin: /\$\d/
      },
      {
        begin: concat(
          /[$%@](\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
          // negative look-ahead tries to avoid matching patterns that are not
          // Perl at all like $ident$, @ident@, etc.
          `(?![A-Za-z])(?![@$%])`
        )
      },
      {
        begin: /[$%@][^\s\w{]/,
        relevance: 0
      }
    ]
  };
  const STRING_CONTAINS = [
    hljs.BACKSLASH_ESCAPE,
    SUBST,
    VAR
  ];
  const REGEX_DELIMS = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/, // valid but infrequent and weird
    /#/ // valid but infrequent and weird
  ];
  /**
   * @param {string|RegExp} prefix
   * @param {string|RegExp} open
   * @param {string|RegExp} close
   */
  const PAIRED_DOUBLE_RE = (prefix, open, close = '\\1') => {
    const middle = (close === '\\1')
      ? close
      : concat(close, open);
    return concat(
      concat("(?:", prefix, ")"),
      open,
      /(?:\\.|[^\\\/])*?/,
      middle,
      /(?:\\.|[^\\\/])*?/,
      close,
      REGEX_MODIFIERS
    );
  };
  /**
   * @param {string|RegExp} prefix
   * @param {string|RegExp} open
   * @param {string|RegExp} close
   */
  const PAIRED_RE = (prefix, open, close) => {
    return concat(
      concat("(?:", prefix, ")"),
      open,
      /(?:\\.|[^\\\/])*?/,
      close,
      REGEX_MODIFIERS
    );
  };
  const PERL_DEFAULT_CONTAINS = [
    VAR,
    hljs.HASH_COMMENT_MODE,
    hljs.COMMENT(
      /^=\w/,
      /=cut/,
      {
        endsWithParent: true
      }
    ),
    METHOD,
    {
      className: 'string',
      contains: STRING_CONTAINS,
      variants: [
        {
          begin: 'q[qwxr]?\\s*\\(',
          end: '\\)',
          relevance: 5
        },
        {
          begin: 'q[qwxr]?\\s*\\[',
          end: '\\]',
          relevance: 5
        },
        {
          begin: 'q[qwxr]?\\s*\\{',
          end: '\\}',
          relevance: 5
        },
        {
          begin: 'q[qwxr]?\\s*\\|',
          end: '\\|',
          relevance: 5
        },
        {
          begin: 'q[qwxr]?\\s*<',
          end: '>',
          relevance: 5
        },
        {
          begin: 'qw\\s+q',
          end: 'q',
          relevance: 5
        },
        {
          begin: '\'',
          end: '\'',
          contains: [ hljs.BACKSLASH_ESCAPE ]
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: '`',
          end: '`',
          contains: [ hljs.BACKSLASH_ESCAPE ]
        },
        {
          begin: /\{\w+\}/,
          relevance: 0
        },
        {
          begin: '-?\\w+\\s*=>',
          relevance: 0
        }
      ]
    },
    {
      className: 'number',
      begin: '(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b',
      relevance: 0
    },
    { // regexp container
      begin: '(\\/\\/|' + hljs.RE_STARTERS_RE + '|\\b(split|return|print|reverse|grep)\\b)\\s*',
      keywords: 'split return print reverse grep',
      relevance: 0,
      contains: [
        hljs.HASH_COMMENT_MODE,
        {
          className: 'regexp',
          variants: [
            // allow matching common delimiters
            { begin: PAIRED_DOUBLE_RE("s|tr|y", either(...REGEX_DELIMS)) },
            // and then paired delmis
            { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\(", "\\)") },
            { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\[", "\\]") },
            { begin: PAIRED_DOUBLE_RE("s|tr|y", "\\{", "\\}") }
          ],
          relevance: 2
        },
        {
          className: 'regexp',
          variants: [
            {
              // could be a comment in many languages so do not count
              // as relevant
              begin: /(m|qr)\/\//,
              relevance: 0
            },
            // prefix is optional with /regex/
            { begin: PAIRED_RE("(?:m|qr)?", /\//, /\//)},
            // allow matching common delimiters
            { begin: PAIRED_RE("m|qr", either(...REGEX_DELIMS), /\1/)},
            // allow common paired delmins
            { begin: PAIRED_RE("m|qr", /\(/, /\)/)},
            { begin: PAIRED_RE("m|qr", /\[/, /\]/)},
            { begin: PAIRED_RE("m|qr", /\{/, /\}/)}
          ]
        }
      ]
    },
    {
      className: 'function',
      beginKeywords: 'sub',
      end: '(\\s*\\(.*?\\))?[;{]',
      excludeEnd: true,
      relevance: 5,
      contains: [ hljs.TITLE_MODE ]
    },
    {
      begin: '-\\w\\b',
      relevance: 0
    },
    {
      begin: "^__DATA__$",
      end: "^__END__$",
      subLanguage: 'mojolicious',
      contains: [
        {
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }
      ]
    }
  ];
  SUBST.contains = PERL_DEFAULT_CONTAINS;
  METHOD.contains = PERL_DEFAULT_CONTAINS;

  return {
    name: 'Perl',
    aliases: [
      'pl',
      'pm'
    ],
    keywords: PERL_KEYWORDS,
    contains: PERL_DEFAULT_CONTAINS
  };
}

module.exports = perl;


/***/ }),

/***/ "6a66":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "6b75":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _arrayLikeToArray; });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}

/***/ }),

/***/ "6b9e":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("e065");

// `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');


/***/ }),

/***/ "6c59":
/***/ (function(module, exports) {

/* global Deno -- Deno case */
module.exports = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';


/***/ }),

/***/ "6ce2":
/***/ (function(module) {

module.exports = JSON.parse("{\"Dismiss\":\"Verwerfen\",\"CodeBlock\":{\"Initial_Content\":\"Lösungsvorgabe\"},\"CodeBlockContainer\":{\"DataBlock\":\"Sandkastendaten\",\"ReloadResources\":\"Resourcen immer neu laden\",\"ReloadResources_detail\":\"Resourcen in Sandkästen die über die resources()-Methode geladen werden immer abrufen bevor init aufgerufen wird.\",\"Order\":\"Reihenfolge\",\"Display\":\"Darstellung\",\"Lines\":\"Zeilen\",\"Lines_detail\":\"Anzahl sichtbarer Zeilen oder <b>auto</b>.\",\"Prepopulate\":\"Antwort Vorbelegen\",\"Prepopulate_detail\":\"Lösungsvorgabe für neue Fragen angeben.\",\"Behaviour\":\"Verhalten\",\"ScriptV\":\"Script-Version\",\"ScriptV_detail\":\"API-Version des Sandkastens.\",\"AutoReset\":\"Autom. Reset\",\"AutoReset_detail\":\"Sandkasten bei jeder Ausführung neu erzeugen.\",\"GenerateTemplate\":\"Canvas erzeugen\",\"GenerateTemplate_detail\":\"Erstellt ein Canvas-Element für diesen Sandkasten\",\"Positioning\":\"Positionierung\",\"Width\":\"Breite\",\"Width_detail\":\"CSS-Eigenschaft für die Breite\",\"Height\":\"Höhe\",\"Height_detail\":\"CSS-Eigenschaft für die Höhe\",\"Alignment\":\"Ausrichtung\",\"Alignment_detail\":\"Horizontale Ausrichtung des Canvas-Element\",\"Delete\":\"Löschen\",\"Start\":\"Anfang\",\"Center\":\"Mitte\",\"End\":\"Ende\",\"ScriptVersion_1\":\"1.0 (original)\",\"ScriptVersion_2\":\"2.0 (seit 2020)\",\"ScriptVersion_3\":\"3.0 (experimental)\",\"Canvas\":\"Sandkasten\",\"Text\":\"Text\",\"Hidden\":\"Quellcode (Versteckt)\",\"Static\":\"Quellcode (Angabe)\",\"Block\":\"Antwortfeld/Lösung\",\"Blockly\":\"Blockly (Experimental!!!)\",\"REPL\":\"Interaktive Eingabe\",\"Confirm\":\"Bestätigung\",\"DeleteQuestion\":\"Soll der <span class='highlightedCard sample'>hervorgehobene</span> Block wirklick entfernt werden?\",\"TypesCaption\":\"Blocktypen\",\"Types\":\"Die Frage wird aus den folgenden Blöcken zusammengestellt. Möglichen Typen sind:<ul><li><b>Text</b>: Text der wie der ursprüngliche Fragetext ohne Syntax highlighting angezeigt wird. Die <b>[code][/code]</b> und <b>[hl][/hl]</b> können verwendet werden</li><li><b>Quellcode (Angabe)</b>: Nicht veränderbarer Quellcode mit Syntax highlighting. Der Inhalt ist deil des ausgeführten Programmes und sollte fest vorgegebenen Code enthalten.</li><li><b>Quellcode (Versteckt)</b>: Der Quellcode ist teil der ausgelieferten Webseite, wird jedoch nicht angezeigt. Diese Variante kann code enthalten der Hilfsmethoden o.ä. definiert. Der Inhalt ist deil des ausgeführten Programmes und sollte fest vorgegebenen Code enthalten.</li><li><b>Antwortfeld/Lösung</b>: Quellcode mit Syntax highlighting. Hier sollte die Musterlösung angegeben werden. Der Inhalt ist deil des ausgeführten Programmes und sollte fest vorgegebenen Code enthalten.</li><li><b>Sandkasten</b>: Eine möglichkeit um vorgegebenen Code im DOM des Browsers auszuführen. Zum Beispiel für eine Zeichenfläche die nutzbar ist um die Ergebnisse der Studenten zu visualisieren. Der Code (für Version 2.0) <b> muss ein JavaScript Object</b> mit den Methoden <ul><li><code>init(canvasElement, outputElement, scope)</code> und </li><li><code>update(txt, json, canvasElement, outputElement)</code></li></ul> definieren</b>.</li><li><b>Sandkastendaten</b>: Ermöglicht es JSON-Formatierte Daten für die Sandkästen bereitzustellen. Die angegebenen JSON-Objekte stehen in den Sandkästen als <b>this.DATA[name]</b> zur Verfügung.</li></ul>\"},\"CodeBlocks\":{\"run_hint\":\"<code>Ctrl</code>+<code>W</code> oder <code>Ctrl</code>+<code>J</code> drücken um Code auszuführen\",\"run\":\"Ausführen\",\"start\":\"Starten\",\"stop\":\"Anhalten\",\"AddBlock\":\"Neuen Block Anlegen\",\"UserCanceled\":\"Vom Benutzer Abgebrochen\"},\"CodeBlocksSettings\":{\"Language\":\"Sprache\",\"AllowExec\":\"Ausführung zulassen\",\"CVersion\":\"Version\",\"RunTime\":\"Max. Laufzeit in ms.\",\"Output\":\"Ausgabe\",\"MaxCharacters\":\"Max. Textlänge\",\"ExperimentalCompiler\":\"Experimentelle Sprache\",\"ExperimentalCompilerDesc\":\"Diese Sprachversion ist experimentell. Sowohl die Eigenschaften also auch das Verhalten können sich daher im nächsten Update ändern. Diese Version sollte nicht in Produktivumgebungen eingestezt werden.\",\"DeprecatedCompiler\":\"Veralteter Sprache\",\"DeprecatedCompilerDesc\":\"Diese Sprachversion ist veraltet und wird in einem der nächsten Updates entfernt. Bitte aktualisieren Sie Ihr Projekt auf eine aktuelle Version.\",\"Parser\":\"Ausgabe Behandlung\",\"Themes\":\"Stile\",\"TGeneral\":\"Allgemeine Darstellung\",\"TSolution\":\"Lösungsdarstellung\",\"Libraries\":\"Bibliotheken\",\"DomLibs\":\"DOM-Bibliotheken\",\"WorkLibs\":\"Worker-Bibliotheken\",\"PAutomatic\":\"Automatisch\",\"PText\":\"Als Text\",\"PJSON\":\"Als JSON\",\"PMagic\":\"Text+JSON (getrennt mit '\\\\n\\\\n&lt;JSON>\\\\n')\",\"PData\":\"Text+Daten (Senden mit 'CodeBlocks.postResult(data)')\",\"NumberErr\":\"Muss eine gültige Zahl sein.\",\"ContinousCompile\":\"Automatisch Ausführen\",\"PersistentArguments\":\"Persistente Argumente\",\"MessagePassing\":\"Nachrichtenaustauch (DOM und Worker)\",\"KeepAlive\":\"Worker nicht automatisch beenden\",\"AllowArguments\":\"Untersützt das Senden von Argumenten\",\"AllowArgumentsCaption\":\"Senden von Argumenten\",\"AllowArgumentsHint\":\"Mit Hilfer der Methode <code>addArgumentsTo(args)</code> eines <b>Sandkastens</b> kann ein Objekt definiert werden, welches an den Programmcode weitergereicht wird. Innerhalb des Programmcodes kann über die Variable <code>args</code> auf das so erstellte Objekt zugegriffen werden.\",\"AllowArgumentsHintJava\":\"Mit Hilfer der Methode <code>addArgumentsTo(args)</code> eines <b>Sandkastens</b> können die Einträge eines String-Array festgelegt werden, welches der <code>main</code>-Methode als Parameter übergeben wird.\",\"UsePersistentArgumentsCaption\":\"Persistente Argumente\",\"UsePersistentArgumentsHint\":\"Wenn diese Option aktiviert ist werden die Werte die vom Worker in der <code>args</code>-Variable abgelegt wurden direkt an <code>addArgumentsTo(args)</code> übergeben. Andernfalls ist <code>args</code> ein leers Objekt.\",\"UsePersistentArgumentsHintJava\":\"Wenn diese Option aktiviert ist werden die Werte im java-code in der <code>args</code>-Variable abgelegt wurden direkt an <code>addArgumentsTo(args)</code> übergeben. Andernfalls ist <code>args</code> ein leers Array.\",\"AllowMessagePassingCaption\":\"Nachrichtenaustauch\",\"AllowMessagePassingHint\":\"<b style=color:red>[EXPERIMENTAL]</b> Ermöglicht den Nachrichtenaustausch zwischen dem Wroker und dem (Canvas)DOM-Code.<br><b>Canvas-Code:</b><ul><li><code>onMessage(cmd, data)</code>: Empföngt Nachrichten vom worker</li><li><code>runner.postMessage(cmd, data)</code>: Sendet Nachrichten an den Worker. Die runner-Instanz wird der <code>init</code>-Method übergeben.</li></ul><b>Worker-Code:</b><ul><li><code>CodeBlocks.startReceivingEvents((request) => {})</code>: Die übergebene Methode empfäöngt die Nachrichten des DOM-Codes</li><li><code>CodeBlocks.postMessage(cmd, data)</code>: Sendet eine Nachricht an den DOM-Code.</li></ul>\",\"AllowMessagePassingHintJava\":\"<b style=color:red>[EXPERIMENTAL]</b> Ermöglicht den Nachrichtenaustausch zwischen dem Wroker und dem (Canvas)DOM-Code.<br><b>Canvas-Code:</b><ul><li><code>onMessage(cmd, data)</code>: Empföngt Nachrichten vom worker</li><li><code>runner.postMessage(cmd, data)</code>: Sendet Nachrichten an den Worker. Die runner-Instanz wird der <code>init</code>-Method übergeben.</li></ul><b>Worker-Code:</b><ul><li><code>CodeBlocks.startReceivingEvents((CodeBlocksBaseMessage request) -> {})</code>: Die übergebene Methode empfäöngt die Nachrichten des DOM-Codes</li><li><code>CodeBlocks.postMessage(cmd, data)</code>: Sendet eine Nachricht an den DOM-Code.</li></ul>\",\"KeepAliveCaption\":\"Worker nicht automatisch beenden\",\"KeepAliveHint\":\"<b style=color:red>[EXPERIMENTAL]</b> Der Worker wird nach dem beenden des studentischen Codes nicht automatisch beendet und kann weiter Nachrichten empfangen und senden.<br><br>Der Worker kann jederzeit manuell durch die <em>Anhalten</em>-Teste oder durch erreichen der maximal erlaubten Laufzeit beendet werden. Der studentische code, kann die Ausführung durch aufrufen von <code>process.exit(0)</code> beenden.<br><br>Die <code>whenFinished(args)</code>-Methode der <b>Sandkästen</b> wird sofort nach dem Ende des studentischen Codes, aber noch vor der Beendigung des Workers aufberufen.\",\"KeepAliveHintJava\":\"<b style=color:red>[EXPERIMENTAL]</b> Der Worker wird nach dem beenden der studentischen <code>main</code>-methode nicht automatisch beendet und kann weiter Nachrichten empfangen und senden.<br><br>Der Worker kann jederzeit manuell durch die <em>Anhalten</em>-Taste oder durch das erreichen der maximal erlaubten Laufzeit beendet werden. Der studentische code, kann die Ausführung durch aufrufen von <code>System.exit(0)</code> beenden.<br><br>Die <code>whenFinished(args)</code>-Methode der <b>Sandkästen</b> wird sofort nach dem Ende der <code>main</code>-Methode, aber noch vor der Beendigung des Workers aufberufen.\"},\"CodePlayground\":{\"InvalidJson\":\"Ausgabe ist nicht JSON-Formatiert\",\"Output\":\"Ausgabe:\",\"Message\":\"Meldung:\",\"ExperimentalScriptVersion\":\"Experimentelle Scriptversion\",\"ExperimentalScriptVersionDesc\":\"Diese Scriptversion ist experimentell. Sowohl die Eigenschaften also auch das Verhalten können sich daher im nächsten Update ändern. Diese Version sollte nicht in Produktivumgebungen eingestezt werden.\",\"DeprecatedScriptVersion\":\"Veralteter Scriptversion\",\"DeprecatedScriptVersionDesc\":\"Diese Scriptversion ist veraltet und wird in einem der nächsten Updates entfernt. Bitte aktualisieren Sie Ihr Projekt auf eine aktuelle Version.\"},\"Tagger\":{\"ConfirmRepl\":\"Ersetzung Bestätigen\",\"ConfirmReplMsg\":\"Sollen <b>alle</b> vorkomnisse von {name} mit dem untenstehenden Wert ersetzt werden?\"},\"RandomizerSetEditor\":{\"Caption\":\"Bearbeit Zusammenstellung {nr}\"},\"RandomizerSettings\":{\"Caption\":\"Würfler\",\"Available\":\"Definierte Platzhalter\",\"Sets\":\"Zusammenstellungen\"},\"Blockly\":{\"CodePreviewLabel\":\"Code-Vorschau\",\"CodePreviewCaption\":\"Der durch die Sequenz erzeugte Quellcode\",\"RAWToolboxLabel\":\"RAW Toolbox Definition\",\"RAWToolboxCaption\":\"Die Toolbox Definition als XML Quelltext\",\"CustomBlocksLabel\":\"Angepasste Blöcke\",\"CustomBlocksCaption\":\"Erstellen und Anpassen von eigenen Blöcken\",\"ToolboxLabel\":\"Toolbox Anpassen\",\"ToolboxCaption\":\"Die Toolbox mit einer UI verwalten und gestalten\",\"ToolboxCategories\":\"Kategorien\",\"ToolboxItems\":\"Blöcke\",\"Properties\":\"Eigenschaften\",\"UseCustomToolbox\":\"Toolbox selbst definieren\",\"ShowControls\":\"Kontrolleiste Anzeigen\",\"Block\":{\"TypeName\":\"Unique Type ID\",\"MainDescription\":\"Main Description (use %1, %2... for Argument PlaceHolders)\",\"CreateCustomTitle\":\"Create a new Block\",\"CreateCustomMessage\":\"Please specify a unique Type-Name (at least <b>three characters</b>) for your new Block.\",\"Arguments\":\"Argument List\",\"ArgumentName\":\"Argument Name\",\"Header\":\"Header\",\"HeaderDescription\":\"The main Row of your Block\",\"AdditionalLines\":\"Additional Lines\",\"AddonLineTitle\":\"Additional Line {nr}\",\"CompileError\":\"Error Compiling Block:\",\"CodeGeneratorFunction\":\"Code-Generator Function\",\"Properties\":\"Block-Eigenschaften\",\"BlockEditTitle\":\"Block Designer\",\"BlockEditDescription\":\"Define the Properties of Your Block with a simple Blockly-Interface.\",\"DesignBlockName\":\"DESIGNER BLOCK\"},\"ArgumentTypeNames\":{\"field_input\":\"field_input\",\"field_dropdown\":\"field_dropdown\",\"field_checkbox\":\"field_checkbox\",\"field_colour\":\"Farbe\",\"field_number\":\"Zahl\",\"field_angle\":\"Winkel\",\"field_variable\":\"field_variable\",\"field_date\":\"Datum\",\"field_label\":\"field_label\",\"field_image\":\"Bild\",\"input_value\":\"input_value\",\"input_statement\":\"input_statement\",\"input_dummy\":\"input_dummy\"},\"BlockTypeNames\":{\"controls_if\":\"Kontrolle: Bedingung (if)\",\"logic_compare\":\"Logik: Vergleich\",\"logic_operation\":\"Logik: Logische Operation\",\"logic_negate\":\"Logik: Logisches Nicht\",\"logic_boolean\":\"Logik: Wahrheitswert\",\"logic_null\":\"Logik: null\",\"logic_ternary\":\"Logik: Ternäre Logikoperation (?:)\",\"controls_repeat_ext\":\"Kontrolle: Schleife: n-Mal Wiederholen\",\"controls_whileUntil\":\"Kontrolle: Schleife: While-Until\",\"controls_for\":\"Kontrolle: Schleife: For\",\"controls_forEach\":\"Kontrolle: Schleife: For-Each\",\"controls_flow_statements\":\"Kontrolle: Schliefen Operationen (continue/break)\",\"math_number\":\"Mathe: Zahl\",\"math_arithmetic\":\"Mathe: Arithmetische Operation\",\"math_single\":\"Mathe: Unöre Operation\",\"math_trig\":\"Mathe: Trigonometrische Funktionen\",\"math_constant\":\"Mathe: Konstanten (pi, ...)\",\"math_number_property\":\"Mathe: Zahleigenschaften (gerade, prim...)\",\"math_round\":\"Mathe: Runden\",\"math_on_list\":\"Mathe: Reduktion auf Liste (summe, min/max, ...)\",\"math_modulo\":\"Mathe: Rest (Modulo)\",\"math_constrain\":\"Mathe: Intervall Begrenzen\",\"math_random_int\":\"Mathe: Zufallszahl (Ganzzahlig)\",\"math_random_float\":\"Mathe: Zufallszahl\",\"text\":\"Text\",\"text_join\":\"text_join\",\"text_append\":\"text_append\",\"text_length\":\"text_length\",\"text_isEmpty\":\"text_isEmpty\",\"text_indexOf\":\"text_indexOf\",\"variables_get\":\"variables_get\",\"text_charAt\":\"text_charAt\",\"text_getSubstring\":\"text_getSubstring\",\"text_changeCase\":\"text_changeCase\",\"text_trim\":\"text_trim\",\"text_print\":\"text_print\",\"text_prompt_ext\":\"text_prompt_ext\",\"lists_create_with\":\"lists_create_with\",\"lists_repeat\":\"lists_repeat\",\"lists_length\":\"lists_length\",\"lists_isEmpty\":\"lists_isEmpty\",\"lists_indexOf\":\"lists_indexOf\",\"lists_getIndex\":\"lists_getIndex\",\"lists_setIndex\":\"lists_setIndex\",\"lists_getSublist\":\"lists_getSublist\",\"lists_split\":\"lists_split\",\"lists_sort\":\"lists_sort\",\"colour_picker\":\"colour_picker\",\"colour_random\":\"colour_random\",\"colour_rgb\":\"colour_rgb\",\"colour_blend\":\"colour_blend\"}},\"DataBlock\":{\"InfoCaption\":\"Verwendung\",\"Info\":\"Sie können auf dieses Datum in den Sandkästen über <b>this.DATA['{NAME}']</b> zugreifen.\"}}");

/***/ }),

/***/ "6ce5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var arrayToReversed = __webpack_require__("df7e");
var ArrayBufferViewCore = __webpack_require__("ebb5");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;

// `%TypedArray%.prototype.toReversed` method
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed
exportTypedArrayMethod('toReversed', function toReversed() {
  return arrayToReversed(aTypedArray(this), getTypedArrayConstructor(this));
});


/***/ }),

/***/ "6d61":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var isForced = __webpack_require__("94ca");
var defineBuiltIn = __webpack_require__("cb2d");
var InternalMetadataModule = __webpack_require__("f183");
var iterate = __webpack_require__("2266");
var anInstance = __webpack_require__("19aa");
var isCallable = __webpack_require__("1626");
var isNullOrUndefined = __webpack_require__("7234");
var isObject = __webpack_require__("861d");
var fails = __webpack_require__("d039");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var setToStringTag = __webpack_require__("d44e");
var inheritIfRequired = __webpack_require__("7156");

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var uncurriedNativeMethod = uncurryThis(NativePrototype[KEY]);
    defineBuiltIn(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        uncurriedNativeMethod(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : uncurriedNativeMethod(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        uncurriedNativeMethod(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  var REPLACE = isForced(
    CONSTRUCTOR_NAME,
    !isCallable(NativeConstructor) || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    }))
  );

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.enable();
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, NativePrototype);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, constructor: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ "6e02":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_TipTap_vue_vue_type_style_index_0_id_5a368702_prod_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("115e");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_TipTap_vue_vue_type_style_index_0_id_5a368702_prod_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_TipTap_vue_vue_type_style_index_0_id_5a368702_prod_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "6e19":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorSeverity; });
var ErrorSeverity;
(function (ErrorSeverity) {
  ErrorSeverity[ErrorSeverity["Error"] = 2] = "Error";
  ErrorSeverity[ErrorSeverity["Warning"] = 1] = "Warning";
})(ErrorSeverity || (ErrorSeverity = {}));

/***/ }),

/***/ "6f19":
/***/ (function(module, exports, __webpack_require__) {

var createNonEnumerableProperty = __webpack_require__("9112");
var clearErrorStack = __webpack_require__("0d26");
var ERROR_STACK_INSTALLABLE = __webpack_require__("b980");

// non-standard V8
var captureStackTrace = Error.captureStackTrace;

module.exports = function (error, C, stack, dropEntries) {
  if (ERROR_STACK_INSTALLABLE) {
    if (captureStackTrace) captureStackTrace(error, C);
    else createNonEnumerableProperty(error, 'stack', clearErrorStack(stack, dropEntries));
  }
};


/***/ }),

/***/ "6f48":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__("6d61");
var collectionStrong = __webpack_require__("6566");

// `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects
collection('Map', function (init) {
  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "7037":
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("a4d3");
__webpack_require__("e01a");
__webpack_require__("d3b7");
__webpack_require__("d28b");
__webpack_require__("e260");
__webpack_require__("3ca3");
__webpack_require__("ddb0");
function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "7149":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var getBuiltIn = __webpack_require__("d066");
var IS_PURE = __webpack_require__("c430");
var NativePromiseConstructor = __webpack_require__("d256");
var FORCED_PROMISE_CONSTRUCTOR = __webpack_require__("4738").CONSTRUCTOR;
var promiseResolve = __webpack_require__("cdf9");

var PromiseConstructorWrapper = getBuiltIn('Promise');
var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;

// `Promise.resolve` method
// https://tc39.es/ecma262/#sec-promise.resolve
$({ target: 'Promise', stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
  resolve: function resolve(x) {
    return promiseResolve(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x);
  }
});


/***/ }),

/***/ "7156":
/***/ (function(module, exports, __webpack_require__) {

var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");
var setPrototypeOf = __webpack_require__("d2bb");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    isCallable(NewTarget = dummy.constructor) &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "7234":
/***/ (function(module, exports) {

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ "7282":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var aCallable = __webpack_require__("59ed");

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "72f7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var exportTypedArrayMethod = __webpack_require__("ebb5").exportTypedArrayMethod;
var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");

var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
var arrayToString = [].toString;
var join = uncurryThis([].join);

if (fails(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return join(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

// `%TypedArray%.prototype.toString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);


/***/ }),

/***/ "735e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $fill = __webpack_require__("81d5");
var toBigInt = __webpack_require__("f495");
var classof = __webpack_require__("f5df");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var fails = __webpack_require__("d039");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var slice = uncurryThis(''.slice);

// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18
var CONVERSION_BUG = fails(function () {
  var count = 0;
  // eslint-disable-next-line es/no-typed-arrays -- safe
  new Int8Array(2).fill({ valueOf: function () { return count++; } });
  return count !== 1;
});

// `%TypedArray%.prototype.fill` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
  var length = arguments.length;
  aTypedArray(this);
  var actualValue = slice(classof(this), 0, 3) === 'Big' ? toBigInt(value) : +value;
  return call($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);
}, CONVERSION_BUG);


/***/ }),

/***/ "7393":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "7418":
/***/ (function(module, exports) {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "74e8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var DESCRIPTORS = __webpack_require__("83ab");
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__("8aa7");
var ArrayBufferViewCore = __webpack_require__("ebb5");
var ArrayBufferModule = __webpack_require__("621a");
var anInstance = __webpack_require__("19aa");
var createPropertyDescriptor = __webpack_require__("5c6c");
var createNonEnumerableProperty = __webpack_require__("9112");
var isIntegralNumber = __webpack_require__("eac5");
var toLength = __webpack_require__("50c4");
var toIndex = __webpack_require__("0b25");
var toOffset = __webpack_require__("182d");
var toPropertyKey = __webpack_require__("a04b");
var hasOwn = __webpack_require__("1a2d");
var classof = __webpack_require__("f5df");
var isObject = __webpack_require__("861d");
var isSymbol = __webpack_require__("d9b5");
var create = __webpack_require__("7c73");
var isPrototypeOf = __webpack_require__("3a9b");
var setPrototypeOf = __webpack_require__("d2bb");
var getOwnPropertyNames = __webpack_require__("241c").f;
var typedArrayFrom = __webpack_require__("a078");
var forEach = __webpack_require__("b727").forEach;
var setSpecies = __webpack_require__("2626");
var defineBuiltInAccessor = __webpack_require__("edd0");
var definePropertyModule = __webpack_require__("9bf2");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var InternalStateModule = __webpack_require__("69f3");
var inheritIfRequired = __webpack_require__("7156");

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var enforceInternalState = InternalStateModule.enforce;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer.prototype;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  aTypedArrayConstructor(C);
  var index = 0;
  var length = list.length;
  var result = new C(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  defineBuiltInAccessor(it, key, {
    configurable: true,
    get: function () {
      return getInternalState(this)[key];
    }
  });
};

var isArrayBuffer = function (it) {
  var klass;
  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && !isSymbol(key)
    && key in target
    && isIntegralNumber(+key)
    && key >= 0;
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  key = toPropertyKey(key);
  return isTypedArrayIndex(target, key)
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  key = toPropertyKey(key);
  if (isTypedArrayIndex(target, key)
    && isObject(descriptor)
    && hasOwn(descriptor, 'value')
    && !hasOwn(descriptor, 'get')
    && !hasOwn(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!hasOwn(descriptor, 'writable') || descriptor.writable)
    && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructorPrototype);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return call(typedArrayFrom, TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructorPrototype);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return call(typedArrayFrom, TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    var FORCED = TypedArrayConstructor != NativeTypedArrayConstructor;

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "7562":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    transitionShow: {
      type: String,
      default: 'fade'
    },
    transitionHide: {
      type: String,
      default: 'fade'
    }
  },
  computed: {
    transitionProps: function transitionProps() {
      var show = "q-transition--".concat(this.transitionShow || this.defaultTransitionShow);
      var hide = "q-transition--".concat(this.transitionHide || this.defaultTransitionHide);
      return {
        appear: true,
        enterClass: "".concat(show, "-enter"),
        enterActiveClass: "".concat(show, "-enter-active"),
        enterToClass: "".concat(show, "-enter-to"),
        leaveClass: "".concat(hide, "-leave"),
        leaveActiveClass: "".concat(hide, "-leave-active"),
        leaveToClass: "".concat(hide, "-leave-to")
      };
    }
  }
});

/***/ }),

/***/ "7697":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlockButton_vue_vue_type_style_index_0_id_0bd2a5d9_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("32e7");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlockButton_vue_vue_type_style_index_0_id_0bd2a5d9_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlockButton_vue_vue_type_style_index_0_id_0bd2a5d9_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "775d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_PlaygroundCanvas_vue_vue_type_style_index_0_id_09d07b72_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca0c");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_PlaygroundCanvas_vue_vue_type_style_index_0_id_09d07b72_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_PlaygroundCanvas_vue_vue_type_style_index_0_id_09d07b72_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "77a7":
/***/ (function(module, exports) {

// IEEE754 conversions based on https://github.com/feross/ieee754
var $Array = Array;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = $Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare -- NaN check
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare -- NaN check
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    c = pow(2, -exponent);
    if (number * c < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  while (mantissaLength >= 8) {
    buffer[index++] = mantissa & 255;
    mantissa /= 256;
    mantissaLength -= 8;
  }
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  while (exponentLength > 0) {
    buffer[index++] = exponent & 255;
    exponent /= 256;
    exponentLength -= 8;
  }
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  while (nBits > 0) {
    exponent = exponent * 256 + buffer[index--];
    nBits -= 8;
  }
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  while (nBits > 0) {
    mantissa = mantissa * 256 + buffer[index--];
    nBits -= 8;
  }
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

module.exports = {
  pack: pack,
  unpack: unpack
};


/***/ }),

/***/ "7839":
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "785a":
/***/ (function(module, exports, __webpack_require__) {

// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`
var documentCreateElement = __webpack_require__("cc12");

var classList = documentCreateElement('span').classList;
var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;

module.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;


/***/ }),

/***/ "7b0b":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("1d80");

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "7c73":
/***/ (function(module, exports, __webpack_require__) {

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__("825a");
var definePropertiesModule = __webpack_require__("37e8");
var enumBugKeys = __webpack_require__("7839");
var hiddenKeys = __webpack_require__("d012");
var html = __webpack_require__("1be4");
var documentCreateElement = __webpack_require__("cc12");
var sharedKey = __webpack_require__("f772");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ "7db0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $find = __webpack_require__("b727").find;
var addToUnscopables = __webpack_require__("44d2");

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
// eslint-disable-next-line es/no-array-prototype-find -- testing
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "7e84":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _getPrototypeOf; });
/* harmony import */ var core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("131a");
/* harmony import */ var core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("3410");
/* harmony import */ var core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_prototype_of_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_object_proto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("1f68");
/* harmony import */ var core_js_modules_es_object_proto_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_proto_js__WEBPACK_IMPORTED_MODULE_2__);



function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "7ee0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0967");
/* harmony import */ var _listeners_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("87e8");


/* harmony default export */ __webpack_exports__["a"] = ({
  mixins: [_listeners_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]],
  props: {
    value: {
      type: Boolean,
      default: void 0
    }
  },
  data: function data() {
    return {
      showing: false
    };
  },
  watch: {
    value: function value(val) {
      this.__processModelChange(val);
    },
    $route: function $route() {
      this.hideOnRouteChange === true && this.showing === true && this.hide();
    }
  },
  methods: {
    toggle: function toggle(evt) {
      this[this.showing === true ? 'hide' : 'show'](evt);
    },
    show: function show(evt) {
      var _this = this;
      if (this.disable === true || this.__showCondition !== void 0 && this.__showCondition(evt) !== true) {
        return;
      }
      if (this.qListeners.input !== void 0 && _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "e"] === false) {
        this.$emit('input', true);
        this.payload = evt;
        this.$nextTick(function () {
          if (_this.payload === evt) {
            _this.payload = void 0;
          }
        });
      }
      if (this.value === void 0 || this.qListeners.input === void 0 || _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "e"] === true) {
        this.__processShow(evt);
      }
    },
    __processShow: function __processShow(evt) {
      if (this.showing === true) {
        return;
      }

      // need to call it before setting showing to true
      // in order to not ruin the animation
      this.__preparePortal !== void 0 && this.__preparePortal();
      this.showing = true;
      this.$emit('before-show', evt);
      if (this.__show !== void 0) {
        this.__show(evt);
      } else {
        this.$emit('show', evt);
      }
    },
    hide: function hide(evt) {
      var _this2 = this;
      if (this.disable === true) {
        return;
      }
      if (this.qListeners.input !== void 0 && _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "e"] === false) {
        this.$emit('input', false);
        this.payload = evt;
        this.$nextTick(function () {
          if (_this2.payload === evt) {
            _this2.payload = void 0;
          }
        });
      }
      if (this.value === void 0 || this.qListeners.input === void 0 || _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* isSSR */ "e"] === true) {
        this.__processHide(evt);
      }
    },
    __processHide: function __processHide(evt) {
      if (this.showing === false) {
        return;
      }
      this.showing = false;
      this.$emit('before-hide', evt);
      if (this.__hide !== void 0) {
        this.__hide(evt);
      } else {
        this.$emit('hide', evt);
      }
    },
    __processModelChange: function __processModelChange(val) {
      if (this.disable === true && val === true) {
        this.qListeners.input !== void 0 && this.$emit('input', false);
      } else if (val === true !== this.showing) {
        this["__process".concat(val === true ? 'Show' : 'Hide')](this.payload);
      }
    }
  }
});

/***/ }),

/***/ "800b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlock.vue?vue&type=template&id=8b34d9ea&scoped=true&

var render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', {
    class: "codeblock block-".concat(_vm.typeName)
  }, [_c('CodeBlockButton', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.showBookmarkButton,
      expression: "showBookmarkButton"
    }],
    attrs: {
      "block": _vm.block,
      "isBookmarkPanel": _vm.isBookmarkPanel
    }
  }), _c('codemirror', {
    ref: "codeBox",
    class: "accqstXmlInput noRTEditor codebox ".concat(_vm.boxClass),
    attrs: {
      "value": _vm.code,
      "options": _vm.options,
      "name": "".concat(_vm.namePrefix, "block[").concat(_vm.block.parentID, "][").concat(_vm.block.id, "]"),
      "id": "teQ".concat(_vm.block.parentID, "B").concat(_vm.block.id),
      "data-question": _vm.block.parentID,
      "events": ['keyup']
    },
    on: {
      "ready": _vm.onCodeReady,
      "focus": _vm.onCodeFocus,
      "input": _vm.onCodeChangeDefered,
      "input-read": _vm.onCodeKeyHandle,
      "keyup": _vm.onCodeKeyHandle
    }
  }), _vm.editMode ? _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.hasAlternativeContent,
      expression: "hasAlternativeContent"
    }]
  }, [_c('div', {
    staticClass: "q-mt-lg text-subtitle2 q-pb-xs"
  }, [_vm._v(_vm._s(_vm.$t('CodeBlock.Initial_Content')))]), _c('codemirror', {
    ref: "altBox",
    class: "accqstXmlInput noRTEditor ".concat(_vm.boxClass),
    attrs: {
      "value": _vm.altCode,
      "options": _vm.altOptions,
      "name": "".concat(_vm.namePrefix, "alt_block[").concat(_vm.block.parentID, "][").concat(_vm.block.id, "]")
    },
    on: {
      "ready": _vm.onAltCodeReady,
      "focus": _vm.onAltCodeFocus,
      "input": _vm.onAltCodeChangeDefered
    }
  })], 1) : _vm._e()], 1);
};
var staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/CodeBlock.vue?vue&type=template&id=8b34d9ea&scoped=true&

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__("d4ec");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__("bee2");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js
var inherits = __webpack_require__("262e");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js + 2 modules
var createSuper = __webpack_require__("2caf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
var es_string_trim = __webpack_require__("498a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__("b0c0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__("9ab4");

// EXTERNAL MODULE: ./node_modules/reflect-metadata/Reflect.js
var Reflect = __webpack_require__("98db");

// EXTERNAL MODULE: ./node_modules/vue-property-decorator/lib/index.js + 15 modules
var lib = __webpack_require__("1b40");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/ErrorTip.vue?vue&type=template&id=67eb593e&
var ErrorTipvue_type_template_id_67eb593e_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('q-icon', {
    class: "mdi ".concat(_vm.severityClass, " mainTipIcon"),
    attrs: {
      "name": _vm.severityIcon
    }
  }, [_c('q-tooltip', [_c('div', [_c('ul', {
    staticClass: "tiplist"
  }, _vm._l(_vm.errors, function (error) {
    return _c('li', {
      key: error.message
    }, [_c('div', {
      staticClass: "row"
    }, [_c('div', {
      staticClass: "col-1"
    }, [_c('q-icon', {
      attrs: {
        "name": _vm.iconForSeverity(error.severity)
      }
    })], 1), _c('div', {
      staticClass: "col-11 q-pr-md"
    }, [_c('div', {
      staticClass: "q-my-none tipper"
    }, [_vm._v(_vm._s(error.message))])])])]);
  }), 0)])])], 1);
};
var ErrorTipvue_type_template_id_67eb593e_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/ErrorTip.vue?vue&type=template&id=67eb593e&

// EXTERNAL MODULE: ./src/lib/ICompilerRegistry.ts
var ICompilerRegistry = __webpack_require__("6e19");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/ErrorTip.vue?vue&type=script&lang=ts&








var ErrorTipvue_type_script_lang_ts_ErrorTip = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(ErrorTip, _Vue);
  var _super = Object(createSuper["a" /* default */])(ErrorTip);
  function ErrorTip() {
    Object(classCallCheck["a" /* default */])(this, ErrorTip);
    return _super.apply(this, arguments);
  }
  Object(createClass["a" /* default */])(ErrorTip, [{
    key: "severityClass",
    get: function get() {
      return this.classForSeverity(this.severity);
    }
  }, {
    key: "severityIcon",
    get: function get() {
      return this.iconForSeverity(this.severity);
    }
  }, {
    key: "classForSeverity",
    value: function classForSeverity(s) {
      if (s == ICompilerRegistry["a" /* ErrorSeverity */].Error) {
        return 'gutter-error';
      }
      return 'gutter-warning';
    }
  }, {
    key: "iconForSeverity",
    value: function iconForSeverity(s) {
      if (s == ICompilerRegistry["a" /* ErrorSeverity */].Error) {
        return 'report';
      }
      return 'warning';
    }
  }]);
  return ErrorTip;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])()], ErrorTipvue_type_script_lang_ts_ErrorTip.prototype, "errors", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])()], ErrorTipvue_type_script_lang_ts_ErrorTip.prototype, "severity", void 0);
ErrorTipvue_type_script_lang_ts_ErrorTip = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], ErrorTipvue_type_script_lang_ts_ErrorTip);
/* harmony default export */ var ErrorTipvue_type_script_lang_ts_ = (ErrorTipvue_type_script_lang_ts_ErrorTip);
// CONCATENATED MODULE: ./src/components/ErrorTip.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_ErrorTipvue_type_script_lang_ts_ = (ErrorTipvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/ErrorTip.vue?vue&type=style&index=0&id=67eb593e&prod&lang=sass&
var ErrorTipvue_type_style_index_0_id_67eb593e_prod_lang_sass_ = __webpack_require__("5df4");

// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__("2877");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/icon/QIcon.js
var QIcon = __webpack_require__("0016");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/tooltip/QTooltip.js
var QTooltip = __webpack_require__("05c0");

// EXTERNAL MODULE: ./node_modules/vue-cli-plugin-quasar/lib/runtime.auto-import.js
var runtime_auto_import = __webpack_require__("93dc");
var runtime_auto_import_default = /*#__PURE__*/__webpack_require__.n(runtime_auto_import);

// CONCATENATED MODULE: ./src/components/ErrorTip.vue






/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  components_ErrorTipvue_type_script_lang_ts_,
  ErrorTipvue_type_template_id_67eb593e_render,
  ErrorTipvue_type_template_id_67eb593e_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var components_ErrorTip = (component.exports);



runtime_auto_import_default()(component, 'components', {QIcon: QIcon["a" /* default */],QTooltip: QTooltip["a" /* default */]});

// EXTERNAL MODULE: ./src/components/BaseBlock.vue + 2 modules
var BaseBlock = __webpack_require__("879e");

// EXTERNAL MODULE: ./node_modules/codemirror/lib/codemirror.css
var codemirror = __webpack_require__("a7be");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/solarized.css
var solarized = __webpack_require__("8c06");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/base16-dark.css
var base16_dark = __webpack_require__("8c2e");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/base16-light.css
var base16_light = __webpack_require__("cc10");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/duotone-dark.css
var duotone_dark = __webpack_require__("e8b0");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/duotone-light.css
var duotone_light = __webpack_require__("b6fc");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/xq-dark.css
var xq_dark = __webpack_require__("bd58");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/xq-light.css
var xq_light = __webpack_require__("8d7e");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/blackboard.css
var blackboard = __webpack_require__("7393");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/midnight.css
var midnight = __webpack_require__("1ad7");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/neo.css
var neo = __webpack_require__("d5db");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/mbo.css
var mbo = __webpack_require__("9603");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/mdn-like.css
var mdn_like = __webpack_require__("eb8f");

// EXTERNAL MODULE: ./node_modules/codemirror/mode/clike/clike.js
var clike = __webpack_require__("4ba6");

// EXTERNAL MODULE: ./node_modules/codemirror/mode/fortran/fortran.js
var fortran = __webpack_require__("518b");

// EXTERNAL MODULE: ./node_modules/codemirror/mode/javascript/javascript.js
var javascript = __webpack_require__("f9d4");

// EXTERNAL MODULE: ./node_modules/codemirror/mode/perl/perl.js
var perl = __webpack_require__("906f");

// EXTERNAL MODULE: ./node_modules/codemirror/mode/python/python.js
var python = __webpack_require__("db91");

// EXTERNAL MODULE: ./node_modules/codemirror/mode/r/r.js
var r = __webpack_require__("903e");

// EXTERNAL MODULE: ./node_modules/codemirror/mode/ruby/ruby.js
var ruby = __webpack_require__("8536");

// EXTERNAL MODULE: ./src/lib/glsl/glsl.js
var glsl = __webpack_require__("5e79");

// EXTERNAL MODULE: ./node_modules/codemirror/addon/edit/closebrackets.js
var closebrackets = __webpack_require__("10b2");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlockButton.vue?vue&type=template&id=0bd2a5d9&scoped=true&
var CodeBlockButtonvue_type_template_id_0bd2a5d9_scoped_true_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', {
    staticClass: "floatingButton"
  }, [_c('q-btn', {
    attrs: {
      "color": _vm.color,
      "text-color": "black",
      "icon": _vm.iconName,
      "round": "",
      "size": "xs"
    },
    on: {
      "click": _vm.onClick
    }
  })], 1);
};
var CodeBlockButtonvue_type_template_id_0bd2a5d9_scoped_true_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/CodeBlockButton.vue?vue&type=template&id=0bd2a5d9&scoped=true&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlockButton.vue?vue&type=script&lang=ts&







var CodeBlockButtonvue_type_script_lang_ts_CodeBlockButton = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(CodeBlockButton, _Vue);
  var _super = Object(createSuper["a" /* default */])(CodeBlockButton);
  function CodeBlockButton() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, CodeBlockButton);
    _this = _super.apply(this, arguments);
    _this.bookmarked = false;
    return _this;
  }
  Object(createClass["a" /* default */])(CodeBlockButton, [{
    key: "color",
    get: function get() {
      return this.isBookmarkPanel ? 'red-4' : 'amber';
    }
  }, {
    key: "iconName",
    get: function get() {
      if (this.isBookmarkPanel) {
        return 'close';
      }
      return this.bookmarked ? 'bookmark' : 'bookmark_border';
    }
  }, {
    key: "bookmarkMe",
    value: function bookmarkMe() {
      var data = {
        uuid: this.block.appSettings.uuid,
        block: this.isBookmarkPanel ? null : this.block
      };
      lib["c" /* Vue */].$GlobalEventHub.$emit('bookmark-block', data);
    }
  }, {
    key: "onClick",
    value: function onClick() {
      this.bookmarkMe();
    }
  }, {
    key: "onBookmark",
    value: function onBookmark(data) {
      this.bookmarked = data.block === null || this.block === null ? false : this.block.uuid === data.block.uuid;
    }
  }, {
    key: "mounted",
    value: function mounted() {
      lib["c" /* Vue */].$GlobalEventHub.$on('bookmark-block', this.onBookmark);
    }
  }, {
    key: "beforeDestroy",
    value: function beforeDestroy() {
      lib["c" /* Vue */].$GlobalEventHub.$off('bookmark-block');
    }
  }]);
  return CodeBlockButton;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodeBlockButtonvue_type_script_lang_ts_CodeBlockButton.prototype, "block", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], CodeBlockButtonvue_type_script_lang_ts_CodeBlockButton.prototype, "isBookmarkPanel", void 0);
CodeBlockButtonvue_type_script_lang_ts_CodeBlockButton = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], CodeBlockButtonvue_type_script_lang_ts_CodeBlockButton);
/* harmony default export */ var CodeBlockButtonvue_type_script_lang_ts_ = (CodeBlockButtonvue_type_script_lang_ts_CodeBlockButton);
// CONCATENATED MODULE: ./src/components/CodeBlockButton.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_CodeBlockButtonvue_type_script_lang_ts_ = (CodeBlockButtonvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/CodeBlockButton.vue?vue&type=style&index=0&id=0bd2a5d9&prod&lang=sass&scoped=true&
var CodeBlockButtonvue_type_style_index_0_id_0bd2a5d9_prod_lang_sass_scoped_true_ = __webpack_require__("7697");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/btn/QBtn.js + 1 modules
var QBtn = __webpack_require__("9c40");

// CONCATENATED MODULE: ./src/components/CodeBlockButton.vue






/* normalize component */

var CodeBlockButton_component = Object(componentNormalizer["a" /* default */])(
  components_CodeBlockButtonvue_type_script_lang_ts_,
  CodeBlockButtonvue_type_template_id_0bd2a5d9_scoped_true_render,
  CodeBlockButtonvue_type_template_id_0bd2a5d9_scoped_true_staticRenderFns,
  false,
  null,
  "0bd2a5d9",
  null
  
)

/* harmony default export */ var components_CodeBlockButton = (CodeBlockButton_component.exports);


runtime_auto_import_default()(CodeBlockButton_component, 'components', {QBtn: QBtn["a" /* default */]});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlock.vue?vue&type=script&lang=ts&















//themes












//languages








//plugins

//helper to create tooltips at runtime

var ErrorTipCtor = lib["c" /* Vue */].extend(components_ErrorTip);
var CodeBlockvue_type_script_lang_ts_CodeBlock = /*#__PURE__*/function (_BaseBlock) {
  Object(inherits["a" /* default */])(CodeBlock, _BaseBlock);
  var _super = Object(createSuper["a" /* default */])(CodeBlock);
  function CodeBlock() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, CodeBlock);
    _this = _super.apply(this, arguments);
    _this.codeUpdateTimer = null;
    _this.codeUpdateStartTime = 0;
    _this.continuousCodeUpdateTimer = null;
    _this.codeNeedsTagUpdate = true;
    _this.altCodeUpdateTimer = null;
    _this.altCodeUpdateStartTime = 0;
    return _this;
  }
  Object(createClass["a" /* default */])(CodeBlock, [{
    key: "showBookmarkButton",
    get: function get() {
      return this.canBookmark && this.editMode;
    }
  }, {
    key: "clearTagMarkers",
    value: function clearTagMarkers() {
      if (this.codemirror === undefined) {
        return;
      }
      var allMarks = this.codemirror.getDoc().getAllMarks();
      allMarks.forEach(function (e) {
        if (e.className == lib["c" /* Vue */].$tagger.className.rnd || e.className == lib["c" /* Vue */].$tagger.className.templ) {
          e.clear();
        }
      });
      if (this.altcodemirror) {
        allMarks = this.altcodemirror.getDoc().getAllMarks();
        allMarks.forEach(function (e) {
          if (e.className == lib["c" /* Vue */].$tagger.className.rnd || e.className == lib["c" /* Vue */].$tagger.className.templ) {
            e.clear();
          }
        });
      }
    }
  }, {
    key: "clearErrorDisplay",
    value: function clearErrorDisplay() {
      if (this.codemirror === undefined) {
        return;
      }
      var allMarks = this.codemirror.getDoc().getAllMarks();
      //console.log("marks", this.block.type, allMarks)
      allMarks.forEach(function (e) {
        if (e.className == 'red-wave') {
          e.clear();
        }
      });
      this.codemirror.getDoc().clearGutter('diagnostics');
    }
  }, {
    key: "onCodeReady",
    value: function onCodeReady(editor) {
      var _this2 = this;
      //we need this for StudON to make sure tinyMCE is not taking over :D
      if (this.codemirror && this.codemirror.display && this.codemirror.display.input && this.codemirror.display.input.textarea) {
        this.codemirror.display.input.textarea.className = 'noRTEditor';
      }
      this.codeBox.$el.querySelectorAll('textarea[name]').forEach(function (el) {
        el.className = (el.className + ' accqstXmlInput noRTEditor').trim();
        el.id = _this2.codeBox.$el.id;
        $(el).text(_this2.block.content);
        el.setAttribute('data-question', "".concat(_this2.block.parentID));
        el.setAttribute('data-blocktype', "".concat(_this2.iliasTypeNr));
        if (_this2.editMode) {
          el.setAttribute('is-editmode', "".concat(_this2.editMode));
        }
      });
      this.updateDiagnosticDisplay();
      this.onCodeChange(this.block.content);
      this.whenBlockIsReady();
    }
  }, {
    key: "onAltCodeReady",
    value: function onAltCodeReady(editor) {
      var _this3 = this;
      console.d('READY');
      //we need this for StudON to make sure tinyMCE is not taking over :D
      if (this.altcodemirror && this.altcodemirror.display && this.altcodemirror.display.input && this.altcodemirror.display.input.textarea) {
        this.altcodemirror.display.input.textarea.className = 'noRTEditor';
      }
      this.altBox.$el.querySelectorAll('textarea[name]').forEach(function (el) {
        el.className = (el.className + ' accqstXmlInput noRTEditor').trim();
      });
      this.$nextTick(function () {
        _this3.onAltCodeChange(_this3.block.alternativeContent);
        _this3.updateTagDisplay();
        _this3.updateHeight();
      });
    }
  }, {
    key: "onCodeFocus",
    value: function onCodeFocus(editor) {}
  }, {
    key: "onAltCodeFocus",
    value: function onAltCodeFocus(editor) {}
  }, {
    key: "onCodeChangeDefered",
    value: function onCodeChangeDefered(newCode) {
      var _this4 = this;
      if (!this.editMode) {
        this.onCodeChange(newCode);
        return;
      }
      var now = new Date().getTime();
      //clear an existing update timeout
      if (this.codeUpdateTimer !== null) {
        clearTimeout(this.codeUpdateTimer);
        this.codeUpdateTimer = null;
      } else {
        this.codeUpdateStartTime = now;
      }
      var doIt = function doIt() {
        _this4.codeUpdateTimer = null;
        _this4.onCodeChange(newCode);
      };
      //did we wait for a maximum time? run
      if (now - this.codeUpdateStartTime > "800") {
        doIt();
        return;
      }
      this.codeUpdateTimer = setTimeout(function () {
        doIt();
      }, "150");
    }
  }, {
    key: "onCodeChange",
    value: function onCodeChange(newCode) {
      var _this5 = this;
      //update line numbers manually (changing in options takes too long)
      this.block.lineCountHint = this.codemirror.doc.size;
      this.codemirror.options.firstLineNumber = this.block.firstLine;
      //copy the content to the actual textbox processed by StudON
      var tb = this.codeBox.$el.querySelector('textarea[name]');
      tb.value = newCode;
      //copy code to the block structure
      this.block.content = newCode;
      //find all tags
      this.updateTagDisplay();
      //send out the event for processing
      if (this.editMode) {
        this.$emit('code-changed-in-edit-mode', undefined);
      } else if (this.emitWhenTypingInViewMode) {
        if (this.continuousCodeUpdateTimer !== null) {
          clearTimeout(this.continuousCodeUpdateTimer);
          this.continuousCodeUpdateTimer = null;
        }
        this.continuousCodeUpdateTimer = setTimeout(function () {
          _this5.$emit('code-changed-in-view-mode', undefined);
        }, "150");
      }
    }
  }, {
    key: "didAddText",
    value: function didAddText(t) {
      //console.log('    ', t)
      if (t.indexOf('!') >= 0 || t.indexOf('+') >= 0 || t.indexOf('{') >= 0 || t.indexOf('{') >= 0 || t.indexOf('\n') >= 0) {
        this.codeNeedsTagUpdate = true;
      }
    }
  }, {
    key: "onCodeKeyHandle",
    value: function onCodeKeyHandle(e) {
      var _this6 = this;
      //console.log('IR', e, arguments)
      if (arguments.length > 1 && arguments[1] !== undefined) {
        if (arguments[1].text !== undefined) {
          arguments[1].text.forEach(function (t) {
            _this6.didAddText(t);
          });
        } else if (arguments[1].key !== undefined) {
          if (arguments[1].keyCode == 13) {
            this.didAddText('\n');
          } else {
            this.didAddText(arguments[1].key);
          }
        }
      }
    }
  }, {
    key: "onAltCodeChangeDefered",
    value: function onAltCodeChangeDefered(newCode) {
      var _this7 = this;
      var now = new Date().getTime();
      //clear an existing update timeout
      if (this.altCodeUpdateTimer !== null) {
        clearTimeout(this.altCodeUpdateTimer);
        this.altCodeUpdateTimer = null;
      } else {
        this.altCodeUpdateStartTime = now;
      }
      var doIt = function doIt() {
        _this7.altCodeUpdateTimer = null;
        _this7.onAltCodeChange(newCode);
      };
      //did we wait for a maximum time? run
      if (now - this.altCodeUpdateStartTime > "800") {
        doIt();
        return;
      }
      this.altCodeUpdateTimer = setTimeout(function () {
        doIt();
      }, "150");
    }
  }, {
    key: "onAltCodeChange",
    value: function onAltCodeChange(newCode) {
      if (this.altBox !== undefined) {
        var tb = this.altBox.$el.querySelector('textarea[name]');
        tb.value = newCode;
      }
      this.block.alternativeContent = newCode;
      this.updateTagDisplay();
    }
  }, {
    key: "updateHeight",
    value: function updateHeight() {
      if (this.visibleLines === 'auto' || this.block.static) {
        if (this.codemirror) {
          this.codemirror.setSize('height', 'auto');
        }
        if (this.altcodemirror) {
          this.altcodemirror.setSize('height', 'auto');
        }
      } else {
        if (this.codemirror) {
          this.codemirror.setSize(null, Math.round(20 * Math.max(1, this.visibleLines)) + 9);
        }
        if (this.altcodemirror) {
          this.altcodemirror.setSize(null, Math.round(20 * Math.max(1, this.visibleLines)) + 9);
        }
      }
    }
  }, {
    key: "replaceTemplateTags",
    value: function replaceTemplateTags(o) {
      if (!this.editMode) {
        return;
      }
      if (o.scopeUUID != this.block.scopeUUID) {
        return;
      }
      this.block.content = lib["c" /* Vue */].$tagger.replaceTemplateTagInString(this.block.content, o.name, o.newValue);
    }
  }, {
    key: "updateTagDisplay",
    value: function updateTagDisplay() {
      var _this8 = this;
      if (!this.editMode || this.block === undefined || this.block.appSettings === undefined || this.block.appSettings.randomizer === undefined || !this.block.appSettings.randomizer.active || !this.codeNeedsTagUpdate) {
        return;
      }
      this.codeNeedsTagUpdate = false;
      //console.log('Updating Tags')
      this.clearTagMarkers();
      lib["c" /* Vue */].$tagger.getMarkers(this.block.content).forEach(function (m) {
        _this8.codemirror.getDoc().markText(m.start, m.end, {
          className: lib["c" /* Vue */].$tagger.className[m.type],
          inclusiveLeft: true,
          inclusiveRight: true,
          title: m.name,
          startStyle: 'tag-mark-start',
          endStyle: 'tag-mark-end'
        });
      });
      this.$nextTick(function () {
        lib["c" /* Vue */].$tagger.hookClick(_this8.codeBox.$el, _this8.block.scopeUUID);
      });
      if (this.altcodemirror) {
        lib["c" /* Vue */].$tagger.getMarkers(this.block.alternativeContent).forEach(function (m) {
          _this8.altcodemirror.getDoc().markText(m.start, m.end, {
            className: lib["c" /* Vue */].$tagger.className[m.type],
            inclusiveLeft: true,
            inclusiveRight: true,
            title: m.name,
            startStyle: 'tag-mark-start',
            endStyle: 'tag-mark-end'
          });
        });
        this.$nextTick(function () {
          if (_this8.altBox !== undefined) {
            lib["c" /* Vue */].$tagger.hookClick(_this8.altBox.$el, _this8.block.scopeUUID);
          }
        });
      }
    }
  }, {
    key: "updateDiagnosticDisplay",
    value: function updateDiagnosticDisplay() {
      var _this9 = this;
      var val = this.errors;
      if (val !== undefined) {
        this.clearErrorDisplay();
        var first = this.block.firstLine;
        val.forEach(function (error) {
          if (error.start.column >= 0) {
            //console.log("squiggle", this.block.type);
            //put a squigly line as code marker
            _this9.codemirror.getDoc().markText({
              line: error.start.line - first,
              ch: error.start.column
            }, {
              line: error.end.line - first,
              ch: error.end.column
            }, {
              className: 'red-wave',
              inclusiveLeft: true,
              inclusiveRight: true,
              title: error.message
            });
          }
          //read existing gutter marker or create a new one
          var info = _this9.codemirror.getDoc().lineInfo(error.start.line - first);
          var element = info && info.gutterMarkers ? info.gutterMarkers['diagnostics'].$component : null;
          if (element == null) {
            //console.log("Gutter", this.block.type, error.start.line, error.message, first);
            element = document.createElement('span');
            //place the updated element
            _this9.codemirror.getDoc().setGutterMarker(error.start.line - first, 'diagnostics', element);
            element.$component = new ErrorTipCtor({
              propsData: {
                errors: [],
                severity: error.severity
              }
            }).$mount(element);
            element = element.$component;
          }
          //make sure we use the proper class for the given severity.
          //We allways choose the maximum severity for each marking
          element.severity = Math.max(error.severity, element.severity);
          //Build the hint text
          if (element.errors.indexOf(error) == -1) {
            element.errors.push(error);
          }
        });
      } else {
        this.clearErrorDisplay();
      }
    }
  }, {
    key: "codeBox",
    get: function get() {
      return this.$refs.codeBox;
    }
  }, {
    key: "altBox",
    get: function get() {
      return this.$refs.altBox;
    }
  }, {
    key: "hasAlternativeContent",
    get: function get() {
      return this.block.hasAlternativeContent && this.typeName == 'block';
    }
  }, {
    key: "errors",
    get: function get() {
      return this.block.errors;
    }
  }, {
    key: "randomizerActive",
    get: function get() {
      return this.tagSet !== undefined;
    }
  }, {
    key: "boxClass",
    get: function get() {
      var cl = '';
      if (this.block.hidden && !this.editMode) {
        cl += 'hiddenBox ';
      }
      if (this.block.readonly || this.readonly) {
        cl += 'readonlyBox ';
      }
      if (this.block.static) {
        cl += 'staticBox ';
      }
      return cl;
    }
  }, {
    key: "iliasTypeNr",
    get: function get() {
      var t = this.typeName;
      if (t == 'text') {
        return 0;
      }
      if (t == 'block-static') {
        return 1;
      }
      if (t == 'block') {
        return 2;
      }
      if (t == 'block-hidden') {
        return 3;
      }
      if (t == 'playground') {
        return 4;
      }
      if (t == 'blockly') {
        return 5;
      }
      if (t == 'repl') {
        return 6;
      }
      if (t == 'data') {
        return 7;
      }
      return -1;
    }
  }, {
    key: "typeName",
    get: function get() {
      var s = this.block.type.toLowerCase();
      if (this.block.hidden) {
        s += '-hidden';
      }
      if (this.block.static) {
        s += '-static';
      }
      return s;
    }
  }, {
    key: "altCode",
    get: function get() {
      if (this.block.alternativeContent === null) {
        return '';
      }
      return this.block.alternativeContent;
    }
  }, {
    key: "code",
    get: function get() {
      if (!this.editMode) {
        return this.block.actualContent();
      }
      return this.block.content;
    }
  }, {
    key: "options",
    get: function get() {
      return {
        // codemirror options
        mode: this.mode,
        theme: this.theme,
        lineNumbers: true,
        line: true,
        tabSize: 4,
        indentUnit: 4,
        autoCloseBrackets: true,
        readOnly: !this.editMode && (this.block.readonly || this.block.static || this.block.hidden || this.readonly),
        //firstLineNumber: this.block.firstLine, //make sure to change altOptions as well when activating this
        gutters: ['diagnostics', 'CodeMirror-linenumbers']
      };
    }
  }, {
    key: "altOptions",
    get: function get() {
      return this.options;
      // let o = { ...this.options }
      // o.firstLineNumber = 1
      // return o
    }
  }, {
    key: "codemirror",
    get: function get() {
      return this.codeBox.codemirror;
    }
  }, {
    key: "altcodemirror",
    get: function get() {
      if (this.altBox === undefined) {
        return undefined;
      }
      return this.altBox.codemirror;
    }
  }, {
    key: "readyWhenMounted",
    get: function get() {
      return false;
    }
  }, {
    key: "onFirstLineChanged",
    value: function onFirstLineChanged(val) {
      if (this.codemirror) {
        if (this.codemirror.options.firstLineNumber != this.block.firstLine) {
          this.codemirror.options.firstLineNumber = this.block.firstLine;
          this.codemirror.refresh();
        }
      }
    }
  }, {
    key: "onVisibleLinesChanged",
    value: function onVisibleLinesChanged(val) {
      this.updateHeight();
    }
  }, {
    key: "onErrorsChanged",
    value: function onErrorsChanged(val) {
      this.updateDiagnosticDisplay();
    }
  }, {
    key: "created",
    value: function created() {
      console.d('ReadyWhenMounted in CodeBlock', this.readyWhenMounted);
      //this.$options.readyWhenMounted = false;
    }
  }, {
    key: "mounted",
    value: function mounted() {
      var _this10 = this;
      this.updateHeight();
      if (this.editMode && this.codemirror) {
        console.d('Attach');
        var buildIt = function buildIt() {
          console.log('EMIT');
          _this10.$emit('build');
        };
        this.codemirror.addKeyMap({
          'Cmd-B': function CmdB(cMirror) {
            buildIt();
          },
          'Ctrl-B': function CtrlB(cMirror) {
            buildIt();
          }
        });
        this.codemirror.addKeyMap({
          Tab: function Tab(cMirror) {
            cMirror.execCommand('insertSoftTab');
          }
        });
      }
      lib["c" /* Vue */].$tagger.$on('replace-template-tag', this.replaceTemplateTags);
      this.codeNeedsTagUpdate = true;
      this.updateTagDisplay();
    }
  }, {
    key: "beforeDestroy",
    value: function beforeDestroy() {
      lib["c" /* Vue */].$tagger.$off('replace-template-tag', this.replaceTemplateTags);
    }
  }]);
  return CodeBlock;
}(BaseBlock["a" /* default */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: ''
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "namePrefix", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "emitWhenTypingInViewMode", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: true
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "canBookmark", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "isBookmarkPanel", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "readonly", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "editMode", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: 'auto'
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "visibleLines", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: 'base16-dark'
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "theme", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: 'text/javascript'
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "mode", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: undefined
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "tagSet", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true,
  validator: function validator(b) {
    if (b === null || b.content === undefined) {
      return false;
    }
    if (b.firstLine === undefined) {
      return false;
    }
    return true;
  }
})], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "block", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["d" /* Watch */])('block.firstLine')], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "onFirstLineChanged", null);
Object(tslib_es6["b" /* __decorate */])([Object(lib["d" /* Watch */])('visibleLines')], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "onVisibleLinesChanged", null);
Object(tslib_es6["b" /* __decorate */])([Object(lib["d" /* Watch */])('errors')], CodeBlockvue_type_script_lang_ts_CodeBlock.prototype, "onErrorsChanged", null);
CodeBlockvue_type_script_lang_ts_CodeBlock = Object(tslib_es6["b" /* __decorate */])([Object(lib["a" /* Component */])({
  components: {
    CodeBlockButton: components_CodeBlockButton
  }
})], CodeBlockvue_type_script_lang_ts_CodeBlock);
/* harmony default export */ var CodeBlockvue_type_script_lang_ts_ = (CodeBlockvue_type_script_lang_ts_CodeBlock);
// CONCATENATED MODULE: ./src/components/CodeBlock.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_CodeBlockvue_type_script_lang_ts_ = (CodeBlockvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/CodeBlock.vue?vue&type=style&index=0&id=8b34d9ea&prod&scoped=true&lang=sass&
var CodeBlockvue_type_style_index_0_id_8b34d9ea_prod_scoped_true_lang_sass_ = __webpack_require__("f517");

// CONCATENATED MODULE: ./src/components/CodeBlock.vue






/* normalize component */

var CodeBlock_component = Object(componentNormalizer["a" /* default */])(
  components_CodeBlockvue_type_script_lang_ts_,
  render,
  staticRenderFns,
  false,
  null,
  "8b34d9ea",
  null
  
)

/* harmony default export */ var components_CodeBlock = __webpack_exports__["a"] = (CodeBlock_component.exports);

/***/ }),

/***/ "80e0":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("e065");

// `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');


/***/ }),

/***/ "8172":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("e065");
var defineSymbolToPrimitive = __webpack_require__("57b9");

// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();


/***/ }),

/***/ "81b8":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("e065");

// `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');


/***/ }),

/***/ "81d5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__("7b0b");
var toAbsoluteIndex = __webpack_require__("23cb");
var lengthOfArrayLike = __webpack_require__("07fa");

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = lengthOfArrayLike(O);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "81e7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ install_queues; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ install_$q; });

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.freeze.js
var es_object_freeze = __webpack_require__("dca8");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.keys.js
var es_object_keys = __webpack_require__("b64b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__("b0c0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.includes.js
var es_string_includes = __webpack_require__("2532");

// EXTERNAL MODULE: ./node_modules/quasar/package.json
var quasar_package = __webpack_require__("c0a8");

// EXTERNAL MODULE: ./node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("0967");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 3 modules
var slicedToArray = __webpack_require__("3835");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("d882");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/debounce.js
var debounce = __webpack_require__("1c16");

// CONCATENATED MODULE: ./node_modules/quasar/src/plugins/Screen.js









var SIZE_LIST = ['sm', 'md', 'lg', 'xl'];
var passive = utils_event["e" /* listenOpts */].passive;
/* harmony default export */ var Screen = ({
  width: 0,
  height: 0,
  name: 'xs',
  sizes: {
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
  },
  lt: {
    sm: true,
    md: true,
    lg: true,
    xl: true
  },
  gt: {
    xs: false,
    sm: false,
    md: false,
    lg: false
  },
  xs: true,
  sm: false,
  md: false,
  lg: false,
  xl: false,
  setSizes: utils_event["f" /* noop */],
  setDebounce: utils_event["f" /* noop */],
  install: function install($q, queues, cfg) {
    var _this = this;
    if (Platform["e" /* isSSR */] === true) {
      $q.screen = this;
      return;
    }
    var _window = window,
      visualViewport = _window.visualViewport;
    var target = visualViewport || window;
    var scrollingElement = document.scrollingElement || document.documentElement;
    var getSize = visualViewport === void 0 || Platform["a" /* client */].is.mobile === true ? function () {
      return [Math.max(window.innerWidth, scrollingElement.clientWidth), Math.max(window.innerHeight, scrollingElement.clientHeight)];
    } : function () {
      return [visualViewport.width * visualViewport.scale + window.innerWidth - scrollingElement.clientWidth, visualViewport.height * visualViewport.scale + window.innerHeight - scrollingElement.clientHeight];
    };
    var classes = cfg.screen !== void 0 && cfg.screen.bodyClasses === true;
    var update = function update(force) {
      var _getSize = getSize(),
        _getSize2 = Object(slicedToArray["a" /* default */])(_getSize, 2),
        w = _getSize2[0],
        h = _getSize2[1];
      if (h !== _this.height) {
        _this.height = h;
      }
      if (w !== _this.width) {
        _this.width = w;
      } else if (force !== true) {
        return;
      }
      var s = _this.sizes;
      _this.gt.xs = w >= s.sm;
      _this.gt.sm = w >= s.md;
      _this.gt.md = w >= s.lg;
      _this.gt.lg = w >= s.xl;
      _this.lt.sm = w < s.sm;
      _this.lt.md = w < s.md;
      _this.lt.lg = w < s.lg;
      _this.lt.xl = w < s.xl;
      _this.xs = _this.lt.sm;
      _this.sm = _this.gt.xs === true && _this.lt.md === true;
      _this.md = _this.gt.sm === true && _this.lt.lg === true;
      _this.lg = _this.gt.md === true && _this.lt.xl === true;
      _this.xl = _this.gt.lg;
      s = _this.xs === true && 'xs' || _this.sm === true && 'sm' || _this.md === true && 'md' || _this.lg === true && 'lg' || 'xl';
      if (s !== _this.name) {
        if (classes === true) {
          document.body.classList.remove("screen--".concat(_this.name));
          document.body.classList.add("screen--".concat(s));
        }
        _this.name = s;
      }
    };
    var updateEvt,
      updateSizes = {},
      updateDebounce = 16;
    this.setSizes = function (sizes) {
      SIZE_LIST.forEach(function (name) {
        if (sizes[name] !== void 0) {
          updateSizes[name] = sizes[name];
        }
      });
    };
    this.setDebounce = function (deb) {
      updateDebounce = deb;
    };
    var start = function start() {
      var style = getComputedStyle(document.body);

      // if css props available
      if (style.getPropertyValue('--q-size-sm')) {
        SIZE_LIST.forEach(function (name) {
          _this.sizes[name] = parseInt(style.getPropertyValue("--q-size-".concat(name)), 10);
        });
      }
      _this.setSizes = function (sizes) {
        SIZE_LIST.forEach(function (name) {
          if (sizes[name]) {
            _this.sizes[name] = sizes[name];
          }
        });
        update(true);
      };
      _this.setDebounce = function (delay) {
        updateEvt !== void 0 && target.removeEventListener('resize', updateEvt, passive);
        updateEvt = delay > 0 ? Object(debounce["a" /* default */])(update, delay) : update;
        target.addEventListener('resize', updateEvt, passive);
      };
      _this.setDebounce(updateDebounce);
      if (Object.keys(updateSizes).length > 0) {
        _this.setSizes(updateSizes);
        updateSizes = void 0; // free up memory
      } else {
        update();
      }

      // due to optimizations, this would be left out otherwise
      classes === true && _this.name === 'xs' && document.body.classList.add('screen--xs');
    };
    if (Platform["c" /* fromSSR */] === true) {
      queues.takeover.push(start);
    } else {
      start();
    }
    external_commonjs_vue_commonjs2_vue_root_Vue_default.a.util.defineReactive($q, 'screen', this);
  }
});
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("5319");

// CONCATENATED MODULE: ./node_modules/quasar/src/plugins/Dark.js






var Dark = {
  isActive: false,
  mode: false,
  install: function install($q, queues, _ref) {
    var _this = this;
    var dark = _ref.dark;
    this.isActive = dark === true;
    if (Platform["e" /* isSSR */] === true) {
      queues.server.push(function (q, ctx) {
        q.dark = {
          isActive: false,
          mode: false,
          set: function set(val) {
            ctx.ssr.Q_BODY_CLASSES = ctx.ssr.Q_BODY_CLASSES.replace(' body--light', '').replace(' body--dark', '') + " body--".concat(val === true ? 'dark' : 'light');
            q.dark.isActive = val === true;
            q.dark.mode = val;
          },
          toggle: function toggle() {
            q.dark.set(q.dark.isActive === false);
          }
        };
        q.dark.set(dark);
      });
      this.set = utils_event["f" /* noop */];
      return;
    }
    var initialVal = dark !== void 0 ? dark : false;
    if (Platform["c" /* fromSSR */] === true) {
      var ssrSet = function ssrSet(val) {
        _this.__fromSSR = val;
      };
      var originalSet = this.set;
      this.set = ssrSet;
      ssrSet(initialVal);
      queues.takeover.push(function () {
        _this.set = originalSet;
        _this.set(_this.__fromSSR);
      });
    } else {
      this.set(initialVal);
    }
    external_commonjs_vue_commonjs2_vue_root_Vue_default.a.util.defineReactive(this, 'isActive', this.isActive);
    external_commonjs_vue_commonjs2_vue_root_Vue_default.a.util.defineReactive($q, 'dark', this);
  },
  set: function set(val) {
    var _this2 = this;
    this.mode = val;
    if (val === 'auto') {
      if (this.__media === void 0) {
        this.__media = window.matchMedia('(prefers-color-scheme: dark)');
        this.__updateMedia = function () {
          _this2.set('auto');
        };
        this.__media.addListener(this.__updateMedia);
      }
      val = this.__media.matches;
    } else if (this.__media !== void 0) {
      this.__media.removeListener(this.__updateMedia);
      this.__media = void 0;
    }
    this.isActive = val === true;
    document.body.classList.remove("body--".concat(val === true ? 'light' : 'dark'));
    document.body.classList.add("body--".concat(val === true ? 'dark' : 'light'));
  },
  toggle: function toggle() {
    Dark.set(Dark.isActive === false);
  },
  __media: void 0
};
/* harmony default export */ var plugins_Dark = (Dark);
// EXTERNAL MODULE: ./node_modules/quasar/src/history.js
var src_history = __webpack_require__("582c");

// EXTERNAL MODULE: ./node_modules/quasar/src/lang.js + 1 modules
var lang = __webpack_require__("ec5d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.join.js
var es_array_join = __webpack_require__("a15b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.error.cause.js
var es_error_cause = __webpack_require__("d9e2");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__("fb6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__("25f0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
var es_string_trim = __webpack_require__("498a");

// CONCATENATED MODULE: ./node_modules/quasar/src/utils/colors.js








var reRGBA = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;
function rgbToHex(_ref) {
  var r = _ref.r,
    g = _ref.g,
    b = _ref.b,
    a = _ref.a;
  var alpha = a !== void 0;
  r = Math.round(r);
  g = Math.round(g);
  b = Math.round(b);
  if (r > 255 || g > 255 || b > 255 || alpha && a > 100) {
    throw new TypeError('Expected 3 numbers below 256 (and optionally one below 100)');
  }
  a = alpha ? (Math.round(255 * a / 100) | 1 << 8).toString(16).slice(1) : '';
  return '#' + (b | g << 8 | r << 16 | 1 << 24).toString(16).slice(1) + a;
}
function rgbToString(_ref2) {
  var r = _ref2.r,
    g = _ref2.g,
    b = _ref2.b,
    a = _ref2.a;
  return "rgb".concat(a !== void 0 ? 'a' : '', "(").concat(r, ",").concat(g, ",").concat(b).concat(a !== void 0 ? ',' + a / 100 : '', ")");
}
function hexToRgb(hex) {
  if (typeof hex !== 'string') {
    throw new TypeError('Expected a string');
  }
  hex = hex.replace(/^#/, '');
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  } else if (hex.length === 4) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
  }
  var num = parseInt(hex, 16);
  return hex.length > 6 ? {
    r: num >> 24 & 255,
    g: num >> 16 & 255,
    b: num >> 8 & 255,
    a: Math.round((num & 255) / 2.55)
  } : {
    r: num >> 16,
    g: num >> 8 & 255,
    b: num & 255
  };
}
function hsvToRgb(_ref3) {
  var h = _ref3.h,
    s = _ref3.s,
    v = _ref3.v,
    a = _ref3.a;
  var r, g, b;
  s = s / 100;
  v = v / 100;
  h = h / 360;
  var i = Math.floor(h * 6),
    f = h * 6 - i,
    p = v * (1 - s),
    q = v * (1 - f * s),
    t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
    a: a
  };
}
function rgbToHsv(_ref4) {
  var r = _ref4.r,
    g = _ref4.g,
    b = _ref4.b,
    a = _ref4.a;
  var max = Math.max(r, g, b),
    min = Math.min(r, g, b),
    d = max - min,
    s = max === 0 ? 0 : d / max,
    v = max / 255;
  var h;
  switch (max) {
    case min:
      h = 0;
      break;
    case r:
      h = g - b + d * (g < b ? 6 : 0);
      h /= 6 * d;
      break;
    case g:
      h = b - r + d * 2;
      h /= 6 * d;
      break;
    case b:
      h = r - g + d * 4;
      h /= 6 * d;
      break;
  }
  return {
    h: Math.round(h * 360),
    s: Math.round(s * 100),
    v: Math.round(v * 100),
    a: a
  };
}
function textToRgb(str) {
  if (typeof str !== 'string') {
    throw new TypeError('Expected a string');
  }
  var color = str.replace(/ /g, '');
  var m = reRGBA.exec(color);
  if (m === null) {
    return hexToRgb(color);
  }
  var rgb = {
    r: Math.min(255, parseInt(m[2], 10)),
    g: Math.min(255, parseInt(m[3], 10)),
    b: Math.min(255, parseInt(m[4], 10))
  };
  if (m[1]) {
    var alpha = parseFloat(m[5]);
    rgb.a = Math.min(1, isNaN(alpha) === true ? 1 : alpha) * 100;
  }
  return rgb;
}

/* works as darken if percent < 0 */
function lighten(color, percent) {
  if (typeof color !== 'string') {
    throw new TypeError('Expected a string as color');
  }
  if (typeof percent !== 'number') {
    throw new TypeError('Expected a numeric percent');
  }
  var rgb = textToRgb(color),
    t = percent < 0 ? 0 : 255,
    p = Math.abs(percent) / 100,
    R = rgb.r,
    G = rgb.g,
    B = rgb.b;
  return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
}
function luminosity(color) {
  if (typeof color !== 'string' && (!color || color.r === void 0)) {
    throw new TypeError('Expected a string or a {r, g, b} object as color');
  }
  var rgb = typeof color === 'string' ? textToRgb(color) : color,
    r = rgb.r / 255,
    g = rgb.g / 255,
    b = rgb.b / 255,
    R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4),
    G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4),
    B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
  return 0.2126 * R + 0.7152 * G + 0.0722 * B;
}
function brightness(color) {
  if (typeof color !== 'string' && (!color || color.r === void 0)) {
    throw new TypeError('Expected a string or a {r, g, b} object as color');
  }
  var rgb = typeof color === 'string' ? textToRgb(color) : color;
  return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
}
function blend(fgColor, bgColor) {
  if (typeof fgColor !== 'string' && (!fgColor || fgColor.r === void 0)) {
    throw new TypeError('Expected a string or a {r, g, b[, a]} object as fgColor');
  }
  if (typeof bgColor !== 'string' && (!bgColor || bgColor.r === void 0)) {
    throw new TypeError('Expected a string or a {r, g, b[, a]} object as bgColor');
  }
  var rgb1 = typeof fgColor === 'string' ? textToRgb(fgColor) : fgColor,
    r1 = rgb1.r / 255,
    g1 = rgb1.g / 255,
    b1 = rgb1.b / 255,
    a1 = rgb1.a !== void 0 ? rgb1.a / 100 : 1,
    rgb2 = typeof bgColor === 'string' ? textToRgb(bgColor) : bgColor,
    r2 = rgb2.r / 255,
    g2 = rgb2.g / 255,
    b2 = rgb2.b / 255,
    a2 = rgb2.a !== void 0 ? rgb2.a / 100 : 1,
    a = a1 + a2 * (1 - a1),
    r = Math.round((r1 * a1 + r2 * a2 * (1 - a1)) / a * 255),
    g = Math.round((g1 * a1 + g2 * a2 * (1 - a1)) / a * 255),
    b = Math.round((b1 * a1 + b2 * a2 * (1 - a1)) / a * 255);
  var ret = {
    r: r,
    g: g,
    b: b,
    a: Math.round(a * 100)
  };
  return typeof fgColor === 'string' ? rgbToHex(ret) : ret;
}
function changeAlpha(color, offset) {
  if (typeof color !== 'string') {
    throw new TypeError('Expected a string as color');
  }
  if (offset === void 0 || offset < -1 || offset > 1) {
    throw new TypeError('Expected offset to be between -1 and 1');
  }
  var _textToRgb = textToRgb(color),
    r = _textToRgb.r,
    g = _textToRgb.g,
    b = _textToRgb.b,
    a = _textToRgb.a;
  var alpha = a !== void 0 ? a / 100 : 0;
  return rgbToHex({
    r: r,
    g: g,
    b: b,
    a: Math.round(Math.min(1, Math.max(0, alpha + offset)) * 100)
  });
}
function setBrand(color, value) {
  var element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document.body;
  if (typeof color !== 'string') {
    throw new TypeError('Expected a string as color');
  }
  if (typeof value !== 'string') {
    throw new TypeError('Expected a string as value');
  }
  if (!(element instanceof Element)) {
    throw new TypeError('Expected a DOM element');
  }
  element.style.setProperty("--q-color-".concat(color), value);
}
function getBrand(color) {
  var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.body;
  if (typeof color !== 'string') {
    throw new TypeError('Expected a string as color');
  }
  if (!(element instanceof Element)) {
    throw new TypeError('Expected a DOM element');
  }
  return getComputedStyle(element).getPropertyValue("--q-color-".concat(color)).trim() || null;
}
function getPaletteColor(colorName) {
  if (typeof colorName !== 'string') {
    throw new TypeError('Expected a string as color');
  }
  var el = document.createElement('div');
  el.className = "text-".concat(colorName, " invisible fixed no-pointer-events");
  document.body.appendChild(el);
  var result = getComputedStyle(el).getPropertyValue('color');
  el.remove();
  return rgbToHex(textToRgb(result));
}

// TODO: remove in v2
var stringToRgb = textToRgb;
/* harmony default export */ var colors = ({
  rgbToHex: rgbToHex,
  hexToRgb: hexToRgb,
  hsvToRgb: hsvToRgb,
  rgbToHsv: rgbToHsv,
  textToRgb: textToRgb,
  lighten: lighten,
  luminosity: luminosity,
  brightness: brightness,
  blend: blend,
  changeAlpha: changeAlpha,
  setBrand: setBrand,
  getBrand: getBrand,
  getPaletteColor: getPaletteColor
});
// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/key-composition.js
var key_composition = __webpack_require__("dc8a");

// CONCATENATED MODULE: ./node_modules/quasar/src/body.js










function getMobilePlatform(is) {
  if (is.ios === true) return 'ios';
  if (is.android === true) return 'android';
}
function getBodyClasses(_ref, cfg) {
  var is = _ref.is,
    has = _ref.has,
    within = _ref.within;
  var cls = [is.desktop === true ? 'desktop' : 'mobile', "".concat(has.touch === false ? 'no-' : '', "touch")];
  if (is.mobile === true) {
    var mobile = getMobilePlatform(is);
    mobile !== void 0 && cls.push('platform-' + mobile);
  }
  if (is.nativeMobile === true) {
    var type = is.nativeMobileWrapper;
    cls.push(type);
    cls.push('native-mobile');
    if (is.ios === true && (cfg[type] === void 0 || cfg[type].iosStatusBarPadding !== false)) {
      cls.push('q-ios-padding');
    }
  } else if (is.electron === true) {
    cls.push('electron');
  } else if (is.bex === true) {
    cls.push('bex');
  }
  within.iframe === true && cls.push('within-iframe');
  return cls;
}

// SSR takeover corrections
function clientUpdate() {
  var classes = document.body.className;
  var newCls = classes;
  if (Platform["d" /* iosCorrection */] !== void 0) {
    newCls = newCls.replace('desktop', 'platform-ios mobile');
  }
  if (Platform["a" /* client */].has.touch === true) {
    newCls = newCls.replace('no-touch', 'touch');
  }
  if (Platform["a" /* client */].within.iframe === true) {
    newCls += ' within-iframe';
  }
  if (classes !== newCls) {
    document.body.className = newCls;
  }
}
function setColors(brand) {
  for (var color in brand) {
    setBrand(color, brand[color]);
  }
}
/* harmony default export */ var body = ({
  install: function install(queues, cfg) {
    if (Platform["e" /* isSSR */] === true) {
      queues.server.push(function (q, ctx) {
        var cls = getBodyClasses(q.platform, cfg),
          fn = ctx.ssr.setBodyClasses;
        if (cfg.screen !== void 0 && cfg.screen.bodyClass === true) {
          cls.push('screen--xs');
        }
        if (typeof fn === 'function') {
          fn(cls);
        } else {
          ctx.ssr.Q_BODY_CLASSES = cls.join(' ');
        }
      });
      return;
    }
    if (Platform["c" /* fromSSR */] === true) {
      clientUpdate();
    } else {
      var cls = getBodyClasses(Platform["a" /* client */], cfg);
      if (Platform["a" /* client */].is.ie === true && Platform["a" /* client */].is.versionNumber === 11) {
        cls.forEach(function (c) {
          return document.body.classList.add(c);
        });
      } else {
        document.body.classList.add.apply(document.body.classList, cls);
      }
    }
    cfg.brand !== void 0 && setColors(cfg.brand);
    if (Platform["a" /* client */].is.ios === true) {
      // needed for iOS button active state
      document.body.addEventListener('touchstart', utils_event["f" /* noop */]);
    }
    window.addEventListener('keydown', key_composition["b" /* onKeyDownComposition */], true);
  }
});
// EXTERNAL MODULE: ./node_modules/quasar/src/icon-set.js + 1 modules
var icon_set = __webpack_require__("9071");

// CONCATENATED MODULE: ./node_modules/quasar/src/install.js















var autoInstalled = [Platform["b" /* default */], Screen, plugins_Dark];
var install_queues = {
  server: [],
  // on SSR update
  takeover: [] // on client takeover
};

var install_$q = {
  version: quasar_package["a" /* version */],
  config: {}
};
/* harmony default export */ var src_install = __webpack_exports__["b"] = (function (Vue) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (this.__qInstalled === true) {
    return;
  }
  this.__qInstalled = true;
  var cfg = install_$q.config = Object.freeze(opts.config || {});

  // required plugins
  Platform["b" /* default */].install(install_$q, install_queues);
  body.install(install_queues, cfg);
  plugins_Dark.install(install_$q, install_queues, cfg);
  Screen.install(install_$q, install_queues, cfg);
  src_history["a" /* default */].install(cfg);
  lang["a" /* default */].install(install_$q, install_queues, opts.lang);
  icon_set["a" /* default */].install(install_$q, install_queues, opts.iconSet);
  if (Platform["e" /* isSSR */] === true) {
    Vue.mixin({
      beforeCreate: function beforeCreate() {
        this.$q = this.$root.$options.$q;
      }
    });
  } else {
    Vue.prototype.$q = install_$q;
  }
  opts.components && Object.keys(opts.components).forEach(function (key) {
    var c = opts.components[key];
    if (typeof c === 'function') {
      Vue.component(c.options.name, c);
    }
  });
  opts.directives && Object.keys(opts.directives).forEach(function (key) {
    var d = opts.directives[key];
    if (d.name !== void 0 && d.unbind !== void 0) {
      Vue.directive(d.name, d);
    }
  });
  if (opts.plugins) {
    var param = {
      $q: install_$q,
      queues: install_queues,
      cfg: cfg
    };
    Object.keys(opts.plugins).forEach(function (key) {
      var p = opts.plugins[key];
      if (typeof p.install === 'function' && autoInstalled.includes(p) === false) {
        p.install(param);
      }
    });
  }
});

/***/ }),

/***/ "8233":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_DataBlock_vue_vue_type_style_index_1_id_0deb24d0_prod_lang_stylus___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("898d");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_DataBlock_vue_vue_type_style_index_1_id_0deb24d0_prod_lang_stylus___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_DataBlock_vue_vue_type_style_index_1_id_0deb24d0_prod_lang_stylus___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "825a":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ "82f8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $includes = __webpack_require__("4d64").includes;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.includes` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "83ab":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "8418":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPropertyKey = __webpack_require__("a04b");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "841c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var call = __webpack_require__("c65b");
var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var anObject = __webpack_require__("825a");
var isNullOrUndefined = __webpack_require__("7234");
var requireObjectCoercible = __webpack_require__("1d80");
var sameValue = __webpack_require__("129f");
var toString = __webpack_require__("577e");
var getMethod = __webpack_require__("dc4a");
var regExpExec = __webpack_require__("14c3");

// @@search logic
fixRegExpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.es/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = isNullOrUndefined(regexp) ? undefined : getMethod(regexp, SEARCH);
      return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
    function (string) {
      var rx = anObject(this);
      var S = toString(string);
      var res = maybeCallNative(nativeSearch, rx, S);

      if (res.done) return res.value;

      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "8536":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("56b3"));
  else {}
})(function(CodeMirror) {
"use strict";

function wordObj(words) {
  var o = {};
  for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;
  return o;
}

var keywordList = [
  "alias", "and", "BEGIN", "begin", "break", "case", "class", "def", "defined?", "do", "else",
  "elsif", "END", "end", "ensure", "false", "for", "if", "in", "module", "next", "not", "or",
  "redo", "rescue", "retry", "return", "self", "super", "then", "true", "undef", "unless",
  "until", "when", "while", "yield", "nil", "raise", "throw", "catch", "fail", "loop", "callcc",
  "caller", "lambda", "proc", "public", "protected", "private", "require", "load",
  "require_relative", "extend", "autoload", "__END__", "__FILE__", "__LINE__", "__dir__"
], keywords = wordObj(keywordList);

var indentWords = wordObj(["def", "class", "case", "for", "while", "until", "module",
                           "catch", "loop", "proc", "begin"]);
var dedentWords = wordObj(["end", "until"]);
var opening = {"[": "]", "{": "}", "(": ")"};
var closing = {"]": "[", "}": "{", ")": "("};

CodeMirror.defineMode("ruby", function(config) {
  var curPunc;

  function chain(newtok, stream, state) {
    state.tokenize.push(newtok);
    return newtok(stream, state);
  }

  function tokenBase(stream, state) {
    if (stream.sol() && stream.match("=begin") && stream.eol()) {
      state.tokenize.push(readBlockComment);
      return "comment";
    }
    if (stream.eatSpace()) return null;
    var ch = stream.next(), m;
    if (ch == "`" || ch == "'" || ch == '"') {
      return chain(readQuoted(ch, "string", ch == '"' || ch == "`"), stream, state);
    } else if (ch == "/") {
      if (regexpAhead(stream))
        return chain(readQuoted(ch, "string-2", true), stream, state);
      else
        return "operator";
    } else if (ch == "%") {
      var style = "string", embed = true;
      if (stream.eat("s")) style = "atom";
      else if (stream.eat(/[WQ]/)) style = "string";
      else if (stream.eat(/[r]/)) style = "string-2";
      else if (stream.eat(/[wxq]/)) { style = "string"; embed = false; }
      var delim = stream.eat(/[^\w\s=]/);
      if (!delim) return "operator";
      if (opening.propertyIsEnumerable(delim)) delim = opening[delim];
      return chain(readQuoted(delim, style, embed, true), stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    } else if (ch == "<" && (m = stream.match(/^<([-~])[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/))) {
      return chain(readHereDoc(m[2], m[1]), stream, state);
    } else if (ch == "0") {
      if (stream.eat("x")) stream.eatWhile(/[\da-fA-F]/);
      else if (stream.eat("b")) stream.eatWhile(/[01]/);
      else stream.eatWhile(/[0-7]/);
      return "number";
    } else if (/\d/.test(ch)) {
      stream.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/);
      return "number";
    } else if (ch == "?") {
      while (stream.match(/^\\[CM]-/)) {}
      if (stream.eat("\\")) stream.eatWhile(/\w/);
      else stream.next();
      return "string";
    } else if (ch == ":") {
      if (stream.eat("'")) return chain(readQuoted("'", "atom", false), stream, state);
      if (stream.eat('"')) return chain(readQuoted('"', "atom", true), stream, state);

      // :> :>> :< :<< are valid symbols
      if (stream.eat(/[\<\>]/)) {
        stream.eat(/[\<\>]/);
        return "atom";
      }

      // :+ :- :/ :* :| :& :! are valid symbols
      if (stream.eat(/[\+\-\*\/\&\|\:\!]/)) {
        return "atom";
      }

      // Symbols can't start by a digit
      if (stream.eat(/[a-zA-Z$@_\xa1-\uffff]/)) {
        stream.eatWhile(/[\w$\xa1-\uffff]/);
        // Only one ? ! = is allowed and only as the last character
        stream.eat(/[\?\!\=]/);
        return "atom";
      }
      return "operator";
    } else if (ch == "@" && stream.match(/^@?[a-zA-Z_\xa1-\uffff]/)) {
      stream.eat("@");
      stream.eatWhile(/[\w\xa1-\uffff]/);
      return "variable-2";
    } else if (ch == "$") {
      if (stream.eat(/[a-zA-Z_]/)) {
        stream.eatWhile(/[\w]/);
      } else if (stream.eat(/\d/)) {
        stream.eat(/\d/);
      } else {
        stream.next(); // Must be a special global like $: or $!
      }
      return "variable-3";
    } else if (/[a-zA-Z_\xa1-\uffff]/.test(ch)) {
      stream.eatWhile(/[\w\xa1-\uffff]/);
      stream.eat(/[\?\!]/);
      if (stream.eat(":")) return "atom";
      return "ident";
    } else if (ch == "|" && (state.varList || state.lastTok == "{" || state.lastTok == "do")) {
      curPunc = "|";
      return null;
    } else if (/[\(\)\[\]{}\\;]/.test(ch)) {
      curPunc = ch;
      return null;
    } else if (ch == "-" && stream.eat(">")) {
      return "arrow";
    } else if (/[=+\-\/*:\.^%<>~|]/.test(ch)) {
      var more = stream.eatWhile(/[=+\-\/*:\.^%<>~|]/);
      if (ch == "." && !more) curPunc = ".";
      return "operator";
    } else {
      return null;
    }
  }

  function regexpAhead(stream) {
    var start = stream.pos, depth = 0, next, found = false, escaped = false
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if ("[{(".indexOf(next) > -1) {
          depth++
        } else if ("]})".indexOf(next) > -1) {
          depth--
          if (depth < 0) break
        } else if (next == "/" && depth == 0) {
          found = true
          break
        }
        escaped = next == "\\"
      } else {
        escaped = false
      }
    }
    stream.backUp(stream.pos - start)
    return found
  }

  function tokenBaseUntilBrace(depth) {
    if (!depth) depth = 1;
    return function(stream, state) {
      if (stream.peek() == "}") {
        if (depth == 1) {
          state.tokenize.pop();
          return state.tokenize[state.tokenize.length-1](stream, state);
        } else {
          state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1);
        }
      } else if (stream.peek() == "{") {
        state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1);
      }
      return tokenBase(stream, state);
    };
  }
  function tokenBaseOnce() {
    var alreadyCalled = false;
    return function(stream, state) {
      if (alreadyCalled) {
        state.tokenize.pop();
        return state.tokenize[state.tokenize.length-1](stream, state);
      }
      alreadyCalled = true;
      return tokenBase(stream, state);
    };
  }
  function readQuoted(quote, style, embed, unescaped) {
    return function(stream, state) {
      var escaped = false, ch;

      if (state.context.type === 'read-quoted-paused') {
        state.context = state.context.prev;
        stream.eat("}");
      }

      while ((ch = stream.next()) != null) {
        if (ch == quote && (unescaped || !escaped)) {
          state.tokenize.pop();
          break;
        }
        if (embed && ch == "#" && !escaped) {
          if (stream.eat("{")) {
            if (quote == "}") {
              state.context = {prev: state.context, type: 'read-quoted-paused'};
            }
            state.tokenize.push(tokenBaseUntilBrace());
            break;
          } else if (/[@\$]/.test(stream.peek())) {
            state.tokenize.push(tokenBaseOnce());
            break;
          }
        }
        escaped = !escaped && ch == "\\";
      }
      return style;
    };
  }
  function readHereDoc(phrase, mayIndent) {
    return function(stream, state) {
      if (mayIndent) stream.eatSpace()
      if (stream.match(phrase)) state.tokenize.pop();
      else stream.skipToEnd();
      return "string";
    };
  }
  function readBlockComment(stream, state) {
    if (stream.sol() && stream.match("=end") && stream.eol())
      state.tokenize.pop();
    stream.skipToEnd();
    return "comment";
  }

  return {
    startState: function() {
      return {tokenize: [tokenBase],
              indented: 0,
              context: {type: "top", indented: -config.indentUnit},
              continuedLine: false,
              lastTok: null,
              varList: false};
    },

    token: function(stream, state) {
      curPunc = null;
      if (stream.sol()) state.indented = stream.indentation();
      var style = state.tokenize[state.tokenize.length-1](stream, state), kwtype;
      var thisTok = curPunc;
      if (style == "ident") {
        var word = stream.current();
        style = state.lastTok == "." ? "property"
          : keywords.propertyIsEnumerable(stream.current()) ? "keyword"
          : /^[A-Z]/.test(word) ? "tag"
          : (state.lastTok == "def" || state.lastTok == "class" || state.varList) ? "def"
          : "variable";
        if (style == "keyword") {
          thisTok = word;
          if (indentWords.propertyIsEnumerable(word)) kwtype = "indent";
          else if (dedentWords.propertyIsEnumerable(word)) kwtype = "dedent";
          else if ((word == "if" || word == "unless") && stream.column() == stream.indentation())
            kwtype = "indent";
          else if (word == "do" && state.context.indented < state.indented)
            kwtype = "indent";
        }
      }
      if (curPunc || (style && style != "comment")) state.lastTok = thisTok;
      if (curPunc == "|") state.varList = !state.varList;

      if (kwtype == "indent" || /[\(\[\{]/.test(curPunc))
        state.context = {prev: state.context, type: curPunc || style, indented: state.indented};
      else if ((kwtype == "dedent" || /[\)\]\}]/.test(curPunc)) && state.context.prev)
        state.context = state.context.prev;

      if (stream.eol())
        state.continuedLine = (curPunc == "\\" || style == "operator");
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize[state.tokenize.length-1] != tokenBase) return CodeMirror.Pass;
      var firstChar = textAfter && textAfter.charAt(0);
      var ct = state.context;
      var closed = ct.type == closing[firstChar] ||
        ct.type == "keyword" && /^(?:end|until|else|elsif|when|rescue)\b/.test(textAfter);
      return ct.indented + (closed ? 0 : config.indentUnit) +
        (state.continuedLine ? config.indentUnit : 0);
    },

    electricInput: /^\s*(?:end|rescue|elsif|else|\})$/,
    lineComment: "#",
    fold: "indent"
  };
});

CodeMirror.defineMIME("text/x-ruby", "ruby");

CodeMirror.registerHelper("hintWords", "ruby", keywordList);

});


/***/ }),

/***/ "8572":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__("ade3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("0967");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/icon/QIcon.js
var QIcon = __webpack_require__("0016");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/spinner/QSpinner.js + 1 modules
var QSpinner = __webpack_require__("0d59");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__("e260");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.promise.js
var es_promise = __webpack_require__("e6cf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find.js
var es_array_find = __webpack_require__("7db0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.test.js
var es_regexp_test = __webpack_require__("00b4");

// CONCATENATED MODULE: ./node_modules/quasar/src/utils/patterns.js


// file referenced from docs

var hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/,
  hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/,
  hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/,
  rgb = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/,
  rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/;
var testPattern = {
  date: function date(v) {
    return /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(v);
  },
  time: function time(v) {
    return /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(v);
  },
  fulltime: function fulltime(v) {
    return /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(v);
  },
  timeOrFulltime: function timeOrFulltime(v) {
    return /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(v);
  },
  // -- RFC 5322 --
  // -- Added in v1.18.10 --
  // This is a basic helper validation.
  // For something more complex (like RFC 822) you should write and use your own rule.
  // We won't be accepting PRs to enhance the one below because of the reason above.
  email: function email(v) {
    return /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v);
  },
  hexColor: function hexColor(v) {
    return hex.test(v);
  },
  hexaColor: function hexaColor(v) {
    return hexa.test(v);
  },
  hexOrHexaColor: function hexOrHexaColor(v) {
    return hexOrHexa.test(v);
  },
  rgbColor: function rgbColor(v) {
    return rgb.test(v);
  },
  rgbaColor: function rgbaColor(v) {
    return rgba.test(v);
  },
  rgbOrRgbaColor: function rgbOrRgbaColor(v) {
    return rgb.test(v) || rgba.test(v);
  },
  hexOrRgbColor: function hexOrRgbColor(v) {
    return hex.test(v) || rgb.test(v);
  },
  hexaOrRgbaColor: function hexaOrRgbaColor(v) {
    return hexa.test(v) || rgba.test(v);
  },
  anyColor: function anyColor(v) {
    return hexOrHexa.test(v) || rgb.test(v) || rgba.test(v);
  }
};
/* harmony default export */ var patterns = ({
  testPattern: testPattern
});
// EXTERNAL MODULE: ./node_modules/quasar/src/utils/debounce.js
var debounce = __webpack_require__("1c16");

// CONCATENATED MODULE: ./node_modules/quasar/src/mixins/validate.js










var lazyRulesValues = [true, false, 'ondemand'];
/* harmony default export */ var mixins_validate = ({
  props: {
    value: {},
    error: {
      type: Boolean,
      default: null
    },
    errorMessage: String,
    noErrorIcon: Boolean,
    rules: Array,
    reactiveRules: Boolean,
    lazyRules: {
      type: [Boolean, String],
      validator: function validator(v) {
        return lazyRulesValues.includes(v);
      }
    }
  },
  data: function data() {
    return {
      isDirty: null,
      innerError: false,
      innerErrorMessage: void 0
    };
  },
  watch: {
    value: function value() {
      this.__validateIfNeeded();
    },
    disable: function disable(val) {
      if (val === true) {
        this.__resetValidation();
      } else {
        this.__validateIfNeeded(true);
      }
    },
    reactiveRules: {
      handler: function handler(val) {
        var _this = this;
        if (val === true) {
          if (this.unwatchRules === void 0) {
            this.unwatchRules = this.$watch('rules', function () {
              _this.__validateIfNeeded(true);
            });
          }
        } else if (this.unwatchRules !== void 0) {
          this.unwatchRules();
          this.unwatchRules = void 0;
        }
      },
      immediate: true
    },
    focused: function focused(_focused) {
      if (_focused === true) {
        if (this.isDirty === null) {
          this.isDirty = false;
        }
      } else if (this.isDirty === false) {
        this.isDirty = true;
        if (this.hasActiveRules === true && this.lazyRules !== 'ondemand' &&
        // Don't re-trigger if it's already in progress;
        // It might mean that focus switched to submit btn and
        // QForm's submit() has been called already (ENTER key)
        this.innerLoading === false) {
          this.debouncedValidate();
        }
      }
    },
    hasError: function hasError(invalid) {
      var targetEl = document.getElementById(this.targetUid);
      targetEl !== null && targetEl.setAttribute('aria-invalid', invalid === true);
    }
  },
  computed: {
    hasRules: function hasRules() {
      return this.rules !== void 0 && this.rules !== null && this.rules.length > 0;
    },
    hasActiveRules: function hasActiveRules() {
      return this.disable !== true && this.hasRules === true;
    },
    hasError: function hasError() {
      return this.error === true || this.innerError === true;
    },
    computedErrorMessage: function computedErrorMessage() {
      return typeof this.errorMessage === 'string' && this.errorMessage.length > 0 ? this.errorMessage : this.innerErrorMessage;
    }
  },
  created: function created() {
    this.debouncedValidate = Object(debounce["a" /* default */])(this.validate, 0);
  },
  mounted: function mounted() {
    this.validateIndex = 0;
  },
  beforeDestroy: function beforeDestroy() {
    this.unwatchRules !== void 0 && this.unwatchRules();
    this.debouncedValidate.cancel();
  },
  methods: {
    resetValidation: function resetValidation() {
      this.isDirty = null;
      this.__resetValidation();
    },
    /*
     * Return value
     *   - true (validation succeeded)
     *   - false (validation failed)
     *   - Promise (pending async validation)
     */
    validate: function validate() {
      var _this2 = this;
      var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.value;
      if (this.hasActiveRules !== true) {
        return true;
      }
      var index = ++this.validateIndex;
      var setDirty = this.innerLoading !== true ? function () {
        return _this2.isDirty !== true && (_this2.isDirty = true);
      } : function () {};
      var update = function update(err, msg) {
        err === true && setDirty();
        if (_this2.innerError !== err) {
          _this2.innerError = err;
        }
        var m = msg || void 0;
        if (_this2.innerErrorMessage !== m) {
          _this2.innerErrorMessage = m;
        }
        if (_this2.innerLoading !== false) {
          _this2.innerLoading = false;
        }
      };
      var promises = [];
      for (var i = 0; i < this.rules.length; i++) {
        var rule = this.rules[i];
        var res = void 0;
        if (typeof rule === 'function') {
          res = rule(val, testPattern);
        } else if (typeof rule === 'string' && testPattern[rule] !== void 0) {
          res = testPattern[rule](val);
        }
        if (res === false || typeof res === 'string') {
          update(true, res);
          return false;
        } else if (res !== true && res !== void 0) {
          promises.push(res);
        }
      }
      if (promises.length === 0) {
        update(false);
        return true;
      }
      if (this.innerLoading !== true) {
        this.innerLoading = true;
      }
      return Promise.all(promises).then(function (res) {
        if (res === void 0 || Array.isArray(res) === false || res.length === 0) {
          index === _this2.validateIndex && update(false);
          return true;
        }
        var msg = res.find(function (r) {
          return r === false || typeof r === 'string';
        });
        index === _this2.validateIndex && update(msg !== void 0, msg);
        return msg === void 0;
      }, function (e) {
        if (index === _this2.validateIndex) {
          console.error(e);
          update(true);
        }
        return false;
      });
    },
    __resetValidation: function __resetValidation() {
      this.debouncedValidate.cancel();
      this.validateIndex++;
      this.innerLoading = false;
      this.innerError = false;
      this.innerErrorMessage = void 0;
    },
    __validateIfNeeded: function __validateIfNeeded(changedRules) {
      if (this.hasActiveRules === true && this.lazyRules !== 'ondemand' && (this.isDirty === true || this.lazyRules !== true && changedRules !== true)) {
        this.debouncedValidate();
      }
    }
  }
});
// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/dark.js
var dark = __webpack_require__("b7fa");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/attrs.js
var mixins_attrs = __webpack_require__("f376");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/slot.js
var slot = __webpack_require__("e277");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/uid.js
var uid = __webpack_require__("1732");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("d882");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/focus-manager.js
var focus_manager = __webpack_require__("f6ba");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/field/QField.js
















function getTargetUid(val) {
  return val === void 0 ? "f_".concat(Object(uid["a" /* default */])()) : val;
}
/* harmony default export */ var QField = __webpack_exports__["a"] = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QField',
  mixins: [dark["a" /* default */], mixins_validate, mixins_attrs["b" /* default */]],
  inheritAttrs: false,
  props: {
    label: String,
    stackLabel: Boolean,
    hint: String,
    hideHint: Boolean,
    prefix: String,
    suffix: String,
    labelColor: String,
    color: String,
    bgColor: String,
    filled: Boolean,
    outlined: Boolean,
    borderless: Boolean,
    standout: [Boolean, String],
    square: Boolean,
    loading: Boolean,
    labelSlot: Boolean,
    bottomSlots: Boolean,
    hideBottomSpace: Boolean,
    rounded: Boolean,
    dense: Boolean,
    itemAligned: Boolean,
    counter: Boolean,
    clearable: Boolean,
    clearIcon: String,
    disable: Boolean,
    readonly: Boolean,
    autofocus: Boolean,
    for: String,
    maxlength: [Number, String],
    maxValues: [Number, String] // private, do not add to JSON; internally needed by QSelect
  },
  data: function data() {
    return {
      focused: false,
      targetUid: getTargetUid(this.for),
      // used internally by validation for QInput
      // or menu handling for QSelect
      innerLoading: false
    };
  },
  watch: {
    for: function _for(val) {
      // don't transform targetUid into a computed
      // prop as it will break SSR
      this.targetUid = getTargetUid(val);
    }
  },
  computed: {
    editable: function editable() {
      return this.disable !== true && this.readonly !== true;
    },
    hasValue: function hasValue() {
      var value = this.__getControl === void 0 ? this.value : this.innerValue;
      return value !== void 0 && value !== null && ('' + value).length > 0;
    },
    computedCounter: function computedCounter() {
      if (this.counter !== false) {
        var len = typeof this.value === 'string' || typeof this.value === 'number' ? ('' + this.value).length : Array.isArray(this.value) === true ? this.value.length : 0;
        var max = this.maxlength !== void 0 ? this.maxlength : this.maxValues;
        return len + (max !== void 0 ? ' / ' + max : '');
      }
    },
    floatingLabel: function floatingLabel() {
      return this.stackLabel === true || this.focused === true || typeof this.inputValue === 'number' || typeof this.inputValue === 'string' && this.inputValue.length > 0 || this.hideSelected !== true && this.hasValue === true && (this.type !== 'number' || isNaN(this.value) === false) || this.displayValue !== void 0 && this.displayValue !== null && ('' + this.displayValue).length > 0;
    },
    shouldRenderBottom: function shouldRenderBottom() {
      return this.bottomSlots === true || this.hint !== void 0 || this.hasRules === true || this.counter === true || this.error !== null;
    },
    classes: function classes() {
      var _ref;
      return _ref = {}, Object(defineProperty["a" /* default */])(_ref, this.fieldClass, this.fieldClass !== void 0), Object(defineProperty["a" /* default */])(_ref, "q-field--".concat(this.styleType), true), Object(defineProperty["a" /* default */])(_ref, 'q-field--rounded', this.rounded), Object(defineProperty["a" /* default */])(_ref, 'q-field--square', this.square), Object(defineProperty["a" /* default */])(_ref, 'q-field--focused', this.focused === true), Object(defineProperty["a" /* default */])(_ref, 'q-field--highlighted', this.focused === true || this.hasError === true), Object(defineProperty["a" /* default */])(_ref, 'q-field--float', this.floatingLabel), Object(defineProperty["a" /* default */])(_ref, 'q-field--labeled', this.hasLabel), Object(defineProperty["a" /* default */])(_ref, 'q-field--dense', this.dense), Object(defineProperty["a" /* default */])(_ref, 'q-field--item-aligned q-item-type', this.itemAligned), Object(defineProperty["a" /* default */])(_ref, 'q-field--dark', this.isDark), Object(defineProperty["a" /* default */])(_ref, 'q-field--auto-height', this.__getControl === void 0), Object(defineProperty["a" /* default */])(_ref, 'q-field--with-bottom', this.hideBottomSpace !== true && this.shouldRenderBottom === true), Object(defineProperty["a" /* default */])(_ref, 'q-field--error', this.hasError), Object(defineProperty["a" /* default */])(_ref, 'q-field--readonly', this.readonly === true && this.disable !== true), Object(defineProperty["a" /* default */])(_ref, 'q-field--disabled', this.disable === true), _ref;
    },
    styleType: function styleType() {
      if (this.filled === true) {
        return 'filled';
      }
      if (this.outlined === true) {
        return 'outlined';
      }
      if (this.borderless === true) {
        return 'borderless';
      }
      if (this.standout) {
        return 'standout';
      }
      return 'standard';
    },
    contentClass: function contentClass() {
      var cls = [];
      if (this.hasError === true) {
        cls.push('text-negative');
      } else if (typeof this.standout === 'string' && this.standout.length > 0 && this.focused === true) {
        return this.standout;
      } else if (this.color !== void 0) {
        cls.push('text-' + this.color);
      }
      if (this.bgColor !== void 0) {
        cls.push("bg-".concat(this.bgColor));
      }
      return cls;
    },
    hasLabel: function hasLabel() {
      return this.labelSlot === true || this.label !== void 0;
    },
    labelClass: function labelClass() {
      if (this.labelColor !== void 0 && this.hasError !== true) {
        return 'text-' + this.labelColor;
      }
    },
    controlSlotScope: function controlSlotScope() {
      return {
        id: this.targetUid,
        field: this.$el,
        editable: this.editable,
        focused: this.focused,
        floatingLabel: this.floatingLabel,
        value: this.value,
        emitValue: this.__emitValue
      };
    },
    bottomSlotScope: function bottomSlotScope() {
      return {
        id: this.targetUid,
        field: this.$el,
        editable: this.editable,
        focused: this.focused,
        value: this.value,
        errorMessage: this.computedErrorMessage
      };
    },
    attrs: function attrs() {
      var attrs = {
        for: this.targetUid
      };
      if (this.disable === true) {
        attrs['aria-disabled'] = 'true';
      } else if (this.readonly === true) {
        attrs['aria-readonly'] = 'true';
      }
      return attrs;
    }
  },
  methods: {
    focus: function focus() {
      Object(focus_manager["a" /* addFocusFn */])(this.__focus);
    },
    blur: function blur() {
      Object(focus_manager["c" /* removeFocusFn */])(this.__focus);
      var el = document.activeElement;
      // IE can have null document.activeElement
      if (el !== null && this.$el.contains(el)) {
        el.blur();
      }
    },
    __focus: function __focus() {
      var el = document.activeElement;
      var target = this.$refs.target;
      // IE can have null document.activeElement
      if (target !== void 0 && (el === null || el.id !== this.targetUid)) {
        target.hasAttribute('tabindex') === true || (target = target.querySelector('[tabindex]'));
        target !== null && target !== el && target.focus({
          preventScroll: true
        });
      }
    },
    __getContent: function __getContent(h) {
      var node = [];
      this.$scopedSlots.prepend !== void 0 && node.push(h('div', {
        staticClass: 'q-field__prepend q-field__marginal row no-wrap items-center',
        key: 'prepend',
        on: this.slotsEvents
      }, this.$scopedSlots.prepend()));
      node.push(h('div', {
        staticClass: 'q-field__control-container col relative-position row no-wrap q-anchor--skip'
      }, this.__getControlContainer(h)));
      this.hasError === true && this.noErrorIcon === false && node.push(this.__getInnerAppendNode(h, 'error', [h(QIcon["a" /* default */], {
        props: {
          name: this.$q.iconSet.field.error,
          color: 'negative'
        }
      })]));
      if (this.loading === true || this.innerLoading === true) {
        node.push(this.__getInnerAppendNode(h, 'inner-loading-append', this.$scopedSlots.loading !== void 0 ? this.$scopedSlots.loading() : [h(QSpinner["a" /* default */], {
          props: {
            color: this.color
          }
        })]));
      } else if (this.clearable === true && this.hasValue === true && this.editable === true) {
        node.push(this.__getInnerAppendNode(h, 'inner-clearable-append', [h(QIcon["a" /* default */], {
          staticClass: 'q-field__focusable-action',
          props: {
            tag: 'button',
            name: this.clearIcon || this.$q.iconSet.field.clear
          },
          attrs: mixins_attrs["c" /* iconAsButton */],
          on: this.clearableEvents
        })]));
      }
      this.$scopedSlots.append !== void 0 && node.push(h('div', {
        staticClass: 'q-field__append q-field__marginal row no-wrap items-center',
        key: 'append',
        on: this.slotsEvents
      }, this.$scopedSlots.append()));
      this.__getInnerAppend !== void 0 && node.push(this.__getInnerAppendNode(h, 'inner-append', this.__getInnerAppend(h)));
      this.__getControlChild !== void 0 && node.push(this.__getControlChild(h));
      return node;
    },
    __getControlContainer: function __getControlContainer(h) {
      var node = [];
      this.prefix !== void 0 && this.prefix !== null && node.push(h('div', {
        staticClass: 'q-field__prefix no-pointer-events row items-center'
      }, [this.prefix]));
      if (this.hasShadow === true && this.__getShadowControl !== void 0) {
        node.push(this.__getShadowControl(h));
      }
      if (this.__getControl !== void 0) {
        node.push(this.__getControl(h));
      }
      // internal usage only:
      else if (this.$scopedSlots.rawControl !== void 0) {
        node.push(this.$scopedSlots.rawControl());
      } else if (this.$scopedSlots.control !== void 0) {
        node.push(h('div', {
          ref: 'target',
          staticClass: 'q-field__native row',
          attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
            tabindex: -1
          }, this.qAttrs), {}, {
            'data-autofocus': this.autofocus || void 0
          })
        }, this.$scopedSlots.control(this.controlSlotScope)));
      }
      this.hasLabel === true && node.push(h('div', {
        staticClass: 'q-field__label no-pointer-events absolute ellipsis',
        class: this.labelClass
      }, [Object(slot["c" /* slot */])(this, 'label', this.label)]));
      this.suffix !== void 0 && this.suffix !== null && node.push(h('div', {
        staticClass: 'q-field__suffix no-pointer-events row items-center'
      }, [this.suffix]));
      return node.concat(this.__getDefaultSlot !== void 0 ? this.__getDefaultSlot(h) : Object(slot["c" /* slot */])(this, 'default'));
    },
    __getBottom: function __getBottom(h) {
      var msg, key;
      if (this.hasError === true) {
        key = 'q--slot-error';
        if (this.$scopedSlots.error !== void 0) {
          msg = this.$scopedSlots.error(this.bottomSlotScope);
        } else if (this.computedErrorMessage !== void 0) {
          msg = [h('div', {
            attrs: {
              role: 'alert'
            }
          }, [this.computedErrorMessage])];
          key = this.computedErrorMessage;
        }
      } else if (this.hideHint !== true || this.focused === true) {
        key = 'q--slot-hint';
        if (this.$scopedSlots.hint !== void 0) {
          msg = this.$scopedSlots.hint(this.bottomSlotScope);
        } else if (this.hint !== void 0) {
          msg = [h('div', [this.hint])];
          key = this.hint;
        }
      }
      var hasCounter = this.counter === true || this.$scopedSlots.counter !== void 0;
      if (this.hideBottomSpace === true && hasCounter === false && msg === void 0) {
        return;
      }
      var main = h('div', {
        key: key,
        staticClass: 'q-field__messages col'
      }, msg);
      return h('div', {
        staticClass: 'q-field__bottom row items-start q-field__bottom--' + (this.hideBottomSpace !== true ? 'animated' : 'stale'),
        on: {
          click: utils_event["h" /* prevent */]
        }
      }, [this.hideBottomSpace === true ? main : h('transition', {
        props: {
          name: 'q-transition--field-message'
        }
      }, [main]), hasCounter === true ? h('div', {
        staticClass: 'q-field__counter'
      }, this.$scopedSlots.counter !== void 0 ? this.$scopedSlots.counter() : [this.computedCounter]) : null]);
    },
    __getInnerAppendNode: function __getInnerAppendNode(h, key, content) {
      return content === null ? null : h('div', {
        staticClass: 'q-field__append q-field__marginal row no-wrap items-center q-anchor--skip',
        key: key
      }, content);
    },
    __onControlPopupShow: function __onControlPopupShow(e) {
      e !== void 0 && Object(utils_event["i" /* stop */])(e);
      this.$emit('popup-show', e);
      this.hasPopupOpen = true;
      this.__onControlFocusin(e);
    },
    __onControlPopupHide: function __onControlPopupHide(e) {
      e !== void 0 && Object(utils_event["i" /* stop */])(e);
      this.$emit('popup-hide', e);
      this.hasPopupOpen = false;
      this.__onControlFocusout(e);
    },
    __onControlFocusin: function __onControlFocusin(e) {
      clearTimeout(this.focusoutTimer);
      if (this.editable === true && this.focused === false) {
        this.focused = true;
        this.$emit('focus', e);
      }
    },
    __onControlFocusout: function __onControlFocusout(e, then) {
      var _this = this;
      clearTimeout(this.focusoutTimer);
      this.focusoutTimer = setTimeout(function () {
        if (document.hasFocus() === true && (_this.hasPopupOpen === true || _this.$refs === void 0 || _this.$refs.control === void 0 || _this.$refs.control.contains(document.activeElement) !== false)) {
          return;
        }
        if (_this.focused === true) {
          _this.focused = false;
          _this.$emit('blur', e);
        }
        then !== void 0 && then();
      });
    },
    __clearValue: function __clearValue(e) {
      var _this2 = this;
      // prevent activating the field but keep focus on desktop
      Object(utils_event["j" /* stopAndPrevent */])(e);
      if (this.$q.platform.is.mobile !== true) {
        var el = this.$refs.target || this.$el;
        el.focus();
      } else if (this.$el.contains(document.activeElement) === true) {
        document.activeElement.blur();
      }
      if (this.type === 'file') {
        // do not let focus be triggered
        // as it will make the native file dialog
        // appear for another selection
        this.$refs.input.value = null;
      }
      this.$emit('input', null);
      this.$emit('clear', this.value);
      this.$nextTick(function () {
        _this2.resetValidation();
        if (_this2.$q.platform.is.mobile !== true) {
          _this2.isDirty = false;
        }
      });
    },
    __emitValue: function __emitValue(value) {
      this.$emit('input', value);
    }
  },
  render: function render(h) {
    this.__onPreRender !== void 0 && this.__onPreRender();
    this.__onPostRender !== void 0 && this.$nextTick(this.__onPostRender);
    var attrs = this.__getControl === void 0 && this.$scopedSlots.control === void 0 ? Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.qAttrs), {}, {
      'data-autofocus': this.autofocus || void 0
    }, this.attrs) : this.attrs;
    return h('label', {
      staticClass: 'q-field q-validation-component row no-wrap items-start',
      class: this.classes,
      attrs: attrs
    }, [this.$scopedSlots.before !== void 0 ? h('div', {
      staticClass: 'q-field__before q-field__marginal row no-wrap items-center',
      on: this.slotsEvents
    }, this.$scopedSlots.before()) : null, h('div', {
      staticClass: 'q-field__inner relative-position col self-stretch'
    }, [h('div', {
      ref: 'control',
      staticClass: 'q-field__control relative-position row no-wrap',
      class: this.contentClass,
      attrs: {
        tabindex: -1
      },
      on: this.controlEvents
    }, this.__getContent(h)), this.shouldRenderBottom === true ? this.__getBottom(h) : null]), this.$scopedSlots.after !== void 0 ? h('div', {
      staticClass: 'q-field__after q-field__marginal row no-wrap items-center',
      on: this.slotsEvents
    }, this.$scopedSlots.after()) : null]);
  },
  created: function created() {
    this.__onPreRender !== void 0 && this.__onPreRender();
    this.slotsEvents = {
      click: utils_event["h" /* prevent */]
    };
    this.clearableEvents = {
      click: this.__clearValue
    };
    this.controlEvents = this.__getControlEvents !== void 0 ? this.__getControlEvents() : {
      focusin: this.__onControlFocusin,
      focusout: this.__onControlFocusout,
      'popup-show': this.__onControlPopupShow,
      'popup-hide': this.__onControlPopupHide
    };
  },
  mounted: function mounted() {
    if (Platform["c" /* fromSSR */] === true && this.for === void 0) {
      this.targetUid = getTargetUid();
    }
    this.autofocus === true && this.focus();
  },
  activated: function activated() {
    if (this.shouldActivate !== true) {
      return;
    }
    this.autofocus === true && this.focus();
  },
  deactivated: function deactivated() {
    this.shouldActivate = true;
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.focusoutTimer);
  }
}));

/***/ }),

/***/ "857a":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var requireObjectCoercible = __webpack_require__("1d80");
var toString = __webpack_require__("577e");

var quot = /"/g;
var replace = uncurryThis(''.replace);

// `CreateHTML` abstract operation
// https://tc39.es/ecma262/#sec-createhtml
module.exports = function (string, tag, attribute, value) {
  var S = toString(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + replace(toString(value), quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};


/***/ }),

/***/ "85fc":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a9e3");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("99af");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("b0c0");
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("cca6");
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("fb6a");
/* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("a434");
/* harmony import */ var core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("14d9");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _dark_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("b7fa");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__("d882");
/* harmony import */ var _form_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__("f89c");
/* harmony import */ var _option_size_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__("ff7b");
/* harmony import */ var _refocus_target_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__("2b69");
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__("e277");
/* harmony import */ var _utils_private_cache_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__("d54d");














/* harmony default export */ __webpack_exports__["a"] = ({
  mixins: [_dark_js__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"], _option_size_js__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"], _form_js__WEBPACK_IMPORTED_MODULE_9__[/* default */ "b"], _refocus_target_js__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"]],
  props: {
    value: {
      required: true,
      default: null
    },
    val: {},
    trueValue: {
      default: true
    },
    falseValue: {
      default: false
    },
    indeterminateValue: {
      default: null
    },
    checkedIcon: String,
    uncheckedIcon: String,
    indeterminateIcon: String,
    toggleOrder: {
      type: String,
      validator: function validator(v) {
        return v === 'tf' || v === 'ft';
      }
    },
    toggleIndeterminate: Boolean,
    label: String,
    leftLabel: Boolean,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  computed: {
    isTrue: function isTrue() {
      return this.modelIsArray === true ? this.index > -1 : this.value === this.trueValue;
    },
    isFalse: function isFalse() {
      return this.modelIsArray === true ? this.index === -1 : this.value === this.falseValue;
    },
    isIndeterminate: function isIndeterminate() {
      return this.isTrue === false && this.isFalse === false;
    },
    index: function index() {
      if (this.modelIsArray === true) {
        return this.value.indexOf(this.val);
      }
    },
    modelIsArray: function modelIsArray() {
      return this.val !== void 0 && Array.isArray(this.value);
    },
    computedTabindex: function computedTabindex() {
      return this.disable === true ? -1 : this.tabindex || 0;
    },
    classes: function classes() {
      return "q-".concat(this.type, " cursor-pointer no-outline row inline no-wrap items-center") + (this.disable === true ? ' disabled' : '') + (this.isDark === true ? " q-".concat(this.type, "--dark") : '') + (this.dense === true ? " q-".concat(this.type, "--dense") : '') + (this.leftLabel === true ? ' reverse' : '');
    },
    innerClass: function innerClass() {
      var state = this.isTrue === true ? 'truthy' : this.isFalse === true ? 'falsy' : 'indet';
      var color = this.color !== void 0 && (this.keepColor === true || (this.type === 'toggle' ? this.isTrue === true : this.isFalse !== true)) ? " text-".concat(this.color) : '';
      return "q-".concat(this.type, "__inner--").concat(state).concat(color);
    },
    formAttrs: function formAttrs() {
      var prop = {
        type: 'checkbox'
      };
      this.name !== void 0 && Object.assign(prop, {
        checked: this.isTrue,
        name: this.name,
        value: this.modelIsArray === true ? this.val : this.trueValue
      });
      return prop;
    },
    attrs: function attrs() {
      var attrs = {
        tabindex: this.computedTabindex,
        role: this.type === 'toggle' ? 'switch' : 'checkbox',
        'aria-label': this.label,
        'aria-checked': this.isIndeterminate === true ? 'mixed' : this.isTrue === true ? 'true' : 'false'
      };
      if (this.disable === true) {
        attrs['aria-disabled'] = 'true';
      }
      return attrs;
    }
  },
  methods: {
    toggle: function toggle(e) {
      if (e !== void 0) {
        Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_8__[/* stopAndPrevent */ "j"])(e);
        this.__refocusTarget(e);
      }
      if (this.disable !== true) {
        this.$emit('input', this.__getNextValue(), e);
      }
    },
    __getNextValue: function __getNextValue() {
      if (this.modelIsArray === true) {
        if (this.isTrue === true) {
          var val = this.value.slice();
          val.splice(this.index, 1);
          return val;
        }
        return this.value.concat([this.val]);
      }
      if (this.isTrue === true) {
        if (this.toggleOrder !== 'ft' || this.toggleIndeterminate === false) {
          return this.falseValue;
        }
      } else if (this.isFalse === true) {
        if (this.toggleOrder === 'ft' || this.toggleIndeterminate === false) {
          return this.trueValue;
        }
      } else {
        return this.toggleOrder !== 'ft' ? this.trueValue : this.falseValue;
      }
      return this.indeterminateValue;
    },
    __onKeydown: function __onKeydown(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_8__[/* stopAndPrevent */ "j"])(e);
      }
    },
    __onKeyup: function __onKeyup(e) {
      if (e.keyCode === 13 || e.keyCode === 32) {
        this.toggle(e);
      }
    }
  },
  render: function render(h) {
    var inner = this.__getInner(h);
    this.disable !== true && this.__injectFormInput(inner, 'unshift', "q-".concat(this.type, "__native absolute q-ma-none q-pa-none"));
    var child = [h('div', {
      staticClass: "q-".concat(this.type, "__inner relative-position non-selectable"),
      class: this.innerClass,
      style: this.sizeStyle,
      attrs: {
        'aria-hidden': 'true'
      }
    }, inner)];
    if (this.__refocusTargetEl !== void 0) {
      child.push(this.__refocusTargetEl);
    }
    var label = this.label !== void 0 ? Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_12__[/* mergeSlot */ "a"])([this.label], this, 'default') : Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_12__[/* slot */ "c"])(this, 'default');
    label !== void 0 && child.push(h('div', {
      staticClass: "q-".concat(this.type, "__label q-anchor--skip")
    }, label));
    return h('div', {
      class: this.classes,
      attrs: this.attrs,
      on: Object(_utils_private_cache_js__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(this, 'inpExt', {
        click: this.toggle,
        keydown: this.__onKeydown,
        keyup: this.__onKeyup
      })
    }, child);
  }
});

/***/ }),

/***/ "861d":
/***/ (function(module, exports, __webpack_require__) {

var isCallable = __webpack_require__("1626");
var $documentAll = __webpack_require__("8ea1");

var documentAll = $documentAll.all;

module.exports = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "867a":
/***/ (function(module, exports) {

var log = Math.log;
var LOG10E = Math.LOG10E;

// eslint-disable-next-line es/no-math-log10 -- safe
module.exports = Math.log10 || function log10(x) {
  return log(x) * LOG10E;
};


/***/ }),

/***/ "8716":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return routerLinkProps; });
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("b64b");
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("ac1f");
/* harmony import */ var core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_exec_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("5319");
/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("b0c0");
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("99af");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_es_promise_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("e6cf");
/* harmony import */ var core_js_modules_es_promise_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_promise_js__WEBPACK_IMPORTED_MODULE_6__);







var trailingSlashRE = /\/?$/;
function equals(current, target) {
  if (Object.keys(current).length !== Object.keys(target).length) {
    return false;
  }

  // route query and params are strings when read from URL
  for (var key in target) {
    if (!(key in current) || String(current[key]) !== String(target[key])) {
      return false;
    }
  }
  return true;
}
function includes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}
function isSameRoute(current, target) {
  if (!target) {
    return false;
  }
  if (current.path && target.path) {
    return current.path.replace(trailingSlashRE, '') === target.path.replace(trailingSlashRE, '') && current.hash === target.hash && equals(current.query, target.query);
  }
  return typeof current.name === 'string' && current.name === target.name && current.hash === target.hash && equals(current.query, target.query) === true && equals(current.params, target.params) === true;
}
function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (typeof target.hash !== 'string' || target.hash.length < 2 || current.hash === target.hash) && includes(current.query, target.query) === true;
}
var routerLinkProps = {
  // router-link
  to: [String, Object],
  exact: Boolean,
  append: Boolean,
  replace: Boolean,
  activeClass: {
    type: String,
    default: 'q-router-link--active'
  },
  exactActiveClass: {
    type: String,
    default: 'q-router-link--exact-active'
  },
  // regular <a> link
  href: String,
  target: String,
  // state
  disable: Boolean
};

// external props: type, tag
// external: fallbackTag

/* harmony default export */ __webpack_exports__["a"] = ({
  props: routerLinkProps,
  computed: {
    hasHrefLink: function hasHrefLink() {
      return this.disable !== true && this.href !== void 0;
    },
    // beware, it gets overwritten in QRouteTab
    hasRouterLinkProps: function hasRouterLinkProps() {
      return this.$router !== void 0 && this.disable !== true && this.hasHrefLink !== true && this.to !== void 0 && this.to !== null && this.to !== '';
    },
    resolvedLink: function resolvedLink() {
      return this.hasRouterLinkProps === true ? this.__getLink(this.to, this.append) : null;
    },
    hasRouterLink: function hasRouterLink() {
      return this.resolvedLink !== null;
    },
    hasLink: function hasLink() {
      return this.hasHrefLink === true || this.hasRouterLink === true;
    },
    linkTag: function linkTag() {
      return this.type === 'a' || this.hasLink === true ? 'a' : this.tag || this.fallbackTag || 'div';
    },
    linkAttrs: function linkAttrs() {
      return this.hasHrefLink === true ? {
        href: this.href,
        target: this.target
      } : this.hasRouterLink === true ? {
        href: this.resolvedLink.href,
        target: this.target
      } : {};
    },
    linkIsActive: function linkIsActive() {
      return this.hasRouterLink === true && isIncludedRoute(this.$route, this.resolvedLink.route);
    },
    linkIsExactActive: function linkIsExactActive() {
      return this.hasRouterLink === true && isSameRoute(this.$route, this.resolvedLink.route);
    },
    linkClass: function linkClass() {
      return this.hasRouterLink === true ? this.linkIsExactActive === true ? " ".concat(this.exactActiveClass, " ").concat(this.activeClass) : this.exact === true ? '' : this.linkIsActive === true ? " ".concat(this.activeClass) : '' : '';
    }
  },
  methods: {
    __getLink: function __getLink(to, append) {
      // we protect from accessing this.$route without
      // actually needing it so that we won't trigger
      // unnecessary updates in computed props using this method
      try {
        return append === true ? this.$router.resolve(to, this.$route, true) : this.$router.resolve(to);
      } catch (_) {}
      return null;
    },
    /**
     * @returns Promise<RouterLocation|RouterError|false> | Promise<RouterLocation|false|void>
     */
    __navigateToRouterLink: function __navigateToRouterLink(e) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        returnRouterError = _ref.returnRouterError,
        to = _ref.to,
        _ref$replace = _ref.replace,
        replace = _ref$replace === void 0 ? this.replace : _ref$replace,
        append = _ref.append;
      if (this.disable === true) {
        // ensure native navigation is prevented in all cases,
        // like in QRouteTab where hasRouterLinkProps does not care about disable state
        e.preventDefault();
        return Promise.resolve(false);
      }
      if (
      // don't redirect with control keys;
      // should match RouterLink from Vue Router
      e.metaKey || e.altKey || e.ctrlKey || e.shiftKey ||
      // don't redirect on right click
      e.button !== void 0 && e.button !== 0 ||
      // don't redirect if it should open in a new window
      this.target === '_blank') {
        return Promise.resolve(false);
      }
      e.preventDefault();
      var resolvedLink = to === void 0 ? this.resolvedLink : this.__getLink(to, append);
      if (resolvedLink === null) {
        return Promise[returnRouterError === true ? 'reject' : 'resolve'](false);
      }
      var promise = this.$router[replace === true ? 'replace' : 'push'](resolvedLink.location);
      return returnRouterError === true ? promise : promise.catch(function () {});
    },
    __navigateOnClick: function __navigateOnClick(e) {
      var _this = this;
      if (this.hasRouterLink === true) {
        var go = function go(opts) {
          return _this.__navigateToRouterLink(e, opts);
        };
        this.$emit('click', e, go);

        // for backward compatibility
        e.navigate === false && e.preventDefault();
        e.defaultPrevented !== true && go();
      } else {
        this.$emit('click', e);
      }
    }
  }
});

/***/ }),

/***/ "879e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__("d4ec");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__("bee2");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js
var inherits = __webpack_require__("262e");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js + 2 modules
var createSuper = __webpack_require__("2caf");

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__("9ab4");

// EXTERNAL MODULE: ./node_modules/reflect-metadata/Reflect.js
var Reflect = __webpack_require__("98db");

// EXTERNAL MODULE: ./node_modules/vue-property-decorator/lib/index.js + 15 modules
var lib = __webpack_require__("1b40");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/BaseBlock.vue?vue&type=script&lang=ts&







var BaseBlockvue_type_script_lang_ts_BaseBlock = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(BaseBlock, _Vue);
  var _super = Object(createSuper["a" /* default */])(BaseBlock);
  function BaseBlock() {
    Object(classCallCheck["a" /* default */])(this, BaseBlock);
    return _super.apply(this, arguments);
  }
  Object(createClass["a" /* default */])(BaseBlock, [{
    key: "whenBlockIsReady",
    value: function whenBlockIsReady() {
      if (this.muteReadyState) {
        return;
      }
      this.block.readyCount++;
      this.$emit('ready', this.block);
    }
  }, {
    key: "whenBlockIsDestroyed",
    value: function whenBlockIsDestroyed() {
      if (this.muteReadyState) {
        return;
      }
      this.block.readyCount--;
    }
  }, {
    key: "readyWhenMounted",
    get: function get() {
      return true;
    }
  }, {
    key: "mounted",
    value: function mounted() {
      if (this.readyWhenMounted) {
        this.whenBlockIsReady();
      }
    }
  }, {
    key: "beforeDestroy",
    value: function beforeDestroy() {
      this.whenBlockIsDestroyed();
    }
  }]);
  return BaseBlock;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], BaseBlockvue_type_script_lang_ts_BaseBlock.prototype, "muteReadyState", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], BaseBlockvue_type_script_lang_ts_BaseBlock.prototype, "block", void 0);
BaseBlockvue_type_script_lang_ts_BaseBlock = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], BaseBlockvue_type_script_lang_ts_BaseBlock);
/* harmony default export */ var BaseBlockvue_type_script_lang_ts_ = (BaseBlockvue_type_script_lang_ts_BaseBlock);
// CONCATENATED MODULE: ./src/components/BaseBlock.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_BaseBlockvue_type_script_lang_ts_ = (BaseBlockvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__("2877");

// CONCATENATED MODULE: ./src/components/BaseBlock.vue
var render, staticRenderFns




/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  components_BaseBlockvue_type_script_lang_ts_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var components_BaseBlock = __webpack_exports__["a"] = (component.exports);

/***/ }),

/***/ "87e8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _utils_private_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d54d");

/* harmony default export */ __webpack_exports__["a"] = (Object(_utils_private_cache_js__WEBPACK_IMPORTED_MODULE_0__[/* getPropCacheMixin */ "b"])('$listeners', 'qListeners'));

/***/ }),

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript')
    // for chrome
    if (!descriptor && 'currentScript' in document && document.currentScript) {
      return document.currentScript
    }

    // for other browsers with native support for currentScript
    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "8925":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var isCallable = __webpack_require__("1626");
var store = __webpack_require__("c6cd");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "898d":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "8a79":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("4625");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var toLength = __webpack_require__("50c4");
var toString = __webpack_require__("577e");
var notARegExp = __webpack_require__("5a34");
var requireObjectCoercible = __webpack_require__("1d80");
var correctIsRegExpLogic = __webpack_require__("ab13");
var IS_PURE = __webpack_require__("c430");

// eslint-disable-next-line es/no-string-prototype-endswith -- safe
var nativeEndsWith = uncurryThis(''.endsWith);
var slice = uncurryThis(''.slice);
var min = Math.min;

var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.endsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.endswith
$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = toString(requireObjectCoercible(this));
    notARegExp(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = that.length;
    var end = endPosition === undefined ? len : min(toLength(endPosition), len);
    var search = toString(searchString);
    return nativeEndsWith
      ? nativeEndsWith(that, search, end)
      : slice(that, end - search.length, end) === search;
  }
});


/***/ }),

/***/ "8aa5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ "8aa7":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-new -- required for testing */
var global = __webpack_require__("da84");
var fails = __webpack_require__("d039");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__("ebb5").NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),

/***/ "8bbf":
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;

/***/ }),

/***/ "8c06":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "8c2e":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "8d7e":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "8ea1":
/***/ (function(module, exports) {

var documentAll = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;

module.exports = {
  all: documentAll,
  IS_HTMLDDA: IS_HTMLDDA
};


/***/ }),

/***/ "8f8e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _icon_QIcon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0016");
/* harmony import */ var _mixins_checkbox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("85fc");



/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({
  name: 'QCheckbox',
  mixins: [_mixins_checkbox_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]],
  computed: {
    computedIcon: function computedIcon() {
      return this.isTrue === true ? this.checkedIcon : this.isIndeterminate === true ? this.indeterminateIcon : this.uncheckedIcon;
    }
  },
  methods: {
    __getInner: function __getInner(h) {
      return this.computedIcon !== void 0 ? [h('div', {
        key: 'icon',
        staticClass: 'q-checkbox__icon-container absolute-full flex flex-center no-wrap'
      }, [h(_icon_QIcon_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], {
        staticClass: 'q-checkbox__icon',
        props: {
          name: this.computedIcon
        }
      })])] : [h('div', {
        key: 'svg',
        staticClass: 'q-checkbox__bg absolute'
      }, [h('svg', {
        staticClass: 'q-checkbox__svg fit absolute-full',
        attrs: {
          focusable: 'false' /* needed for IE11 */,
          viewBox: '0 0 24 24'
        }
      }, [h('path', {
        staticClass: 'q-checkbox__truthy',
        attrs: {
          fill: 'none',
          d: 'M1.73,12.91 8.1,19.28 22.79,4.59'
        }
      }), h('path', {
        staticClass: 'q-checkbox__indet',
        attrs: {
          d: 'M4,14H20V10H4'
        }
      })])])];
    }
  },
  created: function created() {
    this.type = 'checkbox';
  }
}));

/***/ }),

/***/ "8f94":
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__("56b3")):undefined}(this,function(e){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="/",t(t.s=3)}([function(t,n){t.exports=e},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o=function(e){return e&&e.__esModule?e:{default:e}}(r),i=window.CodeMirror||o.default;"function"!=typeof Object.assign&&Object.defineProperty(Object,"assign",{value:function(e,t){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var n=Object(e),r=1;r<arguments.length;r++){var o=arguments[r];if(null!=o)for(var i in o)Object.prototype.hasOwnProperty.call(o,i)&&(n[i]=o[i])}return n},writable:!0,configurable:!0}),t.default={name:"codemirror",data:function(){return{content:"",codemirror:null,cminstance:null}},props:{code:String,value:String,marker:Function,unseenLines:Array,name:{type:String,default:"codemirror"},placeholder:{type:String,default:""},merge:{type:Boolean,default:!1},options:{type:Object,default:function(){return{}}},events:{type:Array,default:function(){return[]}},globalOptions:{type:Object,default:function(){return{}}},globalEvents:{type:Array,default:function(){return[]}}},watch:{options:{deep:!0,handler:function(e){for(var t in e)this.cminstance.setOption(t,e[t])}},merge:function(){this.$nextTick(this.switchMerge)},code:function(e){this.handerCodeChange(e)},value:function(e){this.handerCodeChange(e)}},methods:{initialize:function(){var e=this,t=Object.assign({},this.globalOptions,this.options);this.merge?(this.codemirror=i.MergeView(this.$refs.mergeview,t),this.cminstance=this.codemirror.edit):(this.codemirror=i.fromTextArea(this.$refs.textarea,t),this.cminstance=this.codemirror,this.cminstance.setValue(this.code||this.value||this.content)),this.cminstance.on("change",function(t){e.content=t.getValue(),e.$emit&&e.$emit("input",e.content)});var n={};["scroll","changes","beforeChange","cursorActivity","keyHandled","inputRead","electricInput","beforeSelectionChange","viewportChange","swapDoc","gutterClick","gutterContextMenu","focus","blur","refresh","optionChange","scrollCursorIntoView","update"].concat(this.events).concat(this.globalEvents).filter(function(e){return!n[e]&&(n[e]=!0)}).forEach(function(t){e.cminstance.on(t,function(){for(var n=arguments.length,r=Array(n),o=0;o<n;o++)r[o]=arguments[o];e.$emit.apply(e,[t].concat(r));var i=t.replace(/([A-Z])/g,"-$1").toLowerCase();i!==t&&e.$emit.apply(e,[i].concat(r))})});this.$emit("ready",this.codemirror),this.unseenLineMarkers(),this.refresh()},refresh:function(){var e=this;this.$nextTick(function(){e.cminstance.refresh()})},destroy:function(){var e=this.cminstance.doc.cm.getWrapperElement();e&&e.remove&&e.remove()},handerCodeChange:function(e){if(e!==this.cminstance.getValue()){var t=this.cminstance.getScrollInfo();this.cminstance.setValue(e),this.content=e,this.cminstance.scrollTo(t.left,t.top)}this.unseenLineMarkers()},unseenLineMarkers:function(){var e=this;void 0!==this.unseenLines&&void 0!==this.marker&&this.unseenLines.forEach(function(t){var n=e.cminstance.lineInfo(t);e.cminstance.setGutterMarker(t,"breakpoints",n.gutterMarkers?null:e.marker())})},switchMerge:function(){var e=this.cminstance.doc.history,t=this.cminstance.doc.cleanGeneration;this.options.value=this.cminstance.getValue(),this.destroy(),this.initialize(),this.cminstance.doc.history=e,this.cminstance.doc.cleanGeneration=t}},mounted:function(){this.initialize()},beforeDestroy:function(){this.destroy()}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(1),o=n.n(r);for(var i in r)["default","default"].indexOf(i)<0&&function(e){n.d(t,e,function(){return r[e]})}(i);var s=n(5),c=n(4),a=c(o.a,s.a,!1,null,null,null);t.default=a.exports},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0}),t.install=t.codemirror=t.CodeMirror=void 0;var o=n(0),i=r(o),s=n(2),c=r(s),a=window.CodeMirror||i.default,u=function(e,t){t&&(t.options&&(c.default.props.globalOptions.default=function(){return t.options}),t.events&&(c.default.props.globalEvents.default=function(){return t.events})),e.component(c.default.name,c.default)},l={CodeMirror:a,codemirror:c.default,install:u};t.default=l,t.CodeMirror=a,t.codemirror=c.default,t.install=u},function(e,t){e.exports=function(e,t,n,r,o,i){var s,c=e=e||{},a=typeof e.default;"object"!==a&&"function"!==a||(s=e,c=e.default);var u="function"==typeof c?c.options:c;t&&(u.render=t.render,u.staticRenderFns=t.staticRenderFns,u._compiled=!0),n&&(u.functional=!0),o&&(u._scopeId=o);var l;if(i?(l=function(e){e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,e||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),r&&r.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(i)},u._ssrRegister=l):r&&(l=r),l){var f=u.functional,d=f?u.render:u.beforeCreate;f?(u._injectStyles=l,u.render=function(e,t){return l.call(t),d(e,t)}):u.beforeCreate=d?[].concat(d,l):[l]}return{esModule:s,exports:c,options:u}}},function(e,t,n){"use strict";var r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"vue-codemirror",class:{merge:e.merge}},[e.merge?n("div",{ref:"mergeview"}):n("textarea",{ref:"textarea",attrs:{name:e.name,placeholder:e.placeholder}})])},o=[],i={render:r,staticRenderFns:o};t.a=i}])});

/***/ }),

/***/ "903e":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("56b3"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.registerHelper("wordChars", "r", /[\w.]/);

CodeMirror.defineMode("r", function(config) {
  function wordObj(words) {
    var res = {};
    for (var i = 0; i < words.length; ++i) res[words[i]] = true;
    return res;
  }
  var commonAtoms = ["NULL", "NA", "Inf", "NaN", "NA_integer_", "NA_real_", "NA_complex_", "NA_character_", "TRUE", "FALSE"];
  var commonBuiltins = ["list", "quote", "bquote", "eval", "return", "call", "parse", "deparse"];
  var commonKeywords = ["if", "else", "repeat", "while", "function", "for", "in", "next", "break"];
  var commonBlockKeywords = ["if", "else", "repeat", "while", "function", "for"];

  CodeMirror.registerHelper("hintWords", "r", commonAtoms.concat(commonBuiltins, commonKeywords));

  var atoms = wordObj(commonAtoms);
  var builtins = wordObj(commonBuiltins);
  var keywords = wordObj(commonKeywords);
  var blockkeywords = wordObj(commonBlockKeywords);
  var opChars = /[+\-*\/^<>=!&|~$:]/;
  var curPunc;

  function tokenBase(stream, state) {
    curPunc = null;
    var ch = stream.next();
    if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    } else if (ch == "0" && stream.eat("x")) {
      stream.eatWhile(/[\da-f]/i);
      return "number";
    } else if (ch == "." && stream.eat(/\d/)) {
      stream.match(/\d*(?:e[+\-]?\d+)?/);
      return "number";
    } else if (/\d/.test(ch)) {
      stream.match(/\d*(?:\.\d+)?(?:e[+\-]\d+)?L?/);
      return "number";
    } else if (ch == "'" || ch == '"') {
      state.tokenize = tokenString(ch);
      return "string";
    } else if (ch == "`") {
      stream.match(/[^`]+`/);
      return "variable-3";
    } else if (ch == "." && stream.match(/.(?:[.]|\d+)/)) {
      return "keyword";
    } else if (/[a-zA-Z\.]/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      var word = stream.current();
      if (atoms.propertyIsEnumerable(word)) return "atom";
      if (keywords.propertyIsEnumerable(word)) {
        // Block keywords start new blocks, except 'else if', which only starts
        // one new block for the 'if', no block for the 'else'.
        if (blockkeywords.propertyIsEnumerable(word) &&
            !stream.match(/\s*if(\s+|$)/, false))
          curPunc = "block";
        return "keyword";
      }
      if (builtins.propertyIsEnumerable(word)) return "builtin";
      return "variable";
    } else if (ch == "%") {
      if (stream.skipTo("%")) stream.next();
      return "operator variable-2";
    } else if (
        (ch == "<" && stream.eat("-")) ||
        (ch == "<" && stream.match("<-")) ||
        (ch == "-" && stream.match(/>>?/))
      ) {
      return "operator arrow";
    } else if (ch == "=" && state.ctx.argList) {
      return "arg-is";
    } else if (opChars.test(ch)) {
      if (ch == "$") return "operator dollar";
      stream.eatWhile(opChars);
      return "operator";
    } else if (/[\(\){}\[\];]/.test(ch)) {
      curPunc = ch;
      if (ch == ";") return "semi";
      return null;
    } else {
      return null;
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      if (stream.eat("\\")) {
        var ch = stream.next();
        if (ch == "x") stream.match(/^[a-f0-9]{2}/i);
        else if ((ch == "u" || ch == "U") && stream.eat("{") && stream.skipTo("}")) stream.next();
        else if (ch == "u") stream.match(/^[a-f0-9]{4}/i);
        else if (ch == "U") stream.match(/^[a-f0-9]{8}/i);
        else if (/[0-7]/.test(ch)) stream.match(/^[0-7]{1,2}/);
        return "string-2";
      } else {
        var next;
        while ((next = stream.next()) != null) {
          if (next == quote) { state.tokenize = tokenBase; break; }
          if (next == "\\") { stream.backUp(1); break; }
        }
        return "string";
      }
    };
  }

  var ALIGN_YES = 1, ALIGN_NO = 2, BRACELESS = 4

  function push(state, type, stream) {
    state.ctx = {type: type,
                 indent: state.indent,
                 flags: 0,
                 column: stream.column(),
                 prev: state.ctx};
  }
  function setFlag(state, flag) {
    var ctx = state.ctx
    state.ctx = {type: ctx.type,
                 indent: ctx.indent,
                 flags: ctx.flags | flag,
                 column: ctx.column,
                 prev: ctx.prev}
  }
  function pop(state) {
    state.indent = state.ctx.indent;
    state.ctx = state.ctx.prev;
  }

  return {
    startState: function() {
      return {tokenize: tokenBase,
              ctx: {type: "top",
                    indent: -config.indentUnit,
                    flags: ALIGN_NO},
              indent: 0,
              afterIdent: false};
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if ((state.ctx.flags & 3) == 0) state.ctx.flags |= ALIGN_NO
        if (state.ctx.flags & BRACELESS) pop(state)
        state.indent = stream.indentation();
      }
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (style != "comment" && (state.ctx.flags & ALIGN_NO) == 0) setFlag(state, ALIGN_YES)

      if ((curPunc == ";" || curPunc == "{" || curPunc == "}") && state.ctx.type == "block") pop(state);
      if (curPunc == "{") push(state, "}", stream);
      else if (curPunc == "(") {
        push(state, ")", stream);
        if (state.afterIdent) state.ctx.argList = true;
      }
      else if (curPunc == "[") push(state, "]", stream);
      else if (curPunc == "block") push(state, "block", stream);
      else if (curPunc == state.ctx.type) pop(state);
      else if (state.ctx.type == "block" && style != "comment") setFlag(state, BRACELESS)
      state.afterIdent = style == "variable" || style == "keyword";
      return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), ctx = state.ctx,
          closing = firstChar == ctx.type;
      if (ctx.flags & BRACELESS) ctx = ctx.prev
      if (ctx.type == "block") return ctx.indent + (firstChar == "{" ? 0 : config.indentUnit);
      else if (ctx.flags & ALIGN_YES) return ctx.column + (closing ? 0 : 1);
      else return ctx.indent + (closing ? 0 : config.indentUnit);
    },

    lineComment: "#"
  };
});

CodeMirror.defineMIME("text/x-rsrc", "r");

});


/***/ }),

/***/ "906f":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

// CodeMirror2 mode/perl/perl.js (text/x-perl) beta 0.10 (2011-11-08)
// This is a part of CodeMirror from https://github.com/sabaca/CodeMirror_mode_perl (mail@sabaca.com)

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("56b3"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("perl",function(){
        // http://perldoc.perl.org
        var PERL={                                      //   null - magic touch
                                                        //   1 - keyword
                                                        //   2 - def
                                                        //   3 - atom
                                                        //   4 - operator
                                                        //   5 - variable-2 (predefined)
                                                        //   [x,y] - x=1,2,3; y=must be defined if x{...}
                                                //      PERL operators
                '->'                            :   4,
                '++'                            :   4,
                '--'                            :   4,
                '**'                            :   4,
                                                        //   ! ~ \ and unary + and -
                '=~'                            :   4,
                '!~'                            :   4,
                '*'                             :   4,
                '/'                             :   4,
                '%'                             :   4,
                'x'                             :   4,
                '+'                             :   4,
                '-'                             :   4,
                '.'                             :   4,
                '<<'                            :   4,
                '>>'                            :   4,
                                                        //   named unary operators
                '<'                             :   4,
                '>'                             :   4,
                '<='                            :   4,
                '>='                            :   4,
                'lt'                            :   4,
                'gt'                            :   4,
                'le'                            :   4,
                'ge'                            :   4,
                '=='                            :   4,
                '!='                            :   4,
                '<=>'                           :   4,
                'eq'                            :   4,
                'ne'                            :   4,
                'cmp'                           :   4,
                '~~'                            :   4,
                '&'                             :   4,
                '|'                             :   4,
                '^'                             :   4,
                '&&'                            :   4,
                '||'                            :   4,
                '//'                            :   4,
                '..'                            :   4,
                '...'                           :   4,
                '?'                             :   4,
                ':'                             :   4,
                '='                             :   4,
                '+='                            :   4,
                '-='                            :   4,
                '*='                            :   4,  //   etc. ???
                ','                             :   4,
                '=>'                            :   4,
                '::'                            :   4,
                                                        //   list operators (rightward)
                'not'                           :   4,
                'and'                           :   4,
                'or'                            :   4,
                'xor'                           :   4,
                                                //      PERL predefined variables (I know, what this is a paranoid idea, but may be needed for people, who learn PERL, and for me as well, ...and may be for you?;)
                'BEGIN'                         :   [5,1],
                'END'                           :   [5,1],
                'PRINT'                         :   [5,1],
                'PRINTF'                        :   [5,1],
                'GETC'                          :   [5,1],
                'READ'                          :   [5,1],
                'READLINE'                      :   [5,1],
                'DESTROY'                       :   [5,1],
                'TIE'                           :   [5,1],
                'TIEHANDLE'                     :   [5,1],
                'UNTIE'                         :   [5,1],
                'STDIN'                         :    5,
                'STDIN_TOP'                     :    5,
                'STDOUT'                        :    5,
                'STDOUT_TOP'                    :    5,
                'STDERR'                        :    5,
                'STDERR_TOP'                    :    5,
                '$ARG'                          :    5,
                '$_'                            :    5,
                '@ARG'                          :    5,
                '@_'                            :    5,
                '$LIST_SEPARATOR'               :    5,
                '$"'                            :    5,
                '$PROCESS_ID'                   :    5,
                '$PID'                          :    5,
                '$$'                            :    5,
                '$REAL_GROUP_ID'                :    5,
                '$GID'                          :    5,
                '$('                            :    5,
                '$EFFECTIVE_GROUP_ID'           :    5,
                '$EGID'                         :    5,
                '$)'                            :    5,
                '$PROGRAM_NAME'                 :    5,
                '$0'                            :    5,
                '$SUBSCRIPT_SEPARATOR'          :    5,
                '$SUBSEP'                       :    5,
                '$;'                            :    5,
                '$REAL_USER_ID'                 :    5,
                '$UID'                          :    5,
                '$<'                            :    5,
                '$EFFECTIVE_USER_ID'            :    5,
                '$EUID'                         :    5,
                '$>'                            :    5,
                '$a'                            :    5,
                '$b'                            :    5,
                '$COMPILING'                    :    5,
                '$^C'                           :    5,
                '$DEBUGGING'                    :    5,
                '$^D'                           :    5,
                '${^ENCODING}'                  :    5,
                '$ENV'                          :    5,
                '%ENV'                          :    5,
                '$SYSTEM_FD_MAX'                :    5,
                '$^F'                           :    5,
                '@F'                            :    5,
                '${^GLOBAL_PHASE}'              :    5,
                '$^H'                           :    5,
                '%^H'                           :    5,
                '@INC'                          :    5,
                '%INC'                          :    5,
                '$INPLACE_EDIT'                 :    5,
                '$^I'                           :    5,
                '$^M'                           :    5,
                '$OSNAME'                       :    5,
                '$^O'                           :    5,
                '${^OPEN}'                      :    5,
                '$PERLDB'                       :    5,
                '$^P'                           :    5,
                '$SIG'                          :    5,
                '%SIG'                          :    5,
                '$BASETIME'                     :    5,
                '$^T'                           :    5,
                '${^TAINT}'                     :    5,
                '${^UNICODE}'                   :    5,
                '${^UTF8CACHE}'                 :    5,
                '${^UTF8LOCALE}'                :    5,
                '$PERL_VERSION'                 :    5,
                '$^V'                           :    5,
                '${^WIN32_SLOPPY_STAT}'         :    5,
                '$EXECUTABLE_NAME'              :    5,
                '$^X'                           :    5,
                '$1'                            :    5, // - regexp $1, $2...
                '$MATCH'                        :    5,
                '$&'                            :    5,
                '${^MATCH}'                     :    5,
                '$PREMATCH'                     :    5,
                '$`'                            :    5,
                '${^PREMATCH}'                  :    5,
                '$POSTMATCH'                    :    5,
                "$'"                            :    5,
                '${^POSTMATCH}'                 :    5,
                '$LAST_PAREN_MATCH'             :    5,
                '$+'                            :    5,
                '$LAST_SUBMATCH_RESULT'         :    5,
                '$^N'                           :    5,
                '@LAST_MATCH_END'               :    5,
                '@+'                            :    5,
                '%LAST_PAREN_MATCH'             :    5,
                '%+'                            :    5,
                '@LAST_MATCH_START'             :    5,
                '@-'                            :    5,
                '%LAST_MATCH_START'             :    5,
                '%-'                            :    5,
                '$LAST_REGEXP_CODE_RESULT'      :    5,
                '$^R'                           :    5,
                '${^RE_DEBUG_FLAGS}'            :    5,
                '${^RE_TRIE_MAXBUF}'            :    5,
                '$ARGV'                         :    5,
                '@ARGV'                         :    5,
                'ARGV'                          :    5,
                'ARGVOUT'                       :    5,
                '$OUTPUT_FIELD_SEPARATOR'       :    5,
                '$OFS'                          :    5,
                '$,'                            :    5,
                '$INPUT_LINE_NUMBER'            :    5,
                '$NR'                           :    5,
                '$.'                            :    5,
                '$INPUT_RECORD_SEPARATOR'       :    5,
                '$RS'                           :    5,
                '$/'                            :    5,
                '$OUTPUT_RECORD_SEPARATOR'      :    5,
                '$ORS'                          :    5,
                '$\\'                           :    5,
                '$OUTPUT_AUTOFLUSH'             :    5,
                '$|'                            :    5,
                '$ACCUMULATOR'                  :    5,
                '$^A'                           :    5,
                '$FORMAT_FORMFEED'              :    5,
                '$^L'                           :    5,
                '$FORMAT_PAGE_NUMBER'           :    5,
                '$%'                            :    5,
                '$FORMAT_LINES_LEFT'            :    5,
                '$-'                            :    5,
                '$FORMAT_LINE_BREAK_CHARACTERS' :    5,
                '$:'                            :    5,
                '$FORMAT_LINES_PER_PAGE'        :    5,
                '$='                            :    5,
                '$FORMAT_TOP_NAME'              :    5,
                '$^'                            :    5,
                '$FORMAT_NAME'                  :    5,
                '$~'                            :    5,
                '${^CHILD_ERROR_NATIVE}'        :    5,
                '$EXTENDED_OS_ERROR'            :    5,
                '$^E'                           :    5,
                '$EXCEPTIONS_BEING_CAUGHT'      :    5,
                '$^S'                           :    5,
                '$WARNING'                      :    5,
                '$^W'                           :    5,
                '${^WARNING_BITS}'              :    5,
                '$OS_ERROR'                     :    5,
                '$ERRNO'                        :    5,
                '$!'                            :    5,
                '%OS_ERROR'                     :    5,
                '%ERRNO'                        :    5,
                '%!'                            :    5,
                '$CHILD_ERROR'                  :    5,
                '$?'                            :    5,
                '$EVAL_ERROR'                   :    5,
                '$@'                            :    5,
                '$OFMT'                         :    5,
                '$#'                            :    5,
                '$*'                            :    5,
                '$ARRAY_BASE'                   :    5,
                '$['                            :    5,
                '$OLD_PERL_VERSION'             :    5,
                '$]'                            :    5,
                                                //      PERL blocks
                'if'                            :[1,1],
                elsif                           :[1,1],
                'else'                          :[1,1],
                'while'                         :[1,1],
                unless                          :[1,1],
                'for'                           :[1,1],
                foreach                         :[1,1],
                                                //      PERL functions
                'abs'                           :1,     // - absolute value function
                accept                          :1,     // - accept an incoming socket connect
                alarm                           :1,     // - schedule a SIGALRM
                'atan2'                         :1,     // - arctangent of Y/X in the range -PI to PI
                bind                            :1,     // - binds an address to a socket
                binmode                         :1,     // - prepare binary files for I/O
                bless                           :1,     // - create an object
                bootstrap                       :1,     //
                'break'                         :1,     // - break out of a "given" block
                caller                          :1,     // - get context of the current subroutine call
                chdir                           :1,     // - change your current working directory
                chmod                           :1,     // - changes the permissions on a list of files
                chomp                           :1,     // - remove a trailing record separator from a string
                chop                            :1,     // - remove the last character from a string
                chown                           :1,     // - change the ownership on a list of files
                chr                             :1,     // - get character this number represents
                chroot                          :1,     // - make directory new root for path lookups
                close                           :1,     // - close file (or pipe or socket) handle
                closedir                        :1,     // - close directory handle
                connect                         :1,     // - connect to a remote socket
                'continue'                      :[1,1], // - optional trailing block in a while or foreach
                'cos'                           :1,     // - cosine function
                crypt                           :1,     // - one-way passwd-style encryption
                dbmclose                        :1,     // - breaks binding on a tied dbm file
                dbmopen                         :1,     // - create binding on a tied dbm file
                'default'                       :1,     //
                defined                         :1,     // - test whether a value, variable, or function is defined
                'delete'                        :1,     // - deletes a value from a hash
                die                             :1,     // - raise an exception or bail out
                'do'                            :1,     // - turn a BLOCK into a TERM
                dump                            :1,     // - create an immediate core dump
                each                            :1,     // - retrieve the next key/value pair from a hash
                endgrent                        :1,     // - be done using group file
                endhostent                      :1,     // - be done using hosts file
                endnetent                       :1,     // - be done using networks file
                endprotoent                     :1,     // - be done using protocols file
                endpwent                        :1,     // - be done using passwd file
                endservent                      :1,     // - be done using services file
                eof                             :1,     // - test a filehandle for its end
                'eval'                          :1,     // - catch exceptions or compile and run code
                'exec'                          :1,     // - abandon this program to run another
                exists                          :1,     // - test whether a hash key is present
                exit                            :1,     // - terminate this program
                'exp'                           :1,     // - raise I to a power
                fcntl                           :1,     // - file control system call
                fileno                          :1,     // - return file descriptor from filehandle
                flock                           :1,     // - lock an entire file with an advisory lock
                fork                            :1,     // - create a new process just like this one
                format                          :1,     // - declare a picture format with use by the write() function
                formline                        :1,     // - internal function used for formats
                getc                            :1,     // - get the next character from the filehandle
                getgrent                        :1,     // - get next group record
                getgrgid                        :1,     // - get group record given group user ID
                getgrnam                        :1,     // - get group record given group name
                gethostbyaddr                   :1,     // - get host record given its address
                gethostbyname                   :1,     // - get host record given name
                gethostent                      :1,     // - get next hosts record
                getlogin                        :1,     // - return who logged in at this tty
                getnetbyaddr                    :1,     // - get network record given its address
                getnetbyname                    :1,     // - get networks record given name
                getnetent                       :1,     // - get next networks record
                getpeername                     :1,     // - find the other end of a socket connection
                getpgrp                         :1,     // - get process group
                getppid                         :1,     // - get parent process ID
                getpriority                     :1,     // - get current nice value
                getprotobyname                  :1,     // - get protocol record given name
                getprotobynumber                :1,     // - get protocol record numeric protocol
                getprotoent                     :1,     // - get next protocols record
                getpwent                        :1,     // - get next passwd record
                getpwnam                        :1,     // - get passwd record given user login name
                getpwuid                        :1,     // - get passwd record given user ID
                getservbyname                   :1,     // - get services record given its name
                getservbyport                   :1,     // - get services record given numeric port
                getservent                      :1,     // - get next services record
                getsockname                     :1,     // - retrieve the sockaddr for a given socket
                getsockopt                      :1,     // - get socket options on a given socket
                given                           :1,     //
                glob                            :1,     // - expand filenames using wildcards
                gmtime                          :1,     // - convert UNIX time into record or string using Greenwich time
                'goto'                          :1,     // - create spaghetti code
                grep                            :1,     // - locate elements in a list test true against a given criterion
                hex                             :1,     // - convert a string to a hexadecimal number
                'import'                        :1,     // - patch a module's namespace into your own
                index                           :1,     // - find a substring within a string
                'int'                           :1,     // - get the integer portion of a number
                ioctl                           :1,     // - system-dependent device control system call
                'join'                          :1,     // - join a list into a string using a separator
                keys                            :1,     // - retrieve list of indices from a hash
                kill                            :1,     // - send a signal to a process or process group
                last                            :1,     // - exit a block prematurely
                lc                              :1,     // - return lower-case version of a string
                lcfirst                         :1,     // - return a string with just the next letter in lower case
                length                          :1,     // - return the number of bytes in a string
                'link'                          :1,     // - create a hard link in the filesystem
                listen                          :1,     // - register your socket as a server
                local                           : 2,    // - create a temporary value for a global variable (dynamic scoping)
                localtime                       :1,     // - convert UNIX time into record or string using local time
                lock                            :1,     // - get a thread lock on a variable, subroutine, or method
                'log'                           :1,     // - retrieve the natural logarithm for a number
                lstat                           :1,     // - stat a symbolic link
                m                               :null,  // - match a string with a regular expression pattern
                map                             :1,     // - apply a change to a list to get back a new list with the changes
                mkdir                           :1,     // - create a directory
                msgctl                          :1,     // - SysV IPC message control operations
                msgget                          :1,     // - get SysV IPC message queue
                msgrcv                          :1,     // - receive a SysV IPC message from a message queue
                msgsnd                          :1,     // - send a SysV IPC message to a message queue
                my                              : 2,    // - declare and assign a local variable (lexical scoping)
                'new'                           :1,     //
                next                            :1,     // - iterate a block prematurely
                no                              :1,     // - unimport some module symbols or semantics at compile time
                oct                             :1,     // - convert a string to an octal number
                open                            :1,     // - open a file, pipe, or descriptor
                opendir                         :1,     // - open a directory
                ord                             :1,     // - find a character's numeric representation
                our                             : 2,    // - declare and assign a package variable (lexical scoping)
                pack                            :1,     // - convert a list into a binary representation
                'package'                       :1,     // - declare a separate global namespace
                pipe                            :1,     // - open a pair of connected filehandles
                pop                             :1,     // - remove the last element from an array and return it
                pos                             :1,     // - find or set the offset for the last/next m//g search
                print                           :1,     // - output a list to a filehandle
                printf                          :1,     // - output a formatted list to a filehandle
                prototype                       :1,     // - get the prototype (if any) of a subroutine
                push                            :1,     // - append one or more elements to an array
                q                               :null,  // - singly quote a string
                qq                              :null,  // - doubly quote a string
                qr                              :null,  // - Compile pattern
                quotemeta                       :null,  // - quote regular expression magic characters
                qw                              :null,  // - quote a list of words
                qx                              :null,  // - backquote quote a string
                rand                            :1,     // - retrieve the next pseudorandom number
                read                            :1,     // - fixed-length buffered input from a filehandle
                readdir                         :1,     // - get a directory from a directory handle
                readline                        :1,     // - fetch a record from a file
                readlink                        :1,     // - determine where a symbolic link is pointing
                readpipe                        :1,     // - execute a system command and collect standard output
                recv                            :1,     // - receive a message over a Socket
                redo                            :1,     // - start this loop iteration over again
                ref                             :1,     // - find out the type of thing being referenced
                rename                          :1,     // - change a filename
                require                         :1,     // - load in external functions from a library at runtime
                reset                           :1,     // - clear all variables of a given name
                'return'                        :1,     // - get out of a function early
                reverse                         :1,     // - flip a string or a list
                rewinddir                       :1,     // - reset directory handle
                rindex                          :1,     // - right-to-left substring search
                rmdir                           :1,     // - remove a directory
                s                               :null,  // - replace a pattern with a string
                say                             :1,     // - print with newline
                scalar                          :1,     // - force a scalar context
                seek                            :1,     // - reposition file pointer for random-access I/O
                seekdir                         :1,     // - reposition directory pointer
                select                          :1,     // - reset default output or do I/O multiplexing
                semctl                          :1,     // - SysV semaphore control operations
                semget                          :1,     // - get set of SysV semaphores
                semop                           :1,     // - SysV semaphore operations
                send                            :1,     // - send a message over a socket
                setgrent                        :1,     // - prepare group file for use
                sethostent                      :1,     // - prepare hosts file for use
                setnetent                       :1,     // - prepare networks file for use
                setpgrp                         :1,     // - set the process group of a process
                setpriority                     :1,     // - set a process's nice value
                setprotoent                     :1,     // - prepare protocols file for use
                setpwent                        :1,     // - prepare passwd file for use
                setservent                      :1,     // - prepare services file for use
                setsockopt                      :1,     // - set some socket options
                shift                           :1,     // - remove the first element of an array, and return it
                shmctl                          :1,     // - SysV shared memory operations
                shmget                          :1,     // - get SysV shared memory segment identifier
                shmread                         :1,     // - read SysV shared memory
                shmwrite                        :1,     // - write SysV shared memory
                shutdown                        :1,     // - close down just half of a socket connection
                'sin'                           :1,     // - return the sine of a number
                sleep                           :1,     // - block for some number of seconds
                socket                          :1,     // - create a socket
                socketpair                      :1,     // - create a pair of sockets
                'sort'                          :1,     // - sort a list of values
                splice                          :1,     // - add or remove elements anywhere in an array
                'split'                         :1,     // - split up a string using a regexp delimiter
                sprintf                         :1,     // - formatted print into a string
                'sqrt'                          :1,     // - square root function
                srand                           :1,     // - seed the random number generator
                stat                            :1,     // - get a file's status information
                state                           :1,     // - declare and assign a state variable (persistent lexical scoping)
                study                           :1,     // - optimize input data for repeated searches
                'sub'                           :1,     // - declare a subroutine, possibly anonymously
                'substr'                        :1,     // - get or alter a portion of a string
                symlink                         :1,     // - create a symbolic link to a file
                syscall                         :1,     // - execute an arbitrary system call
                sysopen                         :1,     // - open a file, pipe, or descriptor
                sysread                         :1,     // - fixed-length unbuffered input from a filehandle
                sysseek                         :1,     // - position I/O pointer on handle used with sysread and syswrite
                system                          :1,     // - run a separate program
                syswrite                        :1,     // - fixed-length unbuffered output to a filehandle
                tell                            :1,     // - get current seekpointer on a filehandle
                telldir                         :1,     // - get current seekpointer on a directory handle
                tie                             :1,     // - bind a variable to an object class
                tied                            :1,     // - get a reference to the object underlying a tied variable
                time                            :1,     // - return number of seconds since 1970
                times                           :1,     // - return elapsed time for self and child processes
                tr                              :null,  // - transliterate a string
                truncate                        :1,     // - shorten a file
                uc                              :1,     // - return upper-case version of a string
                ucfirst                         :1,     // - return a string with just the next letter in upper case
                umask                           :1,     // - set file creation mode mask
                undef                           :1,     // - remove a variable or function definition
                unlink                          :1,     // - remove one link to a file
                unpack                          :1,     // - convert binary structure into normal perl variables
                unshift                         :1,     // - prepend more elements to the beginning of a list
                untie                           :1,     // - break a tie binding to a variable
                use                             :1,     // - load in a module at compile time
                utime                           :1,     // - set a file's last access and modify times
                values                          :1,     // - return a list of the values in a hash
                vec                             :1,     // - test or set particular bits in a string
                wait                            :1,     // - wait for any child process to die
                waitpid                         :1,     // - wait for a particular child process to die
                wantarray                       :1,     // - get void vs scalar vs list context of current subroutine call
                warn                            :1,     // - print debugging info
                when                            :1,     //
                write                           :1,     // - print a picture record
                y                               :null}; // - transliterate a string

        var RXstyle="string-2";
        var RXmodifiers=/[goseximacplud]/;              // NOTE: "m", "s", "y" and "tr" need to correct real modifiers for each regexp type

        function tokenChain(stream,state,chain,style,tail){     // NOTE: chain.length > 2 is not working now (it's for s[...][...]geos;)
                state.chain=null;                               //                                                          12   3tail
                state.style=null;
                state.tail=null;
                state.tokenize=function(stream,state){
                        var e=false,c,i=0;
                        while(c=stream.next()){
                                if(c===chain[i]&&!e){
                                        if(chain[++i]!==undefined){
                                                state.chain=chain[i];
                                                state.style=style;
                                                state.tail=tail;}
                                        else if(tail)
                                                stream.eatWhile(tail);
                                        state.tokenize=tokenPerl;
                                        return style;}
                                e=!e&&c=="\\";}
                        return style;};
                return state.tokenize(stream,state);}

        function tokenSOMETHING(stream,state,string){
                state.tokenize=function(stream,state){
                        if(stream.string==string)
                                state.tokenize=tokenPerl;
                        stream.skipToEnd();
                        return "string";};
                return state.tokenize(stream,state);}

        function tokenPerl(stream,state){
                if(stream.eatSpace())
                        return null;
                if(state.chain)
                        return tokenChain(stream,state,state.chain,state.style,state.tail);
                if(stream.match(/^(\-?((\d[\d_]*)?\.\d+(e[+-]?\d+)?|\d+\.\d*)|0x[\da-fA-F_]+|0b[01_]+|\d[\d_]*(e[+-]?\d+)?)/))
                        return 'number';
                if(stream.match(/^<<(?=[_a-zA-Z])/)){                  // NOTE: <<SOMETHING\n...\nSOMETHING\n
                        stream.eatWhile(/\w/);
                        return tokenSOMETHING(stream,state,stream.current().substr(2));}
                if(stream.sol()&&stream.match(/^\=item(?!\w)/)){// NOTE: \n=item...\n=cut\n
                        return tokenSOMETHING(stream,state,'=cut');}
                var ch=stream.next();
                if(ch=='"'||ch=="'"){                           // NOTE: ' or " or <<'SOMETHING'\n...\nSOMETHING\n or <<"SOMETHING"\n...\nSOMETHING\n
                        if(prefix(stream, 3)=="<<"+ch){
                                var p=stream.pos;
                                stream.eatWhile(/\w/);
                                var n=stream.current().substr(1);
                                if(n&&stream.eat(ch))
                                        return tokenSOMETHING(stream,state,n);
                                stream.pos=p;}
                        return tokenChain(stream,state,[ch],"string");}
                if(ch=="q"){
                        var c=look(stream, -2);
                        if(!(c&&/\w/.test(c))){
                                c=look(stream, 0);
                                if(c=="x"){
                                        c=look(stream, 1);
                                        if(c=="("){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                        if(c=="["){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                        if(c=="{"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                        if(c=="<"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}
                                        if(/[\^'"!~\/]/.test(c)){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[stream.eat(c)],RXstyle,RXmodifiers);}}
                                else if(c=="q"){
                                        c=look(stream, 1);
                                        if(c=="("){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[")"],"string");}
                                        if(c=="["){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["]"],"string");}
                                        if(c=="{"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["}"],"string");}
                                        if(c=="<"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[">"],"string");}
                                        if(/[\^'"!~\/]/.test(c)){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[stream.eat(c)],"string");}}
                                else if(c=="w"){
                                        c=look(stream, 1);
                                        if(c=="("){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[")"],"bracket");}
                                        if(c=="["){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["]"],"bracket");}
                                        if(c=="{"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["}"],"bracket");}
                                        if(c=="<"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[">"],"bracket");}
                                        if(/[\^'"!~\/]/.test(c)){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[stream.eat(c)],"bracket");}}
                                else if(c=="r"){
                                        c=look(stream, 1);
                                        if(c=="("){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                        if(c=="["){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                        if(c=="{"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                        if(c=="<"){
                                                eatSuffix(stream, 2);
                                                return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}
                                        if(/[\^'"!~\/]/.test(c)){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[stream.eat(c)],RXstyle,RXmodifiers);}}
                                else if(/[\^'"!~\/(\[{<]/.test(c)){
                                        if(c=="("){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[")"],"string");}
                                        if(c=="["){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,["]"],"string");}
                                        if(c=="{"){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,["}"],"string");}
                                        if(c=="<"){
                                                eatSuffix(stream, 1);
                                                return tokenChain(stream,state,[">"],"string");}
                                        if(/[\^'"!~\/]/.test(c)){
                                                return tokenChain(stream,state,[stream.eat(c)],"string");}}}}
                if(ch=="m"){
                        var c=look(stream, -2);
                        if(!(c&&/\w/.test(c))){
                                c=stream.eat(/[(\[{<\^'"!~\/]/);
                                if(c){
                                        if(/[\^'"!~\/]/.test(c)){
                                                return tokenChain(stream,state,[c],RXstyle,RXmodifiers);}
                                        if(c=="("){
                                                return tokenChain(stream,state,[")"],RXstyle,RXmodifiers);}
                                        if(c=="["){
                                                return tokenChain(stream,state,["]"],RXstyle,RXmodifiers);}
                                        if(c=="{"){
                                                return tokenChain(stream,state,["}"],RXstyle,RXmodifiers);}
                                        if(c=="<"){
                                                return tokenChain(stream,state,[">"],RXstyle,RXmodifiers);}}}}
                if(ch=="s"){
                        var c=/[\/>\]})\w]/.test(look(stream, -2));
                        if(!c){
                                c=stream.eat(/[(\[{<\^'"!~\/]/);
                                if(c){
                                        if(c=="[")
                                                return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                        if(c=="{")
                                                return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                        if(c=="<")
                                                return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                        if(c=="(")
                                                return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                        return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}
                if(ch=="y"){
                        var c=/[\/>\]})\w]/.test(look(stream, -2));
                        if(!c){
                                c=stream.eat(/[(\[{<\^'"!~\/]/);
                                if(c){
                                        if(c=="[")
                                                return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                        if(c=="{")
                                                return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                        if(c=="<")
                                                return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                        if(c=="(")
                                                return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                        return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}
                if(ch=="t"){
                        var c=/[\/>\]})\w]/.test(look(stream, -2));
                        if(!c){
                                c=stream.eat("r");if(c){
                                c=stream.eat(/[(\[{<\^'"!~\/]/);
                                if(c){
                                        if(c=="[")
                                                return tokenChain(stream,state,["]","]"],RXstyle,RXmodifiers);
                                        if(c=="{")
                                                return tokenChain(stream,state,["}","}"],RXstyle,RXmodifiers);
                                        if(c=="<")
                                                return tokenChain(stream,state,[">",">"],RXstyle,RXmodifiers);
                                        if(c=="(")
                                                return tokenChain(stream,state,[")",")"],RXstyle,RXmodifiers);
                                        return tokenChain(stream,state,[c,c],RXstyle,RXmodifiers);}}}}
                if(ch=="`"){
                        return tokenChain(stream,state,[ch],"variable-2");}
                if(ch=="/"){
                        if(!/~\s*$/.test(prefix(stream)))
                                return "operator";
                        else
                                return tokenChain(stream,state,[ch],RXstyle,RXmodifiers);}
                if(ch=="$"){
                        var p=stream.pos;
                        if(stream.eatWhile(/\d/)||stream.eat("{")&&stream.eatWhile(/\d/)&&stream.eat("}"))
                                return "variable-2";
                        else
                                stream.pos=p;}
                if(/[$@%]/.test(ch)){
                        var p=stream.pos;
                        if(stream.eat("^")&&stream.eat(/[A-Z]/)||!/[@$%&]/.test(look(stream, -2))&&stream.eat(/[=|\\\-#?@;:&`~\^!\[\]*'"$+.,\/<>()]/)){
                                var c=stream.current();
                                if(PERL[c])
                                        return "variable-2";}
                        stream.pos=p;}
                if(/[$@%&]/.test(ch)){
                        if(stream.eatWhile(/[\w$]/)||stream.eat("{")&&stream.eatWhile(/[\w$]/)&&stream.eat("}")){
                                var c=stream.current();
                                if(PERL[c])
                                        return "variable-2";
                                else
                                        return "variable";}}
                if(ch=="#"){
                        if(look(stream, -2)!="$"){
                                stream.skipToEnd();
                                return "comment";}}
                if(/[:+\-\^*$&%@=<>!?|\/~\.]/.test(ch)){
                        var p=stream.pos;
                        stream.eatWhile(/[:+\-\^*$&%@=<>!?|\/~\.]/);
                        if(PERL[stream.current()])
                                return "operator";
                        else
                                stream.pos=p;}
                if(ch=="_"){
                        if(stream.pos==1){
                                if(suffix(stream, 6)=="_END__"){
                                        return tokenChain(stream,state,['\0'],"comment");}
                                else if(suffix(stream, 7)=="_DATA__"){
                                        return tokenChain(stream,state,['\0'],"variable-2");}
                                else if(suffix(stream, 7)=="_C__"){
                                        return tokenChain(stream,state,['\0'],"string");}}}
                if(/\w/.test(ch)){
                        var p=stream.pos;
                        if(look(stream, -2)=="{"&&(look(stream, 0)=="}"||stream.eatWhile(/\w/)&&look(stream, 0)=="}"))
                                return "string";
                        else
                                stream.pos=p;}
                if(/[A-Z]/.test(ch)){
                        var l=look(stream, -2);
                        var p=stream.pos;
                        stream.eatWhile(/[A-Z_]/);
                        if(/[\da-z]/.test(look(stream, 0))){
                                stream.pos=p;}
                        else{
                                var c=PERL[stream.current()];
                                if(!c)
                                        return "meta";
                                if(c[1])
                                        c=c[0];
                                if(l!=":"){
                                        if(c==1)
                                                return "keyword";
                                        else if(c==2)
                                                return "def";
                                        else if(c==3)
                                                return "atom";
                                        else if(c==4)
                                                return "operator";
                                        else if(c==5)
                                                return "variable-2";
                                        else
                                                return "meta";}
                                else
                                        return "meta";}}
                if(/[a-zA-Z_]/.test(ch)){
                        var l=look(stream, -2);
                        stream.eatWhile(/\w/);
                        var c=PERL[stream.current()];
                        if(!c)
                                return "meta";
                        if(c[1])
                                c=c[0];
                        if(l!=":"){
                                if(c==1)
                                        return "keyword";
                                else if(c==2)
                                        return "def";
                                else if(c==3)
                                        return "atom";
                                else if(c==4)
                                        return "operator";
                                else if(c==5)
                                        return "variable-2";
                                else
                                        return "meta";}
                        else
                                return "meta";}
                return null;}

        return {
            startState: function() {
                return {
                    tokenize: tokenPerl,
                    chain: null,
                    style: null,
                    tail: null
                };
            },
            token: function(stream, state) {
                return (state.tokenize || tokenPerl)(stream, state);
            },
            lineComment: '#'
        };
});

CodeMirror.registerHelper("wordChars", "perl", /[\w$]/);

CodeMirror.defineMIME("text/x-perl", "perl");

// it's like "peek", but need for look-ahead or look-behind if index < 0
function look(stream, c){
  return stream.string.charAt(stream.pos+(c||0));
}

// return a part of prefix of current stream from current position
function prefix(stream, c){
  if(c){
    var x=stream.pos-c;
    return stream.string.substr((x>=0?x:0),c);}
  else{
    return stream.string.substr(0,stream.pos-1);
  }
}

// return a part of suffix of current stream from current position
function suffix(stream, c){
  var y=stream.string.length;
  var x=y-stream.pos+1;
  return stream.string.substr(stream.pos,(c&&c<y?c:x));
}

// eating and vomiting a part of stream from current position
function eatSuffix(stream, c){
  var x=stream.pos+c;
  var y;
  if(x<=0)
    stream.pos=0;
  else if(x>=(y=stream.string.length-1))
    stream.pos=y;
  else
    stream.pos=x;
}

});


/***/ }),

/***/ "9071":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("0967");

// CONCATENATED MODULE: ./node_modules/quasar/icon-set/material-icons.js
/* harmony default export */ var material_icons = ({
  name: 'material-icons',
  type: {
    positive: 'check_circle',
    negative: 'warning',
    info: 'info',
    warning: 'priority_high'
  },
  arrow: {
    up: 'arrow_upward',
    right: 'arrow_forward',
    down: 'arrow_downward',
    left: 'arrow_back',
    dropdown: 'arrow_drop_down'
  },
  chevron: {
    left: 'chevron_left',
    right: 'chevron_right'
  },
  colorPicker: {
    spectrum: 'gradient',
    tune: 'tune',
    palette: 'style'
  },
  pullToRefresh: {
    icon: 'refresh'
  },
  carousel: {
    left: 'chevron_left',
    right: 'chevron_right',
    up: 'keyboard_arrow_up',
    down: 'keyboard_arrow_down',
    navigationIcon: 'lens'
  },
  chip: {
    remove: 'cancel',
    selected: 'check'
  },
  datetime: {
    arrowLeft: 'chevron_left',
    arrowRight: 'chevron_right',
    now: 'access_time',
    today: 'today'
  },
  editor: {
    bold: 'format_bold',
    italic: 'format_italic',
    strikethrough: 'strikethrough_s',
    underline: 'format_underlined',
    unorderedList: 'format_list_bulleted',
    orderedList: 'format_list_numbered',
    subscript: 'vertical_align_bottom',
    superscript: 'vertical_align_top',
    hyperlink: 'link',
    toggleFullscreen: 'fullscreen',
    quote: 'format_quote',
    left: 'format_align_left',
    center: 'format_align_center',
    right: 'format_align_right',
    justify: 'format_align_justify',
    print: 'print',
    outdent: 'format_indent_decrease',
    indent: 'format_indent_increase',
    removeFormat: 'format_clear',
    formatting: 'text_format',
    fontSize: 'format_size',
    align: 'format_align_left',
    hr: 'remove',
    undo: 'undo',
    redo: 'redo',
    heading: 'format_size',
    code: 'code',
    size: 'format_size',
    font: 'font_download',
    viewSource: 'code'
  },
  expansionItem: {
    icon: 'keyboard_arrow_down',
    denseIcon: 'arrow_drop_down'
  },
  fab: {
    icon: 'add',
    activeIcon: 'close'
  },
  field: {
    clear: 'cancel',
    error: 'error'
  },
  pagination: {
    first: 'first_page',
    prev: 'keyboard_arrow_left',
    next: 'keyboard_arrow_right',
    last: 'last_page'
  },
  rating: {
    icon: 'grade'
  },
  stepper: {
    done: 'check',
    active: 'edit',
    error: 'warning'
  },
  tabs: {
    left: 'chevron_left',
    right: 'chevron_right',
    up: 'keyboard_arrow_up',
    down: 'keyboard_arrow_down'
  },
  table: {
    arrowUp: 'arrow_upward',
    warning: 'warning',
    firstPage: 'first_page',
    prevPage: 'chevron_left',
    nextPage: 'chevron_right',
    lastPage: 'last_page'
  },
  tree: {
    icon: 'play_arrow'
  },
  uploader: {
    done: 'done',
    clear: 'clear',
    add: 'add_box',
    upload: 'cloud_upload',
    removeQueue: 'clear_all',
    removeUploaded: 'done_all'
  }
});
// CONCATENATED MODULE: ./node_modules/quasar/src/icon-set.js





/* harmony default export */ var icon_set = __webpack_exports__["a"] = ({
  install: function install($q, queues, iconSet) {
    var _this = this;
    var initialSet = iconSet || material_icons;
    this.set = function (setObject, ssrContext) {
      var def = Object(objectSpread2["a" /* default */])({}, setObject);
      if (Platform["e" /* isSSR */] === true) {
        if (ssrContext === void 0) {
          console.error('SSR ERROR: second param required: Quasar.iconSet.set(iconSet, ssrContext)');
          return;
        }
        def.set = ssrContext.$q.iconSet.set;
        ssrContext.$q.iconSet = def;
      } else {
        def.set = _this.set;
        $q.iconSet = def;
      }
    };
    if (Platform["e" /* isSSR */] === true) {
      queues.server.push(function (q, ctx) {
        q.iconSet = {};
        q.iconSet.set = function (setObject) {
          _this.set(setObject, ctx.ssr);
        };
        q.iconSet.set(initialSet);
      });
    } else {
      external_commonjs_vue_commonjs2_vue_root_Vue_default.a.util.defineReactive($q, 'iconMapFn', void 0);
      external_commonjs_vue_commonjs2_vue_root_Vue_default.a.util.defineReactive($q, 'iconSet', {});
      this.set(initialSet);
    }
  }
});

/***/ }),

/***/ "907a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var lengthOfArrayLike = __webpack_require__("07fa");
var toIntegerOrInfinity = __webpack_require__("5926");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.at` method
// https://github.com/tc39/proposal-relative-indexing-method
exportTypedArrayMethod('at', function at(index) {
  var O = aTypedArray(this);
  var len = lengthOfArrayLike(O);
  var relativeIndex = toIntegerOrInfinity(index);
  var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
  return (k < 0 || k >= len) ? undefined : O[k];
});


/***/ }),

/***/ "90d8":
/***/ (function(module, exports, __webpack_require__) {

var call = __webpack_require__("c65b");
var hasOwn = __webpack_require__("1a2d");
var isPrototypeOf = __webpack_require__("3a9b");
var regExpFlags = __webpack_require__("ad6d");

var RegExpPrototype = RegExp.prototype;

module.exports = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R)
    ? call(regExpFlags, R) : flags;
};


/***/ }),

/***/ "90e3":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "9112":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "9152":
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "9263":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */
/* eslint-disable regexp/no-useless-quantifier -- testing */
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var toString = __webpack_require__("577e");
var regexpFlags = __webpack_require__("ad6d");
var stickyHelpers = __webpack_require__("9f7f");
var shared = __webpack_require__("5692");
var create = __webpack_require__("7c73");
var getInternalState = __webpack_require__("69f3").get;
var UNSUPPORTED_DOT_ALL = __webpack_require__("fce3");
var UNSUPPORTED_NCG = __webpack_require__("107c");

var nativeReplace = shared('native-string-replace', String.prototype.replace);
var nativeExec = RegExp.prototype.exec;
var patchedExec = nativeExec;
var charAt = uncurryThis(''.charAt);
var indexOf = uncurryThis(''.indexOf);
var replace = uncurryThis(''.replace);
var stringSlice = uncurryThis(''.slice);

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  call(nativeExec, re1, 'a');
  call(nativeExec, re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;

if (PATCH) {
  patchedExec = function exec(string) {
    var re = this;
    var state = getInternalState(re);
    var str = toString(string);
    var raw = state.raw;
    var result, reCopy, lastIndex, match, i, object, group;

    if (raw) {
      raw.lastIndex = re.lastIndex;
      result = call(patchedExec, raw, str);
      re.lastIndex = raw.lastIndex;
      return result;
    }

    var groups = state.groups;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = call(regexpFlags, re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = replace(flags, 'y', '');
      if (indexOf(flags, 'g') === -1) {
        flags += 'g';
      }

      strCopy = stringSlice(str, re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = call(nativeExec, sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = stringSlice(match.input, charsAdded);
        match[0] = stringSlice(match[0], charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn't work for /(.?)?/
      call(nativeReplace, match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    if (match && groups) {
      match.groups = object = create(null);
      for (i = 0; i < groups.length; i++) {
        group = groups[i];
        object[group[0]] = match[group[1]];
      }
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "93dc":
/***/ (function(module, exports) {

/**
 * Quasar runtime for auto-importing
 * components or directives.
 *
 * Warning! This file does NOT get transpiled by Babel
 * but is included into the UI code.
 *
 * @param {component} Vue Component object
 * @param {type}      One of 'components' or 'directives'
 * @param {items}     Object containing components or directives
 */
module.exports = function qInstall (component, type, items) {
  var opt

  if (typeof component.exports === 'function') {
    opt = component.exports.extendOptions
    opt[type] = component.exports.options[type]
  }
  else {
    opt = component.options
  }

  if (opt[type] === void 0) {
    opt[type] = items
  }
  else {
    var target = opt[type]
    for (var i in items) {
      if (target[i] === void 0) {
        target[i] = items[i]
      }
    }
  }
}


/***/ }),

/***/ "944a":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");
var defineWellKnownSymbol = __webpack_require__("e065");
var setToStringTag = __webpack_require__("d44e");

// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag(getBuiltIn('Symbol'), 'Symbol');


/***/ }),

/***/ "94ca":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var isCallable = __webpack_require__("1626");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "9510":
/***/ (function(module, exports) {

/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function lookahead(re) {
  return concat('(?=', re, ')');
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}

/*
Language: Python
Description: Python is an interpreted, object-oriented, high-level programming language with dynamic semantics.
Website: https://www.python.org
Category: common
*/

function python(hljs) {
  const RESERVED_WORDS = [
    'and',
    'as',
    'assert',
    'async',
    'await',
    'break',
    'class',
    'continue',
    'def',
    'del',
    'elif',
    'else',
    'except',
    'finally',
    'for',
    'from',
    'global',
    'if',
    'import',
    'in',
    'is',
    'lambda',
    'nonlocal|10',
    'not',
    'or',
    'pass',
    'raise',
    'return',
    'try',
    'while',
    'with',
    'yield'
  ];

  const BUILT_INS = [
    '__import__',
    'abs',
    'all',
    'any',
    'ascii',
    'bin',
    'bool',
    'breakpoint',
    'bytearray',
    'bytes',
    'callable',
    'chr',
    'classmethod',
    'compile',
    'complex',
    'delattr',
    'dict',
    'dir',
    'divmod',
    'enumerate',
    'eval',
    'exec',
    'filter',
    'float',
    'format',
    'frozenset',
    'getattr',
    'globals',
    'hasattr',
    'hash',
    'help',
    'hex',
    'id',
    'input',
    'int',
    'isinstance',
    'issubclass',
    'iter',
    'len',
    'list',
    'locals',
    'map',
    'max',
    'memoryview',
    'min',
    'next',
    'object',
    'oct',
    'open',
    'ord',
    'pow',
    'print',
    'property',
    'range',
    'repr',
    'reversed',
    'round',
    'set',
    'setattr',
    'slice',
    'sorted',
    'staticmethod',
    'str',
    'sum',
    'super',
    'tuple',
    'type',
    'vars',
    'zip'
  ];

  const LITERALS = [
    '__debug__',
    'Ellipsis',
    'False',
    'None',
    'NotImplemented',
    'True'
  ];

  // https://docs.python.org/3/library/typing.html
  // TODO: Could these be supplemented by a CamelCase matcher in certain
  // contexts, leaving these remaining only for relevance hinting?
  const TYPES = [
    "Any",
    "Callable",
    "Coroutine",
    "Dict",
    "List",
    "Literal",
    "Generic",
    "Optional",
    "Sequence",
    "Set",
    "Tuple",
    "Type",
    "Union"
  ];

  const KEYWORDS = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: RESERVED_WORDS,
    built_in: BUILT_INS,
    literal: LITERALS,
    type: TYPES
  };

  const PROMPT = {
    className: 'meta',
    begin: /^(>>>|\.\.\.) /
  };

  const SUBST = {
    className: 'subst',
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS,
    illegal: /#/
  };

  const LITERAL_BRACKET = {
    begin: /\{\{/,
    relevance: 0
  };

  const STRING = {
    className: 'string',
    contains: [ hljs.BACKSLASH_ESCAPE ],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          PROMPT,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          LITERAL_BRACKET,
          SUBST
        ]
      },
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE
    ]
  };

  // https://docs.python.org/3.9/reference/lexical_analysis.html#numeric-literals
  const digitpart = '[0-9](_?[0-9])*';
  const pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`;
  const NUMBER = {
    className: 'number',
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?\\b`
      },
      {
        begin: `(${pointfloat})[jJ]?`
      },

      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: '\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?\\b'
      },
      {
        begin: '\\b0[bB](_?[01])+[lL]?\\b'
      },
      {
        begin: '\\b0[oO](_?[0-7])+[lL]?\\b'
      },
      {
        begin: '\\b0[xX](_?[0-9a-fA-F])+[lL]?\\b'
      },

      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${digitpart})[jJ]\\b`
      }
    ]
  };
  const COMMENT_TYPE = {
    className: "comment",
    begin: lookahead(/# type:/),
    end: /$/,
    keywords: KEYWORDS,
    contains: [
      { // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: true
      }
    ]
  };
  const PARAMS = {
    className: 'params',
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: true
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS,
        contains: [
          'self',
          PROMPT,
          NUMBER,
          STRING,
          hljs.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  SUBST.contains = [
    STRING,
    NUMBER,
    PROMPT
  ];

  return {
    name: 'Python',
    aliases: [
      'py',
      'gyp',
      'ipython'
    ],
    keywords: KEYWORDS,
    illegal: /(<\/|->|\?)|=>/,
    contains: [
      PROMPT,
      NUMBER,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      STRING,
      COMMENT_TYPE,
      hljs.HASH_COMMENT_MODE,
      {
        variants: [
          {
            className: 'function',
            beginKeywords: 'def'
          },
          {
            className: 'class',
            beginKeywords: 'class'
          }
        ],
        end: /:/,
        illegal: /[${=;\n,]/,
        contains: [
          hljs.UNDERSCORE_TITLE_MODE,
          PARAMS,
          {
            begin: /->/,
            endsWithParent: true,
            keywords: KEYWORDS
          }
        ]
      },
      {
        className: 'meta',
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          NUMBER,
          PARAMS,
          STRING
        ]
      }
    ]
  };
}

module.exports = python;


/***/ }),

/***/ "9564":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _icon_QIcon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0016");
/* harmony import */ var _mixins_checkbox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("85fc");



/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_0___default.a.extend({
  name: 'QToggle',
  mixins: [_mixins_checkbox_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]],
  props: {
    icon: String,
    iconColor: String
  },
  computed: {
    computedIcon: function computedIcon() {
      return (this.isTrue === true ? this.checkedIcon : this.isIndeterminate === true ? this.indeterminateIcon : this.uncheckedIcon) || this.icon;
    },
    computedIconColor: function computedIconColor() {
      if (this.isTrue === true) {
        return this.iconColor;
      }
    }
  },
  methods: {
    __getInner: function __getInner(h) {
      return [h('div', {
        staticClass: 'q-toggle__track'
      }), h('div', {
        staticClass: 'q-toggle__thumb absolute flex flex-center no-wrap'
      }, this.computedIcon !== void 0 ? [h(_icon_QIcon_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"], {
        props: {
          name: this.computedIcon,
          color: this.computedIconColor
        }
      })] : void 0)];
    }
  },
  created: function created() {
    this.type = 'toggle';
  }
}));

/***/ }),

/***/ "9603":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "9612":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ install; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ index_esm_uuid; });

// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/regex.js
/* harmony default export */ var regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/validate.js


function validate(uuid) {
  return typeof uuid === 'string' && regex.test(uuid);
}

/* harmony default export */ var esm_browser_validate = (validate);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var stringify_i = 0; stringify_i < 256; ++stringify_i) {
  byteToHex.push((stringify_i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!esm_browser_validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ var esm_browser_stringify = (stringify);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v1.js

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || rng)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || esm_browser_stringify(b);
}

/* harmony default export */ var esm_browser_v1 = (v1);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/parse.js


function parse(uuid) {
  if (!esm_browser_validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ var esm_browser_parse = (parse);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v35.js



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ var v35 = (function (name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = esm_browser_parse(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return esm_browser_stringify(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
});
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/md5.js
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ var esm_browser_md5 = (md5);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v3.js


var v3 = v35('v3', 0x30, esm_browser_md5);
/* harmony default export */ var esm_browser_v3 = (v3);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return esm_browser_stringify(rnds);
}

/* harmony default export */ var esm_browser_v4 = (v4);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/sha1.js
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ var esm_browser_sha1 = (sha1);
// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v5.js


var v5 = v35('v5', 0x50, esm_browser_sha1);
/* harmony default export */ var esm_browser_v5 = (v5);
// CONCATENATED MODULE: ./node_modules/vue-uuid/dist/index.esm.js


/**
 * @typedef {Object} UUID
 * @property {typeof v1} v1
 * @property {typeof v3} v3
 * @property {typeof v4} v4
 * @property {typeof v5} v5
 */

/**
 * An object with uuid's v1, v3, v4 and v5 functions.
 * @type {UUID}
 */

var index_esm_uuid = {
  v1: esm_browser_v1,
  v3: esm_browser_v3,
  v4: esm_browser_v4,
  v5: esm_browser_v5
};
/**
 * Installs UUID on Vue instance. It creates a property on Vue instance to
 * expose an object with uuid's v1, v3, v4 and v5 functions.
 * @example ```js
 * import Vue from 'vue';
 * import VueUUID from 'vue-uuid';
 *
 * Vue.use(VueUUID);
 *
 * new Vue({
 *   mounted () {
 *     console.log(this.$uuid.v1());
 *   }
 * });
 * ```
 * @param {import('vue').default} Vue Vue constructor.
 */

function install(Vue) {
  Vue.prototype.$uuid = index_esm_uuid;
}




/***/ }),

/***/ "9861":
/***/ (function(module, exports, __webpack_require__) {

// TODO: Remove this module from `core-js@4` since it's replaced to module below
__webpack_require__("5352");


/***/ }),

/***/ "986a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $findLast = __webpack_require__("a258").findLast;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findLast` method
// https://github.com/tc39/proposal-array-find-from-last
exportTypedArrayMethod('findLast', function findLast(predicate /* , thisArg */) {
  return $findLast(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "98af":
/***/ (function(module, exports) {

/*
Language: C#
Author: Jason Diamond <jason@diamond.name>
Contributor: Nicolas LLOBERA <nllobera@gmail.com>, Pieter Vantorre <pietervantorre@gmail.com>, David Pine <david.pine@microsoft.com>
Website: https://docs.microsoft.com/en-us/dotnet/csharp/
Category: common
*/

/** @type LanguageFn */
function csharp(hljs) {
  const BUILT_IN_KEYWORDS = [
    'bool',
    'byte',
    'char',
    'decimal',
    'delegate',
    'double',
    'dynamic',
    'enum',
    'float',
    'int',
    'long',
    'nint',
    'nuint',
    'object',
    'sbyte',
    'short',
    'string',
    'ulong',
    'uint',
    'ushort'
  ];
  const FUNCTION_MODIFIERS = [
    'public',
    'private',
    'protected',
    'static',
    'internal',
    'protected',
    'abstract',
    'async',
    'extern',
    'override',
    'unsafe',
    'virtual',
    'new',
    'sealed',
    'partial'
  ];
  const LITERAL_KEYWORDS = [
    'default',
    'false',
    'null',
    'true'
  ];
  const NORMAL_KEYWORDS = [
    'abstract',
    'as',
    'base',
    'break',
    'case',
    'class',
    'const',
    'continue',
    'do',
    'else',
    'event',
    'explicit',
    'extern',
    'finally',
    'fixed',
    'for',
    'foreach',
    'goto',
    'if',
    'implicit',
    'in',
    'interface',
    'internal',
    'is',
    'lock',
    'namespace',
    'new',
    'operator',
    'out',
    'override',
    'params',
    'private',
    'protected',
    'public',
    'readonly',
    'record',
    'ref',
    'return',
    'sealed',
    'sizeof',
    'stackalloc',
    'static',
    'struct',
    'switch',
    'this',
    'throw',
    'try',
    'typeof',
    'unchecked',
    'unsafe',
    'using',
    'virtual',
    'void',
    'volatile',
    'while'
  ];
  const CONTEXTUAL_KEYWORDS = [
    'add',
    'alias',
    'and',
    'ascending',
    'async',
    'await',
    'by',
    'descending',
    'equals',
    'from',
    'get',
    'global',
    'group',
    'init',
    'into',
    'join',
    'let',
    'nameof',
    'not',
    'notnull',
    'on',
    'or',
    'orderby',
    'partial',
    'remove',
    'select',
    'set',
    'unmanaged',
    'value|0',
    'var',
    'when',
    'where',
    'with',
    'yield'
  ];

  const KEYWORDS = {
    keyword: NORMAL_KEYWORDS.concat(CONTEXTUAL_KEYWORDS),
    built_in: BUILT_IN_KEYWORDS,
    literal: LITERAL_KEYWORDS
  };
  const TITLE_MODE = hljs.inherit(hljs.TITLE_MODE, {
    begin: '[a-zA-Z](\\.?\\w)*'
  });
  const NUMBERS = {
    className: 'number',
    variants: [
      {
        begin: '\\b(0b[01\']+)'
      },
      {
        begin: '(-?)\\b([\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)(u|U|l|L|ul|UL|f|F|b|B)'
      },
      {
        begin: '(-?)(\\b0[xX][a-fA-F0-9\']+|(\\b[\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)([eE][-+]?[\\d\']+)?)'
      }
    ],
    relevance: 0
  };
  const VERBATIM_STRING = {
    className: 'string',
    begin: '@"',
    end: '"',
    contains: [
      {
        begin: '""'
      }
    ]
  };
  const VERBATIM_STRING_NO_LF = hljs.inherit(VERBATIM_STRING, {
    illegal: /\n/
  });
  const SUBST = {
    className: 'subst',
    begin: /\{/,
    end: /\}/,
    keywords: KEYWORDS
  };
  const SUBST_NO_LF = hljs.inherit(SUBST, {
    illegal: /\n/
  });
  const INTERPOLATED_STRING = {
    className: 'string',
    begin: /\$"/,
    end: '"',
    illegal: /\n/,
    contains: [
      {
        begin: /\{\{/
      },
      {
        begin: /\}\}/
      },
      hljs.BACKSLASH_ESCAPE,
      SUBST_NO_LF
    ]
  };
  const INTERPOLATED_VERBATIM_STRING = {
    className: 'string',
    begin: /\$@"/,
    end: '"',
    contains: [
      {
        begin: /\{\{/
      },
      {
        begin: /\}\}/
      },
      {
        begin: '""'
      },
      SUBST
    ]
  };
  const INTERPOLATED_VERBATIM_STRING_NO_LF = hljs.inherit(INTERPOLATED_VERBATIM_STRING, {
    illegal: /\n/,
    contains: [
      {
        begin: /\{\{/
      },
      {
        begin: /\}\}/
      },
      {
        begin: '""'
      },
      SUBST_NO_LF
    ]
  });
  SUBST.contains = [
    INTERPOLATED_VERBATIM_STRING,
    INTERPOLATED_STRING,
    VERBATIM_STRING,
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    NUMBERS,
    hljs.C_BLOCK_COMMENT_MODE
  ];
  SUBST_NO_LF.contains = [
    INTERPOLATED_VERBATIM_STRING_NO_LF,
    INTERPOLATED_STRING,
    VERBATIM_STRING_NO_LF,
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE,
    NUMBERS,
    hljs.inherit(hljs.C_BLOCK_COMMENT_MODE, {
      illegal: /\n/
    })
  ];
  const STRING = {
    variants: [
      INTERPOLATED_VERBATIM_STRING,
      INTERPOLATED_STRING,
      VERBATIM_STRING,
      hljs.APOS_STRING_MODE,
      hljs.QUOTE_STRING_MODE
    ]
  };

  const GENERIC_MODIFIER = {
    begin: "<",
    end: ">",
    contains: [
      {
        beginKeywords: "in out"
      },
      TITLE_MODE
    ]
  };
  const TYPE_IDENT_RE = hljs.IDENT_RE + '(<' + hljs.IDENT_RE + '(\\s*,\\s*' + hljs.IDENT_RE + ')*>)?(\\[\\])?';
  const AT_IDENTIFIER = {
    // prevents expressions like `@class` from incorrect flagging
    // `class` as a keyword
    begin: "@" + hljs.IDENT_RE,
    relevance: 0
  };

  return {
    name: 'C#',
    aliases: [
      'cs',
      'c#'
    ],
    keywords: KEYWORDS,
    illegal: /::/,
    contains: [
      hljs.COMMENT(
        '///',
        '$',
        {
          returnBegin: true,
          contains: [
            {
              className: 'doctag',
              variants: [
                {
                  begin: '///',
                  relevance: 0
                },
                {
                  begin: '<!--|-->'
                },
                {
                  begin: '</?',
                  end: '>'
                }
              ]
            }
          ]
        }
      ),
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      {
        className: 'meta',
        begin: '#',
        end: '$',
        keywords: {
          'meta-keyword': 'if else elif endif define undef warning error line region endregion pragma checksum'
        }
      },
      STRING,
      NUMBERS,
      {
        beginKeywords: 'class interface',
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          {
            beginKeywords: "where class"
          },
          TITLE_MODE,
          GENERIC_MODIFIER,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: 'namespace',
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          TITLE_MODE,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: 'record',
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          TITLE_MODE,
          GENERIC_MODIFIER,
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // [Attributes("")]
        className: 'meta',
        begin: '^\\s*\\[',
        excludeBegin: true,
        end: '\\]',
        excludeEnd: true,
        contains: [
          {
            className: 'meta-string',
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: 'new return throw await else',
        relevance: 0
      },
      {
        className: 'function',
        begin: '(' + TYPE_IDENT_RE + '\\s+)+' + hljs.IDENT_RE + '\\s*(<.+>\\s*)?\\(',
        returnBegin: true,
        end: /\s*[{;=]/,
        excludeEnd: true,
        keywords: KEYWORDS,
        contains: [
          // prevents these from being highlighted `title`
          {
            beginKeywords: FUNCTION_MODIFIERS.join(" "),
            relevance: 0
          },
          {
            begin: hljs.IDENT_RE + '\\s*(<.+>\\s*)?\\(',
            returnBegin: true,
            contains: [
              hljs.TITLE_MODE,
              GENERIC_MODIFIER
            ],
            relevance: 0
          },
          {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS,
            relevance: 0,
            contains: [
              STRING,
              NUMBERS,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE
        ]
      },
      AT_IDENTIFIER
    ]
  };
}

module.exports = csharp;


/***/ }),

/***/ "98db":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && Object({"NODE_ENV":"production","VUE_APP_I18N_LOCALE":"en","VUE_APP_I18N_FALLBACK_LOCALE":"en","VUE_APP_CODE_BLOCK_TIMEOUT":"150","VUE_APP_CODE_BLOCK_MAX_TIMEOUT":"800","VUE_APP_BLOCKLY_TIMEOUT":"200","VUE_APP_CONTINOUS_COMPILE_TIMEOUT":"800","BASE_URL":"/"}) && Object({"NODE_ENV":"production","VUE_APP_I18N_LOCALE":"en","VUE_APP_I18N_FALLBACK_LOCALE":"en","VUE_APP_CODE_BLOCK_TIMEOUT":"150","VUE_APP_CODE_BLOCK_MAX_TIMEOUT":"800","VUE_APP_BLOCKLY_TIMEOUT":"200","VUE_APP_CONTINOUS_COMPILE_TIMEOUT":"800","BASE_URL":"/"})["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362"), __webpack_require__("c8ba")))

/***/ }),

/***/ "99af":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var isArray = __webpack_require__("e8b5");
var isObject = __webpack_require__("861d");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");
var doesNotExceedSafeInteger = __webpack_require__("3511");
var createProperty = __webpack_require__("8418");
var arraySpeciesCreate = __webpack_require__("65f0");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "99b6":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("b64b");
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("caad");
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("2532");
/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("99af");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3__);




var alignMap = {
    left: 'start',
    center: 'center',
    right: 'end',
    between: 'between',
    around: 'around',
    evenly: 'evenly',
    stretch: 'stretch'
  },
  alignValues = Object.keys(alignMap);
/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    align: {
      type: String,
      validator: function validator(v) {
        return alignValues.includes(v);
      }
    }
  },
  computed: {
    alignClass: function alignClass() {
      var align = this.align === void 0 ? this.vertical === true ? 'stretch' : 'left' : this.align;
      return "".concat(this.vertical === true ? 'items' : 'justify', "-").concat(alignMap[align]);
    }
  }
});

/***/ }),

/***/ "99f1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return KnownBlockTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return CodeOutputTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CodeExpansionType; });
var KnownBlockTypes;
(function (KnownBlockTypes) {
  KnownBlockTypes["PLAYGROUND"] = "PLAYGROUND";
  KnownBlockTypes["TEXT"] = "TEXT";
  KnownBlockTypes["BLOCKHIDDEN"] = "BLOCK-hidden";
  KnownBlockTypes["BLOCKSTATIC"] = "BLOCK-static";
  KnownBlockTypes["BLOCK"] = "BLOCK";
  KnownBlockTypes["BLOCKLY"] = "BLOCKLY";
  KnownBlockTypes["REPL"] = "REPL";
  KnownBlockTypes["DATA"] = "DATA";
})(KnownBlockTypes || (KnownBlockTypes = {}));
var CodeOutputTypes;
(function (CodeOutputTypes) {
  CodeOutputTypes["AUTO"] = "auto";
  CodeOutputTypes["TEXT"] = "text";
  CodeOutputTypes["JSON"] = "json";
  CodeOutputTypes["DATA"] = "data";
  CodeOutputTypes["MAGIC"] = "magic";
})(CodeOutputTypes || (CodeOutputTypes = {}));
var CodeExpansionType;
(function (CodeExpansionType) {
  CodeExpansionType[CodeExpansionType["LARGE"] = 2] = "LARGE";
  CodeExpansionType[CodeExpansionType["AUTO"] = 1] = "AUTO";
  CodeExpansionType[CodeExpansionType["TINY"] = 0] = "TINY";
})(CodeExpansionType || (CodeExpansionType = {}));

/***/ }),

/***/ "9a1f":
/***/ (function(module, exports, __webpack_require__) {

var call = __webpack_require__("c65b");
var aCallable = __webpack_require__("59ed");
var anObject = __webpack_require__("825a");
var tryToString = __webpack_require__("0d51");
var getIteratorMethod = __webpack_require__("35a1");

var $TypeError = TypeError;

module.exports = function (argument, usingIterator) {
  var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
  if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
  throw $TypeError(tryToString(argument) + ' is not iterable');
};


/***/ }),

/***/ "9a2b":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = (function() {
'use strict';

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
*/
function clone(parent, circular, depth, prototype) {
  var filter;
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    filter = circular.filter;
    circular = circular.circular
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth == 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
};
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
};
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
};
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
};
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
};
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if ( true && module.exports) {
  module.exports = clone;
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("1c35").Buffer))

/***/ }),

/***/ "9a8c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__("e330");
var ArrayBufferViewCore = __webpack_require__("ebb5");
var $ArrayCopyWithin = __webpack_require__("145e");

var u$ArrayCopyWithin = uncurryThis($ArrayCopyWithin);
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
  return u$ArrayCopyWithin(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});


/***/ }),

/***/ "9ab4":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export __extends */
/* unused harmony export __assign */
/* unused harmony export __rest */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __decorate; });
/* unused harmony export __param */
/* unused harmony export __esDecorate */
/* unused harmony export __runInitializers */
/* unused harmony export __propKey */
/* unused harmony export __setFunctionName */
/* unused harmony export __metadata */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __awaiter; });
/* unused harmony export __generator */
/* unused harmony export __createBinding */
/* unused harmony export __exportStar */
/* unused harmony export __values */
/* unused harmony export __read */
/* unused harmony export __spread */
/* unused harmony export __spreadArrays */
/* unused harmony export __spreadArray */
/* unused harmony export __await */
/* unused harmony export __asyncGenerator */
/* unused harmony export __asyncDelegator */
/* unused harmony export __asyncValues */
/* unused harmony export __makeTemplateObject */
/* unused harmony export __importStar */
/* unused harmony export __importDefault */
/* unused harmony export __classPrivateFieldGet */
/* unused harmony export __classPrivateFieldSet */
/* unused harmony export __classPrivateFieldIn */
/* unused harmony export __addDisposableResource */
/* unused harmony export __disposeResources */
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};

function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};

function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    function next() {
        while (env.stack.length) {
            var rec = env.stack.pop();
            try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
            }
            catch (e) {
                fail(e);
            }
        }
        if (env.hasError) throw env.error;
    }
    return next();
}

/* unused harmony default export */ var _unused_webpack_default_export = ({
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
});


/***/ }),

/***/ "9bdd":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var iteratorClose = __webpack_require__("2a62");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  } catch (error) {
    iteratorClose(iterator, 'throw', error);
  }
};


/***/ }),

/***/ "9bf2":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__("aed9");
var anObject = __webpack_require__("825a");
var toPropertyKey = __webpack_require__("a04b");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "9c40":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./node_modules/quasar/src/components/icon/QIcon.js
var QIcon = __webpack_require__("0016");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/spinner/QSpinner.js + 1 modules
var QSpinner = __webpack_require__("0d59");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.flat.js
var es_array_flat = __webpack_require__("0481");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.unscopables.flat.js
var es_array_unscopables_flat = __webpack_require__("4069");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("13d5");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.assign.js
var es_object_assign = __webpack_require__("cca6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.test.js
var es_regexp_test = __webpack_require__("00b4");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.join.js
var es_array_join = __webpack_require__("a15b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__("d81d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
var es_string_split = __webpack_require__("1276");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/align.js
var align = __webpack_require__("99b6");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/ripple.js + 2 modules
var ripple = __webpack_require__("3d69");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("87e8");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/router-link.js
var router_link = __webpack_require__("8716");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/size.js
var size = __webpack_require__("6642");

// CONCATENATED MODULE: ./node_modules/quasar/src/mixins/btn.js




















var btnPadding = {
  none: 0,
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32
};
var formTypes = ['button', 'submit', 'reset'];
var mediaTypeRe = /[^\s]\/[^\s]/;
var btnDesignOptions = ['flat', 'outline', 'push', 'unelevated'];
var getBtnDesign = function getBtnDesign(vm, defaultValue) {
  if (vm.flat === true) return 'flat';
  if (vm.outline === true) return 'outline';
  if (vm.push === true) return 'push';
  if (vm.unelevated === true) return 'unelevated';
  return defaultValue;
};
/* harmony default export */ var btn = ({
  mixins: [listeners["a" /* default */], ripple["a" /* default */], router_link["a" /* default */], align["a" /* default */], Object(size["b" /* getSizeMixin */])({
    xs: 8,
    sm: 10,
    md: 14,
    lg: 20,
    xl: 24
  })],
  props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
    type: {
      type: String,
      default: 'button'
    },
    to: [Object, String],
    replace: Boolean,
    append: Boolean,
    label: [Number, String],
    icon: String,
    iconRight: String
  }, btnDesignOptions.reduce(function (acc, val) {
    return (acc[val] = Boolean) && acc;
  }, {})), {}, {
    square: Boolean,
    round: Boolean,
    rounded: Boolean,
    glossy: Boolean,
    size: String,
    fab: Boolean,
    fabMini: Boolean,
    padding: String,
    color: String,
    textColor: String,
    noCaps: Boolean,
    noWrap: Boolean,
    dense: Boolean,
    tabindex: [Number, String],
    align: {
      default: 'center'
    },
    stack: Boolean,
    stretch: Boolean,
    loading: {
      type: Boolean,
      default: null
    },
    disable: Boolean
  }),
  computed: {
    style: function style() {
      if (this.fab === false && this.fabMini === false) {
        return this.sizeStyle;
      }
    },
    isRounded: function isRounded() {
      return this.rounded === true || this.fab === true || this.fabMini === true;
    },
    isActionable: function isActionable() {
      return this.disable !== true && this.loading !== true;
    },
    computedTabIndex: function computedTabIndex() {
      return this.isActionable === true ? this.tabindex || 0 : -1;
    },
    design: function design() {
      return getBtnDesign(this, 'standard');
    },
    attrs: function attrs() {
      var acc = {
        tabindex: this.computedTabIndex
      };
      if (this.hasLink === true) {
        Object.assign(acc, this.linkAttrs);
      } else if (formTypes.includes(this.type) === true) {
        acc.type = this.type;
      }
      if (this.linkTag === 'a') {
        if (this.disable === true) {
          acc['aria-disabled'] = 'true';
        } else if (acc.href === void 0) {
          acc.role = 'button';
        }
        if (this.hasRouterLink !== true && mediaTypeRe.test(this.type) === true) {
          acc.type = this.type;
        }
      } else if (this.disable === true) {
        acc.disabled = '';
        acc['aria-disabled'] = 'true';
      }
      if (this.loading === true && this.percentage !== void 0) {
        acc.role = 'progressbar';
        acc['aria-valuemin'] = 0;
        acc['aria-valuemax'] = 100;
        acc['aria-valuenow'] = this.percentage;
      }
      return acc;
    },
    classes: function classes() {
      var colors;
      if (this.color !== void 0) {
        if (this.flat === true || this.outline === true) {
          colors = "text-".concat(this.textColor || this.color);
        } else {
          colors = "bg-".concat(this.color, " text-").concat(this.textColor || 'white');
        }
      } else if (this.textColor) {
        colors = "text-".concat(this.textColor);
      }
      var shape = this.round === true ? 'round' : "rectangle".concat(this.isRounded === true ? ' q-btn--rounded' : this.square === true ? ' q-btn--square' : '');
      return "q-btn--".concat(this.design, " q-btn--").concat(shape) + (colors !== void 0 ? ' ' + colors : '') + (this.isActionable === true ? ' q-btn--actionable q-focusable q-hoverable' : this.disable === true ? ' disabled' : '') + (this.fab === true ? ' q-btn--fab' : this.fabMini === true ? ' q-btn--fab-mini' : '') + (this.noCaps === true ? ' q-btn--no-uppercase' : '') + (this.noWrap === true ? '' : ' q-btn--wrap') + (
      // this is for IE11
      this.dense === true ? ' q-btn--dense' : '') + (this.stretch === true ? ' no-border-radius self-stretch' : '') + (this.glossy === true ? ' glossy' : '');
    },
    innerClasses: function innerClasses() {
      return this.alignClass + (this.stack === true ? ' column' : ' row') + (this.noWrap === true ? ' no-wrap text-no-wrap' : '') + (this.loading === true ? ' q-btn__content--hidden' : '');
    },
    wrapperStyle: function wrapperStyle() {
      if (this.padding !== void 0) {
        return {
          padding: this.padding.split(/\s+/).map(function (v) {
            return v in btnPadding ? btnPadding[v] + 'px' : v;
          }).join(' '),
          minWidth: '0',
          minHeight: '0'
        };
      }
    }
  }
});
// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/slot.js
var slot = __webpack_require__("e277");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("d882");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/key-composition.js
var key_composition = __webpack_require__("dc8a");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/btn/QBtn.js










var passiveCapture = utils_event["e" /* listenOpts */].passiveCapture;
var touchTarget = void 0,
  keyboardTarget = void 0,
  mouseTarget = void 0;
var iconAttrs = {
  role: 'img',
  'aria-hidden': 'true'
};
/* harmony default export */ var QBtn = __webpack_exports__["a"] = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QBtn',
  mixins: [btn],
  props: {
    percentage: Number,
    darkPercentage: Boolean
  },
  computed: {
    hasLabel: function hasLabel() {
      return this.label !== void 0 && this.label !== null && this.label !== '';
    },
    computedRipple: function computedRipple() {
      return this.ripple === false ? false : Object(objectSpread2["a" /* default */])({
        keyCodes: this.hasLink === true ? [13, 32] : [13]
      }, this.ripple === true ? {} : this.ripple);
    },
    percentageStyle: function percentageStyle() {
      var val = Math.max(0, Math.min(100, this.percentage));
      if (val > 0) {
        return {
          transition: 'transform 0.6s',
          transform: "translateX(".concat(val - 100, "%)")
        };
      }
    },
    onEvents: function onEvents() {
      if (this.loading === true) {
        return {
          mousedown: this.__onLoadingEvt,
          touchstart: this.__onLoadingEvt,
          click: this.__onLoadingEvt,
          keydown: this.__onLoadingEvt,
          keyup: this.__onLoadingEvt
        };
      }
      if (this.isActionable === true) {
        var on = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.qListeners), {}, {
          click: this.click,
          keydown: this.__onKeydown,
          mousedown: this.__onMousedown
        });
        if (this.$q.platform.has.touch === true) {
          on["".concat(on.touchstart === void 0 ? '&' : '', "touchstart")] = this.__onTouchstart;
        }
        return on;
      }
      return {
        // needed; especially for disabled <a> tags
        click: utils_event["j" /* stopAndPrevent */]
      };
    },
    directives: function directives() {
      if (this.disable !== true && this.ripple !== false) {
        return [{
          name: 'ripple',
          value: this.computedRipple,
          modifiers: {
            center: this.round
          }
        }];
      }
    }
  },
  methods: {
    click: function click(e) {
      var _this = this;
      if (e !== void 0) {
        if (e.defaultPrevented === true) {
          return;
        }
        var el = document.activeElement;
        // focus button if it came from ENTER on form
        // prevent the new submit (already done)
        if (this.type === 'submit' && (this.$q.platform.is.ie === true && (e.clientX < 0 || e.clientY < 0) || el !== document.body && this.$el.contains(el) === false &&
        // required for iOS and desktop Safari
        el.contains(this.$el) === false)) {
          this.$el.focus();
          var onClickCleanup = function onClickCleanup() {
            document.removeEventListener('keydown', utils_event["j" /* stopAndPrevent */], true);
            document.removeEventListener('keyup', onClickCleanup, passiveCapture);
            _this.$el !== void 0 && _this.$el.removeEventListener('blur', onClickCleanup, passiveCapture);
          };
          document.addEventListener('keydown', utils_event["j" /* stopAndPrevent */], true);
          document.addEventListener('keyup', onClickCleanup, passiveCapture);
          this.$el.addEventListener('blur', onClickCleanup, passiveCapture);
        }
      }
      this.__navigateOnClick(e);
    },
    __onKeydown: function __onKeydown(e) {
      this.$emit('keydown', e);
      if (Object(key_composition["a" /* isKeyCode */])(e, [13, 32]) === true) {
        if (keyboardTarget !== this.$el) {
          keyboardTarget !== void 0 && this.__cleanup();
          if (e.defaultPrevented !== true) {
            // focus external button if the focus helper was focused before
            this.$el.focus();
            keyboardTarget = this.$el;
            this.$el.classList.add('q-btn--active');
            document.addEventListener('keyup', this.__onPressEnd, true);
            this.$el.addEventListener('blur', this.__onPressEnd, passiveCapture);
          }
        }
        Object(utils_event["j" /* stopAndPrevent */])(e);
      }
    },
    __onTouchstart: function __onTouchstart(e) {
      var _this2 = this;
      this.$emit('touchstart', e);
      if (touchTarget !== this.$el) {
        touchTarget !== void 0 && this.__cleanup();
        if (e.defaultPrevented !== true) {
          touchTarget = this.$el;
          var target = this.touchTargetEl = e.target;
          target.addEventListener('touchcancel', this.__onPressEnd, passiveCapture);
          target.addEventListener('touchend', this.__onPressEnd, passiveCapture);
        }
      }

      // avoid duplicated mousedown event
      // triggering another early ripple
      this.avoidMouseRipple = true;
      clearTimeout(this.mouseTimer);
      this.mouseTimer = setTimeout(function () {
        _this2.avoidMouseRipple = false;
      }, 200);
    },
    __onMousedown: function __onMousedown(e) {
      e.qSkipRipple = this.avoidMouseRipple === true;
      this.$emit('mousedown', e);
      if (mouseTarget !== this.$el) {
        mouseTarget !== void 0 && this.__cleanup();
        if (e.defaultPrevented !== true) {
          mouseTarget = this.$el;
          this.$el.classList.add('q-btn--active');
          document.addEventListener('mouseup', this.__onPressEnd, passiveCapture);
        }
      }
    },
    __onPressEnd: function __onPressEnd(e) {
      // needed for IE (because it emits blur when focusing button from focus helper)
      if (e !== void 0 && e.type === 'blur' && document.activeElement === this.$el) {
        return;
      }
      if (e !== void 0 && e.type === 'keyup') {
        if (keyboardTarget === this.$el && Object(key_composition["a" /* isKeyCode */])(e, [13, 32]) === true) {
          // for click trigger
          var evt = new MouseEvent('click', e);
          evt.qKeyEvent = true;
          e.defaultPrevented === true && Object(utils_event["h" /* prevent */])(evt);
          e.cancelBubble === true && Object(utils_event["i" /* stop */])(evt);
          this.$el.dispatchEvent(evt);
          Object(utils_event["j" /* stopAndPrevent */])(e);

          // for ripple
          e.qKeyEvent = true;
        }
        this.$emit('keyup', e);
      }
      this.__cleanup();
    },
    __cleanup: function __cleanup(destroying) {
      var blurTarget = this.$refs.blurTarget;
      if (destroying !== true && (touchTarget === this.$el || mouseTarget === this.$el) && blurTarget !== void 0 && blurTarget !== document.activeElement && this.$el.contains(document.activeElement) === true) {
        blurTarget.setAttribute('tabindex', -1);
        blurTarget.focus();
      }
      if (touchTarget === this.$el) {
        var target = this.touchTargetEl;
        target.removeEventListener('touchcancel', this.__onPressEnd, passiveCapture);
        target.removeEventListener('touchend', this.__onPressEnd, passiveCapture);
        touchTarget = this.touchTargetEl = void 0;
      }
      if (mouseTarget === this.$el) {
        document.removeEventListener('mouseup', this.__onPressEnd, passiveCapture);
        mouseTarget = void 0;
      }
      if (keyboardTarget === this.$el) {
        document.removeEventListener('keyup', this.__onPressEnd, true);
        this.$el !== void 0 && this.$el.removeEventListener('blur', this.__onPressEnd, passiveCapture);
        keyboardTarget = void 0;
      }
      this.$el !== void 0 && this.$el.classList.remove('q-btn--active');
    },
    __onLoadingEvt: function __onLoadingEvt(evt) {
      Object(utils_event["j" /* stopAndPrevent */])(evt);
      evt.qSkipRipple = true;
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.__cleanup(true);
  },
  render: function render(h) {
    var inner = [];
    this.icon !== void 0 && inner.push(h(QIcon["a" /* default */], {
      attrs: iconAttrs,
      props: {
        name: this.icon,
        left: this.stack === false && this.hasLabel === true
      }
    }));
    this.hasLabel === true && inner.push(h('span', {
      staticClass: 'block'
    }, [this.label]));
    inner = Object(slot["a" /* mergeSlot */])(inner, this, 'default');
    if (this.iconRight !== void 0 && this.round === false) {
      inner.push(h(QIcon["a" /* default */], {
        attrs: iconAttrs,
        props: {
          name: this.iconRight,
          right: this.stack === false && this.hasLabel === true
        }
      }));
    }
    var child = [h('span', {
      staticClass: 'q-focus-helper',
      ref: 'blurTarget'
    })];
    if (this.loading === true && this.percentage !== void 0) {
      child.push(h('span', {
        staticClass: 'q-btn__progress absolute-full overflow-hidden',
        class: this.darkPercentage === true ? 'q-btn__progress--dark' : ''
      }, [h('span', {
        staticClass: 'q-btn__progress-indicator fit block',
        style: this.percentageStyle
      })]));
    }
    child.push(h('span', {
      staticClass: 'q-btn__wrapper col row q-anchor--skip',
      style: this.wrapperStyle
    }, [h('span', {
      staticClass: 'q-btn__content text-center col items-center q-anchor--skip',
      class: this.innerClasses
    }, inner)]));
    this.loading !== null && child.push(h('transition', {
      props: {
        name: 'q-transition--fade'
      }
    }, this.loading === true ? [h('span', {
      key: 'loading',
      staticClass: 'absolute-full flex flex-center'
    }, this.$scopedSlots.loading !== void 0 ? this.$scopedSlots.loading() : [h(QSpinner["a" /* default */])])] : void 0));
    return h(this.hasLink === true || this.type === 'a' ? 'a' : 'button', {
      staticClass: 'q-btn q-btn-item non-selectable no-outline',
      class: this.classes,
      style: this.style,
      attrs: this.attrs,
      on: this.onEvents,
      directives: this.directives
    }, child);
  }
}));

/***/ }),

/***/ "9e62":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return closePortalMenus; });
/* unused harmony export closePortals */
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("b0c0");
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("0967");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("f303");
/* harmony import */ var _utils_private_focus_manager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("f6ba");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("1c16");






function closePortalMenus(vm, evt) {
  do {
    if (vm.$options.name === 'QMenu') {
      vm.hide(evt);

      // is this a point of separation?
      if (vm.separateClosePopup === true) {
        return vm.$parent;
      }
    } else if (vm.__renderPortal !== void 0) {
      // treat it as point of separation if parent is QPopupProxy
      // (so mobile matches desktop behavior)
      // and hide it too
      if (vm.$parent !== void 0 && vm.$parent.$options.name === 'QPopupProxy') {
        vm.hide(evt);
        return vm.$parent;
      } else {
        return vm;
      }
    }
    vm = vm.$parent;
  } while (vm !== void 0 && (vm.$el.contains === void 0 ||
  // IE polyfill does not work on comments
  vm.$el.contains(evt.target) !== true));
}
function closePortals(vm, evt, depth) {
  while (depth !== 0 && vm !== void 0) {
    if (vm.__renderPortal !== void 0) {
      depth--;
      if (vm.$options.name === 'QMenu') {
        vm = closePortalMenus(vm, evt);
        continue;
      }
      vm.hide(evt);
    }
    vm = vm.$parent;
  }
}
function isOnGlobalDialog(vm) {
  while (vm !== void 0) {
    if (vm.$options.name === 'QGlobalDialog') {
      return true;
    }
    if (vm.$options.name === 'QDialog') {
      return false;
    }
    vm = vm.$parent;
  }
  return false;
}
var Portal = {
  inheritAttrs: false,
  props: {
    contentClass: [Array, String, Object],
    contentStyle: [Array, String, Object]
  },
  methods: {
    __showPortal: function __showPortal(isReady) {
      var _this = this;
      if (isReady === true) {
        Object(_utils_private_focus_manager_js__WEBPACK_IMPORTED_MODULE_4__[/* removeFocusWaitFlag */ "d"])(this.focusObj);
        this.__portalIsAccessible = true;
        return;
      }
      this.__portalIsAccessible = false;
      if (this.__portalIsActive === true) {
        return;
      }
      this.__portalIsActive = true;
      if (this.focusObj === void 0) {
        this.focusObj = {};
      }
      Object(_utils_private_focus_manager_js__WEBPACK_IMPORTED_MODULE_4__[/* addFocusWaitFlag */ "b"])(this.focusObj);
      if (this.$q.fullscreen !== void 0 && this.$q.fullscreen.isCapable === true) {
        var append = function append() {
          if (_this.__portal === void 0) {
            return;
          }
          var newParent = Object(_utils_dom_js__WEBPACK_IMPORTED_MODULE_3__[/* getBodyFullscreenElement */ "c"])(_this.$q.fullscreen.activeEl);
          if (_this.__portal.$el.parentElement !== newParent && newParent.contains(_this.$el) === (_this.__onGlobalDialog === false)) {
            newParent.appendChild(_this.__portal.$el);
          }
        };
        this.unwatchFullscreen = this.$watch('$q.fullscreen.activeEl', Object(_utils_debounce_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(append, 50));
        if (this.__onGlobalDialog === false || this.$q.fullscreen.isActive === true) {
          append();
        }
      } else if (this.__portal !== void 0 && this.__onGlobalDialog === false) {
        document.body.appendChild(this.__portal.$el);
      }
    },
    __hidePortal: function __hidePortal(isReady) {
      this.__portalIsAccessible = false;
      if (isReady !== true) {
        return;
      }
      this.__portalIsActive = false;
      Object(_utils_private_focus_manager_js__WEBPACK_IMPORTED_MODULE_4__[/* removeFocusWaitFlag */ "d"])(this.focusObj);
      if (this.__portal !== void 0) {
        if (this.unwatchFullscreen !== void 0) {
          this.unwatchFullscreen();
          this.unwatchFullscreen = void 0;
        }
        if (this.__onGlobalDialog === false) {
          this.__portal.$destroy();
          this.__portal.$el.remove();
        }
        this.__portal = void 0;
      }
    },
    __preparePortal: function __preparePortal() {
      var _this2 = this;
      if (this.__portal === void 0) {
        this.__portal = this.__onGlobalDialog === true ? {
          $el: this.$el,
          $refs: this.$refs
        } : new vue__WEBPACK_IMPORTED_MODULE_1___default.a({
          name: 'QPortal',
          parent: this,
          inheritAttrs: false,
          render: function render(h) {
            return _this2.__renderPortal(h);
          },
          components: this.$options.components,
          directives: this.$options.directives
        }).$mount();
      }
    }
  },
  render: function render(h) {
    if (this.__onGlobalDialog === true) {
      return this.__renderPortal(h);
    }
    if (this.__portal !== void 0) {
      this.__portal.$forceUpdate();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.__hidePortal(true);
  }
};
if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_2__[/* isSSR */ "e"] === false) {
  Portal.created = function () {
    this.__onGlobalDialog = isOnGlobalDialog(this.$parent);
  };
}
/* harmony default export */ __webpack_exports__["b"] = (Portal);

/***/ }),

/***/ "9f7f":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
var $RegExp = global.RegExp;

var UNSUPPORTED_Y = fails(function () {
  var re = $RegExp('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

// UC Browser bug
// https://github.com/zloirock/core-js/issues/1008
var MISSED_STICKY = UNSUPPORTED_Y || fails(function () {
  return !$RegExp('a', 'y').sticky;
});

var BROKEN_CARET = UNSUPPORTED_Y || fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = $RegExp('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

module.exports = {
  BROKEN_CARET: BROKEN_CARET,
  MISSED_STICKY: MISSED_STICKY,
  UNSUPPORTED_Y: UNSUPPORTED_Y
};


/***/ }),

/***/ "a04b":
/***/ (function(module, exports, __webpack_require__) {

var toPrimitive = __webpack_require__("c04e");
var isSymbol = __webpack_require__("d9b5");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "a078":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("0366");
var call = __webpack_require__("c65b");
var aConstructor = __webpack_require__("5087");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");
var getIterator = __webpack_require__("9a1f");
var getIteratorMethod = __webpack_require__("35a1");
var isArrayIteratorMethod = __webpack_require__("e95a");
var isBigIntArray = __webpack_require__("bcbf");
var aTypedArrayConstructor = __webpack_require__("ebb5").aTypedArrayConstructor;
var toBigInt = __webpack_require__("f495");

module.exports = function from(source /* , mapfn, thisArg */) {
  var C = aConstructor(this);
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, thisIsBigIntArray, value, step, iterator, next;
  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    O = [];
    while (!(step = call(next, iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2]);
  }
  length = lengthOfArrayLike(O);
  result = new (aTypedArrayConstructor(C))(length);
  thisIsBigIntArray = isBigIntArray(result);
  for (i = 0; length > i; i++) {
    value = mapping ? mapfn(O[i], i) : O[i];
    // FF30- typed arrays doesn't properly convert objects to typed array values
    result[i] = thisIsBigIntArray ? toBigInt(value) : +value;
  }
  return result;
};


/***/ }),

/***/ "a15b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("e330");
var IndexedObject = __webpack_require__("44ad");
var toIndexedObject = __webpack_require__("fc6a");
var arrayMethodIsStrict = __webpack_require__("a640");

var nativeJoin = uncurryThis([].join);

var ES3_STRINGS = IndexedObject != Object;
var FORCED = ES3_STRINGS || !arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.es/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: FORCED }, {
  join: function join(separator) {
    return nativeJoin(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ "a258":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("0366");
var IndexedObject = __webpack_require__("44ad");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");

// `Array.prototype.{ findLast, findLastIndex }` methods implementation
var createMethod = function (TYPE) {
  var IS_FIND_LAST_INDEX = TYPE == 1;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var index = lengthOfArrayLike(self);
    var value, result;
    while (index-- > 0) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (result) switch (TYPE) {
        case 0: return value; // findLast
        case 1: return index; // findLastIndex
      }
    }
    return IS_FIND_LAST_INDEX ? -1 : undefined;
  };
};

module.exports = {
  // `Array.prototype.findLast` method
  // https://github.com/tc39/proposal-array-find-from-last
  findLast: createMethod(0),
  // `Array.prototype.findLastIndex` method
  // https://github.com/tc39/proposal-array-find-from-last
  findLastIndex: createMethod(1)
};


/***/ }),

/***/ "a2bf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray = __webpack_require__("e8b5");
var lengthOfArrayLike = __webpack_require__("07fa");
var doesNotExceedSafeInteger = __webpack_require__("3511");
var bind = __webpack_require__("0366");

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg) : false;
  var element, elementLen;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        elementLen = lengthOfArrayLike(element);
        targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;
      } else {
        doesNotExceedSafeInteger(targetIndex + 1);
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),

/***/ "a370":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5530");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _mixins_tag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("e2fa");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("87e8");
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("e277");





/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1___default.a.extend({
  name: 'QCardSection',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_tag_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]],
  props: {
    horizontal: Boolean
  },
  computed: {
    classes: function classes() {
      return 'q-card__section ' + "q-card__section--".concat(this.horizontal === true ? 'horiz row no-wrap' : 'vert');
    }
  },
  render: function render(h) {
    return h(this.tag, {
      class: this.classes,
      on: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.qListeners)
    }, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_4__[/* slot */ "c"])(this, 'default'));
  }
}));

/***/ }),

/***/ "a38e":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ _toPropertyKey; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__("53ca");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.to-primitive.js
var es_symbol_to_primitive = __webpack_require__("8172");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.date.to-primitive.js
var es_date_to_primitive = __webpack_require__("efec");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__("a4d3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("e01a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.error.cause.js
var es_error_cause = __webpack_require__("d9e2");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js








function _toPrimitive(input, hint) {
  if (Object(esm_typeof["a" /* default */])(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (Object(esm_typeof["a" /* default */])(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return Object(esm_typeof["a" /* default */])(key) === "symbol" ? key : String(key);
}

/***/ }),

/***/ "a3a2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("e330");
var toIntegerOrInfinity = __webpack_require__("5926");
var thisNumberValue = __webpack_require__("408a");
var $repeat = __webpack_require__("1148");
var log10 = __webpack_require__("867a");
var fails = __webpack_require__("d039");

var $RangeError = RangeError;
var $String = String;
var $isFinite = isFinite;
var abs = Math.abs;
var floor = Math.floor;
var pow = Math.pow;
var round = Math.round;
var nativeToExponential = uncurryThis(1.0.toExponential);
var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);

// Edge 17-
var ROUNDS_PROPERLY = nativeToExponential(-6.9e-11, 4) === '-6.9000e-11'
  // IE11- && Edge 14-
  && nativeToExponential(1.255, 2) === '1.25e+0'
  // FF86-, V8 ~ Chrome 49-50
  && nativeToExponential(12345, 3) === '1.235e+4'
  // FF86-, V8 ~ Chrome 49-50
  && nativeToExponential(25, 0) === '3e+1';

// IE8-
var throwsOnInfinityFraction = function () {
  return fails(function () {
    nativeToExponential(1, Infinity);
  }) && fails(function () {
    nativeToExponential(1, -Infinity);
  });
};

// Safari <11 && FF <50
var properNonFiniteThisCheck = function () {
  return !fails(function () {
    nativeToExponential(Infinity, Infinity);
    nativeToExponential(NaN, Infinity);
  });
};

var FORCED = !ROUNDS_PROPERLY || !throwsOnInfinityFraction() || !properNonFiniteThisCheck();

// `Number.prototype.toExponential` method
// https://tc39.es/ecma262/#sec-number.prototype.toexponential
$({ target: 'Number', proto: true, forced: FORCED }, {
  toExponential: function toExponential(fractionDigits) {
    var x = thisNumberValue(this);
    if (fractionDigits === undefined) return nativeToExponential(x);
    var f = toIntegerOrInfinity(fractionDigits);
    if (!$isFinite(x)) return String(x);
    // TODO: ES2018 increased the maximum number of fraction digits to 100, need to improve the implementation
    if (f < 0 || f > 20) throw $RangeError('Incorrect fraction digits');
    if (ROUNDS_PROPERLY) return nativeToExponential(x, f);
    var s = '';
    var m = '';
    var e = 0;
    var c = '';
    var d = '';
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x === 0) {
      e = 0;
      m = repeat('0', f + 1);
    } else {
      // this block is based on https://gist.github.com/SheetJSDev/1100ad56b9f856c95299ed0e068eea08
      // TODO: improve accuracy with big fraction digits
      var l = log10(x);
      e = floor(l);
      var n = 0;
      var w = pow(10, e - f);
      n = round(x / w);
      if (2 * x >= (2 * n + 1) * w) {
        n += 1;
      }
      if (n >= pow(10, f + 1)) {
        n /= 10;
        e += 1;
      }
      m = $String(n);
    }
    if (f !== 0) {
      m = stringSlice(m, 0, 1) + '.' + stringSlice(m, 1);
    }
    if (e === 0) {
      c = '+';
      d = '0';
    } else {
      c = e > 0 ? '+' : '-';
      d = $String(abs(e));
    }
    m += 'e' + c + d;
    return s + m;
  }
});


/***/ }),

/***/ "a434":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var toObject = __webpack_require__("7b0b");
var toAbsoluteIndex = __webpack_require__("23cb");
var toIntegerOrInfinity = __webpack_require__("5926");
var lengthOfArrayLike = __webpack_require__("07fa");
var setArrayLength = __webpack_require__("3a34");
var doesNotExceedSafeInteger = __webpack_require__("3511");
var arraySpeciesCreate = __webpack_require__("65f0");
var createProperty = __webpack_require__("8418");
var deletePropertyOrThrow = __webpack_require__("083a");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

var max = Math.max;
var min = Math.min;

// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
    }
    doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else deletePropertyOrThrow(O, to);
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow(O, k - 1);
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else deletePropertyOrThrow(O, to);
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    setArrayLength(O, len - actualDeleteCount + insertCount);
    return A;
  }
});


/***/ }),

/***/ "a4ac":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "a4b4":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");

module.exports = /web0s(?!.*chrome)/i.test(userAgent);


/***/ }),

/***/ "a4d3":
/***/ (function(module, exports, __webpack_require__) {

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__("d9f5");
__webpack_require__("b4f8");
__webpack_require__("c513");
__webpack_require__("e9c4");
__webpack_require__("5a47");


/***/ }),

/***/ "a630":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var from = __webpack_require__("4df4");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "a640":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__("d039");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ }),

/***/ "a72d":
/***/ (function(module, exports) {

module.exports = [
    [ 0x0300, 0x036F ], [ 0x0483, 0x0486 ], [ 0x0488, 0x0489 ],
    [ 0x0591, 0x05BD ], [ 0x05BF, 0x05BF ], [ 0x05C1, 0x05C2 ],
    [ 0x05C4, 0x05C5 ], [ 0x05C7, 0x05C7 ], [ 0x0600, 0x0603 ],
    [ 0x0610, 0x0615 ], [ 0x064B, 0x065E ], [ 0x0670, 0x0670 ],
    [ 0x06D6, 0x06E4 ], [ 0x06E7, 0x06E8 ], [ 0x06EA, 0x06ED ],
    [ 0x070F, 0x070F ], [ 0x0711, 0x0711 ], [ 0x0730, 0x074A ],
    [ 0x07A6, 0x07B0 ], [ 0x07EB, 0x07F3 ], [ 0x0901, 0x0902 ],
    [ 0x093C, 0x093C ], [ 0x0941, 0x0948 ], [ 0x094D, 0x094D ],
    [ 0x0951, 0x0954 ], [ 0x0962, 0x0963 ], [ 0x0981, 0x0981 ],
    [ 0x09BC, 0x09BC ], [ 0x09C1, 0x09C4 ], [ 0x09CD, 0x09CD ],
    [ 0x09E2, 0x09E3 ], [ 0x0A01, 0x0A02 ], [ 0x0A3C, 0x0A3C ],
    [ 0x0A41, 0x0A42 ], [ 0x0A47, 0x0A48 ], [ 0x0A4B, 0x0A4D ],
    [ 0x0A70, 0x0A71 ], [ 0x0A81, 0x0A82 ], [ 0x0ABC, 0x0ABC ],
    [ 0x0AC1, 0x0AC5 ], [ 0x0AC7, 0x0AC8 ], [ 0x0ACD, 0x0ACD ],
    [ 0x0AE2, 0x0AE3 ], [ 0x0B01, 0x0B01 ], [ 0x0B3C, 0x0B3C ],
    [ 0x0B3F, 0x0B3F ], [ 0x0B41, 0x0B43 ], [ 0x0B4D, 0x0B4D ],
    [ 0x0B56, 0x0B56 ], [ 0x0B82, 0x0B82 ], [ 0x0BC0, 0x0BC0 ],
    [ 0x0BCD, 0x0BCD ], [ 0x0C3E, 0x0C40 ], [ 0x0C46, 0x0C48 ],
    [ 0x0C4A, 0x0C4D ], [ 0x0C55, 0x0C56 ], [ 0x0CBC, 0x0CBC ],
    [ 0x0CBF, 0x0CBF ], [ 0x0CC6, 0x0CC6 ], [ 0x0CCC, 0x0CCD ],
    [ 0x0CE2, 0x0CE3 ], [ 0x0D41, 0x0D43 ], [ 0x0D4D, 0x0D4D ],
    [ 0x0DCA, 0x0DCA ], [ 0x0DD2, 0x0DD4 ], [ 0x0DD6, 0x0DD6 ],
    [ 0x0E31, 0x0E31 ], [ 0x0E34, 0x0E3A ], [ 0x0E47, 0x0E4E ],
    [ 0x0EB1, 0x0EB1 ], [ 0x0EB4, 0x0EB9 ], [ 0x0EBB, 0x0EBC ],
    [ 0x0EC8, 0x0ECD ], [ 0x0F18, 0x0F19 ], [ 0x0F35, 0x0F35 ],
    [ 0x0F37, 0x0F37 ], [ 0x0F39, 0x0F39 ], [ 0x0F71, 0x0F7E ],
    [ 0x0F80, 0x0F84 ], [ 0x0F86, 0x0F87 ], [ 0x0F90, 0x0F97 ],
    [ 0x0F99, 0x0FBC ], [ 0x0FC6, 0x0FC6 ], [ 0x102D, 0x1030 ],
    [ 0x1032, 0x1032 ], [ 0x1036, 0x1037 ], [ 0x1039, 0x1039 ],
    [ 0x1058, 0x1059 ], [ 0x1160, 0x11FF ], [ 0x135F, 0x135F ],
    [ 0x1712, 0x1714 ], [ 0x1732, 0x1734 ], [ 0x1752, 0x1753 ],
    [ 0x1772, 0x1773 ], [ 0x17B4, 0x17B5 ], [ 0x17B7, 0x17BD ],
    [ 0x17C6, 0x17C6 ], [ 0x17C9, 0x17D3 ], [ 0x17DD, 0x17DD ],
    [ 0x180B, 0x180D ], [ 0x18A9, 0x18A9 ], [ 0x1920, 0x1922 ],
    [ 0x1927, 0x1928 ], [ 0x1932, 0x1932 ], [ 0x1939, 0x193B ],
    [ 0x1A17, 0x1A18 ], [ 0x1B00, 0x1B03 ], [ 0x1B34, 0x1B34 ],
    [ 0x1B36, 0x1B3A ], [ 0x1B3C, 0x1B3C ], [ 0x1B42, 0x1B42 ],
    [ 0x1B6B, 0x1B73 ], [ 0x1DC0, 0x1DCA ], [ 0x1DFE, 0x1DFF ],
    [ 0x200B, 0x200F ], [ 0x202A, 0x202E ], [ 0x2060, 0x2063 ],
    [ 0x206A, 0x206F ], [ 0x20D0, 0x20EF ], [ 0x302A, 0x302F ],
    [ 0x3099, 0x309A ], [ 0xA806, 0xA806 ], [ 0xA80B, 0xA80B ],
    [ 0xA825, 0xA826 ], [ 0xFB1E, 0xFB1E ], [ 0xFE00, 0xFE0F ],
    [ 0xFE20, 0xFE23 ], [ 0xFEFF, 0xFEFF ], [ 0xFFF9, 0xFFFB ],
    [ 0x10A01, 0x10A03 ], [ 0x10A05, 0x10A06 ], [ 0x10A0C, 0x10A0F ],
    [ 0x10A38, 0x10A3A ], [ 0x10A3F, 0x10A3F ], [ 0x1D167, 0x1D169 ],
    [ 0x1D173, 0x1D182 ], [ 0x1D185, 0x1D18B ], [ 0x1D1AA, 0x1D1AD ],
    [ 0x1D242, 0x1D244 ], [ 0xE0001, 0xE0001 ], [ 0xE0020, 0xE007F ],
    [ 0xE0100, 0xE01EF ]
]


/***/ }),

/***/ "a7ae":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePlayground_vue_vue_type_style_index_1_id_0fa31c20_prod_lang_stylus___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("6022");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePlayground_vue_vue_type_style_index_1_id_0fa31c20_prod_lang_stylus___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodePlayground_vue_vue_type_style_index_1_id_0fa31c20_prod_lang_stylus___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "a7be":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "a975":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $every = __webpack_require__("b727").every;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.every` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "a9e3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var IS_PURE = __webpack_require__("c430");
var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var path = __webpack_require__("428f");
var uncurryThis = __webpack_require__("e330");
var isForced = __webpack_require__("94ca");
var hasOwn = __webpack_require__("1a2d");
var inheritIfRequired = __webpack_require__("7156");
var isPrototypeOf = __webpack_require__("3a9b");
var isSymbol = __webpack_require__("d9b5");
var toPrimitive = __webpack_require__("c04e");
var fails = __webpack_require__("d039");
var getOwnPropertyNames = __webpack_require__("241c").f;
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var defineProperty = __webpack_require__("9bf2").f;
var thisNumberValue = __webpack_require__("408a");
var trim = __webpack_require__("58a8").trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var PureNumberNamespace = path[NUMBER];
var NumberPrototype = NativeNumber.prototype;
var TypeError = global.TypeError;
var stringSlice = uncurryThis(''.slice);
var charCodeAt = uncurryThis(''.charCodeAt);

// `ToNumeric` abstract operation
// https://tc39.es/ecma262/#sec-tonumeric
var toNumeric = function (value) {
  var primValue = toPrimitive(value, 'number');
  return typeof primValue == 'bigint' ? primValue : toNumber(primValue);
};

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, 'number');
  var first, third, radix, maxCode, digits, length, index, code;
  if (isSymbol(it)) throw TypeError('Cannot convert a Symbol value to a number');
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = charCodeAt(it, 0);
    if (first === 43 || first === 45) {
      third = charCodeAt(it, 2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (charCodeAt(it, 1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = stringSlice(it, 2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = charCodeAt(digits, index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

var FORCED = isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'));

var calledWithNew = function (dummy) {
  // includes check on 1..constructor(foo) case
  return isPrototypeOf(NumberPrototype, dummy) && fails(function () { thisNumberValue(dummy); });
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
var NumberWrapper = function Number(value) {
  var n = arguments.length < 1 ? 0 : NativeNumber(toNumeric(value));
  return calledWithNew(this) ? inheritIfRequired(Object(n), this, NumberWrapper) : n;
};

NumberWrapper.prototype = NumberPrototype;
if (FORCED && !IS_PURE) NumberPrototype.constructor = NumberWrapper;

$({ global: true, constructor: true, wrap: true, forced: FORCED }, {
  Number: NumberWrapper
});

// Use `internal/copy-constructor-properties` helper in `core-js@4`
var copyConstructorProperties = function (target, source) {
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(source) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (hasOwn(source, key = keys[j]) && !hasOwn(target, key)) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};

if (IS_PURE && PureNumberNamespace) copyConstructorProperties(path[NUMBER], PureNumberNamespace);
if (FORCED || IS_PURE) copyConstructorProperties(path[NUMBER], NativeNumber);


/***/ }),

/***/ "ab13":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),

/***/ "ab36":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var createNonEnumerableProperty = __webpack_require__("9112");

// `InstallErrorCause` abstract operation
// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
module.exports = function (O, options) {
  if (isObject(options) && 'cause' in options) {
    createNonEnumerableProperty(O, 'cause', options.cause);
  }
};


/***/ }),

/***/ "ac1f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var exec = __webpack_require__("9263");

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ "acac":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var uncurryThis = __webpack_require__("e330");
var defineBuiltIns = __webpack_require__("6964");
var getWeakData = __webpack_require__("f183").getWeakData;
var anInstance = __webpack_require__("19aa");
var anObject = __webpack_require__("825a");
var isNullOrUndefined = __webpack_require__("7234");
var isObject = __webpack_require__("861d");
var iterate = __webpack_require__("2266");
var ArrayIterationModule = __webpack_require__("b727");
var hasOwn = __webpack_require__("1a2d");
var InternalStateModule = __webpack_require__("69f3");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var splice = uncurryThis([].splice);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (state) {
  return state.frozen || (state.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) splice(this.entries, index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var Constructor = wrapper(function (that, iterable) {
      anInstance(that, Prototype);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var Prototype = Constructor.prototype;

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);
      else data[state.id] = value;
      return that;
    };

    defineBuiltIns(Prototype, {
      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete
      // https://tc39.es/ecma262/#sec-weakset.prototype.delete
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && hasOwn(data, state.id) && delete data[state.id];
      },
      // `{ WeakMap, WeakSet }.prototype.has(key)` methods
      // https://tc39.es/ecma262/#sec-weakmap.prototype.has
      // https://tc39.es/ecma262/#sec-weakset.prototype.has
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && hasOwn(data, state.id);
      }
    });

    defineBuiltIns(Prototype, IS_MAP ? {
      // `WeakMap.prototype.get(key)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.get
      get: function get(key) {
        var state = getInternalState(this);
        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // `WeakMap.prototype.set(key, value)` method
      // https://tc39.es/ecma262/#sec-weakmap.prototype.set
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // `WeakSet.prototype.add(value)` method
      // https://tc39.es/ecma262/#sec-weakset.prototype.add
      add: function add(value) {
        return define(this, value, true);
      }
    });

    return Constructor;
  }
};


/***/ }),

/***/ "ace4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("4625");
var fails = __webpack_require__("d039");
var ArrayBufferModule = __webpack_require__("621a");
var anObject = __webpack_require__("825a");
var toAbsoluteIndex = __webpack_require__("23cb");
var toLength = __webpack_require__("50c4");
var speciesConstructor = __webpack_require__("4840");

var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var DataViewPrototype = DataView.prototype;
var nativeArrayBufferSlice = uncurryThis(ArrayBuffer.prototype.slice);
var getUint8 = uncurryThis(DataViewPrototype.getUint8);
var setUint8 = uncurryThis(DataViewPrototype.setUint8);

var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
$({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice && end === undefined) {
      return nativeArrayBufferSlice(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      setUint8(viewTarget, index++, getUint8(viewSource, first++));
    } return result;
  }
});


/***/ }),

/***/ "ad10":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_RandomizerSettings_vue_vue_type_style_index_0_id_8b99c0d6_prod_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("4bf9");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_RandomizerSettings_vue_vue_type_style_index_0_id_8b99c0d6_prod_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_12_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_12_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_12_oneOf_1_2_node_modules_stylus_loader_index_js_ref_12_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_RandomizerSettings_vue_vue_type_style_index_0_id_8b99c0d6_prod_lang_stylus_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "ad6d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__("825a");

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "addb":
/***/ (function(module, exports, __webpack_require__) {

var arraySlice = __webpack_require__("4dae");

var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(
    array,
    mergeSort(arraySlice(array, 0, middle), comparefn),
    mergeSort(arraySlice(array, middle), comparefn),
    comparefn
  );
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  } return array;
};

var merge = function (array, left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;

  while (lindex < llength || rindex < rlength) {
    array[lindex + rindex] = (lindex < llength && rindex < rlength)
      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]
      : lindex < llength ? left[lindex++] : right[rindex++];
  } return array;
};

module.exports = mergeSort;


/***/ }),

/***/ "ade3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _defineProperty; });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a38e");

function _defineProperty(obj, key, value) {
  key = Object(_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

/***/ }),

/***/ "ae93":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__("d039");
var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");
var create = __webpack_require__("7c73");
var getPrototypeOf = __webpack_require__("e163");
var defineBuiltIn = __webpack_require__("cb2d");
var wellKnownSymbol = __webpack_require__("b622");
var IS_PURE = __webpack_require__("c430");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "aeb0":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("9bf2").f;

module.exports = function (Target, Source, key) {
  key in Target || defineProperty(Target, key, {
    configurable: true,
    get: function () { return Source[key]; },
    set: function (it) { Source[key] = it; }
  });
};


/***/ }),

/***/ "aed9":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ "af03":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};


/***/ }),

/***/ "aff1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("14d9");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_find_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("c740");
/* harmony import */ var core_js_modules_es_array_find_index_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find_index_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("a434");
/* harmony import */ var core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_splice_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _key_composition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("dc8a");




var handlers = [];
var escDown = false;
/* harmony default export */ __webpack_exports__["a"] = ({
  __install: function __install() {
    this.__installed = true;
    window.addEventListener('keydown', function (evt) {
      escDown = evt.keyCode === 27;
    });
    window.addEventListener('blur', function () {
      escDown === true && (escDown = false);
    });
    window.addEventListener('keyup', function (evt) {
      if (escDown === true) {
        escDown = false;
        if (handlers.length !== 0 && Object(_key_composition_js__WEBPACK_IMPORTED_MODULE_3__[/* isKeyCode */ "a"])(evt, 27) === true) {
          handlers[handlers.length - 1].fn(evt);
        }
      }
    });
  },
  register: function register(comp, fn) {
    if (comp.$q.platform.is.desktop === true) {
      this.__installed !== true && this.__install();
      handlers.push({
        comp: comp,
        fn: fn
      });
    }
  },
  pop: function pop(comp) {
    if (comp.$q.platform.is.desktop === true) {
      var index = handlers.findIndex(function (h) {
        return h.comp === comp;
      });
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }
});

/***/ }),

/***/ "b041":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var classof = __webpack_require__("f5df");

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "b0c0":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var FUNCTION_NAME_EXISTS = __webpack_require__("5e77").EXISTS;
var uncurryThis = __webpack_require__("e330");
var defineBuiltInAccessor = __webpack_require__("edd0");

var FunctionPrototype = Function.prototype;
var functionToString = uncurryThis(FunctionPrototype.toString);
var nameRE = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/;
var regExpExec = uncurryThis(nameRE.exec);
var NAME = 'name';

// Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !FUNCTION_NAME_EXISTS) {
  defineBuiltInAccessor(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return regExpExec(nameRE, functionToString(this))[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ "b380":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _setPrototypeOf; });
/* harmony import */ var core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("131a");
/* harmony import */ var core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_set_prototype_of_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_proto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("1f68");
/* harmony import */ var core_js_modules_es_object_proto_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_proto_js__WEBPACK_IMPORTED_MODULE_1__);


function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "b39a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var apply = __webpack_require__("2ba4");
var ArrayBufferViewCore = __webpack_require__("ebb5");
var fails = __webpack_require__("d039");
var arraySlice = __webpack_require__("f36a");

var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});

var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
  return apply(
    $toLocaleString,
    TO_LOCALE_STRING_BUG ? arraySlice(aTypedArray(this)) : aTypedArray(this),
    arraySlice(arguments)
  );
}, FORCED);


/***/ }),

/***/ "b3e9":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return BlockPrimaryColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return BlockSecondaryColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return BlockTertiaryColors; });
/* unused harmony export BlockOutputTypes */
/* unused harmony export BlockSequenceTypes */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BlockArgumentTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return KnownBlocklyTypes; });
var BlockPrimaryColors;
(function (BlockPrimaryColors) {
  BlockPrimaryColors["Colour"] = "#cf63cf";
  BlockPrimaryColors["List"] = "#5cb1d6";
  BlockPrimaryColors["Logic"] = "#ffab19";
  BlockPrimaryColors["Loop"] = "#ffbf00";
  BlockPrimaryColors["Math"] = "#4c97ff";
  BlockPrimaryColors["Procedure"] = "#ff6680";
  BlockPrimaryColors["Text"] = "#bbbbca";
  BlockPrimaryColors["Variable"] = "#59c059";
  BlockPrimaryColors["Variable_dynamic"] = "#0fbd8c";
})(BlockPrimaryColors || (BlockPrimaryColors = {}));
var BlockSecondaryColors;
(function (BlockSecondaryColors) {
  BlockSecondaryColors["Colour"] = "#c55ec5";
  BlockSecondaryColors["List"] = "#57a8cb";
  BlockSecondaryColors["Logic"] = "#f2a218";
  BlockSecondaryColors["Loop"] = "#f2b500";
  BlockSecondaryColors["Math"] = "#488ff2";
  BlockSecondaryColors["Procedure"] = "#f2617a";
  BlockSecondaryColors["Text"] = "#b2b2c0";
  BlockSecondaryColors["Variable"] = "#55b655";
  BlockSecondaryColors["Variable_dynamic"] = "#0eb485";
})(BlockSecondaryColors || (BlockSecondaryColors = {}));
var BlockTertiaryColors;
(function (BlockTertiaryColors) {
  BlockTertiaryColors["Colour"] = "#ba59ba";
  BlockTertiaryColors["List"] = "#539fc1";
  BlockTertiaryColors["Logic"] = "#e69a17";
  BlockTertiaryColors["Loop"] = "#e6ac00";
  BlockTertiaryColors["Math"] = "#4488e6";
  BlockTertiaryColors["Procedure"] = "#e65c73";
  BlockTertiaryColors["Text"] = "#a8a8b6";
  BlockTertiaryColors["Variable"] = "#50ad50";
  BlockTertiaryColors["Variable_dynamic"] = "#0eaa7e";
})(BlockTertiaryColors || (BlockTertiaryColors = {}));
var BlockOutputTypes;
(function (BlockOutputTypes) {
  BlockOutputTypes["Number"] = "Number";
  BlockOutputTypes["Boolean"] = "Boolean";
  BlockOutputTypes["String"] = "String";
  BlockOutputTypes["Array"] = "Array";
  BlockOutputTypes["Color"] = "Colour";
  BlockOutputTypes["Any"] = "";
})(BlockOutputTypes || (BlockOutputTypes = {}));
var BlockSequenceTypes;
(function (BlockSequenceTypes) {
  BlockSequenceTypes["Action"] = "Action";
})(BlockSequenceTypes || (BlockSequenceTypes = {}));
var BlockArgumentTypes;
(function (BlockArgumentTypes) {
  BlockArgumentTypes["field_input"] = "field_input";
  BlockArgumentTypes["field_dropdown"] = "field_dropdown";
  BlockArgumentTypes["field_checkbox"] = "field_checkbox";
  BlockArgumentTypes["field_colour"] = "field_colour";
  BlockArgumentTypes["field_number"] = "field_number";
  BlockArgumentTypes["field_angle"] = "field_angle";
  BlockArgumentTypes["field_variable"] = "field_variable";
  BlockArgumentTypes["field_date"] = "field_date";
  BlockArgumentTypes["field_label"] = "field_label";
  BlockArgumentTypes["field_image"] = "field_image";
  BlockArgumentTypes["input_value"] = "input_value";
  BlockArgumentTypes["input_statement"] = "input_statement";
  BlockArgumentTypes["input_dummy"] = "input_dummy";
})(BlockArgumentTypes || (BlockArgumentTypes = {}));
var KnownBlocklyTypes;
(function (KnownBlocklyTypes) {
  KnownBlocklyTypes["controls_if"] = "controls_if";
  KnownBlocklyTypes["logic_compare"] = "logic_compare";
  KnownBlocklyTypes["logic_operation"] = "logic_operation";
  KnownBlocklyTypes["logic_negate"] = "logic_negate";
  KnownBlocklyTypes["logic_boolean"] = "logic_boolean";
  KnownBlocklyTypes["logic_null"] = "logic_null";
  KnownBlocklyTypes["logic_ternary"] = "logic_ternary";
  KnownBlocklyTypes["controls_repeat_ext"] = "controls_repeat_ext";
  KnownBlocklyTypes["controls_whileUntil"] = "controls_whileUntil";
  KnownBlocklyTypes["controls_for"] = "controls_for";
  KnownBlocklyTypes["controls_forEach"] = "controls_forEach";
  KnownBlocklyTypes["controls_flow_statements"] = "controls_flow_statements";
  KnownBlocklyTypes["math_number"] = "math_number";
  KnownBlocklyTypes["math_arithmetic"] = "math_arithmetic";
  KnownBlocklyTypes["math_single"] = "math_single";
  KnownBlocklyTypes["math_trig"] = "math_trig";
  KnownBlocklyTypes["math_constant"] = "math_constant";
  KnownBlocklyTypes["math_number_property"] = "math_number_property";
  KnownBlocklyTypes["math_round"] = "math_round";
  KnownBlocklyTypes["math_on_list"] = "math_on_list";
  KnownBlocklyTypes["math_modulo"] = "math_modulo";
  KnownBlocklyTypes["math_constrain"] = "math_constrain";
  KnownBlocklyTypes["math_random_int"] = "math_random_int";
  KnownBlocklyTypes["math_random_float"] = "math_random_float";
  KnownBlocklyTypes["text"] = "text";
  KnownBlocklyTypes["text_join"] = "text_join";
  KnownBlocklyTypes["text_append"] = "text_append";
  KnownBlocklyTypes["text_length"] = "text_length";
  KnownBlocklyTypes["text_isEmpty"] = "text_isEmpty";
  KnownBlocklyTypes["text_indexOf"] = "text_indexOf";
  KnownBlocklyTypes["variables_get"] = "variables_get";
  KnownBlocklyTypes["text_charAt"] = "text_charAt";
  KnownBlocklyTypes["text_getSubstring"] = "text_getSubstring";
  KnownBlocklyTypes["text_changeCase"] = "text_changeCase";
  KnownBlocklyTypes["text_trim"] = "text_trim";
  KnownBlocklyTypes["text_print"] = "text_print";
  KnownBlocklyTypes["text_prompt_ext"] = "text_prompt_ext";
  KnownBlocklyTypes["lists_create_with"] = "lists_create_with";
  KnownBlocklyTypes["lists_repeat"] = "lists_repeat";
  KnownBlocklyTypes["lists_length"] = "lists_length";
  KnownBlocklyTypes["lists_isEmpty"] = "lists_isEmpty";
  KnownBlocklyTypes["lists_indexOf"] = "lists_indexOf";
  KnownBlocklyTypes["lists_getIndex"] = "lists_getIndex";
  KnownBlocklyTypes["lists_setIndex"] = "lists_setIndex";
  KnownBlocklyTypes["lists_getSublist"] = "lists_getSublist";
  KnownBlocklyTypes["lists_split"] = "lists_split";
  KnownBlocklyTypes["lists_sort"] = "lists_sort";
  KnownBlocklyTypes["colour_picker"] = "colour_picker";
  KnownBlocklyTypes["colour_random"] = "colour_random";
  KnownBlocklyTypes["colour_rgb"] = "colour_rgb";
  KnownBlocklyTypes["colour_blend"] = "colour_blend";
})(KnownBlocklyTypes || (KnownBlocklyTypes = {}));

/***/ }),

/***/ "b42e":
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ "b4f8":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var getBuiltIn = __webpack_require__("d066");
var hasOwn = __webpack_require__("1a2d");
var toString = __webpack_require__("577e");
var shared = __webpack_require__("5692");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__("0b43");

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});


/***/ }),

/***/ "b575":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var bind = __webpack_require__("0366");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var macrotask = __webpack_require__("2cf4").set;
var Queue = __webpack_require__("01b4");
var IS_IOS = __webpack_require__("1cdc");
var IS_IOS_PEBBLE = __webpack_require__("d4c3");
var IS_WEBOS_WEBKIT = __webpack_require__("a4b4");
var IS_NODE = __webpack_require__("605d");

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var microtask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!microtask) {
  var queue = new Queue();

  var flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (fn = queue.get()) try {
      fn();
    } catch (error) {
      if (queue.head) notify();
      throw error;
    }
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (!IS_IOS_PEBBLE && Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    // workaround of WebKit ~ iOS Safari 10.1 bug
    promise.constructor = Promise;
    then = bind(promise.then, promise);
    notify = function () {
      then(flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessage
  // - onreadystatechange
  // - setTimeout
  } else {
    // `webpack` dev server bug on IE global methods - use bind(fn, global)
    macrotask = bind(macrotask, global);
    notify = function () {
      macrotask(flush);
    };
  }

  microtask = function (fn) {
    if (!queue.head) notify();
    queue.add(fn);
  };
}

module.exports = microtask;


/***/ }),

/***/ "b622":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var shared = __webpack_require__("5692");
var hasOwn = __webpack_require__("1a2d");
var uid = __webpack_require__("90e3");
var NATIVE_SYMBOL = __webpack_require__("04f8");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "b636":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("e065");

// `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');


/***/ }),

/***/ "b64b":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var toObject = __webpack_require__("7b0b");
var nativeKeys = __webpack_require__("df75");
var fails = __webpack_require__("d039");

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "b680":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("e330");
var toIntegerOrInfinity = __webpack_require__("5926");
var thisNumberValue = __webpack_require__("408a");
var $repeat = __webpack_require__("1148");
var fails = __webpack_require__("d039");

var $RangeError = RangeError;
var $String = String;
var floor = Math.floor;
var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);
var nativeToFixed = uncurryThis(1.0.toFixed);

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var multiply = function (data, n, c) {
  var index = -1;
  var c2 = c;
  while (++index < 6) {
    c2 += n * data[index];
    data[index] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (data, n) {
  var index = 6;
  var c = 0;
  while (--index >= 0) {
    c += data[index];
    data[index] = floor(c / n);
    c = (c % n) * 1e7;
  }
};

var dataToString = function (data) {
  var index = 6;
  var s = '';
  while (--index >= 0) {
    if (s !== '' || index === 0 || data[index] !== 0) {
      var t = $String(data[index]);
      s = s === '' ? t : s + repeat('0', 7 - t.length) + t;
    }
  } return s;
};

var FORCED = fails(function () {
  return nativeToFixed(0.00008, 3) !== '0.000' ||
    nativeToFixed(0.9, 0) !== '1' ||
    nativeToFixed(1.255, 2) !== '1.25' ||
    nativeToFixed(1000000000000000128.0, 0) !== '1000000000000000128';
}) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed({});
});

// `Number.prototype.toFixed` method
// https://tc39.es/ecma262/#sec-number.prototype.tofixed
$({ target: 'Number', proto: true, forced: FORCED }, {
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toIntegerOrInfinity(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    // TODO: ES2018 increased the maximum number of fraction digits to 100, need to improve the implementation
    if (fractDigits < 0 || fractDigits > 20) throw $RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare -- NaN check
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return $String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(data, 0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(data, 1e7, 0);
          j -= 7;
        }
        multiply(data, pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(data, 1 << 23);
          j -= 23;
        }
        divide(data, 1 << j);
        multiply(data, 1, 1);
        divide(data, 2);
        result = dataToString(data);
      } else {
        multiply(data, 0, z);
        multiply(data, 1 << -e, 0);
        result = dataToString(data) + repeat('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + repeat('0', fractDigits - k) + result
        : stringSlice(result, 0, k - fractDigits) + '.' + stringSlice(result, k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});


/***/ }),

/***/ "b6b7":
/***/ (function(module, exports, __webpack_require__) {

var ArrayBufferViewCore = __webpack_require__("ebb5");
var speciesConstructor = __webpack_require__("4840");

var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;

// a part of `TypedArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#typedarray-species-create
module.exports = function (originalArray) {
  return aTypedArrayConstructor(speciesConstructor(originalArray, getTypedArrayConstructor(originalArray)));
};


/***/ }),

/***/ "b6fc":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "b727":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("0366");
var uncurryThis = __webpack_require__("e330");
var IndexedObject = __webpack_require__("44ad");
var toObject = __webpack_require__("7b0b");
var lengthOfArrayLike = __webpack_require__("07fa");
var arraySpeciesCreate = __webpack_require__("65f0");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "b7fa":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    dark: {
      type: Boolean,
      default: null
    }
  },
  computed: {
    isDark: function isDark() {
      return this.dark === null ? this.$q.dark.isActive : this.dark;
    }
  }
});

/***/ }),

/***/ "b980":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = !fails(function () {
  var error = Error('a');
  if (!('stack' in error)) return true;
  // eslint-disable-next-line es/no-object-defineproperty -- safe
  Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));
  return error.stack !== 7;
});


/***/ }),

/***/ "ba2b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_eaf51832_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ca1f");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_eaf51832_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_eaf51832_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "bb2f":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "bcbf":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("f5df");

module.exports = function (it) {
  var klass = classof(it);
  return klass == 'BigInt64Array' || klass == 'BigUint64Array';
};


/***/ }),

/***/ "bcd4":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "bd58":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "be02":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_DataBlock_vue_vue_type_style_index_0_id_0deb24d0_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1ec8");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_DataBlock_vue_vue_type_style_index_0_id_0deb24d0_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_DataBlock_vue_vue_type_style_index_0_id_0deb24d0_prod_lang_sass_scoped_true___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "bee2":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _createClass; });
/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a38e");

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, Object(_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

/***/ }),

/***/ "c00e":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "c04e":
/***/ (function(module, exports, __webpack_require__) {

var call = __webpack_require__("c65b");
var isObject = __webpack_require__("861d");
var isSymbol = __webpack_require__("d9b5");
var getMethod = __webpack_require__("dc4a");
var ordinaryToPrimitive = __webpack_require__("485a");
var wellKnownSymbol = __webpack_require__("b622");

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "c0a8":
/***/ (function(module) {

module.exports = JSON.parse("{\"a\":\"1.22.10\"}");

/***/ }),

/***/ "c19f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var arrayBufferModule = __webpack_require__("621a");
var setSpecies = __webpack_require__("2626");

var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = global[ARRAY_BUFFER];

// `ArrayBuffer` constructor
// https://tc39.es/ecma262/#sec-arraybuffer-constructor
$({ global: true, constructor: true, forced: NativeArrayBuffer !== ArrayBuffer }, {
  ArrayBuffer: ArrayBuffer
});

setSpecies(ARRAY_BUFFER);


/***/ }),

/***/ "c1ac":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $filter = __webpack_require__("b727").filter;
var fromSpeciesAndList = __webpack_require__("1448");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.filter` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  return fromSpeciesAndList(this, list);
});


/***/ }),

/***/ "c382":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "c39d":
/***/ (function(module, exports, __webpack_require__) {

var clone = __webpack_require__("9a2b");

module.exports = function(options, defaults) {
  options = options || {};

  Object.keys(defaults).forEach(function(key) {
    if (typeof options[key] === 'undefined') {
      options[key] = clone(defaults[key]);
    }
  });

  return options;
};

/***/ }),

/***/ "c430":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "c474":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _utils_private_selection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f249");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("d882");
/* harmony import */ var _utils_dom_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("f303");
/* harmony import */ var _utils_private_key_composition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("dc8a");




/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    target: {
      default: true
    },
    noParentEvent: Boolean,
    contextMenu: Boolean
  },
  watch: {
    contextMenu: function contextMenu(val) {
      if (this.anchorEl !== void 0) {
        this.__unconfigureAnchorEl();
        this.__configureAnchorEl(val);
      }
    },
    target: function target() {
      if (this.anchorEl !== void 0) {
        this.__unconfigureAnchorEl();
      }
      this.__pickAnchorEl();
    },
    noParentEvent: function noParentEvent(val) {
      if (this.anchorEl !== void 0) {
        if (val === true) {
          this.__unconfigureAnchorEl();
        } else {
          this.__configureAnchorEl();
        }
      }
    }
  },
  methods: {
    __showCondition: function __showCondition(evt) {
      // abort with no parent configured or on multi-touch
      if (this.anchorEl === void 0) {
        return false;
      }
      if (evt === void 0) {
        return true;
      }
      return evt.touches === void 0 || evt.touches.length <= 1;
    },
    __contextClick: function __contextClick(evt) {
      var _this = this;
      this.hide(evt);
      this.$nextTick(function () {
        _this.show(evt);
      });
      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* prevent */ "h"])(evt);
    },
    __toggleKey: function __toggleKey(evt) {
      Object(_utils_private_key_composition_js__WEBPACK_IMPORTED_MODULE_3__[/* isKeyCode */ "a"])(evt, 13) === true && this.toggle(evt);
    },
    __mobileCleanup: function __mobileCleanup(evt) {
      this.anchorEl.classList.remove('non-selectable');
      clearTimeout(this.touchTimer);
      if (this.showing === true && evt !== void 0) {
        Object(_utils_private_selection_js__WEBPACK_IMPORTED_MODULE_0__[/* clearSelection */ "a"])();
      }
    },
    __mobilePrevent: _utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* prevent */ "h"],
    __mobileTouch: function __mobileTouch(evt) {
      var _this2 = this;
      this.__mobileCleanup(evt);
      if (this.__showCondition(evt) !== true) {
        return;
      }
      this.hide(evt);
      this.anchorEl.classList.add('non-selectable');
      var target = evt.target;
      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* addEvt */ "a"])(this, 'anchor', [[target, 'touchmove', '__mobileCleanup', 'passive'], [target, 'touchend', '__mobileCleanup', 'passive'], [target, 'touchcancel', '__mobileCleanup', 'passive'], [this.anchorEl, 'contextmenu', '__mobilePrevent', 'notPassive']]);
      this.touchTimer = setTimeout(function () {
        _this2.show(evt);
      }, 300);
    },
    __unconfigureAnchorEl: function __unconfigureAnchorEl() {
      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* cleanEvt */ "b"])(this, 'anchor');
    },
    __configureAnchorEl: function __configureAnchorEl() {
      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.contextMenu;
      if (this.noParentEvent === true || this.anchorEl === void 0) {
        return;
      }
      var evts;
      if (context === true) {
        if (this.$q.platform.is.mobile === true) {
          evts = [[this.anchorEl, 'touchstart', '__mobileTouch', 'passive']];
        } else {
          evts = [[this.anchorEl, 'click', 'hide', 'passive'], [this.anchorEl, 'contextmenu', '__contextClick', 'notPassive']];
        }
      } else {
        evts = [[this.anchorEl, 'click', 'toggle', 'passive'], [this.anchorEl, 'keyup', '__toggleKey', 'passive']];
      }
      Object(_utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* addEvt */ "a"])(this, 'anchor', evts);
    },
    __setAnchorEl: function __setAnchorEl(el) {
      this.anchorEl = el;
      while (this.anchorEl.classList.contains('q-anchor--skip')) {
        this.anchorEl = this.anchorEl.parentNode;
      }
      this.__configureAnchorEl();
    },
    __pickAnchorEl: function __pickAnchorEl() {
      if (this.target === false || this.target === '' || this.parentEl === null) {
        this.anchorEl = void 0;
      } else if (this.target === true) {
        this.__setAnchorEl(this.parentEl);
      } else {
        this.anchorEl = Object(_utils_dom_js__WEBPACK_IMPORTED_MODULE_2__[/* getElement */ "d"])(this.target) || void 0;
        if (this.anchorEl !== void 0) {
          this.__configureAnchorEl();
        } else {
          console.error("Anchor: target \"".concat(this.target, "\" not found"), this);
        }
      }
    },
    __changeScrollEvent: function __changeScrollEvent(scrollTarget, fn) {
      var fnProp = "".concat(fn !== void 0 ? 'add' : 'remove', "EventListener");
      var fnHandler = fn !== void 0 ? fn : this.__scrollFn;
      if (scrollTarget !== window) {
        scrollTarget[fnProp]('scroll', fnHandler, _utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* listenOpts */ "e"].passive);
      }
      window[fnProp]('scroll', fnHandler, _utils_event_js__WEBPACK_IMPORTED_MODULE_1__[/* listenOpts */ "e"].passive);
      this.__scrollFn = fn;
    }
  },
  created: function created() {
    var _this3 = this;
    if (typeof this.__configureScrollTarget === 'function' && typeof this.__unconfigureScrollTarget === 'function') {
      this.noParentEventWatcher = this.$watch('noParentEvent', function () {
        if (_this3.__scrollTarget !== void 0) {
          _this3.__unconfigureScrollTarget();
          _this3.__configureScrollTarget();
        }
      });
    }
  },
  mounted: function mounted() {
    this.parentEl = this.$el.parentNode;
    this.__pickAnchorEl();
    if (this.value === true && this.anchorEl === void 0) {
      this.$emit('input', false);
    }
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.touchTimer);
    this.noParentEventWatcher !== void 0 && this.noParentEventWatcher();
    this.__anchorCleanup !== void 0 && this.__anchorCleanup();
    this.__unconfigureAnchorEl();
  }
});

/***/ }),

/***/ "c513":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var hasOwn = __webpack_require__("1a2d");
var isSymbol = __webpack_require__("d9b5");
var tryToString = __webpack_require__("0d51");
var shared = __webpack_require__("5692");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__("0b43");

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});


/***/ }),

/***/ "c607":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var UNSUPPORTED_DOT_ALL = __webpack_require__("fce3");
var classof = __webpack_require__("c6b6");
var defineBuiltInAccessor = __webpack_require__("edd0");
var getInternalState = __webpack_require__("69f3").get;

var RegExpPrototype = RegExp.prototype;
var $TypeError = TypeError;

// `RegExp.prototype.dotAll` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.dotall
if (DESCRIPTORS && UNSUPPORTED_DOT_ALL) {
  defineBuiltInAccessor(RegExpPrototype, 'dotAll', {
    configurable: true,
    get: function dotAll() {
      if (this === RegExpPrototype) return undefined;
      // We can't use InternalStateModule.getterFor because
      // we don't add metadata for regexps created by a literal.
      if (classof(this) === 'RegExp') {
        return !!getInternalState(this).dotAll;
      }
      throw $TypeError('Incompatible receiver, RegExp required');
    }
  });
}


/***/ }),

/***/ "c65b":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__("40d5");

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "c6a7":
/***/ (function(module, exports) {

/* global Bun -- Deno case */
module.exports = typeof Bun == 'function' && Bun && typeof Bun.version == 'string';


/***/ }),

/***/ "c6b6":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "c6cd":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var defineGlobalProperty = __webpack_require__("6374");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ "c6d2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var call = __webpack_require__("c65b");
var IS_PURE = __webpack_require__("c430");
var FunctionName = __webpack_require__("5e77");
var isCallable = __webpack_require__("1626");
var createIteratorConstructor = __webpack_require__("dcc3");
var getPrototypeOf = __webpack_require__("e163");
var setPrototypeOf = __webpack_require__("d2bb");
var setToStringTag = __webpack_require__("d44e");
var createNonEnumerableProperty = __webpack_require__("9112");
var defineBuiltIn = __webpack_require__("cb2d");
var wellKnownSymbol = __webpack_require__("b622");
var Iterators = __webpack_require__("3f8c");
var IteratorsCore = __webpack_require__("ae93");

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ "c73d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var defineBuiltInAccessor = __webpack_require__("edd0");
var DESCRIPTORS = __webpack_require__("83ab");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var INCORRECT_VALUE = global.self !== global;

// `self` getter
// https://html.spec.whatwg.org/multipage/window-object.html#dom-self
try {
  if (DESCRIPTORS) {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    var descriptor = Object.getOwnPropertyDescriptor(global, 'self');
    // some engines have `self`, but with incorrect descriptor
    // https://github.com/denoland/deno/issues/15765
    if (INCORRECT_VALUE || !descriptor || !descriptor.get || !descriptor.enumerable) {
      defineBuiltInAccessor(global, 'self', {
        get: function self() {
          return global;
        },
        set: function self(value) {
          if (this !== global) throw $TypeError('Illegal invocation');
          defineProperty(global, 'self', {
            value: value,
            writable: true,
            configurable: true,
            enumerable: true
          });
        },
        configurable: true,
        enumerable: true
      });
    }
  } else $({ global: true, simple: true, forced: INCORRECT_VALUE }, {
    self: global
  });
} catch (error) { /* empty */ }


/***/ }),

/***/ "c740":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $findIndex = __webpack_require__("b727").findIndex;
var addToUnscopables = __webpack_require__("44d2");

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
// eslint-disable-next-line es/no-array-prototype-findindex -- testing
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);


/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "c8d2":
/***/ (function(module, exports, __webpack_require__) {

var PROPER_FUNCTION_NAME = __webpack_require__("5e77").PROPER;
var fails = __webpack_require__("d039");
var whitespaces = __webpack_require__("5899");

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]()
      || non[METHOD_NAME]() !== non
      || (PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME);
  });
};


/***/ }),

/***/ "ca0c":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "ca1f":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "ca84":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var hasOwn = __webpack_require__("1a2d");
var toIndexedObject = __webpack_require__("fc6a");
var indexOf = __webpack_require__("4d64").indexOf;
var hiddenKeys = __webpack_require__("d012");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "ca91":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $reduce = __webpack_require__("d58f").left;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduce` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
  var length = arguments.length;
  return $reduce(aTypedArray(this), callbackfn, length, length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "caad":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $includes = __webpack_require__("4d64").includes;
var fails = __webpack_require__("d039");
var addToUnscopables = __webpack_require__("44d2");

// FF99+ bug
var BROKEN_ON_SPARSE = fails(function () {
  // eslint-disable-next-line es/no-array-prototype-includes -- detection
  return !Array(1).includes();
});

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "cb2d":
/***/ (function(module, exports, __webpack_require__) {

var isCallable = __webpack_require__("1626");
var definePropertyModule = __webpack_require__("9bf2");
var makeBuiltIn = __webpack_require__("13d2");
var defineGlobalProperty = __webpack_require__("6374");

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ "cc10":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "cc12":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "cc98":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var IS_PURE = __webpack_require__("c430");
var FORCED_PROMISE_CONSTRUCTOR = __webpack_require__("4738").CONSTRUCTOR;
var NativePromiseConstructor = __webpack_require__("d256");
var getBuiltIn = __webpack_require__("d066");
var isCallable = __webpack_require__("1626");
var defineBuiltIn = __webpack_require__("cb2d");

var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

// `Promise.prototype.catch` method
// https://tc39.es/ecma262/#sec-promise.prototype.catch
$({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
  'catch': function (onRejected) {
    return this.then(undefined, onRejected);
  }
});

// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
if (!IS_PURE && isCallable(NativePromiseConstructor)) {
  var method = getBuiltIn('Promise').prototype['catch'];
  if (NativePromisePrototype['catch'] !== method) {
    defineBuiltIn(NativePromisePrototype, 'catch', method, { unsafe: true });
  }
}


/***/ }),

/***/ "cca6":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var assign = __webpack_require__("60da");

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing
$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {
  assign: assign
});


/***/ }),

/***/ "cd26":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});


/***/ }),

/***/ "cdce":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ "cdf9":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var isObject = __webpack_require__("861d");
var newPromiseCapability = __webpack_require__("f069");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "d012":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "d039":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "d066":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "d139":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $find = __webpack_require__("b727").find;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.find` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "d1e7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "d256":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = global.Promise;


/***/ }),

/***/ "d28b":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("e065");

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "d2bb":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__("7282");
var anObject = __webpack_require__("825a");
var aPossiblePrototype = __webpack_require__("3bbe");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "d3b7":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var defineBuiltIn = __webpack_require__("cb2d");
var toString = __webpack_require__("b041");

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  defineBuiltIn(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "d429":
/***/ (function(module, exports, __webpack_require__) {

var lengthOfArrayLike = __webpack_require__("07fa");
var toIntegerOrInfinity = __webpack_require__("5926");

var $RangeError = RangeError;

// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.with
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.with
module.exports = function (O, C, index, value) {
  var len = lengthOfArrayLike(O);
  var relativeIndex = toIntegerOrInfinity(index);
  var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
  if (actualIndex >= len || actualIndex < 0) throw $RangeError('Incorrect index');
  var A = new C(len);
  var k = 0;
  for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];
  return A;
};


/***/ }),

/***/ "d44e":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("9bf2").f;
var hasOwn = __webpack_require__("1a2d");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (target, TAG, STATIC) {
  if (target && !STATIC) target = target.prototype;
  if (target && !hasOwn(target, TO_STRING_TAG)) {
    defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "d4c3":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");

module.exports = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != 'undefined';


/***/ }),

/***/ "d4ec":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _classCallCheck; });
/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d9e2");
/* harmony import */ var core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_error_cause_js__WEBPACK_IMPORTED_MODULE_0__);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "d54d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return cache; });
/* unused harmony export cacheWithFn */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getPropCacheMixin; });
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ade3");
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0967");


function cache(vm, key, obj) {
  if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_1__[/* isSSR */ "e"] === true) return obj;
  var k = "__qcache_".concat(key);
  return vm[k] === void 0 ? vm[k] = obj : vm[k];
}
function cacheWithFn(vm, key, fn) {
  if (_plugins_Platform_js__WEBPACK_IMPORTED_MODULE_1__[/* isSSR */ "e"] === true) return fn();
  var k = "__qcache_".concat(key);
  return vm[k] === void 0 ? vm[k] = fn() : vm[k];
}
function getPropCacheMixin(propName, proxyPropName) {
  return {
    data: function data() {
      var target = {};
      var source = this[propName];
      for (var prop in source) {
        target[prop] = source[prop];
      }
      return Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, proxyPropName, target);
    },
    watch: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_defineProperty_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, propName, function (newObj, oldObj) {
      var target = this[proxyPropName];
      if (oldObj !== void 0) {
        // we first delete obsolete events
        for (var prop in oldObj) {
          if (newObj[prop] === void 0) {
            this.$delete(target, prop);
          }
        }
      }
      for (var _prop in newObj) {
        // we then update changed events
        if (target[_prop] !== newObj[_prop]) {
          this.$set(target, _prop, newObj[_prop]);
        }
      }
    })
  };
}

/***/ }),

/***/ "d58f":
/***/ (function(module, exports, __webpack_require__) {

var aCallable = __webpack_require__("59ed");
var toObject = __webpack_require__("7b0b");
var IndexedObject = __webpack_require__("44ad");
var lengthOfArrayLike = __webpack_require__("07fa");

var $TypeError = TypeError;

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aCallable(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(O);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw $TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ "d5d6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $forEach = __webpack_require__("b727").forEach;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.forEach` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "d5db":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "d6d6":
/***/ (function(module, exports) {

var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ "d784":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__("ac1f");
var uncurryThis = __webpack_require__("4625");
var defineBuiltIn = __webpack_require__("cb2d");
var regexpExec = __webpack_require__("9263");
var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var createNonEnumerableProperty = __webpack_require__("9112");

var SPECIES = wellKnownSymbol('species');
var RegExpPrototype = RegExp.prototype;

module.exports = function (KEY, exec, FORCED, SHAM) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    FORCED
  ) {
    var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      var uncurriedNativeMethod = uncurryThis(nativeMethod);
      var $exec = regexp.exec;
      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
        }
        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
      }
      return { done: false };
    });

    defineBuiltIn(String.prototype, KEY, methods[0]);
    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
  }

  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ "d81d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $map = __webpack_require__("b727").map;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "d86b":
/***/ (function(module, exports, __webpack_require__) {

// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it
var fails = __webpack_require__("d039");

module.exports = fails(function () {
  if (typeof ArrayBuffer == 'function') {
    var buffer = new ArrayBuffer(8);
    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe
    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });
  }
});


/***/ }),

/***/ "d882":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return listenOpts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return noop; });
/* unused harmony export leftClick */
/* unused harmony export middleClick */
/* unused harmony export rightClick */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return position; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getEventPath; });
/* unused harmony export getMouseWheelDistance */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return stop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return prevent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return stopAndPrevent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return stopAndPreventClick; });
/* unused harmony export preventDraggable */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addEvt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return cleanEvt; });
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("cca6");
/* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("14d9");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("159b");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("99af");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_4__);





var listenOpts = {
  hasPassive: false,
  passiveCapture: true,
  notPassiveCapture: true
};
try {
  var opts = Object.defineProperty({}, 'passive', {
    get: function get() {
      Object.assign(listenOpts, {
        hasPassive: true,
        passive: {
          passive: true
        },
        notPassive: {
          passive: false
        },
        passiveCapture: {
          passive: true,
          capture: true
        },
        notPassiveCapture: {
          passive: false,
          capture: true
        }
      });
    }
  });
  window.addEventListener('qtest', null, opts);
  window.removeEventListener('qtest', null, opts);
} catch (e) {}
function noop() {}
function leftClick(e) {
  return e.button === 0;
}
function middleClick(e) {
  return e.button === 1;
}
function rightClick(e) {
  return e.button === 2;
}
function position(e) {
  if (e.touches && e.touches[0]) {
    e = e.touches[0];
  } else if (e.changedTouches && e.changedTouches[0]) {
    e = e.changedTouches[0];
  } else if (e.targetTouches && e.targetTouches[0]) {
    e = e.targetTouches[0];
  }
  return {
    top: e.clientY,
    left: e.clientX
  };
}
function getEventPath(e) {
  if (e.path) {
    return e.path;
  }
  if (e.composedPath) {
    return e.composedPath();
  }
  var path = [];
  var el = e.target;
  while (el) {
    path.push(el);
    if (el.tagName === 'HTML') {
      path.push(document);
      path.push(window);
      return path;
    }
    el = el.parentElement;
  }
}

// Reasonable defaults
var LINE_HEIGHT = 40,
  PAGE_HEIGHT = 800;
function getMouseWheelDistance(e) {
  var x = e.deltaX,
    y = e.deltaY;
  if ((x || y) && e.deltaMode) {
    var multiplier = e.deltaMode === 1 ? LINE_HEIGHT : PAGE_HEIGHT;
    x *= multiplier;
    y *= multiplier;
  }
  if (e.shiftKey && !x) {
    var _ref = [x, y];
    y = _ref[0];
    x = _ref[1];
  }
  return {
    x: x,
    y: y
  };
}
function stop(e) {
  e.stopPropagation();
}
function prevent(e) {
  e.cancelable !== false && e.preventDefault();
}
function stopAndPrevent(e) {
  e.cancelable !== false && e.preventDefault();
  e.stopPropagation();
}
function stopAndPreventClick(evt) {
  stopAndPrevent(evt);
  if (evt.type === 'mousedown') {
    var handler = function handler(e) {
      e.target === evt.target && stopAndPrevent(e);
      document.removeEventListener('click', handler, listenOpts.notPassiveCapture);
    };
    document.addEventListener('click', handler, listenOpts.notPassiveCapture);
  }
}
function preventDraggable(el, status) {
  if (el === void 0 || status === true && el.__dragPrevented === true) {
    return;
  }
  var fn = status === true ? function (el) {
    el.__dragPrevented = true;
    el.addEventListener('dragstart', prevent, listenOpts.notPassiveCapture);
  } : function (el) {
    delete el.__dragPrevented;
    el.removeEventListener('dragstart', prevent, listenOpts.notPassiveCapture);
  };
  el.querySelectorAll('a, img').forEach(fn);
}
function create(name) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref2$bubbles = _ref2.bubbles,
    bubbles = _ref2$bubbles === void 0 ? false : _ref2$bubbles,
    _ref2$cancelable = _ref2.cancelable,
    cancelable = _ref2$cancelable === void 0 ? false : _ref2$cancelable;
  try {
    return new CustomEvent(name, {
      bubbles: bubbles,
      cancelable: cancelable
    });
  } catch (e) {
    // IE doesn't support `new Event()`, so...
    var evt = document.createEvent('Event');
    evt.initEvent(name, bubbles, cancelable);
    return evt;
  }
}
function addEvt(ctx, targetName, events) {
  var name = "__q_".concat(targetName, "_evt");
  ctx[name] = ctx[name] !== void 0 ? ctx[name].concat(events) : events;
  events.forEach(function (evt) {
    evt[0].addEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
  });
}
function cleanEvt(ctx, targetName) {
  var name = "__q_".concat(targetName, "_evt");
  if (ctx[name] !== void 0) {
    ctx[name].forEach(function (evt) {
      evt[0].removeEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
    });
    ctx[name] = void 0;
  }
}

/*
 * also update /types/utils/event.d.ts
 */

/* unused harmony default export */ var _unused_webpack_default_export = ({
  listenOpts: listenOpts,
  leftClick: leftClick,
  middleClick: middleClick,
  rightClick: rightClick,
  position: position,
  getEventPath: getEventPath,
  getMouseWheelDistance: getMouseWheelDistance,
  stop: stop,
  prevent: prevent,
  stopAndPrevent: stopAndPrevent,
  preventDraggable: preventDraggable,
  create: create
});

/***/ }),

/***/ "d8af":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "d967":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _isNativeReflectConstruct; });
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_reflect_to_string_tag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("f8c9");
/* harmony import */ var core_js_modules_es_reflect_to_string_tag_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_reflect_to_string_tag_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("4ae1");
/* harmony import */ var core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_reflect_construct_js__WEBPACK_IMPORTED_MODULE_2__);



function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

/***/ }),

/***/ "d998":
/***/ (function(module, exports, __webpack_require__) {

var UA = __webpack_require__("342f");

module.exports = /MSIE|Trident/.test(UA);


/***/ }),

/***/ "d9b5":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");
var isCallable = __webpack_require__("1626");
var isPrototypeOf = __webpack_require__("3a9b");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ "d9d0":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof=__webpack_require__("7037").default;__webpack_require__("14d9");__webpack_require__("ac1f");__webpack_require__("00b4");__webpack_require__("d3b7");__webpack_require__("25f0");__webpack_require__("a3a2");__webpack_require__("b680");__webpack_require__("fb6a");__webpack_require__("a15b");__webpack_require__("a434");__webpack_require__("c73d");__webpack_require__("d9e2");__webpack_require__("13d5");__webpack_require__("d81d");__webpack_require__("e260");__webpack_require__("4ec9");__webpack_require__("3ca3");__webpack_require__("ddb0");__webpack_require__("159b");__webpack_require__("498a");__webpack_require__("a9e3");__webpack_require__("466d");__webpack_require__("1276");__webpack_require__("2c3e");__webpack_require__("4d63");__webpack_require__("c607");__webpack_require__("5319");__webpack_require__("b0c0");__webpack_require__("7db0");__webpack_require__("4de4");__webpack_require__("e439");__webpack_require__("b64b");__webpack_require__("99af");__webpack_require__("e9c4");__webpack_require__("a4d3");__webpack_require__("e01a");__webpack_require__("d28b");__webpack_require__("2351");__webpack_require__("2a1b");__webpack_require__("80e0");__webpack_require__("6b9e");__webpack_require__("841c");__webpack_require__("33d1");__webpack_require__("ea98");__webpack_require__("130f");__webpack_require__("2b3d");__webpack_require__("9861");__webpack_require__("5494");/**@license
 *       __ _____                     ________                              __
 *      / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___  / /
 *  __ / // // // // // _  // _// // / / // _  // _//     // //  \/ // _ \/ /
 * /  / // // // // // ___// / / // / / // ___// / / / / // // /\  // // / /__
 * \___//____ \\___//____//_/ _\_  / /_//____//_/ /_/ /_//_//_/ /_/ \__\_\___/
 *           \/              /____/                              version 2.31.1
 *
 * This file is part of jQuery Terminal. https://terminal.jcubic.pl
 *
 * Copyright (c) 2010-2021 Jakub T. Jankiewicz <https://jcubic.pl/me>
 * Released under the MIT license
 *
 * Contains:
 *
 * Storage plugin Distributed under the MIT License
 * modified to work from Data URIs that block storage and cookies in Chrome
 * Copyright (c) 2010 Dave Schindler
 *
 * jQuery Timers licenced with the WTFPL
 * <http://jquery.offput.ca/timers/>
 *
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 *
 * jQuery Caret
 * Copyright (c) 2009, Gideon Sireling
 * 3 clause BSD License
 *
 * sprintf.js
 * Copyright (c) 2007-2013 Alexandru Marasteanu <hello at alexei dot ro>
 * licensed under 3 clause BSD license
 *
 * debounce function from Lodash
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * The MIT License
 *
 * emoji regex v9.0.0 by Mathias Bynens
 * MIT license
 *
 * broken image by Sophia Bai from the Noun Project (CC-BY)
 *
 * Date: Thu, 30 Dec 2021 10:56:33 +0000
 */ /* global define, Map */ /* eslint-disable */ /* istanbul ignore next */(function(ctx){var sprintf=function sprintf(){if(!sprintf.cache.hasOwnProperty(arguments[0])){sprintf.cache[arguments[0]]=sprintf.parse(arguments[0]);}return sprintf.format.call(null,sprintf.cache[arguments[0]],arguments);};sprintf.format=function(parse_tree,argv){var cursor=1,tree_length=parse_tree.length,node_type='',arg,output=[],i,k,match,pad,pad_character,pad_length;for(i=0;i<tree_length;i++){node_type=get_type(parse_tree[i]);if(node_type==='string'){output.push(parse_tree[i]);}else if(node_type==='array'){match=parse_tree[i];// convenience purposes only
if(match[2]){// keyword argument
arg=argv[cursor];for(k=0;k<match[2].length;k++){if(!arg.hasOwnProperty(match[2][k])){throw sprintf('[sprintf] property "%s" does not exist',match[2][k]);}arg=arg[match[2][k]];}}else if(match[1]){// positional argument (explicit)
arg=argv[match[1]];}else{// positional argument (implicit)
arg=argv[cursor++];}if(/[^s]/.test(match[8])&&get_type(arg)!=='number'){throw sprintf('[sprintf] expecting number but found %s',get_type(arg));}switch(match[8]){case'b':arg=arg.toString(2);break;case'c':arg=String.fromCharCode(arg);break;case'd':arg=parseInt(arg,10);break;case'e':arg=match[7]?arg.toExponential(match[7]):arg.toExponential();break;case'f':arg=match[7]?parseFloat(arg).toFixed(match[7]):parseFloat(arg);break;case'o':arg=arg.toString(8);break;case's':arg=(arg=String(arg))&&match[7]?arg.slice(0,match[7]):arg;break;case'u':arg=arg>>>0;break;case'x':arg=arg.toString(16);break;case'X':arg=arg.toString(16).toUpperCase();break;}arg=/[def]/.test(match[8])&&match[3]&&arg>=0?' +'+arg:arg;pad_character=match[4]?match[4]==='0'?'0':match[4].charAt(1):' ';pad_length=match[6]-String(arg).length;pad=match[6]?str_repeat(pad_character,pad_length):'';output.push(match[5]?arg+pad:pad+arg);}}return output.join('');};sprintf.cache={};sprintf.parse=function(fmt){var _fmt=fmt,match=[],parse_tree=[],arg_names=0;while(_fmt){if((match=/^[^\x25]+/.exec(_fmt))!==null){parse_tree.push(match[0]);}else if((match=/^\x25{2}/.exec(_fmt))!==null){parse_tree.push('%');}else if((match=/^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt))!==null){if(match[2]){arg_names|=1;var field_list=[],replacement_field=match[2],field_match=[];if((field_match=/^([a-z_][a-z_\d]*)/i.exec(replacement_field))!==null){field_list.push(field_match[1]);while((replacement_field=replacement_field.slice(field_match[0].length))!==''){if((field_match=/^\.([a-z_][a-z_\d]*)/i.exec(replacement_field))!==null){field_list.push(field_match[1]);}else if((field_match=/^\[(\d+)\]/.exec(replacement_field))!==null){field_list.push(field_match[1]);}else{throw'[sprintf] huh?';}}}else{throw'[sprintf] huh?';}match[2]=field_list;}else{arg_names|=2;}if(arg_names===3){throw'[sprintf] mixing positional and named placeholders is not (yet) supported';}parse_tree.push(match);}else{throw'[sprintf] huh?';}_fmt=_fmt.slice(match[0].length);}return parse_tree;};var vsprintf=function vsprintf(fmt,argv,_argv){_argv=argv.slice(0);_argv.splice(0,0,fmt);return sprintf.apply(null,_argv);};/**
     * helpers
     */function get_type(variable){return Object.prototype.toString.call(variable).slice(8,-1).toLowerCase();}function str_repeat(input,multiplier){for(var output=[];multiplier>0;output[--multiplier]=input){/* do nothing */}return output.join('');}/**
     * export to either browser or node.js
     */ctx.sprintf=sprintf;ctx.vsprintf=vsprintf;})(typeof global!=="undefined"?global:self||window);// -----------------------------------------------------------------------
/* eslint-enable */ // UMD taken from https://github.com/umdjs/umd
(function(factory,undefined){var root;if(typeof window!=='undefined'){root=window;}else if(typeof self!=='undefined'){root=self;}else if(typeof global!=='undefined'){root=global;}else{throw new Error('Unknow context');}if(true){// AMD. Register as an anonymous module.
// istanbul ignore next
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("1157"),__webpack_require__("f445")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(jquery,wcwidth){factory(jquery,wcwidth,root);return jquery;}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else {}})(function($,wcwidth,root,undefined){'use strict';// -----------------------------------------------------------------------
// :: debug functions
// -----------------------------------------------------------------------
/* eslint-disable */ /* istanbul ignore next */function debug(str){if(false){}}/* eslint-enable */ // -----------------------------------------------------------------------
// :: Replacemenet for jQuery 2 deferred objects
// -----------------------------------------------------------------------
function DelayQueue(){var callbacks=$.Callbacks();var resolved=false;this.resolve=function(){callbacks.fire();resolved=true;};this.add=function(fn){if(resolved){fn();}else{callbacks.add(fn);}};}// -----------------------------------------------------------------------
// :: map object to object
// -----------------------------------------------------------------------
$.omap=function(o,fn){var result={};$.each(o,function(k,v){result[k]=fn.call(o,k,v);});return result;};$.fn.text_length=function(){return this.map(function(){return $(this).text().length;}).get().reduce(function(a,b){return a+b;},0);};// -----------------------------------------------------------------------
// :: Deep clone of objects and arrays
// -----------------------------------------------------------------------
var Clone={clone_object:function clone_object(object){var tmp={};if(_typeof(object)==='object'){if($.isArray(object)){return this.clone_array(object);}else if(object===null){return object;}else{for(var key in object){if($.isArray(object[key])){tmp[key]=this.clone_array(object[key]);}else if(_typeof(object[key])==='object'){tmp[key]=this.clone_object(object[key]);}else{tmp[key]=object[key];}}}}return tmp;},clone_array:function clone_array(array){if(!is_function(Array.prototype.map)){throw new Error("Your browser don't support ES5 array map "+'use es5-shim');}return array.slice(0).map(function(item){if(_typeof(item)==='object'){return this.clone_object(item);}else{return item;}}.bind(this));}};var clone=function clone(object){return Clone.clone_object(object);};// -----------------------------------------------------------------------
// IE11 polyfill
// -----------------------------------------------------------------------
/* eslint-disable */if('Map'in root&&!('clear'in Map.prototype)){Map.prototype.clear=function(){this.forEach(function(value,key,map){map.delete(key);});};}// -----------------------------------------------------------------------
// :: Storage plugin
// -----------------------------------------------------------------------
var localStorage;/* istanbul ignore next */(function(){var hasLS=function hasLS(){try{var testKey='test',storage=window.localStorage;storage.setItem(testKey,'1');storage.removeItem(testKey);return true;}catch(error){return false;}};var hasCookies=function hasCookies(){try{document.cookie.split(';');return true;}catch(e){return false;}};// Private data
var isLS=hasLS();// Private functions
function wls(n,v){var c;if(typeof n==='string'&&typeof v==='string'){localStorage[n]=v;return true;}else if(_typeof(n)==='object'&&typeof v==='undefined'){for(c in n){if(n.hasOwnProperty(c)){localStorage[c]=n[c];}}return true;}return false;}function wc(n,v){var dt,e,c;dt=new Date();dt.setTime(dt.getTime()+31536000000);e='; expires='+dt.toGMTString();if(typeof n==='string'&&typeof v==='string'){document.cookie=n+'='+v+e+'; path=/';return true;}else if(_typeof(n)==='object'&&typeof v==='undefined'){for(c in n){if(n.hasOwnProperty(c)){document.cookie=c+'='+n[c]+e+'; path=/';}}return true;}return false;}function rls(n){return localStorage[n];}function rc(n){var nn,ca,i,c;nn=n+'=';ca=document.cookie.split(';');for(i=0;i<ca.length;i++){c=ca[i];while(c.charAt(0)===' '){c=c.slice(1,c.length);}if(c.indexOf(nn)===0){return c.slice(nn.length,c.length);}}return null;}function dls(n){return delete localStorage[n];}function dc(n){return wc(n,'',-1);}/**
         * Public API
         * $.Storage.set("name", "value")
         * $.Storage.set({"name1":"value1", "name2":"value2", etc})
         * $.Storage.get("name")
         * $.Storage.remove("name")
         */if(!hasCookies()&&!isLS){localStorage={};$.extend({Storage:{set:wls,get:rls,remove:dls}});}else{if(isLS){localStorage=window.localStorage;}$.extend({Storage:{set:isLS?wls:wc,get:isLS?rls:rc,remove:isLS?dls:dc}});}})();// -----------------------------------------------------------------------
// :: Debounce from Lodash
// -----------------------------------------------------------------------
/* istanbul ignore next */var debounce=function(){var FUNC_ERROR_TEXT='Expected a function';function isObject(value){var type=_typeof(value);return value!=null&&(type=='object'||type=='function');}function now(){return Date.now();}return function debounce(func,wait,options){var nativeMax=Math.max,nativeMin=Math.min;var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=wait||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(options.maxWait||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;};}();// -----------------------------------------------------------------------
// :: jQuery Timers
// -----------------------------------------------------------------------
var jQuery=$;/* istanbul ignore next */(function($){jQuery.fn.extend({everyTime:function everyTime(interval,label,fn,times,belay){return this.each(function(){jQuery.timer.add(this,interval,label,fn,times,belay);});},oneTime:function oneTime(interval,label,fn){return this.each(function(){jQuery.timer.add(this,interval,label,fn,1);});},stopTime:function stopTime(label,fn){return this.each(function(){jQuery.timer.remove(this,label,fn);});}});jQuery.extend({timer:{guid:1,global:{},regex:/^([0-9]+)\s*(.*s)?$/,powers:{// Yeah this is major overkill...
'ms':1,'cs':10,'ds':100,'s':1000,'das':10000,'hs':100000,'ks':1000000},timeParse:function timeParse(value){if(value===undefined||value===null){return null;}var result=this.regex.exec(jQuery.trim(value.toString()));if(result[2]){var num=parseInt(result[1],10);var mult=this.powers[result[2]]||1;return num*mult;}else{return value;}},add:function add(element,interval,label,fn,times,belay){var counter=0;if(jQuery.isFunction(label)){if(!times){times=fn;}fn=label;label=interval;}interval=jQuery.timer.timeParse(interval);if(typeof interval!=='number'||isNaN(interval)||interval<=0){return;}if(times&&times.constructor!==Number){belay=!!times;times=0;}times=times||0;belay=belay||false;if(!element.$timers){element.$timers={};}if(!element.$timers[label]){element.$timers[label]={};}fn.$timerID=fn.$timerID||this.guid++;var handler=function handler(){if(belay&&handler.inProgress){return;}handler.inProgress=true;if(++counter>times&&times!==0||fn.call(element,counter)===false){jQuery.timer.remove(element,label,fn);}handler.inProgress=false;};handler.$timerID=fn.$timerID;if(!element.$timers[label][fn.$timerID]){element.$timers[label][fn.$timerID]=setInterval(handler,interval);}if(!this.global[label]){this.global[label]=[];}this.global[label].push(element);},remove:function remove(element,label,fn){var timers=element.$timers,ret;if(timers){if(!label){for(var lab in timers){if(timers.hasOwnProperty(lab)){this.remove(element,lab,fn);}}}else if(timers[label]){if(fn){if(fn.$timerID){clearInterval(timers[label][fn.$timerID]);delete timers[label][fn.$timerID];}}else{for(var _fn in timers[label]){if(timers[label].hasOwnProperty(_fn)){clearInterval(timers[label][_fn]);delete timers[label][_fn];}}}for(ret in timers[label]){if(timers[label].hasOwnProperty(ret)){break;}}if(!ret){ret=null;delete timers[label];}}for(ret in timers){if(timers.hasOwnProperty(ret)){break;}}if(!ret){element.$timers=null;}}}}});if(/(msie) ([\w.]+)/.exec(navigator.userAgent.toLowerCase())){$(window).one('unload',function(){var global=jQuery.timer.global;for(var label in global){if(global.hasOwnProperty(label)){var els=global[label],i=els.length;while(--i){jQuery.timer.remove(els[i],label);}}}});}})(jQuery);// -----------------------------------------------------------------------
// :: CROSS BROWSER SPLIT
// -----------------------------------------------------------------------
/* istanbul ignore next */(function(undef){// prevent double include
if(!String.prototype.split.toString().match(/\[native/)){return;}var nativeSplit=String.prototype.split,compliantExecNpcg=/()??/.exec("")[1]===undef,// NPCG: nonparticipating capturing group
self;self=function self(str,separator,limit){// If `separator` is not a regex, use `nativeSplit`
if(Object.prototype.toString.call(separator)!=="[object RegExp]"){return nativeSplit.call(str,separator,limit);}var output=[],flags=(separator.ignoreCase?"i":"")+(separator.multiline?"m":"")+(separator.extended?"x":"")+(// Proposed for ES6
separator.sticky?"y":""),// Firefox 3+
lastLastIndex=0,// Make `global` and avoid `lastIndex` issues by working with a copy
separator2,match,lastIndex,lastLength;separator=new RegExp(separator.source,flags+"g");str+="";// Type-convert
if(!compliantExecNpcg){// Doesn't need flags gy, but they don't hurt
separator2=new RegExp("^"+separator.source+"$(?!\\s)",flags);}/* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */ // ? Math.pow(2, 32) - 1 : ToUint32(limit)
limit=limit===undef?-1>>>0:limit>>>0;while(match=separator.exec(str)){// `separator.lastIndex` is not reliable cross-browser
lastIndex=match.index+match[0].length;if(lastIndex>lastLastIndex){output.push(str.slice(lastLastIndex,match.index));// Fix browsers whose `exec` methods don't consistently return `undefined` for
// nonparticipating capturing groups
if(!compliantExecNpcg&&match.length>1){match[0].replace(separator2,function(){for(var i=1;i<arguments.length-2;i++){if(arguments[i]===undef){match[i]=undef;}}});}if(match.length>1&&match.index<str.length){Array.prototype.push.apply(output,match.slice(1));}lastLength=match[0].length;lastLastIndex=lastIndex;if(output.length>=limit){break;}}if(separator.lastIndex===match.index){separator.lastIndex++;// Avoid an infinite loop
}}if(lastLastIndex===str.length){if(lastLength||!separator.test("")){output.push("");}}else{output.push(str.slice(lastLastIndex));}return output.length>limit?output.slice(0,limit):output;};// For convenience
String.prototype.split=function(separator,limit){return self(this,separator,limit);};return self;})();// -----------------------------------------------------------------------
// :: jQuery Caret
// -----------------------------------------------------------------------
/* istanbul ignore next */$.fn.caret=function(pos){var target=this[0];var isContentEditable=target.contentEditable==='true';//get
if(arguments.length===0){//HTML5
if(window.getSelection){//contenteditable
if(isContentEditable){if(!this.is(':focus')){target.focus();}var range1=window.getSelection().getRangeAt(0),range2=range1.cloneRange();range2.selectNodeContents(target);range2.setEnd(range1.endContainer,range1.endOffset);return range2.toString().length;}//textarea
return target.selectionStart;}//IE<9
if(document.selection){target.focus();//contenteditable
if(isContentEditable){var range1=document.selection.createRange(),range2=document.body.createTextRange();range2.moveToElementText(target);range2.setEndPoint('EndToEnd',range1);return range2.text.length;}//textarea
var pos=0,range=target.createTextRange(),range2=document.selection.createRange().duplicate(),bookmark=range2.getBookmark();range.moveToBookmark(bookmark);while(range.moveStart('character',-1)!==0)pos++;return pos;}//not supported
return 0;}//set
if(pos===-1)pos=this[isContentEditable?'text':'val']().length;//HTML5
if(window.getSelection){//contenteditable
if(isContentEditable){if(!this.is(':focus')){target.focus();}var selection=window.getSelection();selection.collapse(selection.focusNode,pos);}//textarea
else target.setSelectionRange(pos,pos);}//IE<9
else if(document.body.createTextRange){var range=document.body.createTextRange();range.moveToElementText(target);range.moveStart('character',pos);range.collapse(true);range.select();}if(!isContentEditable&&!this.is(':focus')){target.focus();}return pos;};/* eslint-enable */ // -----------------------------------------------------------------------
// :: callback based event handler plugin generator
// -----------------------------------------------------------------------
function make_callback_plugin(options){var factory_settings=$.extend({init:$.noop,destroy:$.noop,name:'event'},options);return function(callback,options){var trigger=arguments.length===0;var unbind=arguments[0]==="unbind";if(!trigger&&!unbind&&!is_function(callback)){throw new Error('Invalid argument, it need to a function or string '+'"unbind" or no arguments.');}if(unbind){callback=is_function(arguments[1])?arguments[1]:null;}var data_name='callbacks_'+factory_settings.name;return this.each(function(){var $this=$(this);var callbacks;function handler(arg){callbacks.fireWith($this,[arg]);}if(trigger||unbind){callbacks=$this.data(data_name);if(trigger){callbacks&&callbacks.fire();}else{if(callback&&callbacks){callbacks.remove(callback);if(!callbacks.has()){callbacks=null;}}else{callbacks=null;}if(!callbacks){$this.removeData(data_name);factory_settings.destroy.call(this,handler,options);}}}else if($this.data(data_name)){$(this).data(data_name).add(callback);}else{callbacks=$.Callbacks();callbacks.add(callback);$this.data(data_name,callbacks);factory_settings.init.call(this,handler,options);}});};}// -----------------------------------------------------------------------
// :: Cross-browser resize element plugin using sentinel iframe or
// :: resizeObserver
// -----------------------------------------------------------------------
$.fn.resizer=make_callback_plugin({name:'resize',init:function init(handler,options){var settings=$.extend({prefix:''},options);var $this=$(this);var resizer;var first=true;if($this.is('body')){$(window).on('resize.resizer',handler);}else if(window.ResizeObserver){resizer=new ResizeObserver(function(){if(!first){handler();}first=false;});resizer.observe(this);$this.data('observer',resizer);}else{var iframe=$('<iframe/>').addClass(settings.prefix+'resizer').appendTo(this)[0];$(iframe.contentWindow).on('resize',handler);}},destroy:function destroy(){var $this=$(this);if(window.ResizeObserver){var observer=$this.data('observer');if(observer){observer.unobserve(this);$this.removeData('observer');}}else{var iframe=$this.find('> iframe[class$="resizer"]');if(iframe.length){// just in case of memory leaks in IE
$(iframe[0].contentWindow).off('resize').remove();iframe.remove();}else if($this.is('body')){$(window).off('resize.resizer');}}}});// -----------------------------------------------------------------------
// :: Mobile friendly scroll that work without scrollbar (for less)
// -----------------------------------------------------------------------
$.fn.touch_scroll=make_callback_plugin({name:'touch',init:function init(handler){var origin;var previous;$(this).on('touchstart.scroll',function(e){e=e.originalEvent;if(e.target.tagName.toLowerCase()!=='a'&&e.touches.length===1){previous=origin=e.touches[0];}}).on('touchmove.scroll',function(e){e=e.originalEvent;if(origin&&e.touches.length===1){var current=e.touches[0];var ret=handler({origin:origin,previous:previous,current:current});if(ret===false){e.preventDefault();}previous=current;}}).on('touchend.scroll',function(){if(origin||previous){origin=previous=null;}});},destroy:function destroy(){$(this).off('touchstart.scroll touchmove.scroll touchend.scroll');}});// -----------------------------------------------------------------------
function jquery_resolve(value){var defer=jQuery.Deferred();defer.resolve(value);return defer.promise();}// -----------------------------------------------------------------------
function unpromise(value,callback,error){if(value!==undefined){if(is_function(value.catch)){value.catch(error);}if(is_function(value.done)){return value.done(callback);}else if(is_function(value.then)){return value.then(callback);}else if(value instanceof Array){var promises=value.filter(function(value){return value&&(is_function(value.done)||is_function(value.then));});if(promises.length){var result=$.when.apply($,value).then(function(){return callback([].slice.call(arguments));});if(is_function(value.catch)){result.catch(error);}return result;}}// TODO: investigate why it break when called
//       when value is undefined
//       when moving this line outside if
//       it breaks all completion unit tests
return callback(value);}}// -----------------------------------------------------------------------
// :: based on https://github.com/zeusdeux/isInViewport
// :: work only vertically and on dom elements
// -----------------------------------------------------------------------
$.fn.is_fully_in_viewport=function(){function is_visible(node,container){var box=node.getBoundingClientRect();var viewport=container[0].getBoundingClientRect();var top=box.top-viewport.top;var bottom=box.bottom-viewport.top;var height=container.height();return bottom>0&&top<=height;}if(root.IntersectionObserver){return function(container){var node=this[0];var defer=jQuery.Deferred();var item_observer=new root.IntersectionObserver(function(entries){defer.resolve(entries[0].isIntersecting&&entries[0].ratio===1);item_observer.unobserve(node);},{root:container[0]});item_observer.observe(node);return defer.promise();};}else{return function(container){return jquery_resolve(is_visible(this[0],container));};}}();// -------------------------------------------------------------------------
/* eslint-disable */var entity_re=/(&(?:[a-z\d]+|#\d+|#x[a-f\d]+);)/i;// regex that match single character at begining and folowing combine character
// https://en.wikipedia.org/wiki/Combining_character
var combine_chr_re=/(.(?:[\u0300-\u036F]|[\u1AB0-\u1abE]|[\u1DC0-\u1DF9]|[\u1DFB-\u1DFF]|[\u20D0-\u20F0]|[\uFE20-\uFE2F])+)/;// source: https://mathiasbynens.be/notes/javascript-unicode
var astral_symbols_re=/([\uD800-\uDBFF][\uDC00-\uDFFF])/;// source: https://github.com/mathiasbynens/emoji-regex
var emoji_re=/(\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC68(?:\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83E\uDDD1(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69])(?:\uD83C[\uDFFB-\uDFFE])|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69])(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69])(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69])(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69])(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83E\uDDD1(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC3B\u200D\u2744|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDF])\u200D[\u2640\u2642])\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F?|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD]))/;// https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser
var mobile_re=/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i;var tablet_re=/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;var format_split_re=/(\[\[(?:-?[@!gbiuso])*;[^;]*;[^\]]*\](?:[^\]\\]*(?:\\\\)*\\\][^\]]*|[^\]]*|[^[]*\[[^\]]*)\]?)/i;var format_parts_re=/\[\[((?:-?[@!gbiuso])*);([^;]*);([^;\]]*);?([^;\]]*);?([^\]]*)\]([^\]\\]*\\\][^\]]*|[^\]]*|[^[]*\[[^\]]+)\]?/gi;var format_re=/\[\[((?:-?[@!gbiuso])*;[^;\]]*;[^;\]]*(?:;|[^\]()]*);?[^\]]*)\]([^\]]*\\\][^\]]*|[^\]]*|[^[]*\[[^\]]*)\]?/gi;var format_exist_re=/\[\[((?:-?[@!gbiuso])*;[^;\]]*;[^;\]]*(?:;|[^\]()]*);?[^\]]*)\]([^\]]*\\\][^\]]*|[^\]]*|[^[]*\[[^\]]*)\]/gi;var format_full_re=/^(\[\[(?:(?:-?[@!gbiuso])*;[^;\]]*;[^;\]]*(?:;|[^\]()]*);?[^\]]*)\])([^\]]*\\\][^\]]*|[^\]]*|[^[]*\[[^\]]*)(\])$/i;var format_begin_re=/(\[\[(?:-?[@!gbiuso])*;[^;]*;[^\]]*\])/i;var format_start_re=/^(\[\[(?:-?[@!gbiuso])*;[^;]*;[^\]]*\])/i;var format_end_re=/\[\[(?:-?[@!gbiuso])*;[^;]*;[^\]]*\]?$/i;var self_closing_re=/^(?:\[\[)?[^;]*@[^;]*;/;var color_re=/^(?:#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})|rgba?\([^)]+\)|hsla?\([^)]+\))$/i;var url_re=/(\b(?:file|ftp|https?):\/\/(?:(?:(?!&[^;]+;)|(?=&amp;))[^\s"'\\<>\][)])+)/gi;var url_nf_re=/\b(?![^"\s[\]]*])(https?:\/\/(?:(?:(?!&[^;]+;)|(?=&amp;))[^\s"'\\<>\][)])+)/gi;var email_re=/((([^<>('")[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,})))/g;var url_full_re=/^(https?:\/\/(?:(?:(?!&[^;]+;)|(?=&amp;))[^\s"'<>\\\][)])+)$/gi;var email_full_re=/^((([^<>('")[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,})))$/g;var command_re=/((?:"[^"\\]*(?:\\[\S\s][^"\\]*)*"|'[^'\\]*(?:\\[\S\s][^'\\]*)*'|`[^`\\]*(?:\\[\S\s][^`\\]*)*`|\/[^\/\\]*(?:\\[\S\s][^\/\\]*)*\/[gimsuy]*(?=\s|$)|(?:\\\s|\S))+)(?=\s|$)/gi;var extended_command_re=/^\s*((terminal|cmd)::([a-z_]+)\(([\s\S]*)\))\s*$/;var format_exec_split_re=/(\[\[(?:-?[@!gbiuso])*;[^\]]+\](?:\\[[\]]|[^\]])*\]|\[\[[\s\S]+?\]\])/;var format_exec_re=/(\[\[[\s\S]+?\]\])/;var float_re=/^[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?$/;var re_re=/^\/((?:\\\/|[^/]|\[[^\]]*\/[^\]]*\])+)\/([gimsuy]*)$/;var string_re=/("(?:[^"\\]|\\(?:\\\\)*"|\\\\)*"|'(?:[^'\\]|\\(?:\\\\)*'|\\\\)*'|`(?:[^`\\]|\\(?:\\\\)*`|\\\\)*`)/;var unclosed_strings_re=/^(?=((?:[^"']+|"[^"\\]*(?:\\[^][^"\\]*)*"|'[^'\\]*(?:\\[^][^'\\]*)*')*))\1./;var broken_image='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 14"><title id="title2">rounded</title><path id="terminal-broken-image" d="m 14,10 h 2 v 1 a 3,3 0 0 1 -3,3 H 3 A 3,3 0 0 1 0,11 H 4.5 A 1.00012,1.00012 0 0 0 5.207,10.707 L 6.5,9.414 7.793,10.707 a 0.99963,0.99963 0 0 0 1.41406,0 l 2.36719,-2.36719 1.80127,1.44092 A 0.99807,0.99807 0 0 0 14,10 Z M 16,3 V 8 H 14.35059 L 12.12451,6.21924 A 0.99846,0.99846 0 0 0 10.793,6.293 L 8.5,8.586 7.207,7.293 a 0.99962,0.99962 0 0 0 -1.41406,0 L 4.08594,9 H 0 V 3 A 3,3 0 0 1 3,0 h 10 a 3,3 0 0 1 3,3 z M 6,4.5 A 1.5,1.5 0 1 0 4.5,6 1.5,1.5 0 0 0 6,4.5 Z" /></svg>';var use_broken_image='<svg class="terminal-broken-image" role="presentation" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 14" xmlns:xlink="http://www.w3.org/1999/xlink"><use xlink:href="#terminal-broken-image"/></svg>';/* eslint-enable */ // -------------------------------------------------------------------------
// :: features flags
// -------------------------------------------------------------------------
// taken from https://hacks.mozilla.org/2011/09/detecting-and-generating-
// css-animations-in-javascript/
var animation_supported=function(){if(typeof document==='undefined'){return false;}var animation=false,domPrefixes='Webkit Moz O ms Khtml'.split(' '),elm=document.createElement('div');if(elm.style.animationName){animation=true;}if(animation===false){for(var i=0;i<domPrefixes.length;i++){var name=domPrefixes[i]+'AnimationName';if(elm.style[name]!==undefined){animation=true;break;}}}elm=null;return animation;}();// -------------------------------------------------------------------------
var agent=(root.navigator||window.navigator).userAgent;var is_IE=/MSIE|Trident/.test(agent)||/rv:11.0/i.test(agent);var is_IEMobile=/IEMobile/.test(agent);// -------------------------------------------------------------------------
var is_ch_unit_supported=function(){if(is_IE&&!is_IEMobile){return false;}if(typeof document==='undefined'){return true;// run without browser context
}var div=document.createElement('div');div.style.width='1ch';return div.style.width==='1ch';}();// -------------------------------------------------------------------------
var is_css_variables_supported=root.CSS&&root.CSS.supports&&root.CSS.supports('--fake-var',0);// -------------------------------------------------------------------------
var is_android=navigator.userAgent.toLowerCase().indexOf('android')!==-1;// -------------------------------------------------------------------------
var is_key_native=function is_key_native(){if(!('KeyboardEvent'in root&&'key'in root.KeyboardEvent.prototype)){return false;}var proto=root.KeyboardEvent.prototype;var get=Object.getOwnPropertyDescriptor(proto,'key').get;return!!get.toString().match(/\[native code\]/);}();// -------------------------------------------------------------------------
var is_browser=function(){try{return this===window;}catch(e){return false;}}();// -------------------------------------------------------------------------
var is_mobile=function(a){var check=false;if(mobile_re.test(a)||tablet_re.test(a.substr(0,4))){check=true;}// detect iPad 13
// ref: https://stackoverflow.com/a/57924983/387194s
if(navigator.platform==='MacIntel'&&navigator.maxTouchPoints>1){return true;}return check;}(navigator.userAgent||navigator.vendor||root.opera);// -------------------------------------------------------------------------
// IE ch unit bug detection - better that UserAgent that can be changed
// -------------------------------------------------------------------------
var ch_unit_bug=false;if(is_browser){$(function(){function width(e){return e[0].getBoundingClientRect().width;}var base='<span style="font-family: monospace;visibility:hidden;';var ch=$(base+'width:1ch;overflow: hidden">&nbsp;</span>');ch.appendTo('body');var space=$(base+'">&nbsp;</span>').appendTo('body');// in FireFox the size of space is fraction larger #579
ch_unit_bug=Math.abs(width(ch)-width(space))>0.0001;ch.remove();space.remove();});}// -----------------------------------------------------------------------
// :: css helper that work with css variables
// :: jQuery css method from 3.4 support them by default
// -----------------------------------------------------------------------
function css(node,obj,value){if(node instanceof $.fn.init){node.each(function(){css(this,obj,value);});}else if($.isPlainObject(obj)){Object.keys(obj).forEach(function(key){node.style.setProperty(key,obj[key]);});}else if(typeof value==='undefined'){return node.style.getPropertyValue(obj);}else{node.style.setProperty(obj,value);}}// -----------------------------------------------------------------------
// :: hide elements from screen readers
// -----------------------------------------------------------------------
function a11y_hide(element){element.attr({role:'presentation','aria-hidden':'true'});}// ---------------------------------------------------------------------
// :: alert only first exception of type
// ---------------------------------------------------------------------
var excepctions=[];function alert_exception(label,e){if(arguments[0]instanceof $.terminal.Exception){label=arguments[0].type;e=arguments[0];}var message=(label?label+': ':'')+exception_message(e);if(excepctions.indexOf(message)===-1){excepctions.push(message);setTimeout(function(){throw e;},0);//alert(message + (e.stack ? '\n' + e.stack : ''));
}}// ---------------------------------------------------------------------
// ref: https://stackoverflow.com/a/6248722/387194
function generate_id(){// I generate the UID from two parts here
// to ensure the random number provide enough bits.
var firstPart=Math.random()*46656|0;var secondPart=Math.random()*46656|0;firstPart=("000"+firstPart.toString(36)).slice(-3);secondPart=("000"+secondPart.toString(36)).slice(-3);return firstPart+secondPart;}// ---------------------------------------------------------------------
// :; detect if mouse event happen on scrollbar
// ---------------------------------------------------------------------
function scrollbar_event(e,node){var left=node.offset().left;return node.outerWidth()<=e.clientX-left;}// ---------------------------------------------------------------------
// :: Return exception message as string
// ---------------------------------------------------------------------
function exception_message(e){if(typeof e==='string'){return e;}else if(typeof e.fileName==='string'){return e.fileName+': '+e.message;}else{return e.message;}}// -----------------------------------------------------------------------
// :: CYCLE DATA STRUCTURE
// -----------------------------------------------------------------------
function Cycle(){var data=[].slice.call(arguments);var pos=0;$.extend(this,{get:function get(){return data;},index:function index(){return pos;},rotate:function rotate(skip,init){if(init===undefined){init=pos;}else if(init===pos){return;}if(!skip){var defined=data.filter(function(item){return typeof item!=='undefined';});if(!defined.length){return;}}if(!data.length){return;}if(data.length===1){return data[0];}else{if(pos===data.length-1){pos=0;}else{++pos;}if(typeof data[pos]!=='undefined'){return data[pos];}else{return this.rotate(true,init);}}},length:function length(){return data.length;},remove:function remove(index){delete data[index];},set:function set(item){for(var i=data.length;i--;){if(data[i]===item){pos=i;return;}}this.append(item);pos=data.length-1;},front:function front(){if(data.length){var index=pos;var restart=false;while(!data[index]){index++;if(index>data.length){if(restart){break;}index=0;restart=true;}}return data[index];}},map:function map(fn){return data.map(function(item,i){if(typeof item!=='undefined'){return fn(item,i);}return null;}).filter(Boolean);},forEach:function forEach(fn){return data.forEach(function(item,i){if(typeof item!=='undefined'){fn(item,i);}});},append:function append(item){data.push(item);}});}/*
    function time() {
        // performance.now almost equal Date.now()- performance.timing.navigationStart
        // the difference check should be almost the same
        return performance ? performance.now() : Date.now();
    }
    */ // -----------------------------------------------------------------------
// :: STACK DATA STRUCTURE
// -----------------------------------------------------------------------
function Stack(init){var _data=is_array(init)?init:init?[init]:[];$.extend(this,{data:function data(){return _data;},map:function map(fn){return $.map(_data,fn);},size:function size(){return _data.length;},pop:function pop(){if(_data.length===0){return null;}else{var value=_data[_data.length-1];_data=_data.slice(0,_data.length-1);return value;}},push:function push(value){_data=_data.concat([value]);return value;},top:function top(){return _data.length>0?_data[_data.length-1]:null;},clone:function clone(){return new Stack(_data.slice(0));}});}// -------------------------------------------------------------------------
// :: Class for Worker that do some computation when needed
// :: if validation function return false it mean that condition changed
// :: and cache need to be cleared. If value was not processed it will run
// :: the action
// -------------------------------------------------------------------------
function WorkerCache(options){var settings=$.extend({validation:$.noop,action:$.noop,onCache:$.noop},options);this._onCache=settings.onCache.bind(this);this._action=settings.action.bind(this);this._validation=settings.validation.bind(this);if('Map'in root){this._cache=new Map();}}// -------------------------------------------------------------------------
WorkerCache.prototype.validate=function(key){var valid=this._validation(key);var test=valid===undefined||valid===true;if(!test){this._cache.clear();}return test;};// -------------------------------------------------------------------------
WorkerCache.prototype.get=function(key){if(!this._cache){return this._action(key);}var value;if(this.validate(key)&&this._cache.has(key)){value=this._cache.get(key);this._onCache({cache:value});return value;}value=this._action(key);this._cache.set(key,value);return value;};// -------------------------------------------------------------------------
// :: HISTORY CLASS
// -------------------------------------------------------------------------
function History(name,size,memory){var _enabled=true;var storage_key='';if(typeof name==='string'&&name!==''){storage_key=name+'_';}storage_key+='commands';var _data2;if(memory){_data2=[];}else{_data2=$.Storage.get(storage_key);_data2=_data2?JSON.parse(_data2):[];}var pos=_data2.length-1;$.extend(this,{append:function append(item){if(_enabled){if(_data2[_data2.length-1]!==item){_data2.push(item);if(size&&_data2.length>size){_data2=_data2.slice(-size);}pos=_data2.length-1;if(!memory){$.Storage.set(storage_key,JSON.stringify(_data2));}}}},set:function set(new_data){if(is_array(new_data)){_data2=new_data;if(!memory){$.Storage.set(storage_key,JSON.stringify(_data2));}}},data:function data(){return _data2;},reset:function reset(){pos=_data2.length-1;},last:function last(){return _data2[_data2.length-1];},end:function end(){return pos===_data2.length-1;},position:function position(){return pos;},current:function current(){return _data2[pos];},next:function next(){var old=pos;if(pos<_data2.length-1){++pos;}if(old!==pos){return _data2[pos];}},previous:function previous(){var old=pos;if(pos>0){--pos;}if(old!==pos){return _data2[pos];}},clear:function clear(){_data2=[];this.purge();},enabled:function enabled(){return _enabled;},enable:function enable(){_enabled=true;},purge:function purge(){if(!memory){$.Storage.remove(storage_key);}},disable:function disable(){_enabled=false;},toggle:function toggle(value){if(typeof value==='undefined'){_enabled=!_enabled;}else{_enabled=value;}}});}// -------------------------------------------------------------------------
function OutputLines(settings){this._settings=settings;this._lines=[];this._snapshot=[];}// -------------------------------------------------------------------------
OutputLines.prototype.make_snapshot=function(snapshot){this._snapshot.push(snapshot);};// -------------------------------------------------------------------------
OutputLines.prototype.get_partial=function(){var last=this._snapshot[this._snapshot.length-1];return last;};// -------------------------------------------------------------------------
OutputLines.prototype.update_snapshot=function(index,snapshot){this._snapshot[index]=snapshot;};// -------------------------------------------------------------------------
OutputLines.prototype.limit_snapshot=function(limit){this._snapshot=this._snapshot.slice(limit);};// -------------------------------------------------------------------------
OutputLines.prototype.clear_snapshot=function(){this._snapshot=[];};// -------------------------------------------------------------------------
OutputLines.prototype.get_snapshot=function(){return this._snapshot.reduce(function(acc,arr){return acc.concat(arr);},[]).join('\n');};// -------------------------------------------------------------------------
OutputLines.prototype.join=function(){var args=[].slice.call(arguments);if(args.some(is_function)){return function(){return args.reduce(function(acc,arg){if(is_function(acc)){acc=acc();}if(is_function(arg)){arg=arg();}if(is_promise(acc)||is_promise(arg)){return $.when(acc,arg).then(function(acc,arg){return acc+arg;});}return arg;});};}else if(args.some(is_promise)){return args.reduce(function(acc,arg){return $.when(acc,arg).then(function(acc,arg){return acc+arg;});});}return args.join('');};// -------------------------------------------------------------------------
OutputLines.prototype.import=function(data){this._lines=data;};// -------------------------------------------------------------------------
OutputLines.prototype.push=function(data){var value=data[0];var options=data[1];if(this.has_newline()){this._lines.push(data);}else{var last_line=this.last_line();last_line[0]=this.join(last_line[0],value);last_line[1].newline=options.newline;}};// -------------------------------------------------------------------------
OutputLines.prototype.clear=function(fn){this._lines.forEach(function(line,i){var options=line[1];if(is_function(options.onClear)){options.onClear.call(self,fn(i));}});this._lines=[];this._snapshot=[];};// -------------------------------------------------------------------------
OutputLines.prototype.data=function(){return this._lines;};// -------------------------------------------------------------------------
OutputLines.prototype.has_newline=function(){if(this._lines.length===0){return true;}return this.last_line()[1].newline;};// -------------------------------------------------------------------------
OutputLines.prototype.last_line=function(){var len=this._lines.length;return this._lines[len-1];};// -------------------------------------------------------------------------
OutputLines.prototype.update=function(index,value,options){if(value===null){this._lines.splice(index,1);}else{this._lines[index][0]=value;if(options){this._lines[index][1]=$.extend(this._lines[index][1],options);}return this._lines[index][1];}};// -------------------------------------------------------------------------
OutputLines.prototype.length=function(){return this._lines.length;};// -------------------------------------------------------------------------
OutputLines.prototype.valid_index=function(index){return!!this._lines[index];};// -------------------------------------------------------------------------
OutputLines.prototype.render=function(cols,fn){var settings=this._settings();var lines_to_show=[];this._snapshot=[];if(settings.outputLimit>=0){// flush will limit lines but if there is lot of
// lines we don't need to show them and then remove
// them from terminal
var limit;if(settings.outputLimit===0){limit=cols;}else{limit=settings.outputLimit;}this._lines.forEach(function(line,index){var value=line[0];var options=line[1];lines_to_show.push({value:value,index:index,options:options});});var pivot=lines_to_show.length-limit-1;lines_to_show=lines_to_show.slice(pivot);}else{lines_to_show=this._lines.map(function(line,index){return{value:line[0],index:index,options:line[1]};});}return fn(lines_to_show);};// -------------------------------------------------------------------------
// :: FormatBuffer is a class that buffer line printed on terminal
// :: with optional format of the text, the class also usse cache
// :: the options in the constructor is a function that should returns
// :: settings for given format, the settings may change while the terminal
// :: is running, that's why they are dynamic in form of a function
// -------------------------------------------------------------------------
function FormatBuffer(options){this._options=options;if('Map'in root){this._format_cache=new Map();}this._output_buffer=[];}// -------------------------------------------------------------------------
FormatBuffer.NEW_LINE=1;// -------------------------------------------------------------------------
FormatBuffer.prototype.format=function format(arg,newline,raw){var use_cache=this._format_cache&&this._settings.useCache;if(use_cache){var args=JSON.stringify([arg,this._settings]);if(this._format_cache.has(args)){return this._format_cache.get(args);}}var data={line:$.terminal.format(arg,this._settings),raw:raw,newline:newline};if(use_cache){this._format_cache.set(args,data);}return data;};// -------------------------------------------------------------------------
FormatBuffer.prototype.empty=function(){return!this._output_buffer.length;};// -------------------------------------------------------------------------
FormatBuffer.prototype.append=function(arg,index,options,raw){this._settings=$.extend({useCache:true},this._options(options));this._output_buffer.push(FormatBuffer.NEW_LINE);if(arg instanceof Array){var raw_lines=raw.split('\n');for(var i=0,len=arg.length;i<len;++i){if(arg[i]===''||arg[i]==='\r'){this._output_buffer.push({line:'',raw:''});}else{var formatted=this.format(arg[i],i===len-1,raw_lines[i]);this._output_buffer.push(formatted);}}}else if(!options.raw){this._output_buffer.push(this.format(arg,false,raw));}else{this._output_buffer.push({line:arg,raw:raw});}this._output_buffer.push({finalize:options.finalize,index:index,newline:options.newline});};// -------------------------------------------------------------------------
FormatBuffer.prototype.clear_cache=function(){if(this._format_cache){this._format_cache.clear();}};// -------------------------------------------------------------------------
FormatBuffer.prototype.output=function(){return this._output_buffer.slice();};// -------------------------------------------------------------------------
FormatBuffer.prototype.is_empty=function(){return!this._output_buffer.length;};// -------------------------------------------------------------------------
FormatBuffer.prototype.clear=function(){this._output_buffer=[];};// -------------------------------------------------------------------------
FormatBuffer.prototype.forEach=function(fn){var i=0;while(i<this._output_buffer.length){var data=this._output_buffer[i++];if(data===FormatBuffer.NEW_LINE){fn();}else{fn(data);}}};// -------------------------------------------------------------------------
FormatBuffer.prototype.flush=function(render){this.forEach(render);this.clear();};// -------------------------------------------------------------------------
// :: function that handle all cases of prompt and call the function set
// :: with a string
// -------------------------------------------------------------------------
function with_prompt(prompt,set,context){function error(e){var prompt=$.terminal.escape_brackets('[ERR]> ');set('[[;red;]'+prompt+']');alert_exception('Prompt',e);}switch(_typeof(prompt)){case'string':set(prompt);break;case'function':try{var ret=prompt.call(context,function(string){set(string);});if(typeof ret==='string'){set(ret);}if(ret&&ret.then){ret.then(set).catch(error);}}catch(e){error(e);}break;}}// -------------------------------------------------------------------------
// :: COMMAND LINE PLUGIN
// -------------------------------------------------------------------------
var cmd_index=0;$.cmd={defaults:{mask:false,caseSensitiveSearch:true,historySize:60,prompt:'> ',enabled:true,history:true,onPositionChange:$.noop,onCommandChange:$.noop,inputStyle:'textarea',mobileDelete:is_mobile,onPaste:$.noop,clickTimeout:200,holdTimeout:400,holdRepeatTimeout:200,mobileIngoreAutoSpace:[],repeatTimeoutKeys:[],tabindex:1,tabs:4}};$.fn.cmd=function(options){var settings=$.extend({},$.cmd.defaults,options);function mobile_ignore_key(key){return settings.mobileIngoreAutoSpace.length&&settings.mobileIngoreAutoSpace.indexOf(key)!==-1&&is_android;}var self=this;var maybe_data=self.data('cmd');if(maybe_data){return maybe_data;}var id=cmd_index++;self.addClass('cmd');var wrapper=$('<div class="cmd-wrapper"/>').appendTo(self);wrapper.append('<span class="cmd-prompt"></span>');wrapper.append('<div class="cmd-cursor-line">'+'<span></span>'+'<span class="cmd-cursor">'+'<span data-text class="end"><span>&nbsp;</span></span>'+'</span>'+'<span></span>'+'</div>');var cursor_line=wrapper.find('.cmd-cursor-line');// a11y: don't read command it's in textarea that's in focus
a11y_hide(cursor_line);// on mobile the only way to hide textarea on desktop it's needed because
// textarea show up after focus
//self.append('<span class="mask"></mask>');
var _clip;if(is_mobile){_clip=function(){var $node=$('<div class="cmd-editable" '+'contenteditable="plaintext-only" '+'spellcheck="false"/>').attr({autocapitalize:'off',autocorrect:'off',spellcheck:'false',tabindex:settings.tabindex}).insertAfter(self);$node.on('focus',function(){self.enable();}).on('blur',function(){self.disable();});var timer;var clip={$node:$node,val:function val(value){if(typeof value==='undefined'){return $node.text();}else{$node.html(value);}},reset:function reset(){clearTimeout(timer);timer=setTimeout(function(){$node.css({top:'',bottom:''});},400);},focus:function focus(){css($node[0],{top:'calc(var(--terminal-scroll, 0) * 1px)'});clip.reset();},blur:function blur(){$node.css({top:'100%',bottom:0}).blur();// just in case of Webkit bug
window.getSelection().removeAllRanges();clip.reset();}};return clip;}();self.addClass('cmd-mobile');}else{_clip=function(){var id=generate_id();var $node=$('<textarea>').attr({autocapitalize:'off',spellcheck:'false',id:id,tabindex:settings.tabindex}).addClass('cmd-clipboard').appendTo(self);// some a11y to make lighthouse happy
$node.before('<label class="visually-hidden" for="'+id+'">'+'Clipbard textarea for jQuery Terminal</label>');return{$node:$node,val:function val(value){// even if value is undeifned
// when calling val(value) it return jQuery object
if(typeof value==='undefined'){return $node.val();}else{return $node.val(value);}}};}();_clip.val(' ');}if(settings.width){self.width(settings.width);}var num_chars;// calculated by resize
var char_width;var last_rendered_prompt;var prompt_last_line;var just_prompt_len;var extra_prompt_margin=0;var prompt_len;var prompt_node=self.find('.cmd-prompt');var reverse_search=false;var rev_search_str='';var reverse_search_position=null;var backup_prompt;var command='';var last_command;// text from selection using CTRL+SHIFT+C (as in Xterm)
var _kill_text='';// text from command that kill part of the command
var _position=0;var _prompt;var enabled;var formatted_position=0;var _name,history;var cursor=self.find('.cmd-cursor');var animation;var restart_animation;var paste_count=0;// use \uFFFF to mark newline extra character
// so we can hide it by css when using text selection
var line_marker="\uFFFF";var line_marker_re=/\uFFFF$/;var empty_marker_re=/^\uFFFF$/;function get_char_pos(e){var node=$(e.target);if(node.is('span,img,a')){node=node.closest('[data-text]');return node.index()+node.parent('span').prevAll().find('[data-text]').length+node.closest('[role="presentation"]').prevUntil('.cmd-prompt').find('[data-text]').length;}else if(node.is('div[role="presentation"]')){var last=!node.next().length;return node.find('[data-text]').length+node.prevUntil('.cmd-prompt').find('[data-text]').length-(last?0:1);}}// IE mapping
var key_mapping={'SPACEBAR':' ','UP':'ArrowUP','DOWN':'ArrowDown','LEFT':'ArrowLeft','RIGHT':'ArrowRight','DEL':'Delete','MULTIPLY':'*','DIVIDE':'/','SUBTRACT':'-','ADD':'+'};function ie_key_fix(e){var key=e.key.toUpperCase();if(key_mapping[key]){return key_mapping[key];}return key;}function get_key(e){if(e.key){var key=ie_key_fix(e).toUpperCase();if(key==='CONTROL'){return'CTRL';}else{var combo=[];if(e.ctrlKey){combo.push('CTRL');}if(e.metaKey&&key!=='META'){combo.push('META');}if(e.shiftKey&&key!=='SHIFT'){combo.push('SHIFT');}if(e.altKey&&key!=='ALT'){combo.push('ALT');}if(combo.length&&key===' '){key='SPACEBAR';}if(e.key){combo.push(key);}return combo.join('+');}}}// -----------------------------------------------------------------
// for invoking shortcuts using terminal::keydown
// taken from https://github.com/cvan/keyboardevent-key-polyfill/
var keycodes={3:'Cancel',6:'Help',8:'Backspace',9:'Tab',12:'Clear',13:'Enter',16:'Shift',17:'Control',18:'Alt',19:'Pause',20:'CapsLock',27:'Escape',28:'Convert',29:'NonConvert',30:'Accept',31:'ModeChange',32:' ',33:'PageUp',34:'PageDown',35:'End',36:'Home',37:'ArrowLeft',38:'ArrowUp',39:'ArrowRight',40:'ArrowDown',41:'Select',42:'Print',43:'Execute',44:'PrintScreen',45:'Insert',46:'Delete',48:['0',')'],49:['1','!'],50:['2','@'],51:['3','#'],52:['4','$'],53:['5','%'],54:['6','^'],55:['7','&'],56:['8','*'],57:['9','('],91:'OS',93:'ContextMenu',144:'NumLock',145:'ScrollLock',181:'VolumeMute',182:'VolumeDown',183:'VolumeUp',186:[';',':'],187:['=','+'],188:[',','<'],189:['-','_'],190:['.','>'],191:['/','?'],192:['`','~'],219:['[','{'],220:['\\','|'],221:[']','}'],222:["'",'"'],224:'Meta',225:'AltGraph',246:'Attn',247:'CrSel',248:'ExSel',249:'EraseEof',250:'Play',251:'ZoomOut'};var i;// Function keys (F1-24).
for(i=1;i<25;i++){keycodes[111+i]='F'+i;}// Printable ASCII characters.
var letter='';for(i=65;i<91;i++){letter=String.fromCharCode(i);keycodes[i]=[letter.toLowerCase(),letter.toUpperCase()];}var reversed_keycodes={};Object.keys(keycodes).forEach(function(which){if(is_array(keycodes[which])){keycodes[which].forEach(function(key){reversed_keycodes[key.toUpperCase()]=which;});}else{reversed_keycodes[keycodes[which].toUpperCase()]=which;}});// -----------------------------------------------------------------
var _keymap;var default_keymap={'ALT+D':delete_forward({clipboard:true}),'HOLD+ALT+D':delete_forward({clipboard:true,hold:true}),'HOLD+DELETE':delete_forward({clipboard:false,hold:true}),'HOLD+SHIFT+DELETE':delete_forward({clipboard:false,hold:true}),'ENTER':function ENTER(){if(history&&command&&!settings.mask&&(is_function(settings.historyFilter)&&settings.historyFilter(command)||settings.historyFilter instanceof RegExp&&command.match(settings.historyFilter)||!settings.historyFilter)){history.append(command);}var tmp=command;// fix scroll the page where there is no scrollbar
_clip.$node.blur();history.reset();// for next input event on firefox/android with google keyboard
prev_command='';no_keydown=true;var promise;if(settings.commands){promise=settings.commands.call(self,tmp);}if(is_function(_prompt)){if(promise&&is_function(promise.then)){promise.then(draw_prompt);}else{draw_prompt();}}self.set('');_clip.val('');_clip.$node.focus();return false;},'SHIFT+ENTER':function SHIFTENTER(){self.insert('\n');return true;},'BACKSPACE':backspace_key,'SHIFT+BACKSPACE':backspace_key,'TAB':function TAB(){self.insert('\t');},'CTRL+D':function CTRLD(){self['delete'](1);return false;},'DELETE':function DELETE(){self['delete'](1);return true;},'HOLD+ARROWUP':up_arrow,'ARROWUP':up_arrow,'CTRL+ARROWUP':prev_history,'CTRL+P':prev_history,'ARROWDOWN':down_arrow,'HOLD+ARROWDOWN':down_arrow,'CTRL+N':next_history,'CTRL+ARROWDOWN':next_history,'ARROWLEFT':left,'HOLD+ARROWLEFT':debounce(left,10),'CTRL+B':left,'CTRL+ARROWLEFT':function CTRLARROWLEFT(){// jump to one character after last space before prevoius word
var len=_position-1;var pos=0;if(command[len]===' '){--len;}for(var i=len;i>0;--i){if(command[i]===' '&&command[i+1]!==' '){pos=i+1;break;}else if(command[i]==='\n'&&command[i+1]!=='\n'){pos=i;break;}}self.position(pos);},'CTRL+R':function CTRLR(){if(reverse_search){reverse_history_search(true);}else{backup_prompt=_prompt;draw_reverse_prompt();last_command=command;self.set('');redraw();reverse_search=true;}return false;},'CTRL+G':function CTRLG(){if(reverse_search){_prompt=backup_prompt;draw_prompt();self.set(last_command);redraw();reverse_search=false;rev_search_str='';return false;}},'ARROWRIGHT':right,'HOLD+ARROWRIGHT':debounce(right,10),'CTRL+F':right,'CTRL+ARROWRIGHT':function CTRLARROWRIGHT(){// jump to beginning or end of the word
if(command[_position]===' '){++_position;}var re=/\S[\n\s]{2,}|[\n\s]+\S?/;var match=command.slice(_position).match(re);if(!match||match[0].match(/^\s+$/)){self.position(bare_text(command).length);}else if(match[0][0]!==' '){_position+=match.index+1;}else{_position+=match.index+match[0].length-1;if(match[0][match[0].length-1]!==' '){--_position;}}redraw();},'F12':return_true,// Allow Firebug
'END':end(true),'CTRL+END':end(),'CTRL+E':end(),'HOME':home(true),'CTRL+HOME':home(),'CTRL+A':home(),'SHIFT+INSERT':paste_event,'CTRL+SHIFT+T':return_true,// open closed tab
'CTRL+W':delete_backward({clipboard:true,hold:false}),'HOLD+BACKSPACE':delete_backward({clipboard:false,hold:true}),'HOLD+SHIFT+BACKSPACE':delete_backward({clipboard:false,hold:true}),'CTRL+H':function CTRLH(){if(command!==''&&_position>0){self['delete'](-1);}return false;},'CTRL+X':return_true,'CTRL+C':function CTRLC(){return get_selected_html()==='';},'CTRL+T':return_true,'CTRL+Y':function CTRLY(){if(_kill_text!==''){self.insert(_kill_text);}},'CTRL+V':paste_event,'META+V':paste_event,'CTRL+K':function CTRLK(){var len=text(command).length;if(len>_position){_kill_text=self['delete'](len-_position);text_to_clipboard(_clip.$node,_kill_text);}return false;},'CTRL+U':function CTRLU(){if(command!==''&&_position!==0){_kill_text=self['delete'](-_position);text_to_clipboard(_clip.$node,_kill_text);}return false;},'CTRL+TAB':function CTRLTAB(){return false;},'META+`':return_true,// CMD+` switch browser window on Mac
'META+R':return_true,// CMD+R page reload in Chrome Mac
'META+L':return_true// CLD+L jump into Ominbox on Chrome Mac
};// -------------------------------------------------------------------------------
function delete_forward(options){options=options||{};if(options.hold&&!settings.mobileDelete){return function delete_character_forward(){self['delete'](1);return false;};}return function delete_word_forward(){var re=/ *[^ ]+ *(?= )|[^ ]+$/;var substring=command.slice(_position);var m=substring.match(re);if(m){_kill_text=m[0];if(options.clipboard){text_to_clipboard(_clip.$node,_kill_text);}}self.set(command.slice(0,_position)+command.slice(_position).replace(re,''),true);// chrome jump to address bar
return false;};}// -------------------------------------------------------------------------------
function delete_backward(options){options=options||{};if(options.hold&&!settings.mobileDelete){return function delete_character_backward(){self['delete'](-1);};}return function delete_word_backward(){// don't work in Chromium (can't prevent close tab)
if(command!==''&&_position!==0){var m=command.slice(0,_position).match(/([^ ]* *$)/);if(m[0].length){_kill_text=self['delete'](-m[0].length);if(options.clipboard){text_to_clipboard(_clip.$node,_kill_text);}}}return false;};}// -------------------------------------------------------------------------------
function return_true(){return true;}// -------------------------------------------------------------------------------
function paste_event(){_clip.val('');paste_count=0;if(self.isenabled()&&!_clip.$node.is(':focus')){_clip.$node.trigger('focus',[true]);}_clip.$node.one('input',paste);return true;}// ---------------------------------------------------------------------
// :: Paste content to terminal using hidden textarea
// ---------------------------------------------------------------------
function paste(){if(paste_count++>0){return;}function set(){_clip.val(command);fix_textarea();}function insert(text){self.insert(text);set();}if(self.isenabled()){//wait until Browser insert text to textarea
self.oneTime(100,function(){var value=_clip.val().replace(/\r/g,'');if(is_function(settings.onPaste)){var ret=settings.onPaste.call(self,{target:self,text:value});if(ret!==undefined){if(ret&&is_function(ret.then||ret.done)){(ret.then||ret.done).call(ret,insert);}else if(typeof ret==='string'){insert(ret);}else if(ret===false){set();}return;}}insert(value);});}}// -------------------------------------------------------------------------------
function prev_history(){if(first_up_history){last_command=command;self.set(history.current());}else{self.set(history.previous());}first_up_history=false;return false;}// -------------------------------------------------------------------------------
function next_history(){if(history.end()){first_up_history=true;self.set(last_command);}else{self.set(history.next());}return false;}// -------------------------------------------------------------------------------
function have_newlines(string){return string.match(/\n/);}// -------------------------------------------------------------------------------
function have_wrapping(string,prompt_len){var lengths=string.split('\n').map(function(line){return $.terminal.length(line);});if(prompt_len){lengths[0]+=prompt_len;}var wrap=lengths.filter(function(len){return len>=num_chars;});return!!wrap.length;}// -------------------------------------------------------------------------------
function simple_split_command_line(formatted){var prompt=last_rendered_prompt;var lines=$.terminal.split_equal(prompt+formatted,num_chars);var re=new RegExp('^'+$.terminal.escape_regex(prompt));lines=lines.map($.terminal.unescape_brackets);lines[0]=lines[0].replace(re,'');return lines;}// -------------------------------------------------------------------------------
function up_arrow(){var formatted=formatting(command);formatted=$.terminal.strip(formatted);var before=$.terminal.substring(formatted,0,_position);var col=self.column();var cursor_line=self.find('.cmd-cursor-line');var line=cursor_line.prevUntil('span').length;// case when line is wrapped and we are below prompt
if(line===1&&col<=prompt_len){self.position(0);return false;}if(line===0){return prev_history();}if(have_newlines(before)||have_wrapping(before,prompt_len)){var prev=cursor_line.prev();var splitted=prev.is('.cmd-end-line');var lines=simple_split_command_line(formatted);prev=lines[line-1];var left_over=lines[line].substring(col).length;var diff;if(left_over>0){diff=col;if(line-1===0){diff-=prompt_len;}diff=col+prev.substring(diff).length;if(splitted){++diff;}}else{diff=col+1;}self.position(-diff,true);return false;}else{return prev_history();}}// -------------------------------------------------------------------------------
function down_arrow(){// use format and strip so we get visual strings (formatting can change text)
var formatted=formatting(command);formatted=$.terminal.strip(formatted);var after=$.terminal.substring(formatted,_position);if(have_newlines(after)||have_wrapping(after)){var lines=simple_split_command_line(formatted);var col=self.column();var cursor_line=self.find('.cmd-cursor-line');var $line=cursor_line.prevUntil('span');var line=$line.length;var ending=cursor_line.is('.cmd-end-line');var next_broken=cursor_line.next().is('.cmd-end-line');var next=lines[line+1];if(!next){return next_history();}var left_over=lines[line].substring(col).length;var diff;// move to next line if at the end move to end of next line
if(left_over===0){diff=next.length;if(next_broken){diff++;}}else{diff=Math.min(col,next.length)+left_over;if(line===0){diff+=prompt_len;}if(ending){// correction for splitted line that don't have extra space
diff+=1;}}self.position(diff,true);return false;}else{return next_history();}}// -------------------------------------------------------------------------------
function backspace_key(){if(reverse_search){rev_search_str=rev_search_str.slice(0,-1);draw_reverse_prompt();}else if(command!==''&&_position>0){self['delete'](-1);}// for next input after naitve backspace
// we need timeout because we don't want it to trigger
// for current input but next one
self.oneTime(1,function(){no_keydown=true;});}// -------------------------------------------------------------------------------
function left(){if(_position>0){self.position(-1,true);}}// -------------------------------------------------------------------------------
function right(){if(_position<bare_text(command).length){self.position(1,true);}return false;}// -------------------------------------------------------------------------------
function home(line){function home(){self.position(0);}if(line){return function(){if(command.match(/\n/)){var string=command.substring(0,self.position());self.position(string.lastIndexOf('\n')+1);}else{home();}};}else{return home;}}// -------------------------------------------------------------------------------
function end(line){function end(){self.position(text(command).length);}if(line){return function(){if(command.match(/\n/)){var lines=command.split('\n');var pos=self.position();var sum=0;for(var i=0;i<lines.length;++i){sum+=lines[i].length;if(sum>pos){self.position(sum+i);return;}}}end();};}else{return end;}}// -------------------------------------------------------------------------------
function mobile_focus(){//if (is_touch) {
var $clip=_clip.$node;var focus=$clip.is(':focus');if(enabled){if(!focus){//clip.trigger('focus', [true]);
}self.oneTime(10,function(){if(!$clip.is(':focus')&&enabled){$clip.trigger('focus',[true]);}});}else if(focus&&!enabled){$clip.trigger('blur',[true]);}}// -------------------------------------------------------------------------------
// fix for .cursor span animation that should only be applied when
// animation is equal to terminal-blink
// -------------------------------------------------------------------------------
function fix_cursor(){if(animation_supported){var style=window.getComputedStyle(cursor[0]);var animationName=style.getPropertyValue('--animation');animationName=animationName.replace(/^\s*|\s*$/g,'');var _class=self.attr('class');if(_class.match(/-animation/)){_class=_class.replace(/[a-z]+-animation/g,'');}if(animationName&&!animationName.match(/blink/)){var className=animationName.replace(/terminal-/,'')+'-animation';if(!_class.match(className)){_class+=' '+className;}}_class=_class.replace(/\s+/g,' ');if(_class!==self.attr('class').replace(/\s+/g,' ')){self.attr('class',_class);}}}// -------------------------------------------------------------------------------
// on mobile you can't delete character if input is empty (event
// will not fire) so we fake text entry, we could just put dummy
// data but we put real command and position
// -------------------------------------------------------------------------------
function fix_textarea(position_only){if(!self.isenabled()){return;}// delay worked while experimenting
self.oneTime(10,function(){// we use space before command to show select all context menu
// idea taken from CodeMirror
if(!is_mobile&&_clip.val()!==command&&!position_only){_clip.val(' '+command);}if(enabled){self.oneTime(10,function(){try{var pos=!is_mobile?_position+1:_position;// we check first to improve performance
if(_clip.$node.caret()!==pos){_clip.$node.caret(pos);}}catch(e){// firefox throw NS_ERROR_FAILURE ignore
}});}});}// -------------------------------------------------------------------------------
// terminal animation don't work on android because they animate
// 2 properties
// -------------------------------------------------------------------------------
if(animation_supported&&!is_android){animation=function animation(toggle){if(toggle){cursor.addClass('cmd-blink');}else{cursor.removeClass('cmd-blink');}};restart_animation=function restart_animation(){var new_cursor=cursor.clone();new_cursor.insertBefore(cursor);cursor.remove();cursor=new_cursor;};}else{var animating=false;animation=function animation(toggle){if(toggle&&!animating){animating=true;cursor.addClass('cmd-inverted cmd-blink');self.everyTime(500,'blink',blink);}else if(animating&&!toggle){animating=false;self.stopTime('blink',blink);cursor.removeClass('cmd-inverted cmd-blink');}};restart_animation=function restart_animation(){animation(false);animation(true);};}// ---------------------------------------------------------------------
// :: Blinking cursor function
// ---------------------------------------------------------------------
function blink(){cursor.toggleClass('cmd-inverted');}// ---------------------------------------------------------------------
// :: Set prompt for reverse search
// ---------------------------------------------------------------------
function draw_reverse_prompt(){_prompt='(reverse-i-search)`'+rev_search_str+"': ";draw_prompt();}// ---------------------------------------------------------------------
// :: Disable reverse search
// ---------------------------------------------------------------------
function clear_reverse_state(){_prompt=backup_prompt;reverse_search=false;reverse_search_position=null;rev_search_str='';}// ---------------------------------------------------------------------
// :: Search through command line history. If next is not defined or
// :: false it searches for the first item from the end. If true it
// :: search for the next item
// ---------------------------------------------------------------------
function reverse_history_search(next){var history_data=history.data();var regex,save_string;var len=history_data.length;if(next&&reverse_search_position>0){len-=reverse_search_position;}if(rev_search_str.length>0){for(var j=rev_search_str.length;j>0;j--){save_string=$.terminal.escape_regex(rev_search_str.slice(0,j));if(settings.caseSensitiveSearch){regex=new RegExp(save_string);}else{regex=new RegExp(save_string,'i');}for(var i=len;i--;){if(regex.test(history_data[i])){reverse_search_position=history_data.length-i;self.position(history_data[i].indexOf(save_string));self.set(history_data[i],true);redraw();if(rev_search_str.length!==j){rev_search_str=rev_search_str.slice(0,j);draw_reverse_prompt();}return;}}}}rev_search_str='';// clear if not found any
}// ---------------------------------------------------------------------
// :: calculate width of hte character
// ---------------------------------------------------------------------
function get_char_width(){var $prompt=self.find('.cmd-prompt');var html=$prompt.html();$prompt.html('<span>&nbsp;</span>');var width=$prompt.find('span')[0].getBoundingClientRect().width;$prompt.html(html);return width;}// ---------------------------------------------------------------------
// :: return number of characters in command line
// ---------------------------------------------------------------------
function get_num_chars(char_width){var width=self.width();return Math.floor(width/char_width);}// ---------------------------------------------------------------------
// :: Split String that fit into command line where first line need to
// :: fit next to prompt (need to have less characters)
// ---------------------------------------------------------------------
function process_cmd_line(string){function split(string){return $.terminal.split_equal(string,num_chars);}// -----------------------------------------------------------------
function skip_empty(array){// we remove lines that are leftovers after adding space at the end
var result=[];array.forEach(function(line,i){if($.terminal.strip(line).match(empty_marker_re)){result[i]=false;// lines that will get removed need line ending on previos
// line so code that check that marker works correctly
if(i>0){result[i-1]+=line_marker;}}else{result[i]=array[i];}});return result.filter(function(line){return line!==false;});}// -----------------------------------------------------------------
var line=prompt_node.find('.cmd-line');var prompt;if(line.length){prompt=line.nextUntil('.cmd-line').text();}else{prompt=prompt_node.text();}prompt=$.terminal.escape_brackets(prompt);var re=new RegExp('^'+$.terminal.escape_regex(prompt));var array;if(string.match(/\n/)){var tmp=string.split('\n');var first_len=num_chars-prompt_len-1;for(var i=0;i<tmp.length-1;++i){tmp[i]+=line_marker;}// split first line
if(strlen(tmp[0])>first_len){array=split(prompt+tmp[0]);array[0]=array[0].replace(re,'');array=skip_empty(array);}else{array=[tmp[0]];}// process rest of the lines
for(i=1;i<tmp.length;++i){if(strlen(tmp[i])>num_chars){var splitted=split(tmp[i]);if(i<tmp.length-1){splitted=skip_empty(splitted);}array=array.concat(splitted);}else{array.push(tmp[i]);}}}else{array=split(prompt+string,num_chars);array[0]=array[0].replace(re,'');}// fix issue with cursor that was cut off #379
if(array.length>1){var len=$.terminal.length(array[array.length-1]);if(len===num_chars){array.push('');}}return array;}// ---------------------------------------------------------------------
var cmd_line_worker=new WorkerCache({validation:function validation(key){var result=false;if((!this._previous_value||this._previous_value===key)&&(!this._cols||this._cols===num_chars)){result=true;}this._previous_value=key;this._cols=num_chars;return result;},action:process_cmd_line});// ---------------------------------------------------------------------
function split_command_line(string){return cmd_line_worker.get(string);}// ---------------------------------------------------------------------
// :: use custom formatting
// ---------------------------------------------------------------------
function formatting(string,skip_formatted_position){// we don't want to format command when user type formatting in
try{string=$.terminal.escape_formatting(string);var format_options=$.extend({},settings,{unixFormattingEscapeBrackets:true,position:_position,command:true});var formatted=$.terminal.apply_formatters(string,format_options);var output=$.terminal.normalize(formatted[0]);var max=$.terminal.length(output);if(!skip_formatted_position){formatted_position=formatted[1];// fix issue with nested formatting where max length
// is checked before nested_formatting flatten formatting
if(formatted_position>max){formatted_position=max;}}return output;}catch(e){alert_exception('[Formatting]',e.stack);return string;}}// ---------------------------------------------------------------------
// :: format and encode the string
// ---------------------------------------------------------------------
function format(string,before){//string = $.terminal.normalize(string);
var encoded=$.terminal.encode(wrap(string),{tabs:settings.tabs,before:before});return $.terminal.format(encoded,{charWidth:settings.charWidth,allowedAttributes:settings.allowedAttributes||[]});}// ---------------------------------------------------------------------
// :: function create new string with all characters in it's own
// :: formatting - it will only have style if the input is formatting
// :: this function is not very usefull so it's not in $.terminal
// ---------------------------------------------------------------------
function wrap(string){return $.terminal.partition(string).join('');}// ---------------------------------------------------------------------
// :: shortcut helpers
// ---------------------------------------------------------------------
function length(str,raw){return $.terminal.length(str,raw);}// ---------------------------------------------------------------------
function is_multiline(str){return strlen(text(str))>num_chars-prompt_len-1||str.match(/\n/);}// ---------------------------------------------------------------------
function substring(str,start,end){return $.terminal.substring(str,start,end);}// ---------------------------------------------------------------------
// :: helper function that check if string is valid emoji formatting
// ---------------------------------------------------------------------
function is_emoji_formatting(str){if($.terminal.is_formatting(str)){return str.replace(format_parts_re,'$4').match(/^emoji /);}return false;}// ---------------------------------------------------------------------
// :: Function that displays the command line. Split long lines and
// :: place cursor in the right place
// ---------------------------------------------------------------------
var redraw=function(){var before=cursor.prev();var after=cursor.next();var cursor_line=cursor.parent();// -----------------------------------------------------------------
// :: Draw line with the cursor
// -----------------------------------------------------------------
function draw_cursor_line(string,options){var end_line=string.match(line_marker_re);if(end_line){string=string.replace(line_marker_re,' ');}cursor_line.toggleClass('cmd-end-line',!!end_line);var cursor_end_line=false;var settings=$.extend({prompt:'',last:false},options);var position=settings.position;var len=length(string);var prompt=settings.prompt;var c;if(position===len){before.html(format(string));c='&nbsp;';empty_cursor();after.html('');}else if(position===0){before.html('');c=substring(string,0,1);cursor.html(format(c));after.html(format(substring(string,1),prompt+c));}else{var before_str=$.terminal.substring(string,0,position);before.html(format(before_str,prompt));c=substring(string,position,position+1);var c_before=(prompt+before_str).replace(/^.*\t/,'');cursor.html(format(c,c_before));if(position===len-1){cursor_end_line=true;after.html('');}else{if(c.match(/\t/)){c_before='';}else{c_before+=c;}after.html(format(substring(string,position+1),c_before));}}if(ch_unit_bug){if(typeof wcwidth!=='undefined'){// handle emoji and wide characters in IE or
// other possible browsers that don't have valid ch unit
var size=strlen(text(c));if(size===1&&is_emoji_formatting(c)){size=2;}cursor.width(char_width*size);}else{cursor.width(char_width);}}cursor.toggleClass('cmd-end-line',cursor_end_line);// fix for animation when changing --animation dynamically
fix_cursor();var cursor_len=$.terminal.length(cursor.text());if(cursor_len>1){var node=cursor.find('[data-text]')[0];node.style.setProperty('--length',cursor_len);}// synchronize css animations (it's not that important because if user
// will change animation she should disable animation on span, but it
// looks nicer until she disable that inner animation)
restart_animation();}// -----------------------------------------------------------------
function div(string,before){var end_line=string.match(line_marker_re);var result='<div role="presentation" aria-hidden="true"';if(end_line){string=string.replace(line_marker_re,' ');result+=' class="cmd-end-line"';}result+='>'+format(string,before||'')+'</div>';return result;}// -----------------------------------------------------------------
function empty_cursor(){// data-text is for consistency in CSS and end class is for unit tests
cursor.html('<span data-text class="end"><span>&nbsp;<span></span>');}// -----------------------------------------------------------------
// :: Display lines after the cursor
// -----------------------------------------------------------------
function lines_after(lines){var last_ins=cursor_line;$.each(lines,function(i,line){last_ins=$(div(line)).insertAfter(last_ins);});}// -----------------------------------------------------------------
// :: Display lines before the cursor
// -----------------------------------------------------------------
function lines_before(lines){$.each(lines,function(i,line){cursor_line.before(div(line,i===0?prompt_last_line:''));});}// -----------------------------------------------------------------
// :: Redraw function
// -----------------------------------------------------------------
return function(){var string;switch(_typeof(settings.mask)){case'boolean':string=settings.mask?command.replace(/./g,'*'):command;break;case'string':string=command.replace(/./g,settings.mask);break;}var formatted=formatting(string);var pos;if(length(formatted)===text(string).length){pos=_position;}else{pos=formatted_position;}var i;wrapper.css({display:'none'});wrapper.find('div:not(.cmd-cursor-line)').remove();before.html('');if(is_multiline(formatted)){var tabs=formatted.match(/\t/g);var original_string=formatted;//quick tabulation hack
if(tabs){formatted=formatted.replace(/\t/g,'\x00\x00\x00\x00');}var array=split_command_line(formatted);if(tabs){array=$.map(array,function(line){return line.replace(/\x00\x00\x00\x00/g,'\t');});}var first_len=length(array[0]);//cursor in first line
if(first_len===0&&array.length===1){// skip empty line
}else if(pos<first_len){draw_cursor_line(array[0],{length:array.length,position:pos,prompt:prompt_last_line});lines_after(array.slice(1));}else if(pos===first_len){// first char acter of second line
cursor_line.before(div(array[0],prompt_last_line));draw_cursor_line(array[1]||'',{length:array.length,position:0,last:array.length<=2});if(array.length>2){lines_after(array.slice(2));}}else{var last=array.slice(-1)[0];var len=length(original_string);var from_last=len-pos;var last_len=length(last);var new_pos=0;if(from_last===-1){from_last=0;}if(from_last<=last_len){// in last line
lines_before(array.slice(0,-1));if(last_len===from_last){new_pos=0;}else{new_pos=last_len-from_last;}draw_cursor_line(last,{length:array.length,position:new_pos,last:true});}else{// more lines, cursor in the middle
var line_index;var current;new_pos=pos;for(i=0;i<array.length;++i){var current_len=$.terminal.length(array[i]);if(new_pos>current_len){new_pos-=current_len;}else{break;}}current=array[i];line_index=i;// cursor on first character in line
if(new_pos===length(current)){new_pos=0;current=array[++line_index];if(current===undefined){//should never happen
var msg=$.terminal.defaults.strings.redrawError;throw new Error(msg);}}draw_cursor_line(current,{length:array.length,position:new_pos});lines_before(array.slice(0,line_index));lines_after(array.slice(line_index+1));}}self.find('.cmd-cursor-line ~ div:last-of-type').append('<span></span>');}else if(formatted===''){before.html('');empty_cursor();after.html('');}else{draw_cursor_line(formatted,{length:1,position:pos});}var in_line=cursor_line.prevUntil('.cmd-prompt').length;if(is_css_variables_supported){self[0].style.setProperty('--cursor-line',in_line);}else{_clip.$node.css('top',in_line*14+'px');}wrapper.css({display:''});};}();// ---------------------------------------------------------------------
// :: find position that match display position for commands that
// :: change length by formatters
// ---------------------------------------------------------------------
var find_position=function(){function make_guess(string,position){var opts=$.extend({},settings,{position:position,command:true});return $.terminal.apply_formatters(string,opts)[1];}function cmp(search_pos,pos,string){var guess=make_guess(string,pos);if(guess===search_pos){var next_guess=make_guess(string,pos+1);if(next_guess>search_pos){return 0;}return 1;}else if(guess<search_pos){return 1;}else{return-1;}}return function(string,formatted_position){if(formatted_position===0){return 0;}string=bare_text(string);var codepoint_len=string.length;var str=$.terminal.escape_brackets(command);var pos=binary_search(0,codepoint_len,formatted_position,cmp,[str]);var chars=$.terminal.split_characters(string);if(codepoint_len>chars.length){var len=0;for(var i=0;i<chars.length;++i){len+=chars[i].length;if(len>=pos){return len;}}}return pos;};}();// ---------------------------------------------------------------------
// :: Draw prompt that can be a function or a string
// ---------------------------------------------------------------------
var prev_prompt_data;var draw_prompt=function(){function format_prompt(prompt){if(!prompt){just_prompt_len=0;prompt_len=just_prompt_len+extra_prompt_margin;return prompt;}var lines=$.terminal.split_equal(prompt,num_chars).map(function(line){if(!$.terminal.have_formatting(line)){return'[[;;]'+$.terminal.escape_brackets(line)+']';}return $.terminal.format_split(line).map(function(str){if($.terminal.is_formatting(str)){return str;}return'[[;;]'+$.terminal.escape_brackets(str)+']';}).join('');});var options={charWidth:settings.charWidth};prompt_last_line=lines[lines.length-1];var encoded_last_line=$.terminal.encode(lines[lines.length-1],{tabs:settings.tabs});var last_line=$.terminal.format(encoded_last_line,options);just_prompt_len=strlen(text(encoded_last_line));prompt_len=just_prompt_len+extra_prompt_margin;return lines.slice(0,-1).map(function(line){line=$.terminal.encode(line,{tabs:settings.tabs});return'<span class="cmd-line">'+$.terminal.format(line,options)+'</span>';}).concat([last_line]).join('\n');}function set(prompt){if(prompt){prompt=$.terminal.apply_formatters(prompt,{prompt:true});prompt=$.terminal.normalize(prompt);prompt=crlf(prompt);}var formatted=format_prompt(prompt);last_rendered_prompt=prompt;// zero width space to make sure prompt margin takes up space,
// so that echo with newline: false works when prompt is empty
formatted=formatted||$.terminal.format("[[;;]\u200B]");// update prompt if changed
if(prompt_node.html()!==formatted){prompt_node.html(formatted);// fix for Chrome bug width selection
// https://bugs.chromium.org/p/chromium/issues/detail?id=1087787
var spans=prompt_node.find('> span span');_clip.$node.attr('data-cmd-prompt',prompt_node.text());if(is_ch_unit_supported){prompt_node.hide();spans.each(function(){var self=$(this);var len=strlen(self.text());if(len===0){self.css('width',1);}else{self.css('width',len+'ch');}});prompt_node.show();}}}return function(){// the data is used as cancelable reference because we have ref
// data object that is hold in closure and we remove `set` function
// so previous call to function prompt will be ignored
if(prev_prompt_data&&prev_prompt_data.set){prev_prompt_data.set=$.noop;// remove reference for garbage collector
prev_prompt_data=null;}var data=prev_prompt_data={set:set};with_prompt(_prompt,function(prompt){data.set(prompt);},self);};}();// ---------------------------------------------------------------------
function fire_change_command(){if(is_function(settings.onCommandChange)){settings.onCommandChange.call(self,command);}}// ---------------------------------------------------------------------
// :: Command Line Methods
// ---------------------------------------------------------------------
$.extend(self,{option:function option(name,value){if(typeof value==='undefined'){return settings[name];}else{settings[name]=value;}return self;},name:function name(string){if(string!==undefined){_name=string;var enabled=history&&history.enabled()||!history;history=new History(_name,settings.historySize,settings.history==='memory');// disable new history if old was disabled
if(!enabled){history.disable();}return self;}else{return _name;}},purge:function purge(){history.clear();return self;},history:function(_history){function history(){return _history.apply(this,arguments);}history.toString=function(){return _history.toString();};return history;}(function(){return history;}),'delete':function _delete(n,stay){var removed,string;if(n===0){return"";}else if(n<0){if(_position>0){// this may look weird but if n is negative we need
// to use +
removed=command.slice(0,_position).slice(n);string=bare_text(command);string=string.slice(0,_position+n)+string.slice(_position,string.length);if(!stay){self.position(_position+n);}}}else if(command!==''){string=text(command);if(_position<string.length){removed=string.slice(_position).slice(0,n);string=string.slice(0,_position)+string.slice(_position+n,string.length);}}if(removed){command=string;}redraw();fix_textarea();fire_change_command();return removed;},set:function set(string,stay,silent){if(string!==undefined){command=string;if(!stay){self.position(bare_text(command).length);}redraw();fix_textarea();if(!silent){fire_change_command();}}return self;},keymap:function keymap(new_keymap,value){function wrap(key,fn){var original=default_keymap[key];if(is_function(original)){original=original.bind(self);}return function(e){// new keymap function will get default as 2nd argument
return fn.call(self,e,original);};}if(new_keymap===null){_keymap=default_keymap;return self;}else if(typeof new_keymap==='undefined'){return _keymap;}else if(typeof new_keymap==='string'){if(typeof value==='undefined'){if(_keymap[new_keymap]){return _keymap[new_keymap];}else if(default_keymap[new_keymap]){return default_keymap[new_keymap];}}else{_keymap[new_keymap]=wrap(new_keymap,value);}}else{_keymap=$.extend({},_keymap?_keymap:default_keymap,$.omap(new_keymap||{},wrap));return self;}},insert:function insert(string,stay){var bare_command=bare_text(command);var len=bare_text(string).length;if(_position===bare_command.length){string=bare_command+string;}else if(_position===0){string=string+bare_command;}else{string=bare_command.slice(0,_position)+string+bare_command.slice(_position);}command=string;if(!stay){self.position(len,true,true);}fix_textarea();redraw();fire_change_command();return self;},get:function get(){return command;},commands:function commands(_commands){if(_commands){settings.commands=_commands;return self;}else{return _commands;}},destroy:function destroy(){doc.unbind('keypress.cmd',keypress_event);doc.unbind('keydown.cmd',keydown_event);doc.unbind('input.cmd',input_event);self.stopTime('blink',blink);self.find('.cmd-wrapper').remove();self.find('.cmd-prompt, .cmd-clipboard, .cmd-editable').remove();self.removeClass('cmd').removeData('cmd').off('.cmd');return self;},column:function column(include_prompt){var before=command.substring(0,_position);if(_position===0||!command.length){return 0;}var re=/\n?([^\n]*)$/;var match=before.match(re);var col=match[1].length;if(!have_newlines(before)&&(include_prompt||have_wrapping(before,prompt_len))){col+=prompt_len;}if(col===0){return col;}col%=num_chars;if(col===0){return num_chars;}return col;},line:function line(){var before=command.substring(0,_position);if(_position===0||!command.length){return 0;}return before.split(/\n/).length-1;},// inform cursor about size of partial output line
__set_prompt_margin:function __set_prompt_margin(len){extra_prompt_margin=len;prompt_len=just_prompt_len+extra_prompt_margin;},prompt:function prompt(user_prompt){if(user_prompt===true){return last_rendered_prompt;}else if(user_prompt===undefined){return _prompt;}else{var should_redraw=user_prompt!==_prompt;if(typeof user_prompt==='string'||typeof user_prompt==='function'){_prompt=user_prompt;}else{throw new Error('prompt must be a function or string');}if(should_redraw){draw_prompt();// we could check if command is longer then numchars-new
// prompt
redraw();}return self;}},kill_text:function kill_text(){return _kill_text;},position:function position(n,relative,silent){if(typeof n==='number'){var pos=_position;var len=bare_text(command).length;if(relative){_position+=n;}else if(n<0){_position=0;}else if(n>len){_position=len;}else{_position=n;}if(pos!==_position){redraw();if(!silent&&is_function(settings.onPositionChange)){settings.onPositionChange(_position,formatted_position);}fix_textarea(true);}return self;}else{return _position;}},refresh:function refresh(){draw_prompt();redraw();fix_textarea(true);return self;},// if formatter change length of the strings (like emoji demo) we need to keep
// track of two different positions one for command and one for display
display_position:function display_position(n,relative){if(n===undefined){return formatted_position;}else{// double escape
var string=formatting($.terminal.escape_formatting(command),true);var len=length(string);var command_len=bare_text(command).length;var new_formatted_pos;if(relative){new_formatted_pos=formatted_position+n;}else if(n>len){new_formatted_pos=len;}else{new_formatted_pos=n;}if(len===command_len){formatted_position=new_formatted_pos;return self.position(new_formatted_pos);}if(len===new_formatted_pos){formatted_position=new_formatted_pos;return self.position(command_len);}var pos=find_position(command,new_formatted_pos);if(pos!==-1){formatted_position=new_formatted_pos;self.position(pos);}return self;}},visible:function(){var visible=self.visible;return function(){visible.apply(self,[]);redraw();draw_prompt();return self;};}(),show:function(){var show=self.show;return function(){show.apply(self,[]);redraw();draw_prompt();return self;};}(),resize:function resize(num){char_width=get_char_width();var new_num_chars;if(typeof num==='number'){new_num_chars=num;}else{new_num_chars=get_num_chars(char_width);}if(num_chars!==new_num_chars||arguments[0]===true){num_chars=new_num_chars;redraw();draw_prompt();}return self;},invoke_key:function invoke_key(shortcut){if(!enabled){warn('invoke_key("'+shortcut+'") called on disabled terminal');}var keys=shortcut.toUpperCase().split('+');var key=keys.pop();var ctrl=keys.indexOf('CTRL')!==-1;var shift=keys.indexOf('SHIFT')!==-1;var alt=keys.indexOf('ALT')!==-1;var meta=keys.indexOf('META')!==-1;var e=$.Event("keydown",{ctrlKey:ctrl,shiftKey:shift,altKey:alt,metaKey:meta,which:reversed_keycodes[key],key:key});var doc=$(document.documentElement||window);doc.trigger(e);e=$.Event("keypress");e.key=key;e.which=e.keyCode=0;doc.trigger(e);return self;},clip:function clip(){return _clip;},enable:function enable(silent){if(!enabled){enabled=true;self.addClass('enabled');try{if(!_clip.$node.is(':focus')){_clip.$node.focus();}_clip.$node.caret(_position);}catch(e){// firefox throw NS_ERROR_FAILURE - ignore
}animation(true);if(!silent&&is_function(_prompt)){draw_prompt();}fix_cursor();fix_textarea();}mobile_focus();return self;},isenabled:function isenabled(){return enabled;},disable:function disable(focus){enabled=false;self.removeClass('enabled');animation(false);if(!focus){mobile_focus();}return self;},mask:function mask(new_mask){if(typeof new_mask==='undefined'){return settings.mask;}else{settings.mask=new_mask;redraw();return self;}}});// ---------------------------------------------------------------------
// :: INIT
// ---------------------------------------------------------------------
self.name(settings.name||settings.prompt||'');if(settings.prompt!==false){_prompt=settings.prompt;draw_prompt();}if(settings.enabled===true){self.enable();}char_width=get_char_width();num_chars=get_num_chars(char_width);if(!settings.history){history.disable();}var first_up_history=true;// skip_keypress - hack for Android that was inserting characters on
// backspace
var skip_keypress=false;var dead_key=false;var single_key=false;var no_keypress=false;var no_key=false;var no_keydown=true;var backspace=false;var process=false;var hold=false;var hold_pause=false;var skip_insert;// we hold text before keydown to fix backspace for Android/Chrome/SwiftKey
// keyboard that generate keycode 229 for all keys #296
var prev_command='';var prev_key;// ---------------------------------------------------------------------
// :: Keydown Event Handler
// ---------------------------------------------------------------------
function is_backspace(e){return e.key.toUpperCase()==='BACKSPACE'||e.which===8;}// ---------------------------------------------------------------------
function is_single(e){return e.key&&e.key.length===1&&!e.ctrlKey;}// ---------------------------------------------------------------------
function is_delay_key(key){var specials=['HOLD+SHIFT+BACKSPACE','HOLD+BACKSPACE'];return specials.indexOf(key)!==-1&&settings.mobileDelete||settings.repeatTimeoutKeys.indexOf(key)!==-1;}// ---------------------------------------------------------------------
function clear_reverse_search_key(e){// arrows / Home / End / ENTER
return e.which===35||e.which===36||e.which===37||e.which===38||e.which===39||e.which===40||e.which===13||e.which===27;}var skip_keydown=false;// ---------------------------------------------------------------------
// function complexicity is 35 when adding this exception
// eslint-disable-next-line complexity
function keydown_event(e){debug('keydown "'+e.key+'" '+e.fake+' '+e.which);var result;process=(e.key||'').toLowerCase()==='process'||e.which===0;dead_key=no_keypress&&single_key&&!is_backspace(e);// special keys don't trigger keypress fix #293
try{if(!e.fake){single_key=is_single(e);// chrome on android support key property but it's "Unidentified"
no_key=String(e.key).toLowerCase()==='unidentified';backspace=is_backspace(e);}}catch(exception){}// keydown created in input will have text already inserted and we
// want text before input
if(e.key==="Unidentified"){no_keydown=true;// android swift keyboard have always which == 229 we will triger proper
// event in input with e.fake == true
return;}// meta and os are special keydown triggered by Emoji picker on Windows 10
// meta is in Google Chrome is is in Firefox
if(!e.fake&&['meta','os'].indexOf(e.key.toLowerCase())===-1){no_keydown=false;}no_keypress=true;// Meta+V did bind input but it didin't happen because terminal paste
// prevent native insert action
_clip.$node.off('input',paste);var key=get_key(e);if(is_function(settings.keydown)){e.key=ie_key_fix(e);result=settings.keydown.call(self,e);if(result!==undefined){//skip_keypress = true;
if(!result){skip_insert=true;}return result;}}if(key!==prev_key){clear_hold();}// CTRL+C hanlding is only exception of cmd aware terminal logic
// cmd need to call CTRL+C keymap when terminal is not enabled
if(enabled||key==='CTRL+C'&&is_terminal_selected(self)){if(hold){prev_key=key;key='HOLD+'+key;if(hold_pause){return;}if(settings.holdRepeatTimeout>0&&is_delay_key(key)){hold_pause=true;self.oneTime(settings.holdRepeatTimeout,'delay',function(){hold_pause=false;});}}else{self.oneTime(settings.holdTimeout,'hold',function(){hold=true;});prev_key=key;}// if e.fake ignore of space is handled in input and next keydown
// is not triggered this is just in case code since on Android
// keydown is not triggered only input so event is always fake on Android
if(!e.fake&&is_android){if(skip_keydown){clear_hold();skip_keydown=false;return false;}if(mobile_ignore_key(key)){skip_keydown=true;}else if(mobile_ignore_key(prev_key)){// just in case next key is different then space
skip_keydown=false;}}restart_animation();// CTRL+V don't fire keypress in IE11
skip_insert=['CTRL+V','META+V'].indexOf(key)!==-1;// only enter will reset history (and down arrow on last command)
if(key.toLowerCase()==='enter'){first_up_history=true;}if(reverse_search&&clear_reverse_search_key(e)){clear_reverse_state();draw_prompt();if(e.which===27){// ESC
self.set('');}redraw();if(e.which===13){keydown_event.call(this,e);}}else if(is_function(_keymap[key])){result=_keymap[key](e);if(result===true){return;}if(result!==undefined){return result;}}else if(e.altKey){return;}else{skip_keypress=false;return;}// this will prevent for instance backspace to go back one page
//skip_keypress = true;
//e.preventDefault();
}}function clear_hold(){self.stopTime('hold');self.stopTime('delay');hold_pause=hold=false;}var doc=$(document.documentElement||window);self.keymap(settings.keymap||{});function keypress_event(e){debug('keypress "'+e.key+'" '+e.fake);clear_hold();var result;if(!e.fake){no_keypress=false;}if((e.ctrlKey||e.metaKey)&&!e.altKey){return;}if(skip_keypress){return;}if(is_function(settings.keypress)){result=settings.keypress.call(self,e);if(result!==undefined){if(!result){skip_insert=true;}return result;}}if(enabled){if(e.fake){// event created in input, we prevent inserting text
// in different interpreter when keydown called pop
return;}// key polyfill is not correct for keypress
// https://github.com/cvan/keyboardevent-key-polyfill/issues/15
var key;if(is_key_native){key=e.key;// fixing IE inconsistency #362
var normalized=key.toUpperCase();if(key_mapping[normalized]){key=key_mapping[normalized];}}if(!key||no_key){key=String.fromCharCode(e.which);}if($.inArray(e.which,[13,0,8])>-1){if(e.keyCode===123){// for F12 which === 0
return;}return false;// which === 100 - d
}else if(key&&(!e.ctrlKey||e.ctrlKey&&e.ctrlKey)&&(!(e.altKey&&e.which===100)||e.altKey)&&!dead_key){// dead_key are handled by input event
if(reverse_search){rev_search_str+=key;reverse_history_search();draw_reverse_prompt();}else if(key.length===1){self.insert(key);}}}}function event(type,chr,which){var event=$.Event(type);event.which=which;event.key=chr;event.fake=true;doc.trigger(event);}var skip_input=false;function finalize_input_event(){prev_command=command;skip_insert=false;no_keydown=true;}function input_event(){debug('input '+no_keydown+' || '+process+' (('+no_keypress+' || '+dead_key+') && !'+skip_insert+' && ('+single_key+' || '+no_key+') && !'+backspace+')');// correct for fake space used for select all context menu hack
var val=_clip.val();if(!is_mobile){val=val.replace(/^ /,'');}// Some Androids don't fire keypress - #39
// if there is dead_key we also need to grab real character #158
// Firefox/Android with google keyboard don't fire keydown and keyup #319
if(no_keydown||process||(no_keypress||dead_key)&&!skip_insert&&(single_key||no_key)&&!backspace){if(val&&val===command){if(is_android){// ignore autocomplete on GBoard keyboard #693
if(no_keydown){event('keydown','Enter',13);}}finalize_input_event();return;}var pos=_position;// backspace is set in keydown if no keydown we need to get new one
if(no_keydown){var cmd=prev_command;backspace=cmd.slice(0,cmd.length-1).length===val.length;}if(skip_input){skip_input=false;_clip.val(command);return;}if(reverse_search){rev_search_str=val;reverse_history_search();draw_reverse_prompt();}else{var str=val.slice(_position);if(str.length===1||backspace){// original not optimized function called once
var chr=get_next_character(str);if(mobile_ignore_key(chr)){skip_input=true;}// we trigger events so keypress and keydown callback work
if(no_keydown){var keycode;if(backspace){keycode=8;}else{keycode=str.toUpperCase().charCodeAt(0);}event('keydown',backspace?'Backspace':str,keycode);}if(no_keypress&&!backspace){event('keypress',chr,str.charCodeAt(0));}}if(backspace){prev_command=command;return;}// if user return false in keydown we don't want to insert text
if(skip_insert){skip_insert=false;return;}self.set(val);}if(backspace){self.position(pos-1);}else{// user enter more then one character if click on complete word
// on android
self.position(pos+Math.abs(val.length-prev_command.length));}}finalize_input_event();}doc.bind('keypress.cmd',keypress_event);doc.bind('keydown.cmd',keydown_event);doc.bind('keyup.cmd',clear_hold);doc.bind('input.cmd',input_event);(function(){if(is_mobile){$(self[0]).add(_clip.$node).on('touchstart.cmd',function(){if(!self.isenabled()){_clip.focus();}else{_clip.blur();}});self.disable();return;}var was_down=false;var count=0;self.on('mousedown.cmd',function(){was_down=true;}).on('mouseup.cmd',function(e){function trigger(){var $target=$(e.target);var is_prompt=$target.is('.cmd-prompt');if(!is_prompt&&down&&get_selected_html()===''){if(enabled){if($target.is('.cmd')){self.position(text(command).length);}else{self.display_position(get_char_pos(e));}}}count=0;}// we get button from event for testing normally it's on originalEvent
var button;if(e.originalEvent===undefined){button=e.button;}else{button=e.originalEvent.button;}if(button===0&&get_selected_html()===''){var name='click_'+id;if(++count===1){var down=was_down;if(enabled){if(settings.clickTimeout===0){trigger();}else{self.oneTime(settings.clickTimeout,name,trigger);}}else{count=0;}}else{self.stopTime(name);count=0;}}was_down=false;});})();self.data('cmd',self);if(!('KeyboardEvent'in window&&'key'in window.KeyboardEvent.prototype)){setTimeout(function(){throw new Error('key event property not supported try https://github.'+'com/inexorabletash/polyfill/blob/master/keyboard.js');},0);}return self;};// cmd plugin
// -------------------------------------------------------------------------
var strlen=function(){if(typeof wcwidth==='undefined'){return function(string){// fix empty prompt that use 0 width space
string=string.replace(/\u200B/g,'');return $.terminal.length(string);};}else{return wcwidth;}}();// -------------------------------------------------------------------------
function count_selfclosing_formatting(string){var count=0;if($.terminal.have_formatting(string)){var re=new RegExp(format_parts_re.source,'i');// without g flag
$.terminal.format_split(string).forEach(function(str){if($.terminal.is_formatting(str)){var m=str.match(re);if(m&&m[1].match(/@/)&&m[6]===''){count++;}}});}return count;}// -------------------------------------------------------------------------
// entiteis are case sensitive
// generated from https://www.freeformatter.com/html-entities.html
// -------------------------------------------------------------------------
var entities={"&amp;":"&","&lt;":"<","&gt;":">","&Agrave;":"À","&Aacute;":"Á","&Acirc;":"Â","&Atilde;":"Ã","&Auml;":"Ä","&Aring;":"Å","&AElig;":"Æ","&Ccedil;":"Ç","&Egrave;":"È","&Eacute;":"É","&Ecirc;":"Ê","&Euml;":"Ë","&Igrave;":"Ì","&Iacute;":"Í","&Icirc;":"Î","&Iuml;":"Ï","&ETH;":"Ð","&Ntilde;":"Ñ","&Ograve;":"Ò","&Oacute;":"Ó","&Ocirc;":"Ô","&Otilde;":"Õ","&Ouml;":"Ö","&Oslash;":"Ø","&Ugrave;":"Ù","&Uacute;":"Ú","&Ucirc;":"Û","&Uuml;":"Ü","&Yacute;":"Ý","&THORN;":"Þ","&szlig;":"ß","&agrave;":"à","&aacute;":"á","&acirc;":"â","&atilde;":"ã","&auml;":"ä","&aring;":"å","&aelig;":"æ","&ccedil;":"ç","&egrave;":"è","&eacute;":"é","&ecirc;":"ê","&euml;":"ë","&igrave;":"ì","&iacute;":"í","&icirc;":"î","&iuml;":"ï","&eth;":"ð","&ntilde;":"ñ","&ograve;":"ò","&oacute;":"ó","&ocirc;":"ô","&otilde;":"õ","&ouml;":"ö","&oslash;":"ø","&ugrave;":"ù","&uacute;":"ú","&ucirc;":"û","&uuml;":"ü","&yacute;":"ý","&thorn;":"þ","&yuml;":"ÿ","&nbsp;":" ","&iexcl;":"¡","&cent;":"¢","&pound;":"£","&curren;":"¤","&yen;":"¥","&brvbar;":"¦","&sect;":"§","&uml;":"¨","&copy;":"©","&ordf;":"ª","&laquo;":"«","&not;":"¬","&shy;":"­","&reg;":"®","&macr;":"¯","&deg;":"°","&plusmn;":"±","&sup2;":"²","&sup3;":"³","&acute;":"´","&micro;":"µ","&para;":"¶","&cedil;":"¸","&sup1;":"¹","&ordm;":"º","&raquo;":"»","&frac14;":"¼","&frac12;":"½","&frac34;":"¾","&iquest;":"¿","&times;":"×","&divide;":"÷","&forall;":"∀","&part;":"∂","&exist;":"∃","&empty;":"∅","&nabla;":"∇","&isin;":"∈","&notin;":"∉","&ni;":"∋","&prod;":"∏","&sum;":"∑","&minus;":"−","&lowast;":"∗","&radic;":"√","&prop;":"∝","&infin;":"∞","&ang;":"∠","&and;":"∧","&or;":"∨","&cap;":"∩","&cup;":"∪","&int;":"∫","&there4;":"∴","&sim;":"∼","&cong;":"≅","&asymp;":"≈","&ne;":"≠","&equiv;":"≡","&le;":"≤","&ge;":"≥","&sub;":"⊂","&sup;":"⊃","&nsub;":"⊄","&sube;":"⊆","&supe;":"⊇","&oplus;":"⊕","&otimes;":"⊗","&perp;":"⊥","&sdot;":"⋅","&Alpha;":"Α","&Beta;":"Β","&Gamma;":"Γ","&Delta;":"Δ","&Epsilon;":"Ε","&Zeta;":"Ζ","&Eta;":"Η","&Theta;":"Θ","&Iota;":"Ι","&Kappa;":"Κ","&Lambda;":"Λ","&Mu;":"Μ","&Nu;":"Ν","&Xi;":"Ξ","&Omicron;":"Ο","&Pi;":"Π","&Rho;":"Ρ","&Sigma;":"Σ","&Tau;":"Τ","&Upsilon;":"Υ","&Phi;":"Φ","&Chi;":"Χ","&Psi;":"Ψ","&Omega;":"Ω","&alpha;":"α","&beta;":"β","&gamma;":"γ","&delta;":"δ","&epsilon;":"ε","&zeta;":"ζ","&eta;":"η","&theta;":"θ","&iota;":"ι","&kappa;":"κ","&lambda;":"λ","&mu;":"μ","&nu;":"ν","&xi;":"ξ","&omicron;":"ο","&pi;":"π","&rho;":"ρ","&sigmaf;":"ς","&sigma;":"σ","&tau;":"τ","&upsilon;":"υ","&phi;":"φ","&chi;":"χ","&psi;":"ψ","&omega;":"ω","&thetasym;":"ϑ","&upsih;":"ϒ","&piv;":"ϖ","&OElig;":"Œ","&oelig;":"œ","&Scaron;":"Š","&scaron;":"š","&Yuml;":"Ÿ","&fnof;":"ƒ","&circ;":"ˆ","&tilde;":"˜","&ensp;":" ","&emsp;":" ","&thinsp;":" ","&zwnj;":"‌","&zwj;":"‍","&lrm;":"‎","&rlm;":"‏","&ndash;":"–","&mdash;":"—","&lsquo;":"‘","&rsquo;":"’","&sbquo;":"‚","&ldquo;":"“","&rdquo;":"”","&bdquo;":"„","&dagger;":"†","&Dagger;":"‡","&bull;":"•","&hellip;":"…","&permil;":"‰","&prime;":"′","&Prime;":"″","&lsaquo;":"‹","&rsaquo;":"›","&oline;":"‾","&euro;":"€","&trade;":"™","&larr;":"←","&uarr;":"↑","&rarr;":"→","&darr;":"↓","&harr;":"↔","&crarr;":"↵","&lceil;":"⌈","&rceil;":"⌉","&lfloor;":"⌊","&rfloor;":"⌋","&loz;":"◊","&spades;":"♠","&clubs;":"♣","&hearts;":"♥","&diams;":"♦"};// -------------------------------------------------------------------------
function render_entities(str){return str.replace(/&#(x?)([0-9]+);/g,function(_,hex,code){code=parseInt(code,hex?16:10);return String.fromCharCode(code);}).replace(/(&[^;]+;)/g,function(_,entity){return entities[entity]||entity;});}// -------------------------------------------------------------------------
function bare_text(string){if(!string.match(/&/)){return string;}return render_entities(safe(string));}// -------------------------------------------------------------------------
function text(string){return bare_text($.terminal.strip(string));}// -------------------------------------------------------------------------
function safe(string){if(!string.match(/[<>&]/)){return string;}return string.replace(/&(?![^;]+;)/g,'&amp;').replace(/>/g,'&gt;').replace(/</g,'&lt;');}// -------------------------------------------------------------------------
function crlf(string){return string.replace(/\r/g,'');}// -------------------------------------------------------------------------
function char_len(chr){return entity_re.test(chr)?1:chr.length;}// -------------------------------------------------------------------------
function make_re_fn(re){return function(string){var m=string.match(re);if(starts_with(m)){return m[1];}};}// -------------------------------------------------------------------------
function starts_with(match){return match&&match.index===0;}// -------------------------------------------------------------------------
// :: optimized higher order function that it check complex regexes
// :: only when bigger string match those regexes, function is always
// :: used in loop when you process whole string, it's used to create local
// :: get_next_character function only cmd in input use original
// :: not optimized function
// -------------------------------------------------------------------------
function make_next_char_fun(string){var tests=[];[entity_re,emoji_re,combine_chr_re].forEach(function(re){if(string.match(re)){tests.push(make_re_fn(re));}});if(string.match(astral_symbols_re)){tests.push(function(string){var m1=string.match(astral_symbols_re);if(starts_with(m1)){var m2=string.match(combine_chr_re);if(m2&&m2.index===1){return string.slice(0,3);}return m1[1];}});}return function(string){for(var i=0;i<tests.length;++i){var test=tests[i];var ret=test(string);if(ret){return ret;}}return string[0];};}// -------------------------------------------------------------------------
// :: function that return character from beginning of the string
// :: counting emoji, suroggate pairs and combine characters
// -------------------------------------------------------------------------
function get_next_character(string){var match_entity=string.match(entity_re);if(starts_with(match_entity)){return match_entity[1];}var match_combo=string.match(combine_chr_re);if(starts_with(match_combo)){return match_combo[1];}var match_emoji=string.match(emoji_re);if(starts_with(match_emoji)){return match_emoji[1];}else if(string.charCodeAt(0)<255){return string[0];}else{var astral_match=string.match(astral_symbols_re);if(starts_with(astral_match)){match_combo=string.match(combine_chr_re);if(match_combo&&match_combo.index===1){return string.slice(0,3);}return string.slice(0,2);}else{return string[0];}}}// -------------------------------------------------------------------------
// normalize position for counting emoji and extra chars
// -------------------------------------------------------------------------
function normalize_position(string,position){if(position===0){return position;}string=$.terminal.strip(string);var result=$.terminal.split_characters(string).reduce(function(acc,chr){if(typeof acc==='number'){return acc;}var length=acc.length+char_len(chr);if(length>=position){return acc.position+1;}return{position:acc.position+1,length:length};},{position:0,length:0});if(typeof result==='number'){return result;}else{return result.position;}}// -------------------------------------------------------------------------
function char_width_prop(len,options){if(len===0){return'width: 1px';}else if(is_ch_unit_supported){return'width: '+len+'ch';}else if(!is_css_variables_supported){if(options.charWidth){return'width: '+options.charWidth*len+'px';}}else{return'--length: '+len;}return'';}// -------------------------------------------------------------------------
// options {charWidth}
function extra_css(text,options){if(typeof wcwidth!=='undefined'){var bare=bare_text(text);var len=strlen(bare);if(len>1&&len!==$.terminal.length(bare)){return char_width_prop(len,options);}}return'';}// -------------------------------------------------------------------------
function wide_characters(text,options){if(typeof wcwidth!=='undefined'){var bare=bare_text(text);var chars=$.terminal.split_characters(bare);if(chars.length===1){return text;}var specs=chars.map(function(chr){return{len:strlen(chr),chr:chr};}).reduce(function(arr,spec){var last=arr[arr.length-1];if(last){if(last.len!==spec.len){return arr.concat([{sum:spec.len,len:spec.len,specs:[spec]}]);}else{arr.pop();return arr.concat([{sum:last.sum+spec.len,len:last.len,specs:last.specs.concat(spec)}]);}}return[{sum:spec.len,specs:[spec],len:spec.len}];},[]);return specs.map(function(spec){if(spec.len===1){return make_string(spec);}var style=char_width_prop(spec.sum,options);if(spec.sum===chars.length||!style.length){return'<span>'+make_string(spec)+'</span>';}else if(spec.specs.length>1){return wrap(style,spec.specs.map(function(spec){return wrap(char_width_prop(spec.len),spec.chr);}).join(''));}else{return wrap(style,make_string(spec));}}).join('');}function make_string(spec){return spec.specs.map(function(spec){return spec.chr;}).join('');}function wrap(style,str){return'<span style="'+style+'">'+str+'</span>';}return text;}// ---------------------------------------------------------------------
// :: Binary search utility
// ---------------------------------------------------------------------
function binary_search(start,end,search_pos,compare_fn,more_args){var len=end-start;var mid=start+Math.floor(len/2);var args=[search_pos,mid].concat(more_args);var cmp=compare_fn.apply(null,args);if(cmp===0){return mid;}else if(cmp>0&&len>1){return binary_search(mid,end,search_pos,compare_fn,more_args);}else if(cmp<0&&len>1){return binary_search(start,mid,search_pos,compare_fn,more_args);}else{return-1;}}// -----------------------------------------------------------------
// :: selection utilities - should work in modern browser including IE9
// -----------------------------------------------------------------
function is_terminal_selected(cmd){if(is_function(window.getSelection)){var selection=window.getSelection();if(selection.toString()){var node=selection.getRangeAt(0).startContainer.parentNode;var term=$(node).closest('.terminal');return term.length&&(cmd&&term.find('.cmd').is(cmd)||!cmd);}}}// -----------------------------------------------------------------
function get_selected_html(){var html='';if(is_function(window.getSelection)){var sel=window.getSelection();if(sel.rangeCount){var container=document.createElement('div');for(var i=0,len=sel.rangeCount;i<len;++i){container.appendChild(sel.getRangeAt(i).cloneContents());}html=container.innerHTML;}}return html;}// -----------------------------------------------------------------
function with_selection(fn){var html='';var ranges=[];if(is_function(window.getSelection)){var selection=window.getSelection();if(selection.rangeCount){var container=document.createElement("div");for(var i=0,len=selection.rangeCount;i<len;++i){var range=selection.getRangeAt(i).cloneRange();ranges.push(range);container.appendChild(range.cloneContents());}html=container.innerHTML;}}fn(html);if(ranges.length){selection.removeAllRanges();ranges.forEach(function(range){selection.addRange(range);});}return html!=='';}// -----------------------------------------------------------------
function process_selected_line(){var $self=$(this);var result=$self.text();if($self.hasClass('cmd-end-line')){result+='\n';}return result;}// -----------------------------------------------------------------
function process_div(element){// span is empty line, div is default case with text
return $(element).find('> div, > span').map(process_selected_line).get().join('\n').replace(/\n$/,'');}// -----------------------------------------------------------------
function process_selected_html(html){var stdout;var text='';var $html=$('<div>'+html+'</div>');if(html.match(/<\/div>/)){// match multiple echo output
stdout=$html.find('div[data-index]').map(function(){return process_div(this);}).get().join('\n');// match inside single echo output
if(!stdout&&html.match(/style="width: 100%;?"/)){stdout=process_div($html);}text=stdout;}var $prompt=$html.find('.cmd-prompt');if($prompt.length){if(text.length){text+='\n';}text+=$prompt.text();}var $cmd_lines=$html.find('[role="presentation"]');if($cmd_lines.length){text+=$cmd_lines.map(process_selected_line).get().join('');}if(!text.length&&html){text=$html.text();}return text.replace(/\xA0/g,' ');// fix &nbsp; space
}// ---------------------------------------------------------------------
// :: copy given DOM element text to clipboard
// ---------------------------------------------------------------------
var support_copy=function(){if(typeof document==='undefined'){return false;}if(!is_function(document.queryCommandSupported)){return false;}return document.queryCommandSupported('copy');}();// ---------------------------------------------------------------------
var text_to_clipboard;if(support_copy){text_to_clipboard=function text_to_clipboard($textarea,text){var val=$textarea.val();var had_focus=$textarea.is(':focus');var pos=$textarea.caret();if(window.navigator&&window.navigator.clipboard){navigator.clipboard.writeText(text);}else if(had_focus){$textarea.val(text).focus();$textarea[0].select();document.execCommand('copy');$textarea.val(val);$textarea.caret(pos);}else{var $text=$('<textarea/>').css({position:'fixed',top:0,left:0}).appendTo('body');$text.val(text).focus();$text[0].select();document.execCommand('copy');$text.blur();$text.remove();}return true;};}else{text_to_clipboard=$.noop;}// ---------------------------------------------------------------------
var get_textarea_selection=function(){function noop(){return'';}if(typeof document==='undefined'){return noop;}var textarea=document.createElement('textarea');var selectionStart=('selectionStart'in textarea);textarea=null;if(selectionStart){return function(textarea){var length=textarea.selectionEnd-textarea.selectionStart;return textarea.value.substr(textarea.selectionStart,length);};}else if(document.selection){return function(){var range=document.selection.createRange();return range.text();};}else{return noop;}}();// ---------------------------------------------------------------------
function clear_textarea_selection(textarea){textarea.selectionStart=textarea.selectionEnd=0;}// ---------------------------------------------------------------------
// :: return string that are common in all elements of the array
// ---------------------------------------------------------------------
function common_string(string,array,matchCase){if(!array.length){return'';}var type=string_case(string);var result=[];for(var j=string.length;j<array[0].length;++j){var push=false;var candidate=array[0].charAt(j),candidateLower=candidate.toLowerCase();for(var i=1;i<array.length;++i){push=true;var current=array[i].charAt(j),currentLower=current.toLowerCase();if(candidate!==current){if(matchCase||type==='mixed'){push=false;break;}else if(candidateLower===currentLower){if(type==='lower'){candidate=candidate.toLowerCase();}else if(type==='upper'){candidate=candidate.toUpperCase();}else{push=false;break;}}else{push=false;break;}}}if(push){result.push(candidate);}else{break;}}return string+result.join('');}// ---------------------------------------------------------------------
function trigger_terminal_change(next){terminals.forEach(function(term){term.settings().onTerminalChange.call(term,next);});}// ---------------------------------------------------------------------
var select=function(){if(root.getSelection){var selection=root.getSelection();if(selection.setBaseAndExtent){return function(start,end){var selection=root.getSelection();selection.setBaseAndExtent(start,0,end,1);};}else{return function(start,end){var selection=root.getSelection();var range=document.createRange();range.setStart(start,0);range.setEnd(end,end.childNodes.length);selection.removeAllRanges();selection.addRange(range);};}}else{return $.noop;}}();// -------------------------------------------------------------------------
function process_command(original,fn){var string=original.trim();var array=string.match(command_re)||[];if(array.length){var name=array.shift();var args=$.map(array,function(arg){if(arg.match(/^["']/)){arg=arg.replace(/\n/g,"\\u0000\\u0000\\u0000\\u0000");arg=fn(arg);return arg.replace(/\x00\x00\x00\x00/g,'\n');}return fn(arg);});var quotes=$.map(array,function(arg){var m=arg.match(/^(['"`]).*\1$/);return m&&m[1]||'';});var rest=string.slice(name.length).trim();return{command:original,name:name,args:args,args_quotes:quotes,rest:rest};}else{return{command:original,name:'',args:[],args_quotes:[],rest:''};}}// -------------------------------------------------------------------------
$.terminal={version:'2.31.1',date:'Thu, 30 Dec 2021 10:56:33 +0000',// colors from https://www.w3.org/wiki/CSS/Properties/color/keywords
color_names:['transparent','currentcolor','black','silver','gray','white','maroon','red','purple','fuchsia','green','lime','olive','yellow','navy','blue','teal','aqua','aliceblue','antiquewhite','aqua','aquamarine','azure','beige','bisque','black','blanchedalmond','blue','blueviolet','brown','burlywood','cadetblue','chartreuse','chocolate','coral','cornflowerblue','cornsilk','crimson','cyan','darkblue','darkcyan','darkgoldenrod','darkgray','darkgreen','darkgrey','darkkhaki','darkmagenta','darkolivegreen','darkorange','darkorchid','darkred','darksalmon','darkseagreen','darkslateblue','darkslategray','darkslategrey','darkturquoise','darkviolet','deeppink','deepskyblue','dimgray','dimgrey','dodgerblue','firebrick','floralwhite','forestgreen','fuchsia','gainsboro','ghostwhite','gold','goldenrod','gray','green','greenyellow','grey','honeydew','hotpink','indianred','indigo','ivory','khaki','lavender','lavenderblush','lawngreen','lemonchiffon','lightblue','lightcoral','lightcyan','lightgoldenrodyellow','lightgray','lightgreen','lightgrey','lightpink','lightsalmon','lightseagreen','lightskyblue','lightslategray','lightslategrey','lightsteelblue','lightyellow','lime','limegreen','linen','magenta','maroon','mediumaquamarine','mediumblue','mediumorchid','mediumpurple','mediumseagreen','mediumslateblue','mediumspringgreen','mediumturquoise','mediumvioletred','midnightblue','mintcream','mistyrose','moccasin','navajowhite','navy','oldlace','olive','olivedrab','orange','orangered','orchid','palegoldenrod','palegreen','paleturquoise','palevioletred','papayawhip','peachpuff','peru','pink','plum','powderblue','purple','red','rosybrown','royalblue','saddlebrown','salmon','sandybrown','seagreen','seashell','sienna','silver','skyblue','slateblue','slategray','slategrey','snow','springgreen','steelblue','tan','teal','thistle','tomato','turquoise','violet','wheat','white','whitesmoke','yellow','yellowgreen','rebeccapurple'],// for unit tests
Cycle:Cycle,History:History,Stack:Stack,// ---------------------------------------------------------------------
// :: Validate html color (it can be name or hex)
// ---------------------------------------------------------------------
valid_color:function valid_color(color){if(color.match(color_re)){return true;}else{return $.inArray(color.toLowerCase(),$.terminal.color_names)!==-1;}},// ---------------------------------------------------------------------
// :: function check if given string contain invalid strings
// ---------------------------------------------------------------------
unclosed_strings:function unclosed_strings(string){return!!string.match(unclosed_strings_re);},// ---------------------------------------------------------------------
// :: Escape all special regex characters, so it can be use as regex to
// :: match exact string that contain those characters
// ---------------------------------------------------------------------
escape_regex:function escape_regex(str){if(typeof str==='string'){var special=/([-\\^$[\]()+{}?*.|])/g;return str.replace(special,'\\$1');}},// ---------------------------------------------------------------------
// :: test if string contain formatting
// ---------------------------------------------------------------------
have_formatting:function have_formatting(str){return typeof str==='string'&&!!str.match(format_exist_re);},is_formatting:function is_formatting(str){return typeof str==='string'&&!!str.match(format_full_re);},// ---------------------------------------------------------------------
is_extended_command:function is_extended_command(str){return typeof str==='string'&&str.match(format_exec_re)&&!$.terminal.is_formatting(str);},// ---------------------------------------------------------------------
each_extended_command:function each_extended_command(string,fn){var parts=string.split(format_exec_split_re);return $.map(parts,function(string){if($.terminal.is_extended_command(string)){var command=string.replace(/^\[\[|\]\]$/g,'');return fn(command)||'';}return string;}).join('');},// ---------------------------------------------------------------------
// :: return array of formatting and text between them
// ---------------------------------------------------------------------
format_split:function format_split(str){return str.split(format_split_re).filter(Boolean);},// ---------------------------------------------------------------------
// :: replace that return position after replace for working with
// :: replacement that change length of the string
// :: source https://stackoverflow.com/a/46756077/387194
// ---------------------------------------------------------------------
tracking_replace:function tracking_replace(string,rex,replacement,position){if(!(rex instanceof RegExp)){throw new Error('tracking_replace: Second argument need to be RegExp');}function substring(string,start,end){return string.slice(start,end);}function length(string){return $.terminal.strip(string).length;}var new_string="";var match;var index=0;var rep_string;var new_position=position;var start;rex.lastIndex=0;// Just to be sure
while(match=rex.exec(string)){// if regex don't have g flag lastIndex will not work
if(rex.global){// Add any of the original string we just skipped
var last_index=length(substring(string,0,rex.lastIndex));start=last_index-length(match[0]);}else{start=match.index;last_index=start+length(match[0]);}if(index<start){new_string+=substring(string,index,start);}index=last_index;// Build the replacement string. This just handles $$ and $n,
// you may want to add handling for $`, $', and $&.
if(typeof replacement==='function'){rep_string=replacement.apply(null,match);}else{rep_string=replacement.replace(/\$(\$|\d)/g,function(m,c0){if(c0==="$"){return"$";}return match[c0];});}// Add on the replacement
new_string+=rep_string;// If the position is affected...
if(start<position){// ... update it:
var rep_len=length(rep_string);rep_len+=count_selfclosing_formatting(rep_string);if(last_index<position){// It's after the replacement, move it
new_position=Math.max(0,new_position+rep_len-length(match[0]));}else{// It's *in* the replacement, put it just after
new_position+=rep_len-(position-start);}}// If the regular expression doesn't have the g flag, break here so
// we do just one replacement (and so we don't have an endless loop!)
if(!rex.global){break;}}// Add on any trailing text in the string
if(index<length(string)){new_string+=substring(string,index);}// Return the string and the updated position
if(string===new_string){return[string,position];}return[new_string,new_position];},// ---------------------------------------------------------------------
// :: helper function used by substring and split_equal it loop over
// :: string and execute callback with text count and other data
// ---------------------------------------------------------------------
iterate_formatting:function iterate_formatting(string,callback){function is_space(i){return string.slice(i-6,i)==='&nbsp;'||string.slice(i-1,i).match(/\s/);}// ----------------------------------------------------------------
function match_entity(index){return string.slice(index).match(entity_re);}// ----------------------------------------------------------------
function is_open_formatting(i){return string[i]==='['&&string[i+1]==='[';}// ----------------------------------------------------------------
function is_escape_bracket(i){return string[i-1]!=='\\'&&string[i]==='\\'&&string[i+1]===']';}// ----------------------------------------------------------------
function is_text(i){return not_formatting&&(string[i]!==']'||!have_formatting)&&!opening;}// ----------------------------------------------------------------
// :: function will skip to next character in main loop
// :: TODO: improve performance of emoji regex and check whole
// :: string it's complex string if not use simple function
// ----------------------------------------------------------------
var get_next_character=make_next_char_fun(string);function next_iteration(){var char=get_next_character(substring);if(char.length>1&&$.terminal.length(substring)>1){return char.length-1;}return 0;}// ----------------------------------------------------------------
function is_next_space(){return is_space(i)&&(not_formatting||opening)&&(space===-1&&prev_space!==i||space!==-1);}// ----------------------------------------------------------------
// :: last iteration or one before closing formatting
// ----------------------------------------------------------------
var last=false;function is_last(){if(i===string.length-1&&!last){last=true;}else{last=formatting&&!!substring.match(/^.]$/);}return last;}// ----------------------------------------------------------------
var have_formatting=$.terminal.have_formatting(string);var formatting='';var in_text=false;var count=0;var match;var space=-1;var space_count=-1;var prev_space;var length=0;var offset=0;var re_ent=/(&[^;]+);$/;for(var i=0;i<string.length;i++){var substring=string.slice(i);match=substring.match(format_start_re);if(match){formatting=match[1];in_text=false;}else if(formatting){if(string[i]===']'){if(in_text){formatting='';in_text=false;}else{in_text=true;}}}else{in_text=true;}var not_formatting=formatting&&in_text||!formatting;var opening=is_open_formatting(i);if(is_next_space()){space=i;space_count=count;}var braket=string[i].match(/[[\]]/);offset=0;if(not_formatting){// treat entity as one character
if(string[i]==='&'){match=match_entity(i);if(match){i+=match[1].length-2;// 2 because continue adds 1 to i
continue;}++count;++length;}else if(is_escape_bracket(i)){// escape \] and \\ counts as one character
++count;++length;offset=1;i+=1;}else if(!braket||!have_formatting){++count;++length;}}if(is_text(i)){if(strlen(string[i])===2){length++;}var char=get_next_character(substring);var size=char.length;// begining of enity that we've skipped, we are at the end
if(char===';'){match=string.slice(0,i+1).match(re_ent);if(match){offset=match[1].length;size=offset+1;}}var data={last:is_last(),count:count,index:i-offset,formatting:formatting,length:length,text:in_text,size:size,space:space,space_count:space_count};var ret=callback(data);if(ret===false){break;}else if(ret){if(ret.count!==undefined){count=ret.count;}if(ret.length!==undefined){length=ret.length;}if(ret.space!==undefined){prev_space=space;space=ret.space;}if(ret.index!==undefined){i=ret.index;continue;}}}else if(i===string.length-1&&!last){// last iteration, if formatting have last bracket,
// from formatting, then last iteration
// was already called (in if) #550
callback({last:true,count:count+1,index:i,formatting:formatting,length:0,text:in_text,space:space});}// handle emoji, suroggate pairs and combine characters
if(in_text){i+=next_iteration();}}},// ---------------------------------------------------------------------
// :: function return string splitted into single characters
// :: each character is wrapped into formatting from input string
// :: or empty formatting so it will create span when using with ::format
// ---------------------------------------------------------------------
partition:function partition(string){if(!$.terminal.have_formatting(string)){var chars=$.terminal.split_characters(string);return chars.map(wrap);}var result=[];function wrap(string){if(string.match(/\\$/)){string+='\\';}return'[[;;]'+string+']';}function formatting(string){if($.terminal.is_formatting(string)){if(string.match(/\\]$/)){string=string.replace(/\\]/g,'\\\\]');}}else{string=wrap(string);}return string;}$.terminal.iterate_formatting(string,function(data){if(data.text){var text=[];if(data.formatting){text.push(data.formatting);}text.push(string.substring(data.index,data.index+data.size));if(data.formatting){text.push(']');}result.push(formatting(text.join('')));}});return result;},// ---------------------------------------------------------------------
// :: formatting aware substring function
// ---------------------------------------------------------------------
substring:function substring(string,start_index,end_index){var chars=$.terminal.split_characters(string);if(!chars.slice(start_index,end_index).length){return'';}if(!$.terminal.have_formatting(string)){return chars.slice(start_index,end_index).join('');}var start=0;var end;var start_formatting='';var end_formatting='';var prev_index;var offset=1;$.terminal.iterate_formatting(string,function(data){if(start_index&&data.count===start_index+1){start=data.index;if(data.formatting){start_formatting=data.formatting;}}if(end_index&&data.count===end_index){end_formatting=data.formatting;prev_index=data.index;offset=data.size;}if(data.count===end_index+1){end=data.index;if(data.formatting){end=prev_index+offset;}}});if(start_index&&!start){return'';}if(end===undefined){end=string.length;}string=start_formatting+string.slice(start,end);if(end_formatting){string=string.replace(/(\[\[^\]]+)?\]$/,'');string+=']';}return string;},// ---------------------------------------------------------------------
// :: add format text as 5th paramter to formatting it's used for
// :: data attribute in format function - and fix unclosed &
// ---------------------------------------------------------------------
normalize:function normalize(string){string=string.replace(format_re,function(_,format,text){if(format.match(self_closing_re)&&text===''){return'[['+format+'] ]';}if(text===''){return'';}function safe(string){return string.replace(/\\\]/g,'&#93;').replace(/\n/g,'\\n').replace(/&nbsp;/g,' ');}format=safe(format);var semicolons=format.match(/;/g).length;// missing semicolons
if(semicolons>=4){var args=format.split(/;/);var start=args.slice(0,4).join(';');var arg=args.slice(4).join(';');return'[['+start+';'+(arg||text)+']'+text+']';}else if(semicolons===2){semicolons=';;';}else if(semicolons===3){semicolons=';';}// return '[[' + format + ']' + text + ']';
// closing braket will break formatting so we need to escape
// those using html entity equvalent
// space is hack for images that break iterate_formatting
format+=semicolons+safe(text);return'[['+format+']'+text+']';});return $.terminal.amp(string);},// ---------------------------------------------------------------------
// :: split text into lines with equal length so each line can be
// :: rendered separately (text formatting can be longer then a line).
// ---------------------------------------------------------------------
split_equal:function split_equal(str,length,keep_words){var prev_format='';var result=[];var array=$.terminal.normalize(str).split(/\n/g);for(var i=0,len=array.length;i<len;++i){if(array[i]===''){result.push('');continue;}var line=array[i];var get_next_character=make_next_char_fun(line);var first_index=0;var output;var line_length=line.length;var last_bracket=!!line.match(/\[\[[^\]]+\](?:[^\][]|\\\])+\]$/);$.terminal.iterate_formatting(line,function(data){var chr,substring;if(data.length>=length||data.last||data.length===length-1&&strlen(line[data.index+1])===2){var can_break=false;// TODO: this need work
if(keep_words&&data.space!==-1){// replace html entities with characters
var stripped=text(line).substring(data.space_count);// real length, not counting formatting
stripped=stripped.slice(0,length).trim();var text_len=strlen(stripped);if(stripped.match(/\s/)||text_len<length){can_break=true;}}// if words is true we split at last space and make next loop
// continue where the space where located
var after_index=data.index+data.size;if(last_bracket){after_index+=1;}var new_index;if(keep_words&&data.space!==-1&&after_index!==line_length&&can_break){output=line.slice(first_index,data.space);new_index=data.space-1;}else{substring=line.slice(data.index);chr=get_next_character(substring);output=line.slice(first_index,data.index)+chr;if(data.last&&last_bracket&&chr!==']'){output+=']';}new_index=data.index+chr.length-1;}if(keep_words){output=output.replace(/^(&nbsp;|\s)+|(&nbsp;|\s)+$/g,'');}first_index=(new_index||data.index)+1;if(prev_format){var closed_formatting=output.match(/^[^\]]*\]/);output=prev_format+output;if(closed_formatting){prev_format='';}}var matched=output.match(format_re);if(matched){var last=matched[matched.length-1];if(last[last.length-1]!==']'){prev_format=last.match(format_begin_re)[1];output+=']';}else if(output.match(format_end_re)){output=output.replace(format_end_re,'');prev_format=last.match(format_begin_re)[1];}}result.push(output);// modify loop by returing new data
return{index:new_index,length:0,space:-1};}});}return result;},// ---------------------------------------------------------------------
// :: Escape & that's not part of entity
// ---------------------------------------------------------------------
amp:function amp(str){return str.replace(/&(?!#[0-9]+;|#x[0-9a-f]+;|[a-z]+;)/gi,'&amp;');},// ---------------------------------------------------------------------
// :: Encode formating as html for insertion into DOM
// ---------------------------------------------------------------------
encode:function encode(str,options){var settings=$.extend({tabs:4,before:''},options);return $.terminal.amp(str).replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/ /g,'&nbsp;').split('\n').map(function(line){var splitted=line.split(/((?:\[\[[^\]]+\])?\t(?:\])?)/);splitted=splitted.filter(Boolean);return splitted.map(function(str,i){if(str.match(/\t/)){return str.replace(/\t([^\t]*)$/,function(_,end){if(i!==0&&splitted[i-1].match(/\t\]?$/)){var sp=new Array(settings.tabs+1).join('&nbsp;');return sp+end;}else{var before=splitted.slice(i-1,i).join('');if(settings.before&&i<=1){before=settings.before+before;}var len=$.terminal.length(before);var chars=settings.tabs-len%settings.tabs;if(chars===0){chars=4;}return new Array(chars+1).join('&nbsp;')+end;}});}return str;}).join('');}).join('\n');},// -----------------------------------------------------------------------
// :: Default formatter that allow for nested formatting, example:
// :: [[;;#000]hello [[;#f00;]red] world]
// -----------------------------------------------------------------------
nested_formatting:function nested_formatting(string){if(!$.terminal.have_formatting(string)){return string;}var stack=[];var re=/((?:\[\[(?:[^\][]|\\\])+\])?(?:[^\][]|\\\])*\]?)/;var format_re=/\[\[([^\][]+)\][\s\S]*/;var format_split_re=/^\[\[([^;]*);([^;]*);([^\]]*)\]/;var class_i=3;// index of the class in formatting
var attrs_i=5;// index of attributes in formatting
// ---------------------------------------------------------------------------
function unique(value,index,self){return self.indexOf(value)===index;}// ---------------------------------------------------------------------------
function update_style(new_style,old_style){new_style=parse_style(new_style);if(!old_style){return new_style;}return $.extend(old_style,new_style);}// ---------------------------------------------------------------------------
function parse_style(string){var style={};string.split(/\s*;\s*/).forEach(function(string){var parts=string.split(':').map(function(string){return string.trim();});var prop=parts[0];var value=parts[1];style[prop]=value;});return style;}// ---------------------------------------------------------------------------
function stringify_formatting(input){var result=input.slice();if(input[attrs_i]){result[attrs_i]=stringify_attrs(input[attrs_i]);}if(input[class_i]){result[class_i]=stringify_class(input[class_i]);}result[0]=stringify_styles(input[0]);return result.join(';');}// ---------------------------------------------------------------------------
function stringify_styles(input){var ignore=input.filter(function(s){return s[0]==='-';}).map(function(s){return s[1];});return input.filter(function(s){return ignore.indexOf(s)===-1&&ignore.indexOf(s[1])===-1;}).join('');}// ---------------------------------------------------------------------------
function stringify_attrs(attrs){return JSON.stringify(attrs,function(key,value){if(key==='style'){return stringify_style(value);}return value;});}// ---------------------------------------------------------------------------
function stringify_class(klass){return klass.filter(unique).join(' ');}// ---------------------------------------------------------------------------
function stringify_style(style){return Object.keys(style).map(function(prop){return prop+':'+style[prop];}).join(';');}// ---------------------------------------------------------------------------
function get_inherit_style(stack){function update_attrs(value){if(!output[attrs_i]){output[attrs_i]={};}try{var new_attrs=JSON.parse(value);if(new_attrs.style){var new_style=new_attrs.style;var old_style=output[attrs_i].style;new_attrs.style=update_style(new_style,old_style);output[attrs_i]=$.extend(new_attrs,output[attrs_i],{style:update_style(new_style,old_style)});}else{output[attrs_i]=$.extend(new_attrs,output[attrs_i]);}}catch(e){warn('Invalid JSON '+value);}}var output=[[],'',''];if(!stack.length){return output;}for(var i=stack.length;i--;){var formatting=stack[i].split(';');if(formatting.length>5){var last=formatting.slice(5).join(';');formatting=formatting.slice(0,5).concat(last);}var style=formatting[0].split(/(-?[@!gbiuso])/g).filter(Boolean);style.forEach(function(s){if(output[0].indexOf(s)===-1){output[0].push(s);}});for(var j=1;j<formatting.length;++j){var value=formatting[j].trim();if(value){if(j===class_i){if(!output[class_i]){output[class_i]=[];}var classes=value.split(/\s+/);output[class_i]=output[class_i].concat(classes);}else if(j===attrs_i){update_attrs(value);}else if(!output[j]){output[j]=value;}}}}return stringify_formatting(output);}return string.split(re).filter(Boolean).map(function(string){var style;if(string.match(/^\[\[/)&&!$.terminal.is_extended_command(string)){var formatting=string.replace(format_re,'$1');var is_formatting=$.terminal.is_formatting(string);string=string.replace(format_split_re,'');stack.push(formatting);if($.terminal.nested_formatting.__inherit__){style=get_inherit_style(stack);}else{style=formatting;}if(!is_formatting){string+=']';}else{stack.pop();}string='[['+style+']'+string;}else{var pop=false;if(string.match(/\]/)){pop=true;}if(stack.length){if($.terminal.nested_formatting.__inherit__){style=get_inherit_style(stack);}else{style=stack[stack.length-1];}string='[['+style+']'+string;}if(pop){stack.pop();}else if(stack.length){string+=']';}}return string;}).join('');},// ---------------------------------------------------------------------
// :: safe function that will render text as it is
// ---------------------------------------------------------------------
escape_formatting:function escape_formatting(string){return $.terminal.escape_brackets(string);},// ---------------------------------------------------------------------
// :: apply custom formatters only to text
// ---------------------------------------------------------------------
apply_formatters:function apply_formatters(string,settings){if(string===""){if(settings&&typeof settings.position==='number'){return["",settings.position];}else{return"";}}function test_lengths(formatter,index,ret,string){if(!formatter.__no_warn__&&$.terminal.length(ret)!==$.terminal.length(string)){warn('Your formatter['+index+'] change length of the string, '+'you should use [regex, replacement] formatter or function '+' that return [replacement, position] instead');}}function should_format(options){if(!settings||!options){return true;}var props=['echo','command','prompt'];var have_any=props.some(function(name){return options[name]===true;});if(!have_any){return true;}for(var i=props.length;i--;){var prop=props[i];if(options[prop]===true&&settings[prop]===true){return true;}}return false;}settings=settings||{};var formatters=settings.formatters||$.terminal.defaults.formatters;var i=0;function apply_function_formatter(formatter,input){var options=$.extend({},settings,{position:input[1]});var ret=formatter(input[0],options);if(typeof ret==='string'){test_lengths(formatter,i-1,ret,input[0]);if(typeof ret==='string'){return[ret,options.position];}return input;}else if(is_array(ret)&&ret.length===2){return ret;}else{return input;}}var input;if(typeof settings.position==='number'){input=[string,settings.position];}else{input=[string,0];}try{var result=formatters.reduce(function(input,formatter){i++;// __meta__ is for safe formatter that can handle formatters
// inside formatters. for other usage we use format_split so one
// formatter don't mess with formatter that was previous
// on the list
if(typeof formatter==='function'&&formatter.__meta__){return apply_function_formatter(formatter,input);}else{var length=0;var found_position=false;var splitted=$.terminal.format_split(input[0]);var partials=splitted.map(function(string){var position;var this_len=text(string).length;// first position that match is used for this partial
if(input[1]<length+this_len&&!found_position){position=input[1]-length;found_position=true;}else if(found_position){// -1 indicate that we will not track position because it
// was in one of the previous parial strings
position=-1;}else{// initial position for replacers
position=input[1];}// length is used to correct position after replace
var length_before=length;var result;length+=this_len;if($.terminal.is_formatting(string)){if(found_position){return[string,position];}return[string,-1];}else{if(is_array(formatter)){var options=formatter[2]||{};result=[string,position<0?0:position];if(result[0].match(formatter[0])&&should_format(formatter[2])){if(options.loop){while(result[0].match(formatter[0])){result=$.terminal.tracking_replace(result[0],formatter[0],formatter[1],result[1]);}}else{result=$.terminal.tracking_replace(result[0],formatter[0],formatter[1],result[1]);}}if(position<0){return[result[0],-1];}}else if(typeof formatter==='function'){result=apply_function_formatter(formatter,[string,position]);}if(typeof result!=='undefined'){// correct position becuase it's relative
// to partial and we need global for whole string
if(result[1]!==-1){result[1]+=length_before;}var after_len=text(result[0]).length;if(after_len!==this_len){}return result;}return[string,-1];}});var position_partial=partials.filter(function(partial){return partial[1]!==-1;})[0];var string=partials.map(function(partial){return partial[0];}).join('');var position;if(typeof position_partial==='undefined'){position=input[1];}else{position=position_partial[1];}// to make sure that output position is not outside the string
var max=text(string).length;max+=count_selfclosing_formatting(string);if(position>max){position=max;}if(string===input[0]){return input;}var before=$.terminal.strip(input[0]);var after=$.terminal.strip(string);if(before===after){return[string,input[1]];}return[string,position];}},input);if(typeof settings.position==='number'){var codepoint_len=$.terminal.strip(result[0]).length;if($.terminal.length(result[0])<codepoint_len){var position=result[1];position=normalize_position(result[0],position);var max=$.terminal.length(result[0]);if(position>max){position=max;}result[1]=position;}return result;}else{return result[0];}}catch(e){var msg='Error in formatter ['+(i-1)+']';formatters.splice(i-1);throw new $.terminal.Exception('formatting',msg,e.stack);}},// ---------------------------------------------------------------------
// :: Replace terminal formatting with html
// ---------------------------------------------------------------------
format:function format(str,options){var settings=$.extend({},{linksNoReferrer:false,linksNoFollow:false,allowedAttributes:[],charWidth:undefined,escape:true,anyLinks:false},options||{});// -----------------------------------------------------------------
function filter_attr_names(names){if(names.length&&settings.allowedAttributes.length){return names.filter(function(name){if(name==='data-text'){return false;}var allowed=false;var filters=settings.allowedAttributes;for(var i=0;i<filters.length;++i){if(filters[i]instanceof RegExp){if(filters[i].test(name)){allowed=true;break;}}else if(filters[i]===name){allowed=true;break;}}return allowed;});}return[];}// -----------------------------------------------------------------
function clean_data(data,text){if(data===''){return text;}else{return data.replace(/&#93;/g,']').replace(/>/g,'&gt;').replace(/</g,'&lt;').replace(/"/g,'&quot;');}}// -----------------------------------------------------------------
function add_attrs(attrs){if(attrs){var keys=filter_attr_names(Object.keys(attrs));if(keys.length){return' '+keys.map(function(name){var value=attrs[name].replace(/"/g,'&quot;');return name+'="'+value+'"';}).join(' ');}}return'';}// -----------------------------------------------------------------
function rel_attr(){var rel=["noopener"];if(settings.linksNoReferrer){rel.unshift("noreferrer");}if(settings.linksNoFollow){rel.unshift("nofollow");}return rel;}// -----------------------------------------------------------------
// test if this is valid Path
// -----------------------------------------------------------------
function is_path(url){return url.match(/^\.{1,2}\//)||url.match(/^\//)||!(url.match(/\//)||url.match(/^[^:]+:/));}// -----------------------------------------------------------------
function with_url_validation(fn){return function(url){if(settings.anyLinks){return true;}var test=fn(url);if(!test){warn('Invalid URL '+url+' only http(s) ftp and Path '+'are allowed');}return test;};}// -----------------------------------------------------------------
var valid_href=with_url_validation(function(url){return url.match(/^((https?|file|ftp):\/\/|\.{0,2}\/)/)||is_path(url);});// -----------------------------------------------------------------
var valid_src=with_url_validation(function(url){return url.match(/^(https?:|file:|blob:|data:)/)||is_path(url);});// -----------------------------------------------------------------
function format(s,style,color,background,_class,data_text,text){function pre_process_link(data){var result;if(data.match(email_re)){result='<a href="mailto:'+data+'"';}else{// only http and ftp links (prevent javascript)
// unless user force it with anyLinks option
if(!valid_href(data)){data='';}result='<a target="_blank"';if(data){result+=' href="'+data+'"';}result+=' rel="'+rel_attr().join(' ')+'"';}return result;}function pre_process_image(data){var result='<img';if(valid_src(data)){result+=' src="'+data+'"';if(text){result+=' alt="'+text+'"';}}return result;}var attrs;if(data_text.match(/;/)){try{var splitted=data_text.split(';');var str=splitted.slice(1).join(';').replace(/&nbsp;/g,' ').replace(/&lt;/g,'<').replace(/&gt;/g,'>');if(str.match(/^\s*\{[^}]*\}\s*$/)){attrs=JSON.parse(str);data_text=splitted[0];}}catch(e){}}if(text===''&&!style.match(/@/)){return'';//'<span>&nbsp;</span>';
}text=safe(text);text=text.replace(/\\\]/g,'&#93;');if(settings.escape){// inside formatting we need to unescape escaped slashes
// but this escape is not needed when echo - don't know why
text=text.replace(/\\\\/g,'\\');}var style_str='';if(style.indexOf('b')!==-1){style_str+='font-weight:bold;';}var text_decoration=[];if(style.indexOf('u')!==-1){text_decoration.push('underline');}if(style.indexOf('s')!==-1){text_decoration.push('line-through');}if(style.indexOf('o')!==-1){text_decoration.push('overline');}if(text_decoration.length){style_str+='text-decoration:'+text_decoration.join(' ')+';';}if(style.indexOf('i')!==-1){style_str+='font-style:italic;';}if($.terminal.valid_color(color)){style_str+=['color:'+color,'--color:'+color,'--original-color:'+color].join(';')+';';if(style.indexOf('!')!==-1){style_str+='--link-color:'+color+';';}if(style.indexOf('g')!==-1){style_str+='text-shadow:0 0 5px '+color+';';}}if($.terminal.valid_color(background)){style_str+=['background-color:'+background,'--background:'+background].join(';')+';';}var data=clean_data(data_text,text);var extra=extra_css(text,settings);if(extra){text=wide_characters(text,settings);style_str+=extra;}var result;if(style.indexOf('!')!==-1){result=pre_process_link(data);}else if(style.indexOf('@')!==-1){result=pre_process_image(data);}else{result='<span';}if(attrs&&attrs.style){// merge style attr and colors #617
attrs.style=style_str+attrs.style;style_str='';}result+=add_attrs(attrs);if(style_str!==''){result+=' style="'+style_str+'"';}if(_class!==''){result+=' class="'+_class+'"';}// links and image need data-text attribute cmd click behavior
// formatter can return links.
if(style.indexOf('!')!==-1){result+=' data-text>'+text+'</a>';}else if(style.indexOf('@')!==-1){result+=' data-text/>';}else{result+=' data-text="'+data+'">'+'<span>'+text+'</span></span>';}return result;}if(typeof str==='string'){// support for formating foo[[u;;]bar]baz[[b;#fff;]quux]zzz
var splitted=$.terminal.format_split(str);str=$.map(splitted,function(text){if(text===''){return text;}else if($.terminal.is_formatting(text)){// fix &nbsp; inside formatting because encode is called
// before format
text=text.replace(/\[\[[^\]]+\]/,function(text){return text.replace(/&nbsp;/g,' ');});return text.replace(format_parts_re,format);}else{text=safe(text);text=text.replace(/\\\]/,'&#93;');var data=clean_data(text);var extra=extra_css(text,settings);var prefix;if(extra.length){text=wide_characters(text,settings);prefix='<span style="'+extra+'"';}else{prefix='<span';}return prefix+' data-text="'+data+'">'+text+'</span>';}}).join('');return str.replace(/<span><br\s*\/?><\/span>/gi,'<br/>');}else{return'';}},// ---------------------------------------------------------------------
// :: Replace brackets with html entities
// ---------------------------------------------------------------------
escape_brackets:function escape_brackets(string){return string.replace(/\[/g,'&#91;').replace(/\]/g,'&#93;').replace(/\\/g,'&#92;');},// ---------------------------------------------------------------------
// :: complmentary function
// ---------------------------------------------------------------------
unescape_brackets:function unescape_brackets(string){return string.replace(/&#91;/g,'[').replace(/&#93;/g,']').replace(/&#92;/g,'\\');},// ---------------------------------------------------------------------
// :: return number of characters without formatting
// ---------------------------------------------------------------------
length:function length(string,raw){if(!string){return 0;}return $.terminal.split_characters(raw?string:text(string)).length;},// ---------------------------------------------------------------------
// :: split characters handling emoji, surogate pairs and combine chars
// ---------------------------------------------------------------------
split_characters:function split_characters(string){var result=[];var get_next_character=make_next_char_fun(string);while(string.length){var chr=get_next_character(string);string=string.slice(chr.length);result.push(chr);}return result;},// ---------------------------------------------------------------------
// :: return string where array items are in columns padded spaces
// :: after adding align tabs arr.join('\t\t') looks much better
// ---------------------------------------------------------------------
columns:function columns(array,cols,space){var no_formatting=array.map(function(string){return $.terminal.strip(string);});var lengths=no_formatting.map(function(string){return strlen(string);});if(typeof space==='undefined'){space=4;}var length=Math.max.apply(null,lengths)+space;// we need value - 1 because index starts from 0
var column_limit=Math.floor(cols/length)-1;if(column_limit<1){return array.join('\n');}var lines=[];for(var i=0,len=array.length;i<len;i+=column_limit){var line=array.slice(i,i+column_limit);var last=line.pop();lines.push(line.reduce(function(acc,string){var stripped=$.terminal.strip(string);var pad=new Array(length-stripped.length+1).join(' ');acc.push(string+pad);return acc;},[]).join('')+last);}return lines.join('\n');},// ---------------------------------------------------------------------
// :: Remove formatting from text
// ---------------------------------------------------------------------
strip:function strip(str){if(!$.terminal.have_formatting(str)){return str;}return $.terminal.format_split(str).map(function(str){if($.terminal.is_formatting(str)){str=str.replace(format_parts_re,'$6');return str.replace(/\\([[\]])/g,function(whole,bracket){return bracket;});}return str;}).join('');},// ---------------------------------------------------------------------
// :: Return active terminal
// ---------------------------------------------------------------------
active:function active(){return terminals.front();},// ---------------------------------------------------------------------
// :: Implmentation detail id is always length of terminals Cycle
// ---------------------------------------------------------------------
last_id:function last_id(){var len=terminals.length();return len-1;},// ---------------------------------------------------------------------
// :: Function that works with strings like 'asd' 'asd\' asd' "asd asd"
// :: asd\ 123 -n -b / [^ ]+ / /\s+/ asd\ a it creates a regex and
// :: numbers and replaces escape characters in double quotes
// :: if strict is set to false it only strips single and double quotes
// :: and escapes spaces
// ---------------------------------------------------------------------
parse_argument:function parse_argument(arg,strict){function parse_string(string){// split string to string literals and non-strings
return string.split(string_re).map(function(string){// remove quotes if before are even number of slashes
// we don't remove slases becuase they are handled by JSON.parse
if(string.match(/^['"`]/)){// fixing regex to match empty string is not worth it
if(string==='""'||string==="''"||string==="``"){return'';}var quote=string[0];var re=new RegExp("(\\\\\\\\(?:\\\\\\\\)*)"+quote,"g");string=string.replace(re,'$1').replace(/^[`'"]|[`'"]$/g,'');if(quote==="'"){string=string.replace(/"/g,'\\"');}}string='"'+string+'"';// use build in function to parse rest of escaped characters
return JSON.parse(string);}).join('');}if(strict===false){if(arg[0]==="'"&&arg[arg.length-1]==="'"){return arg.replace(/^'|'$/g,'');}else if(arg[0]==="`"&&arg[arg.length-1]==="`"){return arg.replace(/^`|`$/g,'');}else if(arg[0]==='"'&&arg[arg.length-1]==='"'){return arg.replace(/^"|"$/g,'').replace(/\\([" ])/g,'$1');}else if(arg.match(/\/.*\/[gimy]*$/)){return arg;}else if(arg.match(/['"`]]/)){// part of arg is in quote
return parse_string(arg);}else{return arg.replace(/\\ /g,' ');}}if(arg==='true'){return true;}else if(arg==='false'){return false;}var regex=arg.match(re_re);if(regex){return new RegExp(regex[1],regex[2]);}else if(arg.match(/['"`]/)){return parse_string(arg);}else if(arg.match(/^-?[0-9]+$/)){return parseInt(arg,10);}else if(arg.match(float_re)){return parseFloat(arg);}else{return arg.replace(/\\(['"() ])/g,'$1');}},// ---------------------------------------------------------------------
// :: function split and parse arguments
// ---------------------------------------------------------------------
parse_arguments:function parse_arguments(string){return $.map(string.match(command_re)||[],$.terminal.parse_argument);},// ---------------------------------------------------------------------
// :: Function split and strips single and double quotes
// :: and escapes spaces
// ---------------------------------------------------------------------
split_arguments:function split_arguments(string){return $.map(string.match(command_re)||[],function(arg){return $.terminal.parse_argument(arg,false);});},// ---------------------------------------------------------------------
// :: Function that returns an object {name,args}. Arguments are parsed
// :: using the function parse_arguments
// ---------------------------------------------------------------------
parse_command:function parse_command(string){return process_command(string,$.terminal.parse_argument);},// ---------------------------------------------------------------------
// :: Same as parse_command but arguments are parsed using split_arguments
// ---------------------------------------------------------------------
split_command:function split_command(string){return process_command(string,function(arg){return $.terminal.parse_argument(arg,false);});},// ---------------------------------------------------------------------
// :; function that parse arguments like yargs library
// ---------------------------------------------------------------------
parse_options:function parse_options(arg,options){var settings=$.extend({},{boolean:[]},options);if(typeof arg==='string'){return parse_options($.terminal.split_arguments(arg),options);}var result={_:[]};function token(value){this.value=value;}var rest=arg.reduce(function(acc,arg){var str=typeof arg==='string'?arg:'';if(str.match(/^--?[^-]/)&&acc instanceof token){result[acc.value]=true;}if(str.match(/^--[^-]/)){var name=str.replace(/^--/,'');if(settings.boolean.indexOf(name)===-1){return new token(name);}else{result[name]=true;}}else if(str.match(/^-[^-]/)){var single=str.replace(/^-/,'').split('');if(settings.boolean.indexOf(single.slice(-1)[0])===-1){var last=single.pop();}single.forEach(function(single){result[single]=true;});if(last){return new token(last);}}else if(acc instanceof token){result[acc.value]=arg;}else if(arg){result._.push(arg);}return null;},null);if(rest instanceof token){result[rest.value]=true;}return result;},// ---------------------------------------------------------------------
// :: function executed for each text inside [[ .... ]] in echo
// ---------------------------------------------------------------------
extended_command:function extended_command(term,string,options){var settings=$.extend({invokeMethods:false},options);var deferred=new $.Deferred();try{change_hash=false;var m=string.match(extended_command_re);if(m){if(!settings.invokeMethods){warn('To invoke terminal or cmd methods you need to enable '+'invokeMethods option');deferred.reject();}else{string=m[1];var obj=m[2]==='terminal'?term:term.cmd();var fn=m[3];try{var args=eval('['+m[4]+']');if(!obj[fn]){term.error('Unknow function '+fn);}else{var ret=obj[fn].apply(term,args);if(ret&&ret.then){return ret;}}deferred.resolve();}catch(e){term.error('Invalid invocation in '+$.terminal.escape_brackets(string));deferred.reject();}}}else{return term.exec(string,true).done(function(){change_hash=true;});}}catch(e){// error is process in exec
deferred.reject();}return deferred.promise();},// ---------------------------------------------------------------------
// :: ES6 iterator for a given string that handle emoji and formatting
// ---------------------------------------------------------------------
iterator:function iterator(string){function formatting(string){if($.terminal.is_formatting(string)){if(string.match(/\]\\\]/)){string=string.replace(/\]\\\]/g,']\\\\]');}}return string;}if(typeof Symbol==='function'&&_typeof(Symbol.iterator)==='symbol'){var len=$.terminal.length(string);var i=0;var obj={};obj[Symbol.iterator]=function(){return{next:function next(){if(i<len){var text=$.terminal.substring(string,i,i+1);i++;return{value:formatting(text)};}else{return{done:true};}}};};return obj;}},// ---------------------------------------------------------------------
// :: object that can be used in string methods intead of regex
// ---------------------------------------------------------------------
formatter:new function(){try{this[Symbol.split]=function(string){return $.terminal.format_split(string);};this[Symbol.match]=function(string){return string.match(format_re);};this[Symbol.replace]=function(string,replacer){return string.replace(format_parts_re,replacer);};this[Symbol.search]=function(string){return string.search(format_re);};}catch(e){}}(),// ---------------------------------------------------------------------
// :: helper function that add formatter before nested_formatting
// ---------------------------------------------------------------------
new_formatter:function new_formatter(formatter){var formatters=$.terminal.defaults.formatters;for(var i=0;i<formatters.length;++i){if(formatters[i]===$.terminal.nested_formatting){formatters.splice(i,0,formatter);return;}}formatters.push(formatter);}};// -------------------------------------------------------------------------
$.terminal.Exception=function Terminal_Exception(type,message,stack){if(arguments.length===1){this.message=arguments[0];this.type='TERMINAL';}else{this.type=type;this.message=message;if(stack){this.stack=stack;}}};$.terminal.Exception.prototype=new Error();$.terminal.Exception.prototype.toString=function(){return this.message+'\n'+this.stack;};// -----------------------------------------------------------------------
// Helper plugins and functions
// -----------------------------------------------------------------------
$.fn.visible=function(){return this.css('visibility','visible');};$.fn.hidden=function(){return this.css('visibility','hidden');};// -----------------------------------------------------------------------
var warnings=[];function warn(msg){msg='[jQuery Terminal] '+msg;if(warnings.indexOf(msg)===-1){warnings.push(msg);/* eslint-disable */if(console){if(console.warn){console.warn(msg);}else if(console.log){console.log(msg);}/* eslint-enable */}else{// prevent catching in outer try..catch
setTimeout(function(){throw new Error('WARN: '+msg);},0);}}}// -----------------------------------------------------------------------
// JSON-RPC CALL
// -----------------------------------------------------------------------
var ids={};// list of url based ids of JSON-RPC
$.jrpc=function(url,method,params,success,error){var deferred=new $.Deferred();var options;if($.isPlainObject(url)){options=url;}else{options={url:url,method:method,params:params,success:success,error:error};}function validJSONRPC(response){return $.isNumeric(response.id)&&(typeof response.result!=='undefined'||typeof response.error!=='undefined');}ids[options.url]=ids[options.url]||0;var request={'jsonrpc':'2.0','method':options.method,'params':options.params,'id':++ids[options.url]};$.ajax({url:options.url,beforeSend:function beforeSend(jxhr,settings){if(is_function(options.request)){options.request(jxhr,request);}settings.data=JSON.stringify(request);},success:function success(response,status,jqXHR){var content_type=jqXHR.getResponseHeader('Content-Type');if(!content_type.match(/(application|text)\/json/)){warn('Response Content-Type is neither application/json'+' nor text/json');}var json;try{json=JSON.parse(response);}catch(e){if(options.error){options.error(jqXHR,'Invalid JSON',e);}else{throw new $.terminal.Exception('JSON','Invalid JSON',e.stack);}deferred.reject({message:'Invalid JSON',response:response});return;}if(is_function(options.response)){options.response(jqXHR,json);}if(validJSONRPC(json)||options.method==='system.describe'){// don't catch errors in success callback
if(options.success){options.success(json,status,jqXHR);}deferred.resolve(json);}else{if(options.error){options.error(jqXHR,'Invalid JSON-RPC');}deferred.reject({message:'Invalid JSON-RPC',response:response});}},error:options.error,contentType:'application/json',dataType:'text',async:true,cache:false,// timeout: 1,
type:'POST'});return deferred.promise();};// -----------------------------------------------------------------------
$.rpc=function(url,method,params){var deferred=new $.Deferred();function success(res){if(res.error){deferred.reject(res.error);}else{deferred.resolve(res.result);}}function error(jqXHR,status,message){deferred.reject({message:message});}$.jrpc(url,method,params,success,error);return deferred.promise();};// -----------------------------------------------------------------------
function terminal_ready(term){return!!(term.closest('body').length&&term.is(':visible')&&term.find('.cmd-prompt').length);}// -----------------------------------------------------------------------
// :: Create fake terminal to calcualte the dimention of one character
// :: this will make terminal work if terminal div is not added to the
// :: DOM at init like with:
// :: $('<div/>').terminal().echo('foo bar').appendTo('body');
// -----------------------------------------------------------------------
function get_char_size(term){var rect;if(terminal_ready(term)){var $prompt=term.find('.cmd-prompt').clone().css({visiblity:'hidden',position:'absolute'});$prompt.appendTo(term.find('.cmd')).html('&nbsp;');rect=$prompt[0].getBoundingClientRect();$prompt.remove();}else{var temp=$('<div class="terminal terminal-temp"><div class="terminal-'+'wrapper"><div class="terminal-output"><div><div class="te'+'rminal-line" style="float: left"><span>&nbsp;</span></div'+'></div></div></div>').appendTo('body');temp.addClass(term.attr('class')).attr('id',term.attr('id'));if(term){var style=term.attr('style');if(style){style=style.split(/\s*;\s*/).filter(function(s){return!s.match(/display\s*:\s*none/i);}).join(';');temp.attr('style',style);}}rect=temp.find('.terminal-line')[0].getBoundingClientRect();}var result={width:rect.width,height:rect.height};if(temp){temp.remove();}return result;}// -----------------------------------------------------------------------
// :: calculate numbers of characters
// -----------------------------------------------------------------------
function get_num_chars(terminal,char_size){var width=terminal.find('.terminal-fill').width();var result=Math.floor(width/char_size.width);// random number to not get NaN in node.js but big enough to
// not wrap exception
return result||1000;}// -----------------------------------------------------------------------
// :: Calculate number of lines that fit without scroll
// -----------------------------------------------------------------------
function get_num_rows(terminal,char_size){var height=terminal.find('.terminal-fill').height();return Math.floor(height/char_size.height);}// -----------------------------------------------------------------------
function all(array,fn){var same=array.filter(function(item){return item[fn]()===item;});return same.length===array.length;}// -----------------------------------------------------------------------
function string_case(string){var array=string.split('');if(all(array,'toLowerCase')){return'lower';}else if(all(array,'toUpperCase')){return'upper';}else{return'mixed';}}// -----------------------------------------------------------------------
function same_case(string){return string_case(string)!=='mixed';}// -----------------------------------------------------------------------
// fix for jQuery bug
function is_function(object){return get_type(object)==='function';}// -----------------------------------------------------------------------
function is_object(object){return object&&_typeof(object)==='object';}// -----------------------------------------------------------------------
function is_promise(object){return is_object(object)&&is_function(object.then||object.done);}// -----------------------------------------------------------------------
function is_deferred(object){return is_promise(object)&&is_function(object.promise);}// -----------------------------------------------------------------------
if(!Array.isArray){Array.isArray=function(arg){return Object.prototype.toString.call(arg)==='[object Array]';};}// -----------------------------------------------------------------------
function is_array(object){return Array.isArray(object);}// -----------------------------------------------------------------------
function get_type(object){if(typeof object==='function'){return'function';}if(object===null){return object+'';}if(Array.isArray(object)){return'array';}if(_typeof(object)==='object'){return'object';}return _typeof(object);}// -----------------------------------------------------------------------
// :: TERMINAL PLUGIN CODE
// -----------------------------------------------------------------------
var version_set=!$.terminal.version.match(/^\{\{/);var copyright='Copyright (c) 2011-2021 Jakub T. Jankiewicz '+'<https://jcubic.pl/me>';var version_string=version_set?' v. '+$.terminal.version:' ';// regex is for placing version string aligned to the right
var reg=new RegExp(' {'+version_string.length+'}$');var name_ver='jQuery Terminal Emulator'+(version_set?version_string:'');// -----------------------------------------------------------------------
// :: Terminal Signatures
// -----------------------------------------------------------------------
var signatures=[['jQuery Terminal','(c) 2011-2021 jcubic'],[name_ver,copyright.replace(/^Copyright | *<.*>/g,'')],[name_ver,copyright.replace(/^Copyright /,'')],['      _______                 ________                        __','     / / _  /_ ____________ _/__  ___/______________  _____  / /',' __ / / // / // / _  / _/ // / / / _  / _/     / /  \\/ / _ \\/ /','/  / / // / // / ___/ // // / / / ___/ // / / / / /\\  / // / /__','\\___/____ \\\\__/____/_/ \\__ / /_/____/_//_/_/_/_/_/  \\/\\__\\_\\___/','         \\/          /____/                                   '.replace(reg,' ')+version_string,copyright],['      __ _____                     ________                            '+'  __','     / // _  /__ __ _____ ___ __ _/__  ___/__ ___ ______ __ __  __ ___ '+' / /',' __ / // // // // // _  // _// // / / // _  // _//     // //  \\/ // _ '+'\\/ /','/  / // // // // // ___// / / // / / // ___// / / / / // // /\\  // // '+'/ /__','\\___//____ \\\\___//____//_/ _\\_  / /_//____//_/ /_/ /_//_//_/ /_/ \\'+'__\\_\\___/',('          \\/              /____/                                     '+'     ').replace(reg,'')+version_string,copyright]];// -----------------------------------------------------------------------
// :: Default options
// -----------------------------------------------------------------------
$.terminal.nested_formatting.__meta__=true;// if set to false nested formatting will not inherit styles colors and attribues
$.terminal.nested_formatting.__inherit__=true;// nested formatting will always return different length so we silent the warning
$.terminal.nested_formatting.__no_warn__=true;$.terminal.defaults={prompt:'> ',history:true,exit:true,clear:true,enabled:true,maskChar:'*',wrap:true,checkArity:true,raw:false,tabindex:1,invokeMethods:false,exceptionHandler:null,pauseEvents:true,softPause:false,mousewheel:null,touchscroll:null,memory:false,cancelableAjax:true,processArguments:true,execAnimation:false,execAnimationDelay:100,linksNoReferrer:false,useCache:true,anyLinks:false,linksNoFollow:false,processRPCResponse:null,completionEscape:true,onCommandChange:null,mobileDelete:is_mobile,onPositionChange:null,convertLinks:true,extra:{},tabs:4,historySize:60,scrollObject:null,historyState:false,importHistory:false,historyFilter:null,echoCommand:true,scrollOnEcho:true,login:null,outputLimit:-1,formatters:[$.terminal.nested_formatting],unixFormatting:{escapeBrackets:false,ansiParser:{},ansiArt:false},onAjaxError:null,pasteImage:true,scrollBottomOffset:20,wordAutocomplete:true,caseSensitiveAutocomplete:true,caseSensitiveSearch:true,clickTimeout:200,holdTimeout:400,holdRepeatTimeout:200,repeatTimeoutKeys:[],mobileIngoreAutoSpace:[],request:$.noop,response:$.noop,describe:'procs',onRPCError:null,keymap:null,doubleTab:null,doubleTabEchoCommand:false,completion:false,onInit:$.noop,onClear:$.noop,onBlur:$.noop,onFocus:$.noop,onTerminalChange:$.noop,onExit:$.noop,onPush:$.noop,onPop:$.noop,keypress:$.noop,keydown:$.noop,renderHandler:null,onAfterRedraw:$.noop,onEchoCommand:$.noop,onPaste:$.noop,onFlush:$.noop,onBeforeCommand:null,onAfterCommand:null,onBeforeEcho:null,onAfterEcho:null,onBeforeLogin:null,onAfterLogout:null,onBeforeLogout:null,allowedAttributes:['title',/^aria-/,'id',/^data-/],strings:{comletionParameters:'From version 1.0.0 completion function need to'+' have two arguments',wrongPasswordTryAgain:'Wrong username or password try again!',wrongPassword:'Wrong username or password!',ajaxAbortError:'Error while aborting ajax call!',wrongArity:"Wrong number of arguments. Function '%s' expects %s got"+' %s!',commandNotFound:"Command '%s' Not Found!",oneRPCWithIgnore:'You can use only one rpc with describe == false '+'or rpc without system.describe',oneInterpreterFunction:"You can't use more than one function (rpc "+'without system.describe or with option describe == false count'+'s as one)',loginFunctionMissing:"You didn't specify a login function",noTokenError:'Access denied (no token)',serverResponse:'Server responded',wrongGreetings:'Wrong value of greetings parameter',notWhileLogin:"You can't call `%s' function while in login",loginIsNotAFunction:'Authenticate must be a function',canExitError:"You can't exit from main interpreter",invalidCompletion:'Invalid completion',invalidSelector:'Sorry, but terminal said that you use invalid '+'selector!',invalidTerminalId:'Invalid Terminal ID',login:'login',password:'password',recursiveLoop:'Recursive loop in echo detected, skip',notAString:'%s function: argument is not a string',redrawError:'Internal error, wrong position in cmd redraw',invalidStrings:'Command %s have unclosed strings',defunctTerminal:"You can't call method on terminal that was destroyed"}};// -------------------------------------------------------------------------
// :: All terminal globals
// -------------------------------------------------------------------------
var requests=[];// for canceling on CTRL+D
var terminals=new Cycle();// list of terminals global in this scope
// state for all terminals, terminals can't have own array fo state because
// there is only one popstate event
var _save_state=[];// hold objects returned by export_view by history API
var hash_commands;var change_hash=false;// don't change hash on Init
var fire_hash_change=true;var first_instance=true;// used by history state
$.fn.terminal=function(init_interpreter,options){function StorageHelper(memory){if(memory){this.storage={};}this.set=function(key,value){if(memory){this.storage[key]=value;}else{$.Storage.set(key,value);}};this.get=function(key){if(memory){return this.storage[key];}else{return $.Storage.get(key);}};this.remove=function(key){if(memory){delete this.storage[key];}else{$.Storage.remove(key);}};}// ---------------------------------------------------------------------
// :: helper function
// ---------------------------------------------------------------------
function get_processed_command(command){if($.terminal.unclosed_strings(command)){var string=$.terminal.escape_brackets(command);var message=sprintf(strings().invalidStrings,"`"+string+"`");throw new $.terminal.Exception(message);}else if(is_function(_settings.processArguments)){return process_command(command,_settings.processArguments);}else if(_settings.processArguments){return $.terminal.parse_command(command);}else{return $.terminal.split_command(command);}}// ---------------------------------------------------------------------
// :: helper function that use option to render objects
// ---------------------------------------------------------------------
function preprocess_value(value,options){if($.terminal.Animation&&value instanceof $.terminal.Animation){value.start(self);return false;}if(is_function(_settings.renderHandler)){var ret=_settings.renderHandler.call(self,value,options,self);if(ret===false){return false;}if(typeof ret==='string'||is_node(ret)||is_promise(ret)){return ret;}else{return value;}}return value;}// ---------------------------------------------------------------------
// :: call when line is out of view when outputLimit is used
// :: NOTE: it's not called when less plugin is used onClear is called
// :: instead because less call term::clear() after export old view
// ---------------------------------------------------------------------
function unmount(node){var index=node.data('index');var line=lines[index];var options=line[1];if(is_function(options.unmount)){options.unmount.call(self,node);}}// ---------------------------------------------------------------------
// :: helper function used in render and in update
// ---------------------------------------------------------------------
function prepare_render(value,options){if(is_node(value)){var settings=$.extend({},options,{raw:true,finalize:function finalize(div){div.find('.terminal-render-item').replaceWith(value);if(options&&is_function(options.finalize)){options.finalize(div,self);}}});return['<div class="terminal-render-item"/>',settings];}}// ---------------------------------------------------------------------
// :: helper function that renders DOM nodes and jQuery objects
// ---------------------------------------------------------------------
function render(value,options){var ret=prepare_render(value,options);if(ret){self.echo.apply(self,ret);return true;}}// ---------------------------------------------------------------------
function get_node(index){return output.find('[data-index='+index+']');}// ---------------------------------------------------------------------
// :: test if object can be rendered
// ---------------------------------------------------------------------
function is_node(object){return object instanceof $.fn.init||object instanceof Element;}// ---------------------------------------------------------------------
// :: Display object on terminal
// ---------------------------------------------------------------------
function display_object(object){object=preprocess_value(object);if(object===false){return;}if(render(object)){return;}if(typeof object==='string'){self.echo(object);}else if(is_array(object)){self.echo($.map(object,function(object){return JSON.stringify(object);}).join(' '));}else if(_typeof(object)==='object'){self.echo(JSON.stringify(object));}else{self.echo(object);}}// ---------------------------------------------------------------------
// :: Display line code in the file if line numbers are present
// ---------------------------------------------------------------------
function print_line(url_spec,cols){var re=/(.*):([0-9]+):([0-9]+)$/;// google chrome have line and column after filename
var m=url_spec.match(re);if(m){// TODO: do we need to call pause/resume or return promise?
self.pause(_settings.softPause);$.get(m[1],function(response){var file=m[1];var code=response.split('\n');var n=+m[2]-1;var start=n>2?n-2:0;var lines=code.slice(start,n+3).map(function(line,i){var prefix='['+(n+i-1)+']: ';var limit=cols-prefix.length-4;if(line.length>limit){line=line.substring(0,limit)+'...';}if(n>2?i===2:i===n){line='[[;#f00;]'+$.terminal.escape_brackets(line)+']';}return prefix+line;}).filter(Boolean).join('\n');if(lines.length){self.echo('[[b;white;]'+file+']');self.echo(lines).resume();}},'text');}}// ---------------------------------------------------------------------
// :: Helper function
// ---------------------------------------------------------------------
function display_json_rpc_error(error){if(is_function(_settings.onRPCError)){_settings.onRPCError.call(self,error);}else{self.error('&#91;RPC&#93; '+error.message);if(error.error&&error.error.message){error=error.error;// more detailed error message
var msg='\t'+error.message;if(error.file){msg+=' in file "'+error.file.replace(/.*\//,'')+'"';}if(error.at){msg+=' at line '+error.at;}self.error(msg);}}}// ---------------------------------------------------------------------
// :: Create interpreter function from url string
// ---------------------------------------------------------------------
function make_basic_json_rpc(url,auth){var interpreter=function interpreter(method,params){self.pause(_settings.softPause);$.jrpc({url:url,method:method,params:params,request:function request(jxhr,_request){try{_settings.request.call(self,jxhr,_request,self);}catch(e){display_exception(e,'USER');}},response:function response(jxhr,_response){try{_settings.response.call(self,jxhr,_response,self);}catch(e){display_exception(e,'USER');}},success:function success(json){if(json.error){display_json_rpc_error(json.error);}else if(is_function(_settings.processRPCResponse)){_settings.processRPCResponse.call(self,json.result,self);}else if(json.result!==null){display_object(json.result);}self.resume();},error:ajax_error});};// this is the interpreter function
return function(command,terminal){if(command===''){return;}try{command=get_processed_command(command);}catch(e){// exception can be thrown on invalid regex
display_exception(e,'TERMINAL (get_processed_command)');return;// throw e; // this will show stack in other try..catch
}if(!auth||command.name==='help'){// allows to call help without a token
interpreter(command.name,command.args);}else{var token=terminal.token(true);if(token){interpreter(command.name,[token].concat(command.args));}else{// should never happen
terminal.error('&#91;AUTH&#93; '+strings().noTokenError);}}};}// ---------------------------------------------------------------------
// :: Create interpreter function from Object. If the value is object
// :: it will create nested interpreters
// ---------------------------------------------------------------------
function make_object_interpreter(object,arity,login,fallback){// function that maps commands to object methods
// it keeps terminal context
return function(user_command,terminal){if(user_command===''){return;}var command;try{command=get_processed_command(user_command);}catch(e){// exception can be thrown on invalid regex
if(is_function(_settings.exception)){_settings.exception(e,self);}else{self.error('Error: '+(e.message||e));}return;// throw e; // this will show stack in other try..catch
}var val=object[command.name];var type=get_type(val);if(type==='function'){if(arity&&val.length!==command.args.length){self.error('&#91;Arity&#93; '+sprintf(strings().wrongArity,command.name,val.length,command.args.length));}else{return val.apply(self,command.args);}}else if(type==='object'||type==='string'){var commands=[];if(type==='object'){commands=Object.keys(val);val=make_object_interpreter(val,arity,login);}terminal.push(val,{prompt:command.name+'> ',name:command.name,completion:type==='object'?commands:undefined});}else if(is_function(fallback)){fallback(user_command,self);}else if(is_function(_settings.onCommandNotFound)){_settings.onCommandNotFound.call(self,user_command,self);}else{terminal.error(sprintf(strings().commandNotFound,command.name));}};}// ---------------------------------------------------------------------
function ajax_error(xhr,status,error){self.resume();// onAjaxError can use pause/resume call it first
if(is_function(_settings.onAjaxError)){_settings.onAjaxError.call(self,xhr,status,error);}else if(status!=='abort'){self.error('&#91;AJAX&#93; '+status+' - '+strings().serverResponse+':\n'+$.terminal.escape_brackets(xhr.responseText));}}// ---------------------------------------------------------------------
// :: function create interpreter object based on JSON-RPC meta data
// ---------------------------------------------------------------------
function make_json_rpc_object(url,auth,success){function jrpc_success(json){if(json.error){display_json_rpc_error(json.error);}else if(is_function(_settings.processRPCResponse)){_settings.processRPCResponse.call(self,json.result,self);}else{display_object(json.result);}self.resume();}function jrpc_request(jxhr,request){try{_settings.request.call(self,jxhr,request,self);}catch(e){display_exception(e,'USER');}}function jrpc_response(jxhr,response){try{_settings.response.call(self,jxhr,response,self);}catch(e){display_exception(e,'USER');}}function response(response){var procs=response;// we check if it's false before we call this function but
// it don't hurt to be explicit here
if(_settings.describe!==false&&_settings.describe!==''){_settings.describe.split('.').forEach(function(field){procs=procs[field];});}if(procs&&procs.length){var interpreter_object={};$.each(procs,function(_,proc){if($.isPlainObject(proc)&&typeof proc.name==='string'){interpreter_object[proc.name]=function(){var append=auth&&proc.name!=='help';var args=Array.prototype.slice.call(arguments);var args_len=args.length+(append?1:0);if(_settings.checkArity&&proc.params&&proc.params.length!==args_len){self.error('&#91;Arity&#93; '+sprintf(strings().wrongArity,proc.name,proc.params.length,args_len));}else{self.pause(_settings.softPause);if(append){var token=self.token(true);if(token){args=[token].concat(args);}else{self.error('&#91;AUTH&#93; '+strings().noTokenError);}}$.jrpc({url:url,method:proc.name,params:args,request:jrpc_request,response:jrpc_response,success:jrpc_success,error:ajax_error});}};}});var login=typeof auth==='string'?auth:'login';interpreter_object.help=interpreter_object.help||function(fn){if(typeof fn==='undefined'){var names=procs.map(function(proc){return proc.name;}).join(', ')+', help';self.echo('Available commands: '+names);}else{var found=false;$.each(procs,function(_,proc){if(proc.name===fn){found=true;var msg='';msg+='[[bu;;]'+proc.name+']';if(proc.params){var params=proc.params;if(auth&&proc.name!==login){params=params.slice(1);}msg+=' '+params.join(' ');}if(proc.help){msg+='\n'+proc.help;}self.echo(msg);return false;}});if(!found){if(fn==='help'){self.echo('[[bu;;]help] [method]\ndisplay help '+'for the method or list of methods if not'+' specified');}else{var msg='Method `'+fn+"' not found ";self.error(msg);}}}};success(interpreter_object);}else{success(null);}}return $.jrpc({url:url,method:'system.describe',params:[],success:response,request:jrpc_request,response:jrpc_response,error:function error(){success(null);}});}// ---------------------------------------------------------------------
// :: function create interpeter function and call finalize with
// :: interpreter and optional completion
// ---------------------------------------------------------------------
function make_interpreter(user_intrp,login,finalize){finalize=finalize||$.noop;var type=get_type(user_intrp);var object;var result={};var rpc_count=0;// only one rpc can be use for array
var fn_interpreter;if(type==='array'){object={};// recur will be called when previous acync call is finished
(function recur(interpreters,success){if(interpreters.length){var first=interpreters[0];var rest=interpreters.slice(1);var type=get_type(first);if(type==='string'){self.pause(_settings.softPause);if(_settings.describe===false){if(++rpc_count===1){fn_interpreter=make_basic_json_rpc(first,login);}else{self.error(strings().oneRPCWithIgnore);}recur(rest,success);}else{make_json_rpc_object(first,login,function(new_obj){if(new_obj){$.extend(object,new_obj);}else if(++rpc_count===1){fn_interpreter=make_basic_json_rpc(first,login);}else{self.error(strings().oneRPCWithIgnore);}self.resume();recur(rest,success);});}}else if(type==='function'){if(fn_interpreter){self.error(strings().oneInterpreterFunction);}else{fn_interpreter=first;}recur(rest,success);}else if(type==='object'){$.extend(object,first);recur(rest,success);}}else{success();}})(user_intrp,function(){finalize({interpreter:make_object_interpreter(object,false,login,fn_interpreter&&fn_interpreter.bind(self)),completion:Object.keys(object)});});}else if(type==='string'){if(_settings.describe===false){object={interpreter:make_basic_json_rpc(user_intrp,login)};if($.isArray(_settings.completion)){object.completion=_settings.completion;}finalize(object);}else{self.pause(_settings.softPause);make_json_rpc_object(user_intrp,login,function(object){if(object){result.interpreter=make_object_interpreter(object,false,login);result.completion=Object.keys(object);}else{// no procs in system.describe
result.interpreter=make_basic_json_rpc(user_intrp,login);}finalize(result);self.resume();});}}else if(type==='object'){finalize({interpreter:make_object_interpreter(user_intrp,_settings.checkArity,login),completion:Object.keys(user_intrp)});}else{// allow $('<div/>').terminal();
if(type==='undefined'){user_intrp=$.noop;}else if(type!=='function'){var msg=type+' is invalid interpreter value';throw new $.terminal.Exception(msg);}// single function don't need bind
finalize({interpreter:user_intrp,completion:_settings.completion});}}// ---------------------------------------------------------------------
// :: Create JSON-RPC authentication function
// ---------------------------------------------------------------------
function make_json_rpc_login(url,login){var method=get_type(login)==='boolean'?'login':login;return function(user,passwd,callback){self.pause(_settings.softPause);$.jrpc({url:url,method:method,params:[user,passwd],request:function request(jxhr,_request2){try{_settings.request.call(self,jxhr,_request2,self);}catch(e){display_exception(e,'USER');}},response:function response(jxhr,_response2){try{_settings.response.call(self,jxhr,_response2,self);}catch(e){display_exception(e,'USER');}},success:function success(response){if(!response.error&&response.result){callback(response.result);}else{// null will trigger message that login fail
callback(null);}self.resume();},error:ajax_error});};// default name is login so you can pass true
}// ---------------------------------------------------------------------
// :: display Exception on terminal
// ---------------------------------------------------------------------
function display_exception(e,label,silent){if(is_function(_settings.exceptionHandler)){_settings.exceptionHandler.call(self,e,label);}else{self.exception(e,label);if(!silent){setTimeout(function(){throw e;},0);}}}// ---------------------------------------------------------------------
function links(string){function format(_,style,color,background,_class,data,text){function formatting(s,text){return'[['+[style+(s||''),color,background,_class,text||data].join(';')+']';}function escaped(_){return']'+formatting('!',_)+_+']'+formatting();}if(!style.match(/!/)){var m=text.match(email_full_re)||text.match(url_full_re);if(m){return formatting('!',m[1])+text+']';}else if(text.match(email_re)||text.match(url_nf_re)){var output=text.replace(email_re,escaped).replace(url_nf_re,escaped);return formatting('',data)+output+']';}}return _;}function linkify(string){return string.replace(email_re,'[[!;;]$1]').replace(url_nf_re,'[[!;;]$1]');}if(!$.terminal.have_formatting(string)){return linkify(string);}return $.terminal.format_split(string).map(function(str){if($.terminal.is_formatting(str)){return str.replace(format_parts_re,format);}else{return linkify(str);}}).join('');}// ---------------------------------------------------------------------
function should_wrap(string,options){return(strlen(text(string))>options.cols||string.match(/\n/))&&(_settings.wrap===true&&options.wrap===undefined||_settings.wrap===false&&options.wrap===true);}// ---------------------------------------------------------------------
var line_cache;if('Map'in root){line_cache=new Map();}// ---------------------------------------------------------------------
function process_extended_commands(string,line,line_settings){if(line_settings.exec||line.options.clear_exec){return $.terminal.each_extended_command(string,function(command){// redraw should not execute commands and it have
// and lines variable have all extended commands
if(line_settings.exec){line.options.exec=false;line.options.clear_exec=true;var trim=command.trim();if(prev_exec_cmd&&prev_exec_cmd===trim){prev_exec_cmd='';self.error(strings().recursiveLoop);}else{prev_exec_cmd=trim;$.terminal.extended_command(self,command,{invokeMethods:line_settings.invokeMethods}).then(function(){prev_exec_cmd='';});}}});}return string;}// ---------------------------------------------------------------------
function process_line(line){// prevent exception in display exception
try{var use_cache=!is_function(line.value);var line_settings=$.extend({exec:true,raw:false,finalize:$.noop,useCache:use_cache,invokeMethods:false,formatters:true,convertLinks:_settings.convertLinks},line.options||{});var string=stringify_value(line.value);if(string&&is_function(string.then)){// handle function that return a promise #629
return string.then(function(string){process_line($.extend(line,{value:string,options:line_settings}));});}if(string!==''){if(!line_settings.raw){if(_settings.useCache&&line_settings.useCache){var key=string;if(line_cache&&line_cache.has(key)){var data=line_cache.get(key);buffer.append(data.input,line.index,line_settings,data.raw);return true;}}if(line_settings.formatters){try{string=$.terminal.apply_formatters(string,$.extend(_settings,{echo:true}));}catch(e){display_exception(e,'FORMATTING');}}string=process_extended_commands(string,line,line_settings);if(string===''){return;}if(line_settings.convertLinks){string=links(string);}var raw_string=string;string=crlf($.terminal.normalize(string));string=$.terminal.encode(string,{tabs:_settings.tabs});//string = $.terminal.normalize(string);
var array;var cols=line_settings.cols=self.cols();if(should_wrap(string,line_settings)){var words=line_settings.keepWords;array=$.terminal.split_equal(string,cols,words);}else if(string.match(/\n/)){array=string.split(/\n/);}}}else{raw_string='';}var arg=array||string;if(line_cache&&key&&use_cache){line_cache.set(key,{input:arg,raw:raw_string});}buffer.append(arg,line.index,line_settings,raw_string);}catch(e){buffer.clear();// don't display exception if exception throw in terminal
if(is_function(_settings.exceptionHandler)){_settings.exceptionHandler.call(self,e,'TERMINAL');}else{alert_exception('[Internal Exception(process_line)]',e);}}// is it work with unpromise that ignore undefined
return true;}// ---------------------------------------------------------------------
// :: Update terminal lines
// ---------------------------------------------------------------------
function redraw(options){options=$.extend({},{// should be used when single line is updated
update:false,// should be used if you want to scroll to bottom after redraw
scroll:true},options||{});if(!options.update){command_line.resize(num_chars);// we don't want reflow while processing lines
var detached_output=output.empty().detach();}try{buffer.clear();unpromise(lines.render(self.rows(),function(lines_to_show){return lines_to_show.map(function(line){return process_line(line);});}),function(){self.flush(options);if(!options.update){command_line.before(detached_output);// reinsert output
}fire_event('onAfterRedraw');});}catch(e){if(is_function(_settings.exceptionHandler)){_settings.exceptionHandler.call(self,e,'TERMINAL (redraw)');}else{alert_exception('[redraw]',e);}}}// ---------------------------------------------------------------------
// :: Function limit output lines based on outputLimit option
// ---------------------------------------------------------------------
function limit_lines(){if(_settings.outputLimit>=0){var limit;if(_settings.outputLimit===0){limit=self.rows();}else{limit=_settings.outputLimit;}var $lines=output.find('> div > div');if($lines.length+1>limit){var max=$lines.length-limit+1;var for_remove=$lines.slice(0,max);// you can't get parent if you remove the
// element so we first get the parent
var parents=for_remove.parent();for_remove.remove();parents.each(function(){var $self=$(this);if($self.is(':empty')){unmount($self);// there can be divs inside parent that
// was not removed
$self.remove();}});lines.limit_snapshot(max);}}}// ---------------------------------------------------------------------
// :: Display user greetings or terminal signature
// ---------------------------------------------------------------------
function show_greetings(){if(_settings.greetings===undefined){// signature have ascii art so it's not suite for screen readers
self.echo(self.signature,{finalize:a11y_hide,formatters:false});}else if(_settings.greetings){var type=_typeof(_settings.greetings);if(type==='string'){self.echo(_settings.greetings);}else if(type==='function'){self.echo(function(){try{return _settings.greetings.call(self,self.echo);}catch(e){_settings.greetings=null;display_exception(e,'greetings');}});}else{self.error(strings().wrongGreetings);}}}// ---------------------------------------------------------------------
// :: Display prompt and last command
// ---------------------------------------------------------------------
function echo_command(command){if(typeof command==='undefined'){command=self.get_command();}// true will return last rendered string
var prompt=command_line.prompt(true);var mask=command_line.mask();switch(_typeof(mask)){case'string':command=command.replace(/./g,mask);break;case'boolean':if(mask){command=command.replace(/./g,_settings.maskChar);}else{command=$.terminal.escape_formatting(command);}break;}var options={exec:false,formatters:false,finalize:function finalize(div){a11y_hide(div.addClass('terminal-command'));fire_event('onEchoCommand',[div,command]);}};command=$.terminal.apply_formatters(command,{command:true});self.echo(prompt+command,options);}// ---------------------------------------------------------------------
function have_scrollbar(){return fill.outerWidth()!==self.outerWidth();}// ---------------------------------------------------------------------
// :: Helper function that restore state. Call import_view or exec
// ---------------------------------------------------------------------
function restore_state(spec){// spec [terminal_id, state_index, command]
var terminal=terminals.get()[spec[0]];if(!terminal){throw new $.terminal.Exception(strings().invalidTerminalId);}var command_idx=spec[1];if(_save_state[command_idx]){// state exists
terminal.import_view(_save_state[command_idx]);}else{// restore state
change_hash=false;var command=spec[2];if(command){terminal.exec(command).done(function(){change_hash=true;_save_state[command_idx]=terminal.export_view();});}}/*if (spec[3].length) {
                restore_state(spec[3]);
            }*/}// ---------------------------------------------------------------------
function make_label_error(label){return function(e){self.error('['+label+'] '+(e.message||e)).resume();};}// ---------------------------------------------------------------------
// :: Helper function
// ---------------------------------------------------------------------
function maybe_update_hash(){if(change_hash){fire_hash_change=false;location.hash='#'+JSON.stringify(hash_commands);setTimeout(function(){fire_hash_change=true;},100);}}// ---------------------------------------------------------------------
// :: Wrapper over interpreter, it implements exit and catches all
// :: exeptions from user code and displays them on the terminal
// ---------------------------------------------------------------------
var first_command=true;var resume_callbacks=[];function commands(command,silent,exec){function init_state(){// execHash need first empty command too
if(_settings.historyState||_settings.execHash&&exec){if(!_save_state.length){// first command in first terminal don't have hash
self.save_state();}else{self.save_state(null);}}}// -----------------------------------------------------------------
function before_async_exec(){// variables defined later in commands
if(!exec){change_hash=true;if(_settings.historyState){self.save_state(command,false);}change_hash=saved_change_hash;}}// -----------------------------------------------------------------
function after_exec(){deferred.resolve();fire_event('onAfterCommand',[command]);}// -----------------------------------------------------------------
function show(result){if(typeof result!=='undefined'){display_object(result);}after_exec();self.resume();}// -----------------------------------------------------------------
function is_animation_promise(ret){return is_function(ret.done||ret.then)&&animating;}// -----------------------------------------------------------------
function invoke(){// Call user interpreter function
var result=interpreter.interpreter.call(self,command,self);before_async_exec();if(result){// auto pause/resume when user return promises
// it should not pause when user return promise from read()
if(!force_awake){if(is_animation_promise(result)){_paused=true;}else{self.pause(_settings.softPause);}}force_awake=false;var error=make_label_error('Command');// when for native Promise object work only in jQuery 3.x
if(is_function(result.done||result.then)){return unpromise(result,show,error);}else{return $.when(result).done(show).catch(error);}}else{if(_paused){resume_callbacks.push(function(){// exec with resume/pause in user code
after_exec();});}else{after_exec();}return deferred.promise();}}// -----------------------------------------------------------------
// first command store state of the terminal before the command get
// executed
if(first_command){first_command=false;init_state();}try{// this callback can disable commands
if(fire_event('onBeforeCommand',[command])===false){return;}if(exec){prev_exec_cmd=command.trim();prev_command=$.terminal.split_command(prev_exec_cmd);}else{prev_command=$.terminal.split_command(command);}if(!ghost()){// exec execute this function wihout the help of cmd plugin
// that add command to history on enter
if(exec&&(is_function(_settings.historyFilter)&&_settings.historyFilter(command)||command.match(_settings.historyFilter))){command_line.history().append(command);}}var interpreter=interpreters.top();if(!silent&&_settings.echoCommand){echo_command(command);}// new promise will be returned to exec that will resolve his
// returned promise
var deferred=new $.Deferred();// we need to save sate before commands is deleyd because
// execute_extended_command disable it and it can be executed
// after delay
var saved_change_hash=change_hash;if(command.match(/^\s*login\s*$/)&&self.token(true)){before_async_exec();if(self.level()>1){self.logout(true);}else{self.logout();}after_exec();}else if(_settings.exit&&command.match(/^\s*exit\s*$/)&&!in_login){before_async_exec();var level=self.level();if(level===1&&self.get_token()||level>1){if(self.get_token(true)){self.set_token(undefined,true);}self.pop();}after_exec();}else if(_settings.clear&&command.match(/^\s*clear\s*$/)&&!in_login){before_async_exec();self.clear();after_exec();}else{var ret=invoke();if(ret){return ret;}}return deferred.promise();}catch(e){display_exception(e,'USER',exec);self.resume();if(exec){throw e;}}}// ---------------------------------------------------------------------
// :: The logout function removes Storage, disables history and runs
// :: the login function. This function is called only when options.login
// :: function is defined. The check for this is in the self.pop method
// ---------------------------------------------------------------------
function global_logout(){if(fire_event('onBeforeLogout',[],true)===false){return;}clear_loging_storage();fire_event('onAfterlogout',[],true);self.login(global_login_fn,true,initialize);}// ---------------------------------------------------------------------
function clear_loging_storage(){var name=self.prefix_name(true)+'_';storage.remove(name+'token');storage.remove(name+'login');}// ---------------------------------------------------------------------
// :: Save the interpreter name for use with purge
// ---------------------------------------------------------------------
function maybe_append_name(interpreter_name){var storage_key=self.prefix_name()+'_interpreters';var names=storage.get(storage_key);if(names){names=JSON.parse(names);}else{names=[];}if($.inArray(interpreter_name,names)===-1){names.push(interpreter_name);storage.set(storage_key,JSON.stringify(names));}}// ---------------------------------------------------------------------
// :: Function enables history, sets prompt, runs interpreter function
// ---------------------------------------------------------------------
function prepare_top_interpreter(silent){var interpreter=interpreters.top();var name=self.prefix_name(true);if(!ghost()){maybe_append_name(name);}var login=self.login_name(true);command_line.name(name+(login?'_'+login:''));var prompt=interpreter.prompt;if(is_function(prompt)){prompt=context_callback_proxy(prompt);}if(prompt!==command_line.prompt()){if(is_function(interpreter.prompt)){// prevent flicker of old prompt until async prompt finishes
command_line.prompt('');}command_line.prompt(interpreter.prompt);}if(typeof interpreter.history!=='undefined'){self.history().toggle(interpreter.history);}if($.isPlainObject(interpreter.keymap)){command_line.keymap(null).keymap($.extend({},terminal_init_keymap,$.omap(interpreter.keymap,function(name,fun){return function(){var args=[].slice.call(arguments);try{return fun.apply(self,args);}catch(e){display_exception(e,'USER KEYMAP');}};})));}command_line.set('');init_queue.resolve();if(!silent&&is_function(interpreter.onStart)){interpreter.onStart.call(self,self);}}// ---------------------------------------------------------------------
function fire_event(name,args,skip_local){args=(args||[]).concat([self]);// create new array
// even can be fired before interpreters is created
var top=interpreters&&interpreters.top();if(top&&is_function(top[name])&&!skip_local){try{return top[name].apply(self,args);}catch(e){delete top[name];display_exception(e,name);}}else if(is_function(_settings[name])){try{return _settings[name].apply(self,args);}catch(e){_settings[name]=null;display_exception(e,name);}}}var scroll_to_view=function(){function scroll_to_view(visible){if(!visible){// try catch for Node.js unit tests
try{self.scroll_to(self.find('.cmd-cursor-line'));return true;}catch(e){return true;}}}// we don't want debounce in Unit Tests
if(typeof global!=='undefined'&&typeof global.it==='function'){return scroll_to_view;}return debounce(scroll_to_view,100,{leading:true,trailing:false});}();// ---------------------------------------------------------------------
function make_cursor_visible(){var cursor=self.find('.cmd-cursor-line');return cursor.is_fully_in_viewport(self).then(scroll_to_view);}// ---------------------------------------------------------------------
function replace_hash(state){if(typeof history!=='undefined'&&history.replaceState){var new_hash='#'+JSON.stringify(state);var url=location.href.replace(/#.*$/,new_hash);history.replaceState(null,'',url);}}// ---------------------------------------------------------------------
function hashchange(){if(fire_hash_change&&_settings.execHash){try{if(location.hash){var hash=location.hash.replace(/^#/,'');hash_commands=JSON.parse(decodeURIComponent(hash));}else{hash_commands=[];}if(hash_commands.length){restore_state(hash_commands[hash_commands.length-1]);}else if(_save_state[0]){self.import_view(_save_state[0]);}}catch(e){display_exception(e,'TERMINAL');}}}// ---------------------------------------------------------------------
function initialize(){prepare_top_interpreter();show_greetings();if(lines.length){// for case when showing long error before init
if(echo_delay.length){// for case when greetting is async function
$.when.apply($,echo_delay).then(self.refresh);}else{self.refresh();}}function next(){onPause=$.noop;if(!was_paused&&self.enabled()){// resume login if user didn't call pause in onInit
// if user pause in onInit wait with exec until it
// resume
self.resume(true);}}// was_paused flag is workaround for case when user call exec before
// login and pause in onInit, 3rd exec will have proper timing (will
// execute after onInit resume)
var was_paused=false;if(is_function(_settings.onInit)){onPause=function onPause(){// local in terminal
was_paused=true;};var ret;try{ret=_settings.onInit.call(self,self);}catch(e){display_exception(e,'OnInit');}finally{if(!is_promise(ret)){next();}else{ret.then(next).catch(function(e){display_exception(e,'OnInit');next();});}}}if(first_instance){first_instance=false;$(window).on('hashchange',hashchange);}}// ---------------------------------------------------------------------
// :: If Ghost don't store anything in localstorage
// ---------------------------------------------------------------------
function ghost(){return in_login||command_line.mask()!==false;}// ---------------------------------------------------------------------
// :: Keydown event handler
// ---------------------------------------------------------------------
function user_key_down(e){var result,top=interpreters.top();if(is_function(top.keydown)){result=top.keydown.call(self,e,self);if(result!==undefined){return result;}}else if(is_function(_settings.keydown)){result=_settings.keydown.call(self,e,self);if(result!==undefined){return result;}}}var keymap={'CTRL+D':function CTRLD(e,original){if(!in_login){if(command_line.get()===''){if(interpreters.size()>1||is_function(global_login_fn)){self.pop('');}else{self.resume();}}else{original();}}return false;},'CTRL+C':function CTRLC(){with_selection(function(html){if(html===''){var command=self.get_command();var position=self.get_position();command=command.slice(0,position)+'^C'+command.slice(position+2);echo_command(command);self.set_command('');}else{var clip=self.find('textarea');text_to_clipboard(clip,process_selected_html(html));}});return false;},'CTRL+L':function CTRLL(){self.clear();return false;},'TAB':function TAB(e,orignal){// TODO: move this to cmd plugin
//       add completion = array | function
//       !!! Problem complete more then one key need terminal
var top=interpreters.top(),completion,caseSensitive;if(typeof top.caseSensitiveAutocomplete!=='undefined'){caseSensitive=top.caseSensitiveAutocomplete;}else{caseSensitive=_settings.caseSensitiveAutocomplete;}if(_settings.completion&&get_type(_settings.completion)!=='boolean'&&top.completion===undefined){completion=_settings.completion;}else{completion=top.completion;}if(completion==='settings'){completion=_settings.completion;}function resolve(commands){// local copy
commands=commands.slice();// default commands should not match for arguments
if(!self.before_cursor(false).match(/\s/)){if(_settings.clear&&$.inArray('clear',commands)===-1){commands.push('clear');}if(_settings.exit&&$.inArray('exit',commands)===-1){commands.push('exit');}}self.complete(commands,{echo:true,word:_settings.wordAutocomplete,escape:_settings.completionEscape,caseSensitive:caseSensitive,echoCommand:_settings.doubleTabEchoCommand,doubleTab:_settings.doubleTab});}if(completion){switch(get_type(completion)){case'function':var string=self.before_cursor(_settings.wordAutocomplete);if(completion.length===3){var error=new Error(strings().comletionParameters);display_exception(error,'USER');return false;}var result=completion.call(self,string,resolve);unpromise(result,resolve,make_label_error('Completion'));break;case'array':resolve(completion);break;default:throw new $.terminal.Exception(strings().invalidCompletion);}}else{orignal();}return false;},'CTRL+V':function CTRLV(e,original){original(e);self.oneTime(200,function(){self.scroll_to_bottom();});return true;},'CTRL+TAB':function CTRLTAB(){if(terminals.length()>1){self.focus(false);return false;}},'PAGEDOWN':function PAGEDOWN(){self.scroll(self.height());},'PAGEUP':function PAGEUP(){self.scroll(-self.height());}};// ---------------------------------------------------------------------
function key_down(e){// Prevent to be executed by cmd: CTRL+D, TAB, CTRL+TAB (if more
// then one terminal)
var result,i;if(animating){return false;}if(self.enabled()){if(!self.paused()){result=user_key_down(e);if(result!==undefined){return result;}if(e.which!==9){// not a TAB
tab_count=0;}}else{if(!_settings.pauseEvents){result=user_key_down(e);if(result!==undefined){return result;}}if(e.which===68&&e.ctrlKey){// CTRL+D (if paused)
if(_settings.pauseEvents){result=user_key_down(e);if(result!==undefined){return result;}}if(requests.length){for(i=requests.length;i--;){var r=requests[i];if(r.readyState!==4){try{r.abort();}catch(error){if(is_function(_settings.exceptionHandler)){_settings.exceptionHandler.call(self,e,'AJAX ABORT');}else{self.error(strings().ajaxAbortError);}}}}requests=[];}self.resume();}return false;}}}// ---------------------------------------------------------------------
function key_press(e){var top=interpreters.top();if(_enabled2&&(!_paused||!_settings.pauseEvents)){if(is_function(top.keypress)){return top.keypress.call(self,e,self);}else if(is_function(_settings.keypress)){return _settings.keypress.call(self,e,self);}}}// ---------------------------------------------------------------------
// :: Typing animation generator
// ---------------------------------------------------------------------
function typed(finish_typing_fn){return function typing_animation(message,options){var formattted=$.terminal.apply_formatters(message);animating=true;var prompt=self.get_prompt();var char_i=0;var len=$.terminal.length(formattted);if(message.length>0){var new_prompt='';if(options.prompt){new_prompt=options.prompt;}else{self.set_prompt('');}var bottom=self.is_bottom();var interval=setInterval(function(){var chr=$.terminal.substring(formattted,char_i,char_i+1);new_prompt+=chr;self.set_prompt(new_prompt);if(chr==='\n'&&bottom){self.scroll_to_bottom();}char_i++;if(char_i===len){clearInterval(interval);setTimeout(function(){// swap command with prompt
finish_typing_fn(message,prompt,options);animating=false;},options.delay);}},options.delay);}};}// ---------------------------------------------------------------------
var typed_prompt=typed(function(message,_,options){self.set_prompt(message);options.finalize();});// ---------------------------------------------------------------------
var typed_message=typed(function(message,prompt,options){self.set_prompt(prompt);self.echo(message,$.extend({},options,{typing:false}));});// ---------------------------------------------------------------------
var typed_enter=function(){var helper=typed(function(message,prompt,options){self.set_prompt(prompt);with_prompt(prompt,function(prompt){self.echo(prompt+message,$.extend({},options,{typing:false}));},self);});return function(prompt,message,options){return helper(message,$.extend({},options,{prompt:prompt}));};}();// ---------------------------------------------------------------------
function with_typing(kind,else_fn,finalize_fn){return function with_typing_fn(string,options){var d=new $.Deferred();when_ready(function ready(){var locals=$.extend({typing:false,delay:_settings.execAnimationDelay},options);if(locals.typing){if(typeof string!=='string'){return d.reject(kind+': Typing animation require string');}if(typeof locals.delay!=='number'||isNaN(locals.delay)){return d.reject(kind+': Invalid argument, delay need to'+' be a number');}var p=self.typing(kind,locals.delay,string,locals);p.then(function(){d.resolve();});}else{else_fn(string,locals);}if(is_function(finalize_fn)){finalize_fn(string,locals);}});if(options&&options.typing){return d.promise();}return self;};}// ---------------------------------------------------------------------
function ready(queue){return function(fun){queue.add(fun);};}// ---------------------------------------------------------------------
function strings(){return $.extend({},$.terminal.defaults.strings,_settings&&_settings.strings||{});}// ---------------------------------------------------------------------
var self=this;if(this.length>1){return this.each(function(){$.fn.terminal.call($(this),init_interpreter,$.extend({name:self.selector},options));});}var body_terminal;if(self.is('body,html')){// terminal already exists on body
if(self.hasClass('full-screen-terminal')){var data=self.find('> .terminal').data('terminal');if(data){return data;}}body_terminal=self;self=$('<div/>').appendTo('body');$('body').addClass('full-screen-terminal');}else if(self.data('terminal')){// terminal already exists
return self.data('terminal');}// -----------------------------------------------------------------
// TERMINAL METHODS
// -----------------------------------------------------------------
var public_api=$.omap({id:function id(){return terminal_id;},// -------------------------------------------------------------
// :: Clear the output
// -------------------------------------------------------------
clear:function clear(){if(fire_event('onClear')!==false){buffer.clear();lines.clear(function(i){return get_node(i);});output[0].innerHTML='';self.prop({scrollTop:0});}return self;},// -------------------------------------------------------------
// :: Return an object that can be used with import_view to
// :: restore the state
// -------------------------------------------------------------
export_view:function export_view(){var user_export=fire_event('onExport');user_export=user_export||{};return $.extend({},{focus:_enabled2,mask:command_line.mask(),prompt:self.get_prompt(),command:self.get_command(),position:command_line.position(),lines:clone(lines.data()),interpreters:interpreters.clone(),history:command_line.history().data},user_export);},// -------------------------------------------------------------
// :: Restore the state of the previous exported view
// -------------------------------------------------------------
import_view:function import_view(view){if(in_login){throw new Error(sprintf(strings().notWhileLogin,'import_view'));}fire_event('onImport',[view]);when_ready(function ready(){self.set_prompt(view.prompt);self.set_command(view.command);command_line.position(view.position);command_line.mask(view.mask);if(view.focus){self.focus();}lines.import(clone(view.lines).filter(function(line){return line[0];}));if(view.interpreters instanceof Stack){interpreters=view.interpreters;}if(_settings.importHistory){command_line.history().set(view.history);}redraw();});return self;},// -------------------------------------------------------------
// :: Store current terminal state
// -------------------------------------------------------------
save_state:function save_state(command,ignore_hash,index){// save_state.push({view:self.export_view(), join:[]});
if(typeof index!=='undefined'){_save_state[index]=self.export_view();}else{_save_state.push(self.export_view());}if(!$.isArray(hash_commands)){hash_commands=[];}if(command!==undefined&&!ignore_hash){var state=[terminal_id,_save_state.length-1,command];hash_commands.push(state);maybe_update_hash();}return self;},// -------------------------------------------------------------
// :: Execute a command, it will handle commands that do AJAX
// :: calls and have delays, if the second argument is set to
// :: true it will not echo executed command
// :: if second argument is object is used as options
// -------------------------------------------------------------
exec:function exec(command,silent,options){function invoke(silent){// commands may return promise from user code
// it will resolve exec promise when user promise
// is resolved
var ret=commands(command,silent,true);unpromise(ret,function(){// reset prev command for push called after exec
// so push didn't get name/prompt from exec command
prev_command=null;d.resolve();},function(){prev_command=null;d.reject();});}if(silent&&_typeof(silent)==='object'){options=silent;silent=null;}var exec_settings=$.extend({deferred:null,silent:false,typing:false,delay:_settings.execAnimationDelay},options);if(silent===null){silent=exec_settings.silent;}if(!is_deferred(exec_settings.deferred)){exec_settings.deferred=new $.Deferred();}var d=exec_settings.deferred;cmd_ready(function ready(){if($.isArray(command)){(function recur(){var cmd=command.shift();if(cmd){self.exec(cmd,silent,options).done(recur);}else{d.resolve();}})();}else if(_paused){// both commands executed here (resume will call Term::exec)
// delay command multiple time
delayed_commands.push([command,silent,exec_settings]);}else if(exec_settings.typing&&!silent){var delay=exec_settings.delay;_paused=true;var ret=self.typing('enter',delay,command,{delay:delay});ret.then(function(){_paused=false;invoke(true);});d.then(function(){_paused=false;});}else{invoke(silent);}});// while testing it didn't executed last exec when using this
// for resolved deferred
return d.promise();},// -------------------------------------------------------------
// :: bypass login function that wait untill you type user/pass
// :: it hide implementation detail
// -------------------------------------------------------------
autologin:function autologin(user,token,silent){self.trigger('terminal.autologin',[user,token,silent]);return self;},// -------------------------------------------------------------
// :: Function changes the prompt of the command line to login
// :: with a password and calls the user login function with
// :: the callback that expects a token. The login is successful
// :: if the user calls it with value that is truthy
// -------------------------------------------------------------
login:function login(auth,infinite,success,error){logins.push([].slice.call(arguments));if(in_login){throw new Error(sprintf(strings().notWhileLogin,'login'));}if(!is_function(auth)){throw new Error(strings().loginIsNotAFunction);}in_login=true;if(self.token()&&self.level()===1&&!autologin){in_login=false;// logout will call login
self.logout(true);}else if(self.token(true)&&self.login_name(true)){in_login=false;if(is_function(success)){success();}return self;}// don't store login data in history
if(_settings.history){command_line.history().disable();}function popUserPass(){while(self.level()>level){self.pop(undefined,true);}if(_settings.history){command_line.history().enable();}}// so we know how many times call pop
var level=self.level();function login_callback(user,token,silent){if(token){popUserPass();var name=self.prefix_name(true)+'_';storage.set(name+'token',token);storage.set(name+'login',user);in_login=false;fire_event('onAfterLogin',[user,token]);if(is_function(success)){// will be used internaly since users know
// when login success (they decide when
// it happen by calling the callback -
// this funtion)
success();}}else{if(infinite){if(!silent){self.error(strings().wrongPasswordTryAgain);}self.pop(undefined,true).set_mask(false);}else{in_login=false;if(!silent){self.error(strings().wrongPassword);}self.pop(undefined,true).pop(undefined,true);}// used only to call pop in push
if(is_function(error)){error();}}if(self.paused()){self.resume();}self.off('terminal.autologin');}self.on('terminal.autologin',function(event,user,token,silent){if(fire_event('onBeforeLogin',[user,token])===false){return;}login_callback(user,token,silent);});self.push(function(user){self.set_mask(_settings.maskChar).push(function(pass){try{if(fire_event('onBeforeLogin',[user,pass])===false){popUserPass();return;}self.pause();var ret=auth.call(self,user,pass,function(token,silent){login_callback(user,token,silent);});if(ret&&is_function(ret.then||ret.done)){(ret.then||ret.done).call(ret,function(token){login_callback(user,token);}).catch(function(err){self.pop(undefined,true).pop(undefined,true);self.error(err.message);if(is_function(error)){error();}if(self.paused()){self.resume();}self.off('terminal.autologin');});}}catch(e){display_exception(e,'AUTH');}},{prompt:strings().password+': ',name:'password'});},{prompt:strings().login+': ',name:'login'});return self;},// -------------------------------------------------------------
// :: User defined settings and defaults as well
// -------------------------------------------------------------
settings:function settings(){return _settings;},// -------------------------------------------------------------
// :: Get string before cursor
// -------------------------------------------------------------
before_cursor:function before_cursor(word){var pos=command_line.position();var command=command_line.get().slice(0,pos);var cmd_strings=command.split(' ');var string;// string before cursor that will be completed
if(word){if(cmd_strings.length===1){string=cmd_strings[0];}else{var m=command.match(/(\\?")/g);var double_quotes=m?m.filter(function(chr){return!chr.match(/^\\/);}).length:0;m=command.match(/'/g);var single_quote=m?m.length:0;if(single_quote%2===1){string=command.match(/('[^']*)$/)[0];}else if(double_quotes%2===1){string=command.match(/("(?:[^"]|\\")*)$/)[0];}else{string=cmd_strings[cmd_strings.length-1];for(i=cmd_strings.length-1;i>0;i--){// treat escape space as part of the string
var prev_string=cmd_strings[i-1];if(prev_string[prev_string.length-1]==='\\'){string=cmd_strings[i-1]+' '+string;}else{break;}}}}}else{string=command;}return string;},// -------------------------------------------------------------
// :: complete word or command based on array of words
// -------------------------------------------------------------
complete:function complete(commands,options){options=$.extend({word:true,echo:false,escape:true,echoCommand:false,caseSensitive:true,doubleTab:null},options||{});var sensitive=options.caseSensitive;// cursor can be in the middle of the command
// so we need to get the text before the cursor
var string=self.before_cursor(options.word).replace(/\\"/g,'"');var quote=false;if(options.word){if(string.match(/^"/)){quote='"';}else if(string.match(/^'/)){quote="'";}if(quote){string=string.replace(/^["']/,'');}}if(tab_count%2===0){command=self.before_cursor(options.word);}else{var test=self.before_cursor(options.word);if(test!==command){// command line changed between TABS - ignore
return;}}var safe=$.terminal.escape_regex(string);if(options.escape){safe=safe.replace(/(\\+)(["'() ])/g,function(_,slash,chr){if(chr.match(/[()]/)){return slash+'\\?\\'+chr;}else{return slash+'?'+chr;}});}function escape(string){if(quote==='"'){string=string.replace(/"/g,'\\"');}if(!quote&&options.escape){string=string.replace(/(["'() ])/g,'\\$1');}return string;}function matched_strings(){var matched=[];for(var i=commands.length;i--;){if(commands[i].match(/\n/)&&options.word){warn('If you use commands with newlines you '+'should use word option for complete or'+' wordAutocomplete terminal option');}if(regex.test(commands[i])){var match=escape(commands[i]);if(!sensitive&&same_case(match)){if(string.toLowerCase()===string){match=match.toLowerCase();}else if(string.toUpperCase()===string){match=match.toUpperCase();}}matched.push(match);}}return matched;}var flags=sensitive?'':'i';var regex=new RegExp('^'+safe,flags);var matched=matched_strings();function replace(input,replacement){var text=self.get_command();var pos=self.get_position();var re=new RegExp('^'+input,'i');var pre=text.slice(0,pos);var post=text.slice(pos);var to_insert=replacement.replace(re,'')+(quote||'');self.set_command(pre+to_insert+post);self.set_position((pre+to_insert).length);}if(matched.length===1){if(options.escape){replace(safe,matched[0]);}else{self.insert(matched[0].replace(regex,'')+(quote||''));}command=self.before_cursor(options.word);return true;}else if(matched.length>1){if(++tab_count>=2){tab_count=0;if(options.echo){if(is_function(options.doubleTab)){// new API old is keep for backward compatibility
if(options.echoCommand){echo_command();}var ret=options.doubleTab.call(self,string,matched,echo_command);if(typeof ret==='undefined'){return true;}else{return ret;}}else if(options.doubleTab!==false){echo_command();var text=matched.slice().reverse().join('\t\t');self.echo($.terminal.escape_brackets(text),{keepWords:true,formatters:false});}return true;}}else{var common=common_string(escape(string),matched,sensitive);if(common){replace(safe,common);command=self.before_cursor(options.word);return true;}}}},// -------------------------------------------------------------
// :: Return commands function from top interpreter
// -------------------------------------------------------------
commands:function commands(){return interpreters.top().interpreter;},// -------------------------------------------------------------
// :: Low Level method that overwrites interpreter
// -------------------------------------------------------------
set_interpreter:function set_interpreter(user_intrp,login){var defer=$.Deferred();function overwrite_interpreter(){self.pause(_settings.softPause);make_interpreter(user_intrp,login,function(result){self.resume();var top=interpreters.top();$.extend(top,result);prepare_top_interpreter(true);defer.resolve();});}if(is_function(login)){self.login(login,true,overwrite_interpreter);}else if(get_type(user_intrp)==='string'&&login){self.login(make_json_rpc_login(user_intrp,login),true,overwrite_interpreter);}else{overwrite_interpreter();}return defer.promise();},// -------------------------------------------------------------
// :: Show user greetings or terminal signature
// -------------------------------------------------------------
greetings:function greetings(){show_greetings();return self;},// -------------------------------------------------------------
// :: Return true if terminal is paused false otherwise
// -------------------------------------------------------------
paused:function paused(){return _paused;},// -------------------------------------------------------------
// :: Pause the terminal, it should be used for ajax calls
// -------------------------------------------------------------
pause:function pause(visible){cmd_ready(function ready(){onPause();_paused=true;command_line.disable(visible||is_android);if(!visible){command_line.find('.cmd-prompt').hidden();}fire_event('onPause');});return self;},// -------------------------------------------------------------
// :: Resume the previously paused terminal
// -------------------------------------------------------------
resume:function resume(silent){cmd_ready(function ready(){_paused=false;if(_enabled2&&terminals.front()===self){command_line.enable(silent);}command_line.find('.cmd-prompt').visible();var original=delayed_commands;delayed_commands=[];for(var i=0;i<original.length;++i){self.exec.apply(self,original[i]);}self.trigger('resume');var fn=resume_callbacks.shift();if(fn){fn();}self.scroll_to_bottom();fire_event('onResume');});return self;},// -------------------------------------------------------------
// :: Return the number of characters that fit into the width of
// :: the terminal
// -------------------------------------------------------------
cols:function cols(){if(_settings.numChars){return _settings.numChars;}if(!num_chars||num_chars===1000){num_chars=get_num_chars(self,char_size);}return num_chars;},// -------------------------------------------------------------
// :: Return the number of lines that fit into the height of the
// :: terminal
// -------------------------------------------------------------
rows:function rows(){if(_settings.numRows){return _settings.numRows;}if(!num_rows){num_rows=get_num_rows(self,char_size);}return num_rows;},// -------------------------------------------------------------
// :: Return the History object
// -------------------------------------------------------------
history:function history(){return command_line.history();},// -------------------------------------------------------------
// :: Return size of the terminal instance
// -------------------------------------------------------------
geometry:function geometry(){var style=window.getComputedStyle(self[0]);function padding(name){return parseInt(style.getPropertyValue('padding-'+name),10)||0;}var left=padding('left');var right=padding('right');var top=padding('top');var bottom=padding('bottom');return{terminal:{padding:{left:left,right:right,top:top,bottom:bottom},width:old_width+left+right,height:old_height+top+bottom},char:char_size,cols:this.cols(),rows:this.rows()};},// -------------------------------------------------------------
// :: toggle recording of history state
// -------------------------------------------------------------
history_state:function history_state(toggle){function run(){_settings.historyState=true;if(!_save_state.length){self.save_state();}else if(terminals.length()>1){self.save_state(null);}}if(toggle){// if set to true and if set from user command we need
// not to include the command
if(typeof window.setImmediate==='undefined'){setTimeout(run,0);}else{setImmediate(run);}}else{_settings.historyState=false;}return self;},// -------------------------------------------------------------
// :: clear the history state
// -------------------------------------------------------------
clear_history_state:function clear_history_state(){hash_commands=[];_save_state=[];return self;},// -------------------------------------------------------------
// :: Switch to the next terminal
// -------------------------------------------------------------
next:function next(){if(terminals.length()===1){return self;}else{terminals.front().disable();var next=terminals.rotate().enable();// 50 provides buffer in viewport
var x=next.offset().top-50;$('html,body').animate({scrollTop:x},500);try{trigger_terminal_change(next);}catch(e){display_exception(e,'onTerminalChange');}return next;}},// -------------------------------------------------------------
// :: Make the terminal in focus or blur depending on the first
// :: argument. If there is more then one terminal it will
// :: switch to next one, if the second argument is set to true
// :: the events will be not fired. Used on init
// -------------------------------------------------------------
focus:function focus(toggle,silent){cmd_ready(function ready(){if(terminals.length()===1){if(toggle===false){self.disable(silent);}else{self.enable(silent);}}else if(toggle===false){self.next();}else{var front=terminals.front();if(front!==self){// there should be only from terminal enabled but tests
// sometime fail because there where more them one
// where cursor have blink class
terminals.forEach(function(terminal){if(terminal!==self&&terminal.enabled()){terminal.disable(silent);}});if(!silent){try{trigger_terminal_change(self);}catch(e){display_exception(e,'onTerminalChange');}}}terminals.set(self);self.enable(silent);}});return self;},// -------------------------------------------------------------
// :: Disable/Enable terminal that can be enabled by click
// -------------------------------------------------------------
freeze:function freeze(_freeze){when_ready(function ready(){if(_freeze){self.disable();_frozen=true;}else{_frozen=false;self.enable();}});return self;},// -------------------------------------------------------------
// :: check if terminal is frozen
// -------------------------------------------------------------
frozen:function frozen(){return _frozen;},// -------------------------------------------------------------
// :: Enable the terminal
// -------------------------------------------------------------
enable:function enable(silent){if(!_enabled2&&!_frozen){if(num_chars===undefined){// enabling first time
self.resize();}cmd_ready(function ready(){var ret;if(!silent&&!_enabled2){fire_event('onFocus');}if(!silent&&ret===undefined||silent){_enabled2=true;if(!self.paused()){command_line.enable(true);}}});}return self;},// -------------------------------------------------------------
// :: function clear formatting cache if you don't longer need it
// :: cache is used if option useCache is set to true
// -------------------------------------------------------------
clear_cache:'Map'in root?function(){buffer.clear_cache();line_cache.clear();return self;}:function(){return self;},// -------------------------------------------------------------
// :: Disable the terminal
// -------------------------------------------------------------
disable:function disable(silent){cmd_ready(function ready(){var ret;if(!silent&&_enabled2){ret=fire_event('onBlur');}if(!silent&&ret===undefined||silent){_enabled2=false;command_line.disable();}});return self;},// -------------------------------------------------------------
// :: return true if the terminal is enabled
// -------------------------------------------------------------
enabled:function enabled(){return _enabled2;},// -------------------------------------------------------------
// :: Return the terminal signature depending on the size of the terminal
// -------------------------------------------------------------
signature:function signature(){var cols=self.cols();for(var i=signatures.length;i--;){var lengths=signatures[i].map(function(line){return line.length;});if(Math.max.apply(null,lengths)<=cols){return signatures[i].join('\n')+'\n';}}return'';},// -------------------------------------------------------------
// :: Return the version number
// -------------------------------------------------------------
version:function version(){return $.terminal.version;},// -------------------------------------------------------------
// :: Return actual command line object (jquery object with cmd
// :: methods)
// -------------------------------------------------------------
cmd:function cmd(){return command_line;},// -------------------------------------------------------------
// :: Return the current command entered by terminal
// -------------------------------------------------------------
get_command:function get_command(){return command_line.get();},// -------------------------------------------------------------
// :: better API than echo_command that supports animation
// -------------------------------------------------------------
enter:with_typing('enter',echo_command),// -------------------------------------------------------------
// :: Change the command line to the new one
// -------------------------------------------------------------
set_command:function set_command(command,silent){when_ready(function ready(){// TODO: refactor to use options - breaking change
if(typeof command!=='string'){command=JSON.stringify(command);}command_line.set(command,undefined,silent);});return self;},// -------------------------------------------------------------
// :: Change position of the command line
// -------------------------------------------------------------
set_position:function set_position(position,relative){when_ready(function ready(){command_line.position(position,relative);});return self;},// -------------------------------------------------------------
// :: Return position of the command line
// -------------------------------------------------------------
get_position:function get_position(){return command_line.position();},// -------------------------------------------------------------
// :: Insert text into the command line after the cursor
// -------------------------------------------------------------
insert:function insert(string,stay){if(typeof string==='string'){when_ready(function ready(){var bottom=self.is_bottom();command_line.insert(string,stay);if(_settings.scrollOnEcho||bottom){self.scroll_to_bottom();}});return self;}else{throw new Error(sprintf(strings().notAString,'insert'));}},// -------------------------------------------------------------
// :: Set the prompt of the command line
// -------------------------------------------------------------
set_prompt:with_typing('prompt',function(prompt){if(is_function(prompt)){command_line.prompt(function(callback){return prompt.call(self,callback,self);});}else{command_line.prompt(prompt);}},function(prompt){interpreters.top().prompt=prompt;}),// -------------------------------------------------------------
// :: Return the prompt used by the terminal
// -------------------------------------------------------------
get_prompt:function get_prompt(){return interpreters.top().prompt;// command_line.prompt(); - can be a wrapper
//return command_line.prompt();
},// -------------------------------------------------------------
// :: Enable or Disable mask depedning on the passed argument
// :: the mask can also be character (in fact it will work with
// :: strings longer then one)
// -------------------------------------------------------------
set_mask:function set_mask(mask){when_ready(function ready(){command_line.mask(mask===true?_settings.maskChar:mask);});return self;},// -------------------------------------------------------------
// :: Return the ouput of the terminal as text
// :: the output may contain user terminal formatting
// -------------------------------------------------------------
get_output:function get_output(raw){if(raw){return lines.data();}else{return lines.get_snapshot();}},// -------------------------------------------------------------
// :: Recalculate and redraw everything
// -------------------------------------------------------------
resize:function resize(width,height){if(!self.is(':visible')){// delay resize if terminal not visible
self.stopTime('resize');self.oneTime(500,'resize',function(){self.resize(width,height);});}else{if(width&&height){self.width(width);self.height(height);}width=self.width();height=self.height();if(typeof _settings.numChars!=='undefined'||typeof _settings.numRows!=='undefined'){command_line.resize(_settings.numChars);self.refresh();fire_event('onResize');return;}var new_num_chars=get_num_chars(self,char_size);var new_num_rows=get_num_rows(self,char_size);// only if number of chars changed
if(new_num_chars!==num_chars||new_num_rows!==num_rows){self.clear_cache();num_chars=new_num_chars;num_rows=new_num_rows;command_line.resize(num_chars);self.refresh();fire_event('onResize');}}return self;},// -------------------------------------------------------------
// :: redraw the terminal and invalidate cache
// -------------------------------------------------------------
refresh:function refresh(){if(char_size.width!==0){self[0].style.setProperty('--char-width',char_size.width);}self.clear_cache();if(command){command_line.resize();}redraw({scroll:false,update:true});return self;},// -------------------------------------------------------------
// :: Flush the output to the terminal
// -------------------------------------------------------------
flush:function flush(options){options=$.extend({},{update:false,scroll:true},options||{});when_ready(function ready(){try{if(buffer.is_empty()){return self;}var bottom=self.is_bottom();var scroll=_settings.scrollOnEcho&&options.scroll||bottom;var wrapper;// print all lines
var first=true;var appending_to_partial=false;var partial=$();var snapshot;if(!options.update){partial=self.find('.partial');snapshot=lines.get_partial();}// TODO: refactor buffer.flush(), there is way
//       to many levels of abstractions in one place
buffer.flush(function(data){if(!data){if(!partial.length){wrapper=$('<div/>');snapshot=[];}else if(first){first=false;appending_to_partial=true;wrapper=partial;}}else if(is_function(data.finalize)){if(scroll){wrapper.find('img').on('load',function(){self.scroll_to_bottom();});}// this is finalize function from echo
if(options.update){lines.update_snapshot(data.index,snapshot);var selector='> div[data-index='+data.index+']';var node=output.find(selector);if(node.html()!==wrapper.html()){node.replaceWith(wrapper);}}else{wrapper.appendTo(output);if(!partial.length){lines.make_snapshot(snapshot);}}wrapper.attr('data-index',data.index);appending_to_partial=!data.newline;wrapper.toggleClass('partial',appending_to_partial);if(appending_to_partial){partial=wrapper;}data.finalize(wrapper);}else{var line=data.line;var div;if(typeof data.raw==='string'){if(appending_to_partial){snapshot[snapshot.length-1]+=data.raw;}else{snapshot.push(data.raw);}}if(appending_to_partial){div=wrapper.children().last().append(line);appending_to_partial=false;}else{div=$('<div/>').html(line);if(data.newline){div.addClass('cmd-end-line');}wrapper.append(div);}// width = '100%' does some weird extra magic
// that makes the height correct. Any other
// value doesn't work.
div.css('width','100%');}});var cmd_prompt=self.find('.cmd-prompt');var cmd_outer=self.find('.cmd');partial=self.find('.partial');var last_row;if(partial.length===0){cmd_prompt.css('margin-left',0);cmd_outer.css('top',0);command_line.__set_prompt_margin(0);last_row=self.find('.terminal-output div:last-child'+' div:last-child');// check if the div is parital fix #695
if(last_row.css('display')==='inline-block'){last_row.css({width:'100%',display:''});}}else{last_row=partial.children().last();// Remove width='100%' for two reasons:
// 1. so we can measure the width right here
// 2. so that the background of this last line of output
//    doesn't occlude the first line of input to the right
last_row.css({width:'',display:'inline-block'});var last_row_rect=last_row[0].getBoundingClientRect();var partial_width=last_row_rect.width;// Shift command prompt up one line and to the right
// enough so that it appears directly next to the
// partially constructed output line
cmd_prompt.css('margin-left',partial_width);cmd_outer.css('top',-last_row_rect.height);// Measure length of partial line in characters
var char_width=self.geometry().char.width;var prompt_margin=Math.round(partial_width/char_width);command_line.__set_prompt_margin(prompt_margin);}limit_lines();fire_event('onFlush');var cmd_cursor=self.find('.cmd-cursor');var offset=self.find('.cmd').offset();var self_offset=self.offset();setTimeout(function(){css(self[0],{'--terminal-height':self.height(),'--terminal-x':offset.left-self_offset.left,'--terminal-y':offset.top-self_offset.top,'--terminal-scroll':self.prop('scrollTop')});// Firefox won't reflow the cursor automatically, so
// hide it briefly then reshow it
cmd_cursor.hide();setTimeout(function(){cmd_cursor.show();},0);},0);if(scroll){self.scroll_to_bottom();}}catch(e1){if(is_function(_settings.exceptionHandler)){try{_settings.exceptionHandler.call(self,e1,'TERMINAL (Flush)');}catch(e2){_settings.exceptionHandler=$.noop;alert_exception('[exceptionHandler]',e2);}}else{alert_exception('[Flush]',e1);}}finally{buffer.clear();}});return self;},// -------------------------------------------------------------
// :: Update the output line - line number can be negative
// -------------------------------------------------------------
update:function update(line,value,options){when_ready(function ready(){if(line<0){line=lines.length()+line;// yes +
}if(!lines.valid_index(line)){self.error('Invalid line number '+line);}else if(value===null){lines.update(line,null);output.find('[data-index='+line+']').remove();}else{value=preprocess_value(value,{update:true,line:line});if(value===false){return self;}unpromise(value,function(value){var ret=prepare_render(value,options);if(ret){value=ret[0];options=ret[1];}options=lines.update(line,value,options);var next=process_line({value:value,index:line,options:options});// process_line can return a promise
// value is function that resolve to promise
unpromise(next,function(){// trigger flush even if next is undefined
self.flush({scroll:false,update:true});});});}});return self;},// -------------------------------------------------------------
// :: convenience method for removing selected line
// -------------------------------------------------------------
remove_line:function remove_line(line){return self.update(line,null);},// -------------------------------------------------------------
// :: return index of last line in case when you need to update
// :: after something is echo on the terminal
// -------------------------------------------------------------
last_index:function last_index(){return lines.length()-1;},// -------------------------------------------------------------
// :: Print data to the terminal output. It can have options
// :: * flush - indicate that arg should be send to DOM
// :: * raw - indicate if it should handle input as html
// :: * finalize - function call with container div
// :: * keepWords - inform how to wrap text
// :: * formatters - inform function if it should use formatters
// ::   on input string - good to prevent XSS when you want
// ::   advanced server side controling of terminal
// :: you can echo: promise, function, strings array or string
// -------------------------------------------------------------
echo:function echo(arg,options){var arg_defined=arguments.length>0;var d=new $.Deferred();function echo(arg){try{var locals=$.extend({flush:true,exec:true,raw:_settings.raw,finalize:$.noop,unmount:$.noop,delay:_settings.execAnimationDelay,ansi:false,typing:false,keepWords:false,invokeMethods:_settings.invokeMethods,onClear:null,formatters:true,allowedAttributes:_settings.allowedAttributes,newline:true},options||{});// finalize function is passed around and invoked
// in terminal::flush after content is added to DOM
(function(finalize){locals.finalize=function(div){if(locals.raw){div.addClass('raw');}if(locals.ansi){div.addClass('ansi');}try{if(is_function(finalize)){finalize.call(self,div);}var $images=div.find('img');$images.each(function(){var self=$(this);var img=new Image();img.onerror=function(){self.replaceWith(use_broken_image);};img.src=this.src;});}catch(e){display_exception(e,'USER:echo(finalize)');finalize=null;}};})(locals.finalize);if(locals.flush){// flush buffer if there was no flush after previous echo
if(!buffer.empty()){self.flush();}}if(fire_event('onBeforeEcho',[arg])===false){return;}if(locals.typing){if(typeof arg!=='string'){return d.reject('echo: Typing animation require string'+' or promise that resolve to string');}if(typeof locals.delay!=='number'||isNaN(locals.delay)){return d.reject('echo: Invalid argument, delay need to'+' be a number');}var p=self.typing('echo',locals.delay,arg,locals);p.then(function(){d.resolve();});return;}var value;if(typeof arg==='function'){value=arg.bind(self);}else if(typeof arg==='undefined'){if(arg_defined){value=String(arg);}else{value='';}}else{var ret=preprocess_value(arg,{});if(ret===false){return self;}value=ret;}if(is_promise(value)){echo_promise=true;}unpromise(value,function(value){if(render(value,locals)){return self;}var index=lines.length();var last_newline=lines.has_newline();if(!last_newline){index--;}if(!locals.newline&&value[value.length-1]==='\n'){// This adjusts the value, so that when it updates or
// refresh the lines list it does the right thing.
value=value.slice(0,-1);locals.newline=true;}var next=process_line({value:value,options:locals,index:index});// queue async functions in echo
if(is_promise(next)){echo_promise=true;}lines.push([value,locals]);unpromise(next,function(){// extended commands should be processed only
// once in echo and not on redraw
if(locals.flush){self.flush();fire_event('onAfterEcho',[arg]);}echo_promise=false;var original=echo_delay;echo_delay=[];for(var i=0;i<original.length;++i){self.echo.apply(self,original[i]);}});});}catch(e){// if echo throw exception we can't use error to
// display that exception
if(is_function(_settings.exceptionHandler)){_settings.exceptionHandler.call(self,e,'TERMINAL (echo)');}else{alert_exception('[Terminal.echo]',e);}}}if(echo_promise){echo_delay.push([arg,options]);}else{echo(arg);}if(options&&options.typing){return d.promise();}return self;},// -------------------------------------------------------------
typing:function typing(type,delay,string,options){var d=new $.Deferred();var settings;var finish;if(_typeof(options)==='object'){finish=options.finalize||$.noop;settings=$.extend({},options,{delay:delay,finalize:done});}else{finish=options||$.noop;settings={delay:delay,finalize:done};}function done(){d.resolve();if(is_function(finish)){finish.apply(self,arguments);}}when_ready(function ready(){if(['prompt','echo','enter'].indexOf(type)>=0){if(type==='prompt'){typed_prompt(string,settings);}else if(type==='echo'){typed_message(string,settings);}else if(type==='enter'){with_prompt(self.get_prompt(),function(prompt){typed_enter(prompt,string,settings);},self);}}else{d.reject('Invalid type only `echo` and `prompt` are supported');}});return d.promise();},// -------------------------------------------------------------
// :: echo red text
// -------------------------------------------------------------
error:function error(message,options){options=$.extend({},options,{raw:false,formatters:false});function format(string){if(typeof string!=='string'){string=String(string);}// quick hack to fix trailing backslash
var str=$.terminal.escape_brackets(string).replace(/\\$/,'&#92;').replace(url_re,']$1[[;;;terminal-error]');return'[[;;;terminal-error]'+str+']';}if(typeof message==='function'){return self.echo(function(){return format(message.call(self));},options);}if(message&&message.then){message.then(function(string){self.echo(format(string));}).catch(make_label_error('Echo Error'));return self;}return self.echo(format(message),options);},// -------------------------------------------------------------
// :: Display Exception on terminal
// -------------------------------------------------------------
exception:function exception(e,label){var message=exception_message(e);if(label){message='&#91;'+label+'&#93;: '+message;}if(message){self.error(message,{finalize:function finalize(div){div.addClass('terminal-exception terminal-message');},keepWords:true});}if(typeof e.fileName==='string'){// display filename and line which throw exeption
self.pause(_settings.softPause);$.get(e.fileName,function(file){var num=e.lineNumber-1;var line=file.split('\n')[num];if(line){self.error('['+e.lineNumber+']: '+line);}self.resume();},'text');}if(e.stack){var stack=$.terminal.escape_brackets(e.stack);var output=stack.split(/\n/g).map(function(trace){// nested formatting will handle urls but that formatting
// can be removed - this code was created before
// that formatting existed (see commit ce01c3f5)
return'[[;;;terminal-error]'+trace.replace(url_re,function(url){return']'+url+'[[;;;terminal-error]';})+']';}).join('\n');self.echo(output,{finalize:function finalize(div){div.addClass('terminal-exception terminal-stack-trace');},formatters:false});}return self;},// -------------------------------------------------------------
// :: Scroll Div that holds the terminal
// -------------------------------------------------------------
scroll:function scroll(amount){var pos;amount=Math.round(amount);if(self.prop){// work with jQuery > 1.6
if(amount>self.prop('scrollTop')&&amount>0){self.prop('scrollTop',0);}pos=self.prop('scrollTop');self.scrollTop(pos+amount);}else{if(amount>self.prop('scrollTop')&&amount>0){self.prop('scrollTop',0);}pos=self.prop('scrollTop');self.scrollTop(pos+amount);}return self;},// -------------------------------------------------------------
// :: Exit all interpreters and logout. The function will throw
// :: exception if there is no login provided
// -------------------------------------------------------------
logout:function logout(local){if(in_login){throw new Error(sprintf(strings().notWhileLogin,'logout'));}when_ready(function ready(){if(local){var login=logins.pop();self.set_token(undefined,true);self.login.apply(self,login);}else if(interpreters.size()===1&&self.token()){self.logout(true);}else{while(interpreters.size()>1){// pop will call global_logout that will call login
// and size will be > 0; this is workaround the problem
if(self.token()){self.logout(true).pop().pop();}else{self.pop();}}}});return self;},// -------------------------------------------------------------
// :: Function returns the token returned by callback function
// :: in login function. It does nothing (return undefined) if
// :: there is no login
// -------------------------------------------------------------
token:function token(local){return storage.get(self.prefix_name(local)+'_token');},// -------------------------------------------------------------
// :: Function sets the token to the supplied value. This function
// :: works regardless of wherer settings.login is supplied
// -------------------------------------------------------------
set_token:function set_token(token,local){var name=self.prefix_name(local)+'_token';if(typeof token==='undefined'){storage.remove(name);}else{storage.set(name,token);}return self;},// -------------------------------------------------------------
// :: Function get the token either set by the login method or
// :: by the set_token method.
// -------------------------------------------------------------
get_token:function get_token(local){return self.token(local);},// -------------------------------------------------------------
// :: Function return Login name entered by the user
// -------------------------------------------------------------
login_name:function login_name(local){return storage.get(self.prefix_name(local)+'_login');},// -------------------------------------------------------------
// :: Function returns the name of current interpreter
// -------------------------------------------------------------
name:function name(){return interpreters.top().name;},// -------------------------------------------------------------
// :: Function return prefix name for login/token
// -------------------------------------------------------------
prefix_name:function prefix_name(local){var name=(_settings.name?_settings.name+'_':'')+terminal_id;if(local&&interpreters.size()>1){var local_name=interpreters.map(function(intrp){return intrp.name||'';}).slice(1).join('_');if(local_name){name+='_'+local_name;}}return name;},// -------------------------------------------------------------
// :: wrapper for common use case
// -------------------------------------------------------------
read:function read(message,success,cancel){var options;if(_typeof(arguments[1])==='object'){options=$.extend({typing:false,delay:_settings.execAnimationDelay,success:$.noop,cancel:$.noop},arguments[1]);}else{options={typing:false,success:success||$.noop,cancel:cancel||$.noop};}if(options.typing){var prompt=self.get_prompt();options.typing=false;return self.typing('prompt',options.delay,message).then(function(){return self.set_prompt(prompt).read(message,options);});}// return from read() should not pause terminal
force_awake=true;var defer=jQuery.Deferred();var read=false;self.push(function(string){read=true;defer.resolve(string);if(is_function(options.success)){options.success(string);}self.pop();if(_settings.history){command_line.history().enable();}},{name:'read',history:false,prompt:message||'',onExit:function onExit(){if(!read){defer.reject();if(is_function(options.cancel)){options.cancel();}}}});if(_settings.history){command_line.history().disable();}return defer.promise();},// -------------------------------------------------------------
// :: Push a new interenter on the Stack
// -------------------------------------------------------------
push:function push(interpreter,options){cmd_ready(function ready(){options=options||{};var defaults={infiniteLogin:false};var push_settings=$.extend({},defaults,options);if(!push_settings.name&&prev_command){// name the interpreter from last command
push_settings.name=prev_command.name;}if(push_settings.prompt===undefined){push_settings.prompt=(push_settings.name||'>')+' ';}// names.push(options.name);
var top=interpreters.top();if(top){top.mask=command_line.mask();}var was_paused=_paused;function init(){fire_event('onPush',[top,interpreters.top()]);prepare_top_interpreter();}//self.pause();
make_interpreter(interpreter,options.login,function(ret){// result is object with interpreter and completion properties
interpreters.push($.extend({},ret,push_settings));if(push_settings.completion===true){if($.isArray(ret.completion)){interpreters.top().completion=ret.completion;}else if(!ret.completion){interpreters.top().completion=false;}}if(push_settings.login){var error;var type=get_type(push_settings.login);if(type==='function'){error=push_settings.infiniteLogin?$.noop:self.pop;self.login(push_settings.login,push_settings.infiniteLogin,init,error);}else if(get_type(interpreter)==='string'&&type==='string'||type==='boolean'){error=push_settings.infiniteLogin?$.noop:self.pop;self.login(make_json_rpc_login(interpreter,push_settings.login),push_settings.infiniteLogin,init,error);}}else{init();}if(!was_paused&&self.enabled()){self.resume();}});});return self;},// -------------------------------------------------------------
// :: Remove the last interpreter from the Stack
// -------------------------------------------------------------
pop:function pop(string,silent){if(string!==undefined){echo_command(string);}var token=self.token(true);var top;if(interpreters.size()===1){top=interpreters.top();if(_settings.login){if(!silent){fire_event('onPop',[top,null]);}global_logout();fire_event('onExit');}else{self.error(strings().canExitError);}}else{if(token){clear_loging_storage();}var current=interpreters.pop();top=interpreters.top();prepare_top_interpreter();// restore mask
self.set_mask(top.mask);if(!silent){fire_event('onPop',[current,top]);}// we check in case if you don't pop from password interpreter
if(in_login&&self.get_prompt()!==strings().login+': '){in_login=false;}if(is_function(current.onExit)){try{current.onExit.call(self,self);}catch(e){current.onExit=$.noop;display_exception(e,'onExit');}}}return self;},// -------------------------------------------------------------
// :: Change terminal option(s) at runtime
// -------------------------------------------------------------
option:function option(object_or_name,value){if(typeof value==='undefined'){if(typeof object_or_name==='string'){return _settings[object_or_name];}else if(_typeof(object_or_name)==='object'){$.each(object_or_name,function(key,value){_settings[key]=value;});}}else{_settings[object_or_name]=value;if(object_or_name.match(/^num(Chars|Rows)$/)){redraw();}}return self;},// -------------------------------------------------------------
// :: invoke keydown shorcut
// -------------------------------------------------------------
invoke_key:function invoke_key(shortcut){command_line.invoke_key(shortcut);return self;},// -------------------------------------------------------------
// :: change terminal keymap at runtime
// -------------------------------------------------------------
keymap:function keymap(_keymap2,fn){if(arguments.length===0){return command_line.keymap();}if(typeof fn==='undefined'){if(typeof _keymap2==='string'){return command_line.keymap(_keymap2);}else if($.isPlainObject(_keymap2)){// argument is an object
_keymap2=$.extend({},terminal_init_keymap,$.omap(_keymap2||{},function(key,fn){if(!terminal_init_keymap[key]){return fn.bind(self);}return function(e,original){// new keymap function will get default as 2nd arg
return fn.call(self,e,function(){return terminal_init_keymap[key](e,original);});};}));command_line.keymap(null).keymap(_keymap2);}}else if(typeof fn==='function'){var key=_keymap2;if(!terminal_init_keymap[key]){command_line.keymap(key,fn.bind(self));}else{command_line.keymap(key,function(e,original){return fn.call(self,e,function(){return terminal_init_keymap[key](e,original);});});}}},// -------------------------------------------------------------
// :: Return how deep you are in nested interpreters
// -------------------------------------------------------------
level:function level(){return interpreters.size();},// -------------------------------------------------------------
// :: Reinitialize the terminal
// -------------------------------------------------------------
reset:function reset(){when_ready(function ready(){self.clear();while(interpreters.size()>1){interpreters.pop();}initialize();});return self;},// -------------------------------------------------------------
// :: Remove all local storage left by terminal, it will not
// :: logout you until you refresh the browser
// -------------------------------------------------------------
purge:function purge(){when_ready(function ready(){var prefix=self.prefix_name()+'_';var names=storage.get(prefix+'interpreters');if(names){$.each(JSON.parse(names),function(_,name){storage.remove(name+'_commands');storage.remove(name+'_token');storage.remove(name+'_login');});}command_line.purge();storage.remove(prefix+'interpreters');});return self;},// -------------------------------------------------------------
// :: Remove all events and DOM nodes left by terminal, it will
// :: not purge the terminal so you will have the same state
// :: when you refresh the browser
// -------------------------------------------------------------
destroy:function destroy(){when_ready(function ready(){command_line.destroy().remove();self.resizer('unbind');self.touch_scroll('unbind');font_resizer.resizer('unbind').remove();$(document).unbind('.terminal_'+self.id());$(window).unbind('.terminal_'+self.id());self.unbind('click wheel mousewheel mousedown mouseup');self.removeData('terminal').removeClass('terminal').unbind('.terminal');if(_settings.width){self.css('width','');}if(_settings.height){self.css('height','');}$(window).off('blur',blur_terminal).off('focus',focus_terminal);self.find('.terminal-fill, .terminal-font').remove();self.stopTime();terminals.remove(terminal_id);if(visibility_observer){if(visibility_observer.unobserve){visibility_observer.unobserve(self[0]);}else{clearInterval(visibility_observer);}}var scroll_marker=self.find('.terminal-scroll-marker');if(is_bottom_observer){is_bottom_observer.unobserve(scroll_marker[0]);}scroll_marker.remove();if(mutation_observer){mutation_observer.disconnect();}if(!terminals.length()){$(window).off('hashchange');}if(is_mobile){self.off(['touchstart.terminal','touchmove.terminal','touchend.terminal'].join(' '));}output.remove();wrapper.remove();if(body_terminal){var $body=$(body_terminal);if($body.attr('class')==='full-screen-terminal'){$body.removeAttr('class');}else{$body.removeClass('full-screen-terminal');}self.remove();}defunct=true;});return self;},// -------------------------------------------------------------
// :: ref: https://stackoverflow.com/a/18927969/387194
// -------------------------------------------------------------
scroll_to:function scroll_to(elem){var scroll=self.scrollTop()-self.offset().top+$(elem).offset().top;self.scrollTop(scroll);return self;},// -------------------------------------------------------------
scroll_to_bottom:function scroll_to_bottom(){var scrollHeight;if(self.prop){scrollHeight=self.prop('scrollHeight');}else{scrollHeight=self.attr('scrollHeight');}self.scrollTop(scrollHeight);return self;},// -------------------------------------------------------------
// :: return true if terminal div or body is at the bottom
// :: is use scrollBottomOffset option as margin for the check
// -------------------------------------------------------------
is_bottom:function is_bottom(){if(_settings.scrollBottomOffset===-1){return false;}else if(typeof is_bottom_detected==='boolean'){return is_bottom_detected;}else{var scroll_height,scroll_top,height;scroll_height=self[0].scrollHeight;scroll_top=self[0].scrollTop;height=self[0].offsetHeight;var limit=scroll_height-_settings.scrollBottomOffset;return scroll_top+height>limit;}},// -------------------------------------------------------------
// :: create terminal object clone, used by pipe
// -------------------------------------------------------------
duplicate:function duplicate(){var copy=$(self);return $.extend(copy,public_api);},// -------------------------------------------------------------
// :: return output flush buffer
// -------------------------------------------------------------
get_output_buffer:function get_output_buffer(options){var settings=$.extend({html:false},options);var result=[];var append=false;buffer.forEach(function(data){if(data){if(is_function(data.finalize)){append=!data.newline;}else{var output;if(settings.html){output=data.line;}else{output=data.raw;}if(append){var last=result.length-1;result[last]+=output;}else{result.push(output);}}}});if(settings.html){return result.map(function(line){return'<div>'+line+'</div>';}).join('\n');}return result.join('\n');},// -------------------------------------------------------------
// :: clear flush buffer
// -------------------------------------------------------------
clear_buffer:function clear_buffer(){buffer.clear();return self;}},function(name,fun){// wrap all functions and display execptions
return function(){if(defunct){if(!_settings.exceptionHandler){throw new $.terminal.Exception(strings().defunctTerminal);}}try{return fun.apply(self,[].slice.apply(arguments));}catch(e){// exec catch by command (resume call exec)
if(name!=='exec'&&name!=='resume'){display_exception(e,e.type||'TERMINAL',true);}if(!_settings.exceptionHandler){throw e;}}};});$.extend(self,public_api);// -----------------------------------------------------------------
// :: INIT CODE
// -----------------------------------------------------------------
if(self.length===0){var msg=sprintf(strings().invalidSelector);throw new $.terminal.Exception(msg);}self.data('terminal',self);// synchronize the echo calls (used for async functions) that need
// to be called in order
var echo_delay=[];var echo_promise=false;// var names = []; // stack if interpreter names
var prev_command;// used for name on the terminal if not defined
var prev_exec_cmd;var tab_count=0;// for tab completion
var output;// .terminal-output jquery object
var terminal_id=terminals.length();var force_awake=false;// flag used to don't pause when user return read() call
var num_chars;// numer of chars in line
var num_rows;// number of lines that fit without scrollbar
var command;// for tab completion
var logins=new Stack();// stack of logins
var command_queue=new DelayQueue();var animating=false;// true on typing animation
var init_queue=new DelayQueue();var when_ready=ready(init_queue);var cmd_ready=ready(command_queue);var is_bottom_detected;var is_bottom_observer;var in_login=false;// some Methods should not be called when login
// TODO: Try to use mutex like counter for pause/resume
var onPause=$.noop;// used to indicate that user call pause onInit
var old_width,old_height;var delayed_commands=[];// used when exec commands while paused
var _settings=$.extend({},$.terminal.defaults,{name:self.selector,exit:!!(options&&options.login||!options)},options||{});if(typeof _settings.width==='number'){self.width(_settings.width);}if(typeof _settings.height==='number'){self.height(_settings.height);}var char_size=get_char_size(self);// this is needed when terminal have selector with --size that is not
// bare .terminal so fake terminal will not get the proper size #602
var need_char_size_recalculate=!terminal_ready(self);// so it's the same as in TypeScript definition for options
delete _settings.formatters;// used to throw error when calling methods on destroyed terminal
var defunct=false;// ---------------------------------------------------------------------
// :: FormatBuffer is used to to buffer the lines that echoed
// :: it have append function that have 2 options raw and finalize
// :: raw - will not encode the string and finalize if a function that
// :: will have div container of the line as first argument
// :: actuall echo to the terminal happen when calling flush
// ---------------------------------------------------------------------
var buffer=new FormatBuffer(function(options){return{linksNoReferrer:_settings.linksNoReferrer,linksNoFollow:_settings.linksNoFollow,anyLinks:_settings.anyLinks,charWidth:char_size.width,useCache:_settings.useCache,escape:false,allowedAttributes:options.allowedAttributes||[]};});var lines=new OutputLines(function(){return _settings;});var storage=new StorageHelper(_settings.memory);var _enabled2=_settings.enabled;var _frozen=false;var _paused=false;var autologin=true;// set to false if onBeforeLogin return false
var interpreters;var command_line;var old_enabled;var visibility_observer;var mutation_observer;// backward compatibility
if(_settings.ignoreSystemDescribe===true){_settings.describe=false;}// register ajaxSend for cancel requests on CTRL+D
$(document).bind('ajaxSend.terminal_'+self.id(),function(e,xhr){requests.push(xhr);});var wrapper=$('<div class="terminal-wrapper"/>').appendTo(self);$(broken_image).hide().appendTo(wrapper);var font_resizer=$('<div class="terminal-font">&nbsp;</div>').appendTo(self);var fill=$('<div class="terminal-fill"/>').appendTo(self);output=$('<div>').addClass('terminal-output').attr('role','log').appendTo(wrapper);self.addClass('terminal');// before login event
if(_settings.login&&fire_event('onBeforeLogin')===false){autologin=false;}// create json-rpc authentication function
var base_interpreter;if(typeof init_interpreter==='string'){base_interpreter=init_interpreter;}else if(is_array(init_interpreter)){// first JSON-RPC
for(var i=0,len=init_interpreter.length;i<len;++i){if(typeof init_interpreter[i]==='string'){base_interpreter=init_interpreter[i];break;}}}var global_login_fn;if(is_function(_settings.login)){global_login_fn=_settings.login;}else if(base_interpreter&&(typeof _settings.login==='string'||_settings.login===true)){global_login_fn=make_json_rpc_login(base_interpreter,_settings.login);}terminals.append(self);function focus_terminal(){if(old_enabled){self.focus();self.scroll_to_bottom();}}// -------------------------------------------------------------------------------
function blur_terminal(){old_enabled=_enabled2;self.disable().find('.cmd textarea').trigger('blur',[true]);}// -------------------------------------------------------------------------------
function stringify_value(value){if(is_function(value)){value=value();}if(value&&is_function(value.then)){return value.then(stringify_value);}if(get_type(value)!=='string'){if(is_function(_settings.parseObject)){var ret=_settings.parseObject(value);if(get_type(ret)==='string'){value=ret;}}else if(is_array(value)){value=$.terminal.columns(value,self.cols(),_settings.tabs);}else{value=String(value);}}return value;}// -------------------------------------------------------------------------------
function context_callback_proxy(fn){if(fn.proxy){return fn;}var wrapper=function wrapper(callback){return fn.call(self,callback,self);};wrapper.proxy=true;return wrapper;}// -------------------------------------------------------------------------------
// paste event is not testable in node
// istanbul ignore next
function paste_event(e){e=e.originalEvent;// we don't care about browser that don't support clipboard data
// those browser simple will not have this feature normal paste
// is cross-browser and it's handled by cmd plugin
function is_type(item,type){return item.type.indexOf(type)!==-1;}function echo_image(image){self.echo('<img src="'+image+'"/>',{raw:true});}function data_uri(blob){var URL=window.URL||window.webkitURL;return URL.createObjectURL(blob);}function echo(object,ignoreEvents){if(!ignoreEvents){var event={target:self};if(typeof object==='string'){event.text=object;}else if(object instanceof Blob){event.image=data_uri(object);}var ret=fire_event('onPaste',[event]);if(ret){if(is_function(ret.then||ret.done)){return(ret.then||ret.done).call(ret,function(ret){echo(ret,true);});}else{echo(ret,true);}}else if(ret!==false){echo(event.image||event.text,true);}}else if(object instanceof Blob){echo_image(data_uri(object));}else if(typeof object==='string'){if(object.match(/^(data:|blob:)/)){echo_image(object);}else{self.insert(object);}}}if(e.clipboardData){if(self.enabled()){var items=e.clipboardData.items;if(items){for(var i=0;i<items.length;i++){if(is_type(items[i],'image')&&_settings.pasteImage){var blob=items[i].getAsFile();echo(blob);}else if(is_type(items[i],'text/plain')){items[i].getAsString(function(text){echo(text.replace(/\r/g,''));});}}}else if(e.clipboardData.getData){var text=e.clipboardData.getData('text/plain');echo(text.replace(/\r/g,''));}return false;}}}$(document).on('paste.terminal_'+self.id(),paste_event);var terminal_init_keymap=$.extend({},keymap,$.omap(_settings.keymap||{},function(key,fn){if(!keymap[key]){return fn.bind(self);}return function(e,original){// new keymap function will get default as 2nd argument
return fn.call(self,e,function(){return keymap[key](e,original);});};}));make_interpreter(init_interpreter,_settings.login,function(interpreter){if(_settings.completion&&typeof _settings.completion!=='boolean'||!_settings.completion){// overwrite interpreter completion by global setting #224
// we use string to indicate that it need to be taken from settings
// so we are able to change it using option API method
interpreter.completion='settings';}var prompt=_settings.prompt;if(is_function(prompt)){prompt=context_callback_proxy(prompt);}interpreters=new Stack($.extend({},_settings.extra,{name:_settings.name,prompt:prompt,keypress:_settings.keypress,keydown:_settings.keydown,resize:_settings.onResize,greetings:_settings.greetings,mousewheel:_settings.mousewheel,history:_settings.history,keymap:terminal_init_keymap},interpreter));// CREATE COMMAND LINE
command_line=$('<div/>').appendTo(wrapper).cmd({tabindex:_settings.tabindex,mobileDelete:_settings.mobileDelete,mobileIngoreAutoSpace:_settings.mobileIngoreAutoSpace,prompt:global_login_fn?false:prompt,history:_settings.memory?'memory':_settings.history,historyFilter:_settings.historyFilter,historySize:_settings.historySize,caseSensitiveSearch:_settings.caseSensitiveSearch,onPaste:_settings.onPaste,width:'100%',enabled:false,charWidth:char_size.width,keydown:key_down,keymap:terminal_init_keymap,clickTimeout:_settings.clickTimeout,holdTimeout:_settings.holdTimeout,holdRepeatTimeout:_settings.holdRepeatTimeout,repeatTimeoutKeys:_settings.repeatTimeoutKeys,allowedAttributes:_settings.allowedAttributes,keypress:key_press,tabs:_settings.tabs,onPositionChange:function onPositionChange(){var args=[].slice.call(arguments);make_cursor_visible();fire_event('onPositionChange',args);},onCommandChange:function onCommandChange(command){// resize is not triggered when insert called just after init
//  and scrollbar appear
if(old_width!==fill.width()){// resizer handler will update old_width
self.resizer();}fire_event('onCommandChange',[command]);make_cursor_visible();},commands:commands});function disable(e){if(is_mobile){return;}e=e.originalEvent;if(e){// e.terget is body when click outside of context menu to close it
// even if you click on terminal
var node=document.elementFromPoint(e.clientX,e.clientY);if(!$(node).closest('.terminal').length&&self.enabled()){// we only need to disable when click outside of terminal
// click on other terminal is handled by focus event
self.disable();}}}self.oneTime(100,function(){$(document).bind('click.terminal_'+self.id(),disable).bind('contextmenu.terminal_'+self.id(),disable);});var $win=$(window);// cordova application, if keyboard was open and we resume, it will be
// closed so we need to disable terminal so you can enable it with tap
document.addEventListener("resume",function(){self.disable();});// istanbul ignore next
if(is_mobile){(function(){self.addClass('terminal-mobile');var start;var move;var enabled;var SENSITIVITY=3;var clip=command_line.clip();var HOLD_TIME=200;var timer;clip.$node.off('touchstart.cmd');self.on('touchstart.terminal',function(e){e=e.originalEvent;window.touch_event=e;if(e.target.tagName.toLowerCase()==='a'){return;}if(!_frozen&&e.touches.length===1){enabled=self.enabled();var point=e.touches[0];start={x:point.clientX,y:point.clientY};timer=setTimeout(function(){start=null;},HOLD_TIME);}}).on('touchmove.terminal',function(e){if(e.touches.length===1&&start){var point=e.touches[0];var diff_x=Math.abs(point.clientX-start.x);var diff_y=Math.abs(point.clientY-start.y);if(diff_x>SENSITIVITY||diff_y>SENSITIVITY){move=true;}}}).on('touchend.terminal',function(){if(start){clearTimeout(timer);if(!move){if(!enabled){clip.focus();self.focus();}else{clip.blur();self.disable();}}}move=false;start=null;});})();}else{// work weird on mobile
$win.on('focus.terminal_'+self.id(),focus_terminal).on('blur.terminal_'+self.id(),blur_terminal);// context is used to check if terminal should not scroll to bottom
// after right click on  e.g. img, canvas, a and then click to hide
// the menu. The problem is that right click on those elements don't
// move the textarea to show proper context menu like save as on images
// or open on links. See #644 bug
var was_ctx_event;// detect mouse drag
(function(){var count=0;var $target;var name='click_'+self.id();var textarea=self.find('.cmd textarea');function click(){if($target.is('.terminal')||$target.is('.terminal-wrapper')){var len=self.get_command().length;self.set_position(len);}else if($target.closest('.cmd-prompt').length){self.set_position(0);}if(!textarea.is(':focus')){textarea.focus();}reset();}function reset(){count=0;$target=null;}var ignore_elements='.terminal-output textarea,'+'.terminal-output input';self.mousedown(function(e){if(!scrollbar_event(e,fill)){$target=$(e.target);}}).mouseup(function(){if(was_ctx_event){was_ctx_event=false;return;}if($target&&$target.closest(ignore_elements).length){if(_enabled2){self.disable();}}else if(get_selected_html()===''&&$target){if(++count===1){if(!_frozen){if(!_enabled2){self.focus();self.scroll_to_bottom();}else{var timeout=_settings.clickTimeout;self.oneTime(timeout,name,click);return;}}}else{self.stopTime(name);}}reset();}).dblclick(function(){reset();self.stopTime(name);});})();(function(){var $clip=command_line.clip().$node;function is_context_event(e){return e.type==='mousedown'&&e.buttons===2||e.type==='contextmenu';}var event_name;if('oncontextmenu'in window){event_name='contextmenu.terminal';}else{event_name='mousedown.terminal';}self.on(event_name,function(e){was_ctx_event=get_selected_html()===''&&is_context_event(e);if(was_ctx_event){var $target=$(e.target);if($target.is('img,value,audio,object,canvas,a')){return;}if(!self.enabled()){self.enable();}var cmd_offset=command_line.offset();var cmd_rect=command_line[0].getBoundingClientRect();var self_offset=self.offset();var top_limit=self_offset.top-cmd_offset.top;var top=Math.max(e.pageY-cmd_offset.top-20,top_limit);var left=e.pageX-cmd_offset.left-20;var height=4*14;var width=5*14;var rect=self[0].getBoundingClientRect();// we need width without scrollbar
var content_width=fill.outerWidth();// fix jumping when click near bottom or left edge #592
var diff_h=top+cmd_rect.top+height;diff_h=diff_h-rect.height-rect.top;var diff_w=left+cmd_rect.left+width;// in Chrome scrollbar is added even when width
// of textarea is smaller, adding 1px solved the issue
diff_w=diff_w-content_width-rect.left;if(diff_h>0){height-=Math.ceil(diff_h);}if(diff_w>0){width-=Math.ceil(diff_w);}$clip.attr('style',['left:'+left+'px !important','top:'+top+'px !important','width:'+width+'px !important','height:'+height+'px !important'].join(';'));if(!$clip.is(':focus')){$clip.focus();}self.stopTime('textarea');self.oneTime(100,'textarea',function(){var props={left:'',top:'',width:'',height:''};if(!is_css_variables_supported){var in_line=self.find('.cmd .cmd-cursor-line').prevUntil('.cmd-prompt').length;props.top=in_line*14+'px';}$clip.css(props);});self.stopTime('selection');self.everyTime(20,'selection',function(){if($clip[0].selection!==$clip[0].value){if(get_textarea_selection($clip[0])){clear_textarea_selection($clip[0]);select(self.find('.terminal-output')[0],self.find('.cmd div:last-of-type')[0]);self.stopTime('selection');}}});}});})();self.on('scroll',function(){var $textarea=self.find('textarea');var rect=self[0].getBoundingClientRect();var height=self[0].scrollHeight;var scrollTop=self.scrollTop();var diff=height-(scrollTop+rect.height);// if scrolled to bottom top need to be aligned with cursor line
// done by CSS file using css variables
if(diff===0){$textarea.css('top','');}else{$textarea.css('top',-diff);}});}self.on('click','a',function(e){var $this=$(this);if($this.closest('.terminal-exception').length){var href=$this.attr('href');if(href.match(/:[0-9]+$/)){// display line if specified
e.preventDefault();print_line(href,self.cols());}}// refocus because links have tabindex in case where user want
// tab change urls, we can ignore this function on click
if(_enabled2){self.find('.cmd textarea').focus();}});function calculate_char_size(){var width=char_size.width;char_size=get_char_size(self);if(width!==char_size.width){command_line.option('charWidth',char_size.width).refresh();}}resize();function resize(){if(self.is(':visible')){var width=fill.width();var height=fill.height();if(need_char_size_recalculate){need_char_size_recalculate=!terminal_ready(self);calculate_char_size();}// prevent too many calculations in IE
if(old_height!==height||old_width!==width){self.resize();}old_height=height;old_width=width;}}function create_resizers(){var options={prefix:'terminal-'};self.resizer('unbind').resizer(resize,options);font_resizer.resizer('unbind').resizer(function(){calculate_char_size();self.resize();},options);}function bottom_detect(intersections){is_bottom_detected=intersections[0].intersectionRatio===1;}function create_bottom_detect(){if(window.IntersectionObserver){var top=$('<div class="terminal-scroll-marker"/>').appendTo(self);var marker=top;if(_settings.scrollBottomOffset!==-1){marker=$('<div/>').css({height:_settings.scrollBottomOffset}).appendTo(top);}is_bottom_observer=new IntersectionObserver(bottom_detect,{root:self[0]});is_bottom_observer.observe(marker[0]);}}// this observer can be added imedietely even if terminal is not in the DOM
// because both of the elements (root and target) are in same fragment
create_bottom_detect();if(self.is(':visible')){create_resizers();}function observe_visibility(){if(visibility_observer){if(visibility_observer.unobserve){visibility_observer.unobserve(self[0]);}else{clearInterval(visibility_observer);}}var was_enabled=self.enabled();var visible=self.is(':visible');if(was_enabled&&!visible){self.disable();}if(visible){create_resizers();}else{// hide terminal content until it's resized (and num chars calculated)
wrapper.css('visibility','hidden');}function visibility_checker(){if(self.is(':visible')&&!visible){visible=true;create_resizers();calculate_char_size();resize();if(was_enabled){self.enable();}wrapper.css('visibility','');}else if(visible&&!self.is(':visible')){visible=false;was_enabled=$.terminal.active()===self&&self.enabled();self.disable();wrapper.css('visibility','hidden');}}if(window.IntersectionObserver&&self.css('position')!=='fixed'){visibility_observer=new IntersectionObserver(visibility_checker,{root:null});visibility_observer.observe(self[0]);}else{visibility_observer=setInterval(visibility_checker,100);}}var in_dom=!!self.closest('body').length;var MutationObsrv=window.MutationObserver||window.WebKitMutationObserver;if(MutationObsrv){mutation_observer=new MutationObsrv(function(){if(self.closest('body').length){if(!in_dom){self.scroll_to_bottom();// this observer need to be added when terminal is in the DOM
observe_visibility();resize();}in_dom=true;}else if(in_dom){in_dom=false;}});mutation_observer.observe(document.body,{childList:true});}if(in_dom){// check if element is in the DOM if not running IntersectionObserver
// don't make sense
observe_visibility();}command_queue.resolve();// touch devices need touch event to get virtual keyboard
if(_enabled2&&self.is(':visible')&&!is_mobile){self.focus(undefined,true);}else{self.disable();}// -------------------------------------------------------------
// Run Login
if(is_function(global_login_fn)){self.login(global_login_fn,true,initialize);}else{initialize();}// -------------------------------------------------------------
// :: helper
function exec_spec(spec,options){var terminal=terminals.get()[spec[0]];// execute if belong to this terminal
var defer=$.Deferred();if(terminal&&terminal_id===terminal.id()){if(!spec[2]){defer.resolve();return defer.promise();}else if(_paused){resume_callbacks.push(function(){return terminal.exec(spec[2],options).done(function(){terminal.save_state(spec[2],true,spec[1]);defer.resolve();});});return defer.promise();}else{return terminal.exec(spec[2],options).done(function(){terminal.save_state(spec[2],true,spec[1]);});}}}// exec from hash called in each terminal instance
if(_settings.execHash){if(location.hash){// wait until login is initialized
setTimeout(function(){try{var hash=location.hash.replace(/^#/,'');// yes no var - local inside terminal
hash_commands=JSON.parse(decodeURIComponent(hash));if(!hash.match(/\[/)){// fix the hash to look like array if it's not
replace_hash(hash_commands);}var i=0;var options={typing:_settings.execAnimation,delay:_settings.execAnimationDelay};(function recur(){var spec=hash_commands[i++];if(spec){exec_spec(spec,options).done(recur);}else{change_hash=true;}})();// */
}catch(e){// invalid json - ignore
}});}else{change_hash=true;}}else{change_hash=true;// if enabled later
}// change_hash = true; // exec can now change hash
// -------------------------------------------------------------
/* istanbul ignore next */(function(){var shift=false;$(document).bind('keydown.terminal_'+self.id(),function(e){if(e.shiftKey){shift=true;}}).bind('keyup.terminal_'+self.id(),function(e){// in Google Chromium/Linux shiftKey is false
if(e.shiftKey||e.which===16){shift=false;}});// this could work without calling scroll on wheel event but we
// need it for cases where you have mouse wheel work differently
// like with less command that scroll text
function mousewheel(event,delta){if(!shift){var interpreter=interpreters.top();var ret;if(is_function(interpreter.mousewheel)){ret=interpreter.mousewheel(event,delta,self);}else if(is_function(_settings.mousewheel)){ret=_settings.mousewheel(event,delta,self);}if(ret===true){return;}if((have_scrollbar()||ret===false)&&!event.ctrlKey){event.stopPropagation();event.preventDefault();}if(ret===false){return false;}if(delta>0){self.scroll(-40);}else{self.scroll(40);}}}if($.event.special.mousewheel){// we keep mousewheel plugin just in case
self.on('mousewheel',mousewheel);}else{// detection take from:
// https://developer.mozilla.org/en-US/docs/Web/Events/wheel
var event;var div=document.createElement("div");if("onwheel"in div){event="wheel";// Modern browsers support "wheel"
}else if(document.onmousewheel!==undefined){// Webkit and IE support at least "mousewheel"
event="mousewheel";}else{// let's assume that remaining browsers are older Firefox
event="DOMMouseScroll";}div=null;self.on(event,function(e){var delta;if(event==='mousewheel'){delta=-1/40*e.originalEvent.wheelDelta;}else{delta=e.originalEvent.deltaY||e.originalEvent.detail;}mousewheel(e,-delta);});}self.touch_scroll(function(event){var delta=event.current.clientY-event.previous.clientY;var ret;var interpreter=interpreters.top();if(is_function(interpreter.touchscroll)){ret=interpreter.touchscroll(event,delta,self);}else if(is_function(_settings.touchscroll)){ret=_settings.touchscroll(event,delta,self);}css(self[0],{'--terminal-scroll':self.prop('scrollTop')});if(ret===true){return;}return false;});})();});// make_interpreter
return self;};// terminal plugin
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "d9e2":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-unused-vars -- required for functions `.length` */
var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var apply = __webpack_require__("2ba4");
var wrapErrorConstructorWithCause = __webpack_require__("e5cb");

var WEB_ASSEMBLY = 'WebAssembly';
var WebAssembly = global[WEB_ASSEMBLY];

var FORCED = Error('e', { cause: 7 }).cause !== 7;

var exportGlobalErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  var O = {};
  O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
  $({ global: true, constructor: true, arity: 1, forced: FORCED }, O);
};

var exportWebAssemblyErrorCauseWrapper = function (ERROR_NAME, wrapper) {
  if (WebAssembly && WebAssembly[ERROR_NAME]) {
    var O = {};
    O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED);
    $({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O);
  }
};

// https://tc39.es/ecma262/#sec-nativeerror
// https://github.com/tc39/proposal-error-cause
exportGlobalErrorCauseWrapper('Error', function (init) {
  return function Error(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('EvalError', function (init) {
  return function EvalError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('RangeError', function (init) {
  return function RangeError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('ReferenceError', function (init) {
  return function ReferenceError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('SyntaxError', function (init) {
  return function SyntaxError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('TypeError', function (init) {
  return function TypeError(message) { return apply(init, this, arguments); };
});
exportGlobalErrorCauseWrapper('URIError', function (init) {
  return function URIError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('CompileError', function (init) {
  return function CompileError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('LinkError', function (init) {
  return function LinkError(message) { return apply(init, this, arguments); };
});
exportWebAssemblyErrorCauseWrapper('RuntimeError', function (init) {
  return function RuntimeError(message) { return apply(init, this, arguments); };
});


/***/ }),

/***/ "d9f5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var IS_PURE = __webpack_require__("c430");
var DESCRIPTORS = __webpack_require__("83ab");
var NATIVE_SYMBOL = __webpack_require__("04f8");
var fails = __webpack_require__("d039");
var hasOwn = __webpack_require__("1a2d");
var isPrototypeOf = __webpack_require__("3a9b");
var anObject = __webpack_require__("825a");
var toIndexedObject = __webpack_require__("fc6a");
var toPropertyKey = __webpack_require__("a04b");
var $toString = __webpack_require__("577e");
var createPropertyDescriptor = __webpack_require__("5c6c");
var nativeObjectCreate = __webpack_require__("7c73");
var objectKeys = __webpack_require__("df75");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertyNamesExternal = __webpack_require__("057f");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");
var definePropertiesModule = __webpack_require__("37e8");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var defineBuiltIn = __webpack_require__("cb2d");
var defineBuiltInAccessor = __webpack_require__("edd0");
var shared = __webpack_require__("5692");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");
var uid = __webpack_require__("90e3");
var wellKnownSymbol = __webpack_require__("b622");
var wrappedWellKnownSymbolModule = __webpack_require__("e538");
var defineWellKnownSymbol = __webpack_require__("e065");
var defineSymbolToPrimitive = __webpack_require__("57b9");
var setToStringTag = __webpack_require__("d44e");
var InternalStateModule = __webpack_require__("69f3");
var $forEach = __webpack_require__("b727").forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError = global.TypeError;
var QObject = global.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    defineBuiltInAccessor(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "da84":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || this || Function('return this')();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "db4f":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "db91":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("56b3"));
  else {}
})(function(CodeMirror) {
  "use strict";

  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b");
  }

  var wordOperators = wordRegexp(["and", "or", "not", "is"]);
  var commonKeywords = ["as", "assert", "break", "class", "continue",
                        "def", "del", "elif", "else", "except", "finally",
                        "for", "from", "global", "if", "import",
                        "lambda", "pass", "raise", "return",
                        "try", "while", "with", "yield", "in", "False", "True"];
  var commonBuiltins = ["abs", "all", "any", "bin", "bool", "bytearray", "callable", "chr",
                        "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod",
                        "enumerate", "eval", "filter", "float", "format", "frozenset",
                        "getattr", "globals", "hasattr", "hash", "help", "hex", "id",
                        "input", "int", "isinstance", "issubclass", "iter", "len",
                        "list", "locals", "map", "max", "memoryview", "min", "next",
                        "object", "oct", "open", "ord", "pow", "property", "range",
                        "repr", "reversed", "round", "set", "setattr", "slice",
                        "sorted", "staticmethod", "str", "sum", "super", "tuple",
                        "type", "vars", "zip", "__import__", "NotImplemented",
                        "Ellipsis", "__debug__"];
  CodeMirror.registerHelper("hintWords", "python", commonKeywords.concat(commonBuiltins).concat(["exec", "print"]));

  function top(state) {
    return state.scopes[state.scopes.length - 1];
  }

  CodeMirror.defineMode("python", function(conf, parserConf) {
    var ERRORCLASS = "error";

    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\(\)\[\]\{\}@,:`=;\.\\]/;
    //               (Backwards-compatibility with old, cumbersome config system)
    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,
                     parserConf.operators || /^([-+*/%\/&|^]=?|[<>=]+|\/\/=?|\*\*=?|!=|[~!@]|\.\.\.)/]
    for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1)

    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;

    var myKeywords = commonKeywords, myBuiltins = commonBuiltins;
    if (parserConf.extra_keywords != undefined)
      myKeywords = myKeywords.concat(parserConf.extra_keywords);

    if (parserConf.extra_builtins != undefined)
      myBuiltins = myBuiltins.concat(parserConf.extra_builtins);

    var py3 = !(parserConf.version && Number(parserConf.version) < 3)
    if (py3) {
      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator
      var identifiers = parserConf.identifiers|| /^[_A-Za-z\u00A1-\uFFFF][_A-Za-z0-9\u00A1-\uFFFF]*/;
      myKeywords = myKeywords.concat(["nonlocal", "None", "aiter", "anext", "async", "await", "breakpoint", "match", "case"]);
      myBuiltins = myBuiltins.concat(["ascii", "bytes", "exec", "print"]);
      var stringPrefixes = new RegExp("^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|\"{3}|['\"]))", "i");
    } else {
      var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;
      myKeywords = myKeywords.concat(["exec", "print"]);
      myBuiltins = myBuiltins.concat(["apply", "basestring", "buffer", "cmp", "coerce", "execfile",
                                      "file", "intern", "long", "raw_input", "reduce", "reload",
                                      "unichr", "unicode", "xrange", "None"]);
      var stringPrefixes = new RegExp("^(([rubf]|(ur)|(br))?('{3}|\"{3}|['\"]))", "i");
    }
    var keywords = wordRegexp(myKeywords);
    var builtins = wordRegexp(myBuiltins);

    // tokenizers
    function tokenBase(stream, state) {
      var sol = stream.sol() && state.lastToken != "\\"
      if (sol) state.indent = stream.indentation()
      // Handle scope changes
      if (sol && top(state).type == "py") {
        var scopeOffset = top(state).offset;
        if (stream.eatSpace()) {
          var lineOffset = stream.indentation();
          if (lineOffset > scopeOffset)
            pushPyScope(state);
          else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != "#")
            state.errorToken = true;
          return null;
        } else {
          var style = tokenBaseInner(stream, state);
          if (scopeOffset > 0 && dedent(stream, state))
            style += " " + ERRORCLASS;
          return style;
        }
      }
      return tokenBaseInner(stream, state);
    }

    function tokenBaseInner(stream, state, inFormat) {
      if (stream.eatSpace()) return null;

      // Handle Comments
      if (!inFormat && stream.match(/^#.*/)) return "comment";

      // Handle Number Literals
      if (stream.match(/^[0-9\.]/, false)) {
        var floatLiteral = false;
        // Floats
        if (stream.match(/^[\d_]*\.\d+(e[\+\-]?\d+)?/i)) { floatLiteral = true; }
        if (stream.match(/^[\d_]+\.\d*/)) { floatLiteral = true; }
        if (stream.match(/^\.\d+/)) { floatLiteral = true; }
        if (floatLiteral) {
          // Float literals may be "imaginary"
          stream.eat(/J/i);
          return "number";
        }
        // Integers
        var intLiteral = false;
        // Hex
        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;
        // Binary
        if (stream.match(/^0b[01_]+/i)) intLiteral = true;
        // Octal
        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;
        // Decimal
        if (stream.match(/^[1-9][\d_]*(e[\+\-]?[\d_]+)?/)) {
          // Decimal literals may be "imaginary"
          stream.eat(/J/i);
          // TODO - Can you have imaginary longs?
          intLiteral = true;
        }
        // Zero by itself with no other piece of number.
        if (stream.match(/^0(?![\dx])/i)) intLiteral = true;
        if (intLiteral) {
          // Integer literals may be "long"
          stream.eat(/L/i);
          return "number";
        }
      }

      // Handle Strings
      if (stream.match(stringPrefixes)) {
        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;
        if (!isFmtString) {
          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);
          return state.tokenize(stream, state);
        } else {
          state.tokenize = formatStringFactory(stream.current(), state.tokenize);
          return state.tokenize(stream, state);
        }
      }

      for (var i = 0; i < operators.length; i++)
        if (stream.match(operators[i])) return "operator"

      if (stream.match(delimiters)) return "punctuation";

      if (state.lastToken == "." && stream.match(identifiers))
        return "property";

      if (stream.match(keywords) || stream.match(wordOperators))
        return "keyword";

      if (stream.match(builtins))
        return "builtin";

      if (stream.match(/^(self|cls)\b/))
        return "variable-2";

      if (stream.match(identifiers)) {
        if (state.lastToken == "def" || state.lastToken == "class")
          return "def";
        return "variable";
      }

      // Handle non-detected items
      stream.next();
      return inFormat ? null :ERRORCLASS;
    }

    function formatStringFactory(delimiter, tokenOuter) {
      while ("rubf".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)
        delimiter = delimiter.substr(1);

      var singleline = delimiter.length == 1;
      var OUTCLASS = "string";

      function tokenNestedExpr(depth) {
        return function(stream, state) {
          var inner = tokenBaseInner(stream, state, true)
          if (inner == "punctuation") {
            if (stream.current() == "{") {
              state.tokenize = tokenNestedExpr(depth + 1)
            } else if (stream.current() == "}") {
              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1)
              else state.tokenize = tokenString
            }
          }
          return inner
        }
      }

      function tokenString(stream, state) {
        while (!stream.eol()) {
          stream.eatWhile(/[^'"\{\}\\]/);
          if (stream.eat("\\")) {
            stream.next();
            if (singleline && stream.eol())
              return OUTCLASS;
          } else if (stream.match(delimiter)) {
            state.tokenize = tokenOuter;
            return OUTCLASS;
          } else if (stream.match('{{')) {
            // ignore {{ in f-str
            return OUTCLASS;
          } else if (stream.match('{', false)) {
            // switch to nested mode
            state.tokenize = tokenNestedExpr(0)
            if (stream.current()) return OUTCLASS;
            else return state.tokenize(stream, state)
          } else if (stream.match('}}')) {
            return OUTCLASS;
          } else if (stream.match('}')) {
            // single } in f-string is an error
            return ERRORCLASS;
          } else {
            stream.eat(/['"]/);
          }
        }
        if (singleline) {
          if (parserConf.singleLineStringErrors)
            return ERRORCLASS;
          else
            state.tokenize = tokenOuter;
        }
        return OUTCLASS;
      }
      tokenString.isString = true;
      return tokenString;
    }

    function tokenStringFactory(delimiter, tokenOuter) {
      while ("rubf".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)
        delimiter = delimiter.substr(1);

      var singleline = delimiter.length == 1;
      var OUTCLASS = "string";

      function tokenString(stream, state) {
        while (!stream.eol()) {
          stream.eatWhile(/[^'"\\]/);
          if (stream.eat("\\")) {
            stream.next();
            if (singleline && stream.eol())
              return OUTCLASS;
          } else if (stream.match(delimiter)) {
            state.tokenize = tokenOuter;
            return OUTCLASS;
          } else {
            stream.eat(/['"]/);
          }
        }
        if (singleline) {
          if (parserConf.singleLineStringErrors)
            return ERRORCLASS;
          else
            state.tokenize = tokenOuter;
        }
        return OUTCLASS;
      }
      tokenString.isString = true;
      return tokenString;
    }

    function pushPyScope(state) {
      while (top(state).type != "py") state.scopes.pop()
      state.scopes.push({offset: top(state).offset + conf.indentUnit,
                         type: "py",
                         align: null})
    }

    function pushBracketScope(stream, state, type) {
      var align = stream.match(/^[\s\[\{\(]*(?:#|$)/, false) ? null : stream.column() + 1
      state.scopes.push({offset: state.indent + hangingIndent,
                         type: type,
                         align: align})
    }

    function dedent(stream, state) {
      var indented = stream.indentation();
      while (state.scopes.length > 1 && top(state).offset > indented) {
        if (top(state).type != "py") return true;
        state.scopes.pop();
      }
      return top(state).offset != indented;
    }

    function tokenLexer(stream, state) {
      if (stream.sol()) {
        state.beginningOfLine = true;
        state.dedent = false;
      }

      var style = state.tokenize(stream, state);
      var current = stream.current();

      // Handle decorators
      if (state.beginningOfLine && current == "@")
        return stream.match(identifiers, false) ? "meta" : py3 ? "operator" : ERRORCLASS;

      if (/\S/.test(current)) state.beginningOfLine = false;

      if ((style == "variable" || style == "builtin")
          && state.lastToken == "meta")
        style = "meta";

      // Handle scope changes.
      if (current == "pass" || current == "return")
        state.dedent = true;

      if (current == "lambda") state.lambda = true;
      if (current == ":" && !state.lambda && top(state).type == "py" && stream.match(/^\s*(?:#|$)/, false))
        pushPyScope(state);

      if (current.length == 1 && !/string|comment/.test(style)) {
        var delimiter_index = "[({".indexOf(current);
        if (delimiter_index != -1)
          pushBracketScope(stream, state, "])}".slice(delimiter_index, delimiter_index+1));

        delimiter_index = "])}".indexOf(current);
        if (delimiter_index != -1) {
          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent
          else return ERRORCLASS;
        }
      }
      if (state.dedent && stream.eol() && top(state).type == "py" && state.scopes.length > 1)
        state.scopes.pop();

      return style;
    }

    var external = {
      startState: function(basecolumn) {
        return {
          tokenize: tokenBase,
          scopes: [{offset: basecolumn || 0, type: "py", align: null}],
          indent: basecolumn || 0,
          lastToken: null,
          lambda: false,
          dedent: 0
        };
      },

      token: function(stream, state) {
        var addErr = state.errorToken;
        if (addErr) state.errorToken = false;
        var style = tokenLexer(stream, state);

        if (style && style != "comment")
          state.lastToken = (style == "keyword" || style == "punctuation") ? stream.current() : style;
        if (style == "punctuation") style = null;

        if (stream.eol() && state.lambda)
          state.lambda = false;
        return addErr ? style + " " + ERRORCLASS : style;
      },

      indent: function(state, textAfter) {
        if (state.tokenize != tokenBase)
          return state.tokenize.isString ? CodeMirror.Pass : 0;

        var scope = top(state)
        var closing = scope.type == textAfter.charAt(0) ||
            scope.type == "py" && !state.dedent && /^(else:|elif |except |finally:)/.test(textAfter)
        if (scope.align != null)
          return scope.align - (closing ? 1 : 0)
        else
          return scope.offset - (closing ? hangingIndent : 0)
      },

      electricInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/,
      closeBrackets: {triples: "'\""},
      lineComment: "#",
      fold: "indent"
    };
    return external;
  });

  CodeMirror.defineMIME("text/x-python", "python");

  var words = function(str) { return str.split(" "); };

  CodeMirror.defineMIME("text/x-cython", {
    name: "python",
    extra_keywords: words("by cdef cimport cpdef ctypedef enum except "+
                          "extern gil include nogil property public "+
                          "readonly struct union DEF IF ELIF ELSE")
  });

});


/***/ }),

/***/ "dbb4":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var DESCRIPTORS = __webpack_require__("83ab");
var ownKeys = __webpack_require__("56ef");
var toIndexedObject = __webpack_require__("fc6a");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var createProperty = __webpack_require__("8418");

// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ "dc4a":
/***/ (function(module, exports, __webpack_require__) {

var aCallable = __webpack_require__("59ed");
var isNullOrUndefined = __webpack_require__("7234");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ "dc8a":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return onKeyDownComposition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return shouldIgnoreKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isKeyCode; });
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("caad");
/* harmony import */ var core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_includes_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("2532");
/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("99af");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_2__);



var lastKeyCompositionStatus = false;
function onKeyDownComposition(evt) {
  lastKeyCompositionStatus = evt.isComposing === true;
}
function shouldIgnoreKey(evt) {
  return lastKeyCompositionStatus === true || evt !== Object(evt) || evt.isComposing === true || evt.qKeyEvent === true;
}
function isKeyCode(evt, keyCodes) {
  return shouldIgnoreKey(evt) === true ? false : [].concat(keyCodes).includes(evt.keyCode);
}

/***/ }),

/***/ "dca8":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var FREEZING = __webpack_require__("bb2f");
var fails = __webpack_require__("d039");
var isObject = __webpack_require__("861d");
var onFreeze = __webpack_require__("f183").onFreeze;

// eslint-disable-next-line es/no-object-freeze -- safe
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () { $freeze(1); });

// `Object.freeze` method
// https://tc39.es/ecma262/#sec-object.freeze
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  freeze: function freeze(it) {
    return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ "dcc3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
var create = __webpack_require__("7c73");
var createPropertyDescriptor = __webpack_require__("5c6c");
var setToStringTag = __webpack_require__("d44e");
var Iterators = __webpack_require__("3f8c");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "ddb0":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DOMIterables = __webpack_require__("fdbc");
var DOMTokenListPrototype = __webpack_require__("785a");
var ArrayIteratorMethods = __webpack_require__("e260");
var createNonEnumerableProperty = __webpack_require__("9112");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

var handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
};

for (var COLLECTION_NAME in DOMIterables) {
  handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype, COLLECTION_NAME);
}

handlePrototype(DOMTokenListPrototype, 'DOMTokenList');


/***/ }),

/***/ "ddd8":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var defineProperty = __webpack_require__("ade3");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__("53ca");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
var es_array_filter = __webpack_require__("4de4");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__("d81d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.join.js
var es_array_join = __webpack_require__("a15b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__("fb6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
var es_array_splice = __webpack_require__("a434");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find-index.js
var es_array_find_index = __webpack_require__("c740");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find.js
var es_array_find = __webpack_require__("7db0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.constructor.js
var es_regexp_constructor = __webpack_require__("4d63");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.dot-all.js
var es_regexp_dot_all = __webpack_require__("c607");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.sticky.js
var es_regexp_sticky = __webpack_require__("2c3e");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__("25f0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.test.js
var es_regexp_test = __webpack_require__("00b4");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./node_modules/quasar/src/components/field/QField.js + 2 modules
var QField = __webpack_require__("8572");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/icon/QIcon.js
var QIcon = __webpack_require__("0016");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.assign.js
var es_object_assign = __webpack_require__("cca6");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/dark.js
var dark = __webpack_require__("b7fa");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/ripple.js + 2 modules
var ripple = __webpack_require__("3d69");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/size.js
var size = __webpack_require__("6642");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("d882");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/slot.js
var slot = __webpack_require__("e277");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/cache.js
var cache = __webpack_require__("d54d");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/chip/QChip.js













/* harmony default export */ var QChip = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QChip',
  mixins: [ripple["a" /* default */], dark["a" /* default */], Object(size["b" /* getSizeMixin */])({
    xs: 8,
    sm: 10,
    md: 14,
    lg: 20,
    xl: 24
  })],
  model: {
    event: 'remove'
  },
  props: {
    dense: Boolean,
    icon: String,
    iconRight: String,
    iconRemove: String,
    iconSelected: String,
    label: [String, Number],
    color: String,
    textColor: String,
    value: {
      type: Boolean,
      default: true
    },
    selected: {
      type: Boolean,
      default: null
    },
    square: Boolean,
    outline: Boolean,
    clickable: Boolean,
    removable: Boolean,
    removeAriaLabel: String,
    tabindex: [String, Number],
    disable: Boolean
  },
  computed: {
    classes: function classes() {
      var _ref;
      var text = this.outline === true ? this.color || this.textColor : this.textColor;
      return _ref = {}, Object(defineProperty["a" /* default */])(_ref, "bg-".concat(this.color), this.outline === false && this.color !== void 0), Object(defineProperty["a" /* default */])(_ref, "text-".concat(text, " q-chip--colored"), text), Object(defineProperty["a" /* default */])(_ref, "disabled", this.disable), Object(defineProperty["a" /* default */])(_ref, 'q-chip--dense', this.dense), Object(defineProperty["a" /* default */])(_ref, 'q-chip--outline', this.outline), Object(defineProperty["a" /* default */])(_ref, 'q-chip--selected', this.selected), Object(defineProperty["a" /* default */])(_ref, 'q-chip--clickable cursor-pointer non-selectable q-hoverable', this.isClickable), Object(defineProperty["a" /* default */])(_ref, 'q-chip--square', this.square), Object(defineProperty["a" /* default */])(_ref, 'q-chip--dark q-dark', this.isDark), _ref;
    },
    hasLeftIcon: function hasLeftIcon() {
      return this.selected === true || this.icon !== void 0;
    },
    leftIcon: function leftIcon() {
      return this.selected === true ? this.iconSelected || this.$q.iconSet.chip.selected : this.icon;
    },
    removeIcon: function removeIcon() {
      return this.iconRemove || this.$q.iconSet.chip.remove;
    },
    isClickable: function isClickable() {
      return this.disable === false && (this.clickable === true || this.selected !== null);
    },
    attrs: function attrs() {
      var chip = this.disable === true ? {
        tabindex: -1,
        'aria-disabled': 'true'
      } : {
        tabindex: this.tabindex || 0
      };
      var remove = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, chip), {}, {
        role: 'button',
        'aria-hidden': 'false',
        'aria-label': this.removeAriaLabel || this.$q.lang.label.remove
      });
      return {
        chip: chip,
        remove: remove
      };
    }
  },
  methods: {
    __onKeyup: function __onKeyup(e) {
      e.keyCode === 13 /* ENTER */ && this.__onClick(e);
    },
    __onClick: function __onClick(e) {
      if (!this.disable) {
        this.$emit('update:selected', !this.selected);
        this.$emit('click', e);
      }
    },
    __onRemove: function __onRemove(e) {
      if (e.keyCode === void 0 || e.keyCode === 13) {
        Object(utils_event["j" /* stopAndPrevent */])(e);
        !this.disable && this.$emit('remove', false);
      }
    },
    __getContent: function __getContent(h) {
      var child = [];
      this.isClickable === true && child.push(h('div', {
        staticClass: 'q-focus-helper'
      }));
      this.hasLeftIcon === true && child.push(h(QIcon["a" /* default */], {
        staticClass: 'q-chip__icon q-chip__icon--left',
        props: {
          name: this.leftIcon
        }
      }));
      var label = this.label !== void 0 ? [h('div', {
        staticClass: 'ellipsis'
      }, [this.label])] : void 0;
      child.push(h('div', {
        staticClass: 'q-chip__content col row no-wrap items-center q-anchor--skip'
      }, Object(slot["b" /* mergeSlotSafely */])(label, this, 'default')));
      this.iconRight && child.push(h(QIcon["a" /* default */], {
        staticClass: 'q-chip__icon q-chip__icon--right',
        props: {
          name: this.iconRight
        }
      }));
      this.removable === true && child.push(h(QIcon["a" /* default */], {
        staticClass: 'q-chip__icon q-chip__icon--remove cursor-pointer',
        props: {
          name: this.removeIcon
        },
        attrs: this.attrs.remove,
        on: Object(cache["a" /* default */])(this, 'non', {
          click: this.__onRemove,
          keyup: this.__onRemove
        })
      }));
      return child;
    }
  },
  render: function render(h) {
    if (this.value === false) {
      return;
    }
    var data = {
      staticClass: 'q-chip row inline no-wrap items-center',
      class: this.classes,
      style: this.sizeStyle
    };
    this.isClickable === true && Object.assign(data, {
      attrs: this.attrs.chip,
      on: Object(cache["a" /* default */])(this, 'click', {
        click: this.__onClick,
        keyup: this.__onKeyup
      }),
      directives: Object(cache["a" /* default */])(this, 'dir#' + this.ripple, [{
        name: 'ripple',
        value: this.ripple
      }])
    });
    return h('div', data, this.__getContent(h));
  }
}));
// EXTERNAL MODULE: ./node_modules/quasar/src/components/item/QItem.js
var QItem = __webpack_require__("66e5");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/item/QItemSection.js
var QItemSection = __webpack_require__("4074");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/item/QItemLabel.js
var QItemLabel = __webpack_require__("0170");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/menu/QMenu.js + 2 modules
var QMenu = __webpack_require__("4e73");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/dialog/QDialog.js + 2 modules
var QDialog = __webpack_require__("24e8");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/is.js
var is = __webpack_require__("5ff7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.to-fixed.js
var es_number_to_fixed = __webpack_require__("b680");

// CONCATENATED MODULE: ./node_modules/quasar/src/utils/format.js




var units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
function humanStorageSize(bytes) {
  var u = 0;
  while (parseInt(bytes, 10) >= 1024 && u < units.length - 1) {
    bytes /= 1024;
    ++u;
  }
  return "".concat(bytes.toFixed(1)).concat(units[u]);
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function between(v, min, max) {
  return max <= min ? min : Math.min(max, Math.max(min, v));
}
function normalizeToInterval(v, min, max) {
  if (max <= min) {
    return min;
  }
  var size = max - min + 1;
  var index = min + (v - min) % size;
  if (index < min) {
    index = size + index;
  }
  return index === 0 ? 0 : index; // fix for (-a % a) => -0
}

function pad(v) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var char = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';
  if (v === void 0 || v === null) {
    return v;
  }
  var val = '' + v;
  return val.length >= length ? val : new Array(length - val.length + 1).join(char) + val;
}
/* harmony default export */ var format = ({
  humanStorageSize: humanStorageSize,
  capitalize: capitalize,
  between: between,
  normalizeToInterval: normalizeToInterval,
  pad: pad
});
// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/key-composition.js
var key_composition = __webpack_require__("dc8a");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/form.js
var mixins_form = __webpack_require__("f89c");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("13d5");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.keys.js
var es_object_keys = __webpack_require__("b64b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("5319");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/debounce.js
var debounce = __webpack_require__("1c16");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/scroll.js
var utils_scroll = __webpack_require__("0831");

// CONCATENATED MODULE: ./node_modules/quasar/src/mixins/virtual-scroll.js
















var aggBucketSize = 1000;
var scrollToEdges = ['start', 'center', 'end', 'start-force', 'center-force', 'end-force'];
var filterProto = Array.prototype.filter;
function sumFn(acc, h) {
  return acc + h;
}
function getScrollDetails(parent, child, beforeRef, afterRef, horizontal, rtl, stickyStart, stickyEnd) {
  var parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent,
    propElSize = horizontal === true ? 'offsetWidth' : 'offsetHeight',
    details = {
      scrollStart: 0,
      scrollViewSize: -stickyStart - stickyEnd,
      scrollMaxSize: 0,
      offsetStart: -stickyStart,
      offsetEnd: -stickyEnd
    };
  if (horizontal === true) {
    if (parent === window) {
      details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0;
      details.scrollViewSize += document.documentElement.clientWidth;
    } else {
      details.scrollStart = parentCalc.scrollLeft;
      details.scrollViewSize += parentCalc.clientWidth;
    }
    details.scrollMaxSize = parentCalc.scrollWidth;
    if (rtl === true) {
      details.scrollStart = (Object(utils_scroll["f" /* rtlHasScrollBug */])() === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart;
    }
  } else {
    if (parent === window) {
      details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0;
      details.scrollViewSize += document.documentElement.clientHeight;
    } else {
      details.scrollStart = parentCalc.scrollTop;
      details.scrollViewSize += parentCalc.clientHeight;
    }
    details.scrollMaxSize = parentCalc.scrollHeight;
  }
  if (beforeRef !== void 0) {
    for (var el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {
      if (el.classList.contains('q-virtual-scroll--skip') === false) {
        details.offsetStart += el[propElSize];
      }
    }
  }
  if (afterRef !== void 0) {
    for (var _el = afterRef.nextElementSibling; _el !== null; _el = _el.nextElementSibling) {
      if (_el.classList.contains('q-virtual-scroll--skip') === false) {
        details.offsetEnd += _el[propElSize];
      }
    }
  }
  if (child !== parent) {
    var parentRect = parentCalc.getBoundingClientRect(),
      childRect = child.getBoundingClientRect();
    if (horizontal === true) {
      details.offsetStart += childRect.left - parentRect.left;
      details.offsetEnd -= childRect.width;
    } else {
      details.offsetStart += childRect.top - parentRect.top;
      details.offsetEnd -= childRect.height;
    }
    if (parent !== window) {
      details.offsetStart += details.scrollStart;
    }
    details.offsetEnd += details.scrollMaxSize - details.offsetStart;
  }
  return details;
}
function setScroll(parent, scroll, horizontal, rtl) {
  if (scroll === 'end') {
    scroll = (parent === window ? document.body : parent)[horizontal === true ? 'scrollWidth' : 'scrollHeight'];
  }
  if (parent === window) {
    if (horizontal === true) {
      if (rtl === true) {
        scroll = (Object(utils_scroll["f" /* rtlHasScrollBug */])() === true ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - scroll;
      }
      window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
    } else {
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll);
    }
  } else if (horizontal === true) {
    if (rtl === true) {
      scroll = (Object(utils_scroll["f" /* rtlHasScrollBug */])() === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll;
    }
    parent.scrollLeft = scroll;
  } else {
    parent.scrollTop = scroll;
  }
}
function sumSize(sizeAgg, size, from, to) {
  if (from >= to) {
    return 0;
  }
  var lastTo = size.length,
    fromAgg = Math.floor(from / aggBucketSize),
    toAgg = Math.floor((to - 1) / aggBucketSize) + 1;
  var total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0);
  if (from % aggBucketSize !== 0) {
    total -= size.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0);
  }
  if (to % aggBucketSize !== 0 && to !== lastTo) {
    total -= size.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0);
  }
  return total;
}
var commonVirtScrollProps = {
  virtualScrollSliceSize: {
    type: [Number, String],
    default: null
  },
  virtualScrollSliceRatioBefore: {
    type: [Number, String],
    default: 1
  },
  virtualScrollSliceRatioAfter: {
    type: [Number, String],
    default: 1
  },
  virtualScrollItemSize: {
    type: [Number, String],
    default: 24
  },
  virtualScrollStickySizeStart: {
    type: [Number, String],
    default: 0
  },
  virtualScrollStickySizeEnd: {
    type: [Number, String],
    default: 0
  },
  tableColspan: [Number, String]
};
function setOverflowAnchor(contentEl, index) {
  if (setOverflowAnchor.isSupported === void 0) {
    setOverflowAnchor.isSupported = window.getComputedStyle(document.body).overflowAnchor !== void 0;
  }
  if (setOverflowAnchor.isSupported === false || contentEl === void 0) {
    return;
  }
  cancelAnimationFrame(contentEl._qOverflowAnimationFrame);
  contentEl._qOverflowAnimationFrame = requestAnimationFrame(function () {
    if (contentEl === void 0) {
      return;
    }
    var children = contentEl.children || [];
    filterProto.call(children, function (el) {
      return el.dataset && el.dataset.qVsAnchor !== void 0;
    }).forEach(function (el) {
      delete el.dataset.qVsAnchor;
    });
    var el = children[index];
    if (el && el.dataset) {
      el.dataset.qVsAnchor = '';
    }
  });
}
var commonVirtPropsList = Object.keys(commonVirtScrollProps);
/* harmony default export */ var virtual_scroll = ({
  props: Object(objectSpread2["a" /* default */])({
    virtualScrollHorizontal: Boolean
  }, commonVirtScrollProps),
  data: function data() {
    return {
      virtualScrollSliceRange: {
        from: 0,
        to: 0
      }
    };
  },
  watch: {
    needsSliceRecalc: function needsSliceRecalc() {
      this.__setVirtualScrollSize();
    },
    needsReset: function needsReset() {
      this.reset();
    }
  },
  computed: {
    needsReset: function needsReset() {
      var _this = this;
      return ['virtualScrollItemSizeComputed', 'virtualScrollHorizontal'].map(function (p) {
        return _this[p];
      }).join(';');
    },
    needsSliceRecalc: function needsSliceRecalc() {
      var _this2 = this;
      return this.needsReset + ';' + ['virtualScrollSliceRatioBefore', 'virtualScrollSliceRatioAfter'].map(function (p) {
        return _this2[p];
      }).join(';');
    },
    colspanAttr: function colspanAttr() {
      return this.tableColspan !== void 0 ? {
        colspan: this.tableColspan
      } : {
        colspan: 100
      };
    },
    virtualScrollItemSizeComputed: function virtualScrollItemSizeComputed() {
      return this.virtualScrollItemSize;
    }
  },
  methods: {
    reset: function reset() {
      this.__resetVirtualScroll(this.prevToIndex, true);
    },
    refresh: function refresh(toIndex) {
      this.__resetVirtualScroll(toIndex === void 0 ? this.prevToIndex : toIndex);
    },
    scrollTo: function scrollTo(toIndex, edge) {
      var scrollEl = this.__getVirtualScrollTarget();
      if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
        return;
      }
      var scrollDetails = getScrollDetails(scrollEl, this.__getVirtualScrollEl(), this.$refs.before, this.$refs.after, this.virtualScrollHorizontal, this.$q.lang.rtl, this.virtualScrollStickySizeStart, this.virtualScrollStickySizeEnd);
      this.__scrollViewSize !== scrollDetails.scrollViewSize && this.__setVirtualScrollSize(scrollDetails.scrollViewSize);
      this.__setVirtualScrollSliceRange(scrollEl, scrollDetails, Math.min(this.virtualScrollLength - 1, Math.max(0, parseInt(toIndex, 10) || 0)), 0, scrollToEdges.indexOf(edge) > -1 ? edge : this.prevToIndex > -1 && toIndex > this.prevToIndex ? 'end' : 'start');
    },
    __onVirtualScrollEvt: function __onVirtualScrollEvt() {
      var scrollEl = this.__getVirtualScrollTarget();
      if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {
        return;
      }
      var scrollDetails = getScrollDetails(scrollEl, this.__getVirtualScrollEl(), this.$refs.before, this.$refs.after, this.virtualScrollHorizontal, this.$q.lang.rtl, this.virtualScrollStickySizeStart, this.virtualScrollStickySizeEnd),
        listLastIndex = this.virtualScrollLength - 1,
        listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - this.virtualScrollPaddingAfter;
      if (this.prevScrollStart === scrollDetails.scrollStart) {
        return;
      }
      if (scrollDetails.scrollMaxSize <= 0) {
        this.__setVirtualScrollSliceRange(scrollEl, scrollDetails, 0, 0);
        return;
      }
      this.__scrollViewSize !== scrollDetails.scrollViewSize && this.__setVirtualScrollSize(scrollDetails.scrollViewSize);
      this.__updateVirtualScrollSizes(this.virtualScrollSliceRange.from);
      var scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize - Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd) - Math.min(this.virtualScrollSizes[listLastIndex], scrollDetails.scrollViewSize / 2));
      if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {
        this.__setVirtualScrollSliceRange(scrollEl, scrollDetails, listLastIndex, scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - this.virtualScrollSizesAgg.reduce(sumFn, 0));
        return;
      }
      var toIndex = 0,
        listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart,
        offset = listOffset;
      if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= this.virtualScrollPaddingBefore) {
        listOffset -= this.virtualScrollPaddingBefore;
        toIndex = this.virtualScrollSliceRange.from;
        offset = listOffset;
      } else {
        for (var j = 0; listOffset >= this.virtualScrollSizesAgg[j] && toIndex < listLastIndex; j++) {
          listOffset -= this.virtualScrollSizesAgg[j];
          toIndex += aggBucketSize;
        }
      }
      while (listOffset > 0 && toIndex < listLastIndex) {
        listOffset -= this.virtualScrollSizes[toIndex];
        if (listOffset > -scrollDetails.scrollViewSize) {
          toIndex++;
          offset = listOffset;
        } else {
          offset = this.virtualScrollSizes[toIndex] + listOffset;
        }
      }
      this.__setVirtualScrollSliceRange(scrollEl, scrollDetails, toIndex, offset);
    },
    __setVirtualScrollSliceRange: function __setVirtualScrollSliceRange(scrollEl, scrollDetails, toIndex, offset, align) {
      var _this3 = this;
      var alignForce = typeof align === 'string' && align.indexOf('-force') > -1;
      var alignEnd = alignForce === true ? align.replace('-force', '') : align;
      var alignRange = alignEnd !== void 0 ? alignEnd : 'start';
      var from = Math.max(0, toIndex - this.virtualScrollSliceSizeComputed[alignRange]),
        to = from + this.virtualScrollSliceSizeComputed.total;
      if (to > this.virtualScrollLength) {
        to = this.virtualScrollLength;
        from = Math.max(0, to - this.virtualScrollSliceSizeComputed.total);
      }
      this.prevScrollStart = scrollDetails.scrollStart;
      var rangeChanged = from !== this.virtualScrollSliceRange.from || to !== this.virtualScrollSliceRange.to;
      if (rangeChanged === false && alignEnd === void 0) {
        this.__emitScroll(toIndex);
        return;
      }
      var _document = document,
        activeElement = _document.activeElement;
      var contentEl = this.$refs.content;
      if (rangeChanged === true && contentEl !== void 0 && contentEl !== activeElement && contentEl.contains(activeElement) === true) {
        contentEl.addEventListener('focusout', this.__onBlurRefocusFn);
        setTimeout(function () {
          contentEl !== void 0 && contentEl.removeEventListener('focusout', _this3.__onBlurRefocusFn);
        });
      }
      setOverflowAnchor(contentEl, toIndex - from);
      var sizeBefore = alignEnd !== void 0 ? this.virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0;
      if (rangeChanged === true) {
        // vue key matching algorithm works only if
        // the array of VNodes changes on only one of the ends
        // so we first change one end and then the other

        var tempTo = to >= this.virtualScrollSliceRange.from && from <= this.virtualScrollSliceRange.to ? this.virtualScrollSliceRange.to : to;
        this.virtualScrollSliceRange = {
          from: from,
          to: tempTo
        };
        this.virtualScrollPaddingBefore = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, 0, from);
        this.virtualScrollPaddingAfter = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, this.virtualScrollSliceRange.to, this.virtualScrollLength);
        requestAnimationFrame(function () {
          if (_this3.virtualScrollSliceRange.to !== to && _this3.prevScrollStart === scrollDetails.scrollStart) {
            _this3.virtualScrollSliceRange = {
              from: _this3.virtualScrollSliceRange.from,
              to: to
            };
            _this3.virtualScrollPaddingAfter = sumSize(_this3.virtualScrollSizesAgg, _this3.virtualScrollSizes, to, _this3.virtualScrollLength);
          }
        });
      }
      requestAnimationFrame(function () {
        // if the scroll was changed give up
        // (another call to __setVirtualScrollSliceRange before animation frame)
        if (_this3.prevScrollStart !== scrollDetails.scrollStart) {
          return;
        }
        if (rangeChanged === true) {
          _this3.__updateVirtualScrollSizes(from);
        }
        var sizeAfter = _this3.virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0),
          posStart = sizeAfter + scrollDetails.offsetStart + _this3.virtualScrollPaddingBefore,
          posEnd = posStart + _this3.virtualScrollSizes[toIndex];
        var scrollPosition = posStart + offset;
        if (alignEnd !== void 0) {
          var sizeDiff = sizeAfter - sizeBefore;
          var scrollStart = scrollDetails.scrollStart + sizeDiff;
          scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize ? scrollStart : alignEnd === 'end' ? posEnd - scrollDetails.scrollViewSize : posStart - (alignEnd === 'start' ? 0 : Math.round((scrollDetails.scrollViewSize - _this3.virtualScrollSizes[toIndex]) / 2));
        }
        _this3.prevScrollStart = scrollPosition;
        setScroll(scrollEl, scrollPosition, _this3.virtualScrollHorizontal, _this3.$q.lang.rtl);
        _this3.__emitScroll(toIndex);
      });
    },
    __updateVirtualScrollSizes: function __updateVirtualScrollSizes(from) {
      var contentEl = this.$refs.content;
      if (contentEl !== void 0) {
        var children = filterProto.call(contentEl.children || [], function (el) {
            return el.classList && el.classList.contains('q-virtual-scroll--skip') === false;
          }),
          // fallback [] for IE
          childrenLength = children.length,
          sizeFn = this.virtualScrollHorizontal === true ? function (el) {
            return el.getBoundingClientRect().width;
          } : function (el) {
            return el.offsetHeight;
          };
        var index = from,
          size,
          diff;
        for (var i = 0; i < childrenLength;) {
          size = sizeFn(children[i]);
          i++;
          while (i < childrenLength && children[i].classList.contains('q-virtual-scroll--with-prev') === true) {
            size += sizeFn(children[i]);
            i++;
          }
          diff = size - this.virtualScrollSizes[index];
          if (diff !== 0) {
            this.virtualScrollSizes[index] += diff;
            this.virtualScrollSizesAgg[Math.floor(index / aggBucketSize)] += diff;
          }
          index++;
        }
      }
    },
    __resetVirtualScroll: function __resetVirtualScroll(toIndex, fullReset) {
      var _this4 = this;
      var defaultSize = 1 * this.virtualScrollItemSizeComputed;
      if (fullReset === true || Array.isArray(this.virtualScrollSizes) === false) {
        this.virtualScrollSizes = [];
      }
      var oldVirtualScrollSizesLength = this.virtualScrollSizes.length;
      this.virtualScrollSizes.length = this.virtualScrollLength;
      for (var i = this.virtualScrollLength - 1; i >= oldVirtualScrollSizesLength; i--) {
        this.virtualScrollSizes[i] = defaultSize;
      }
      var jMax = Math.floor((this.virtualScrollLength - 1) / aggBucketSize);
      this.virtualScrollSizesAgg = [];
      for (var j = 0; j <= jMax; j++) {
        var size = 0;
        var iMax = Math.min((j + 1) * aggBucketSize, this.virtualScrollLength);
        for (var _i = j * aggBucketSize; _i < iMax; _i++) {
          size += this.virtualScrollSizes[_i];
        }
        this.virtualScrollSizesAgg.push(size);
      }
      this.prevToIndex = -1;
      this.prevScrollStart = void 0;
      this.virtualScrollPaddingBefore = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, 0, this.virtualScrollSliceRange.from);
      this.virtualScrollPaddingAfter = sumSize(this.virtualScrollSizesAgg, this.virtualScrollSizes, this.virtualScrollSliceRange.to, this.virtualScrollLength);
      if (toIndex >= 0) {
        this.__updateVirtualScrollSizes(this.virtualScrollSliceRange.from);
        this.$nextTick(function () {
          _this4.scrollTo(toIndex);
        });
      } else {
        this.__onVirtualScrollEvt();
      }
    },
    __setVirtualScrollSize: function __setVirtualScrollSize(scrollViewSize) {
      if (scrollViewSize === void 0 && typeof window !== 'undefined') {
        var scrollEl = this.__getVirtualScrollTarget();
        if (scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {
          scrollViewSize = getScrollDetails(scrollEl, this.__getVirtualScrollEl(), this.$refs.before, this.$refs.after, this.virtualScrollHorizontal, this.$q.lang.rtl, this.virtualScrollStickySizeStart, this.virtualScrollStickySizeEnd).scrollViewSize;
        }
      }
      this.__scrollViewSize = scrollViewSize;
      var virtualScrollSliceRatioBefore = parseFloat(this.virtualScrollSliceRatioBefore) || 0;
      var virtualScrollSliceRatioAfter = parseFloat(this.virtualScrollSliceRatioAfter) || 0;
      var multiplier = 1 + virtualScrollSliceRatioBefore + virtualScrollSliceRatioAfter;
      var view = scrollViewSize === void 0 || scrollViewSize <= 0 ? 1 : Math.ceil(scrollViewSize / this.virtualScrollItemSizeComputed);
      var baseSize = Math.max(1, view, Math.ceil((this.virtualScrollSliceSize > 0 ? this.virtualScrollSliceSize : 10) / multiplier));
      this.virtualScrollSliceSizeComputed = {
        total: Math.ceil(baseSize * multiplier),
        start: Math.ceil(baseSize * virtualScrollSliceRatioBefore),
        center: Math.ceil(baseSize * (0.5 + virtualScrollSliceRatioBefore)),
        end: Math.ceil(baseSize * (1 + virtualScrollSliceRatioBefore)),
        view: view
      };
    },
    __padVirtualScroll: function __padVirtualScroll(h, tag, content) {
      var paddingSize = this.virtualScrollHorizontal === true ? 'width' : 'height';
      var style = Object(defineProperty["a" /* default */])({}, '--q-virtual-scroll-item-' + paddingSize, this.virtualScrollItemSizeComputed + 'px');
      return [tag === 'tbody' ? h(tag, {
        staticClass: 'q-virtual-scroll__padding',
        key: 'before',
        ref: 'before'
      }, [h('tr', [h('td', {
        style: Object(objectSpread2["a" /* default */])(Object(defineProperty["a" /* default */])({}, paddingSize, "".concat(this.virtualScrollPaddingBefore, "px")), style),
        attrs: this.colspanAttr
      })])]) : h(tag, {
        staticClass: 'q-virtual-scroll__padding',
        key: 'before',
        ref: 'before',
        style: Object(objectSpread2["a" /* default */])(Object(defineProperty["a" /* default */])({}, paddingSize, "".concat(this.virtualScrollPaddingBefore, "px")), style)
      }), h(tag, {
        staticClass: 'q-virtual-scroll__content',
        key: 'content',
        ref: 'content',
        attrs: {
          tabindex: -1
        }
      }, content), tag === 'tbody' ? h(tag, {
        staticClass: 'q-virtual-scroll__padding',
        key: 'after',
        ref: 'after'
      }, [h('tr', [h('td', {
        style: Object(objectSpread2["a" /* default */])(Object(defineProperty["a" /* default */])({}, paddingSize, "".concat(this.virtualScrollPaddingAfter, "px")), style),
        attrs: this.colspanAttr
      })])]) : h(tag, {
        staticClass: 'q-virtual-scroll__padding',
        key: 'after',
        ref: 'after',
        style: Object(objectSpread2["a" /* default */])(Object(defineProperty["a" /* default */])({}, paddingSize, "".concat(this.virtualScrollPaddingAfter, "px")), style)
      })];
    },
    __emitScroll: function __emitScroll(index) {
      if (this.prevToIndex !== index) {
        this.qListeners['virtual-scroll'] !== void 0 && this.$emit('virtual-scroll', {
          index: index,
          from: this.virtualScrollSliceRange.from,
          to: this.virtualScrollSliceRange.to - 1,
          direction: index < this.prevToIndex ? 'decrease' : 'increase',
          ref: this
        });
        this.prevToIndex = index;
      }
    },
    __onBlurRefocusFn: function __onBlurRefocusFn() {
      this.$refs.content !== void 0 && this.$refs.content.focus();
    }
  },
  created: function created() {
    this.__setVirtualScrollSize();
  },
  activated: function activated() {
    if (this.shouldActivate !== true) {
      return;
    }
    var scrollEl = this.__getVirtualScrollTarget();
    if (this.prevScrollStart !== void 0 && scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {
      setScroll(scrollEl, this.prevScrollStart, this.virtualScrollHorizontal, this.$q.lang.rtl);
    } else {
      this.scrollTo(this.prevToIndex);
    }
  },
  deactivated: function deactivated() {
    this.shouldActivate = true;
  },
  beforeMount: function beforeMount() {
    this.__onVirtualScrollEvt = Object(debounce["a" /* default */])(this.__onVirtualScrollEvt, this.$q.platform.is.ios === true ? 120 : 35);
    this.__setVirtualScrollSize();
  },
  beforeDestroy: function beforeDestroy() {
    this.__onVirtualScrollEvt.cancel();
  }
});
// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/composition.js
var composition = __webpack_require__("21e1");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("87e8");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/select/QSelect.js








































var validateNewValueMode = function validateNewValueMode(v) {
  return ['add', 'add-unique', 'toggle'].includes(v);
};
var reEscapeList = '.*+?^${}()|[]\\';
/* harmony default export */ var QSelect = __webpack_exports__["a"] = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QSelect',
  mixins: [QField["a" /* default */], virtual_scroll, composition["a" /* default */], mixins_form["a" /* FormFieldMixin */], listeners["a" /* default */]],
  props: {
    value: {
      required: true
    },
    multiple: Boolean,
    displayValue: [String, Number],
    displayValueSanitize: Boolean,
    dropdownIcon: String,
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    optionValue: [Function, String],
    optionLabel: [Function, String],
    optionDisable: [Function, String],
    hideSelected: Boolean,
    hideDropdownIcon: Boolean,
    fillInput: Boolean,
    maxValues: [Number, String],
    optionsDense: Boolean,
    optionsDark: {
      type: Boolean,
      default: null
    },
    optionsSelectedClass: String,
    optionsSanitize: Boolean,
    optionsCover: Boolean,
    menuShrink: Boolean,
    menuAnchor: String,
    menuSelf: String,
    menuOffset: Array,
    popupContentClass: String,
    popupContentStyle: [String, Array, Object],
    useInput: Boolean,
    useChips: Boolean,
    newValueMode: {
      type: String,
      validator: validateNewValueMode
    },
    mapOptions: Boolean,
    emitValue: Boolean,
    inputDebounce: {
      type: [Number, String],
      default: 500
    },
    inputClass: [Array, String, Object],
    inputStyle: [Array, String, Object],
    tabindex: {
      type: [String, Number],
      default: 0
    },
    autocomplete: String,
    transitionShow: String,
    transitionHide: String,
    behavior: {
      type: String,
      validator: function validator(v) {
        return ['default', 'menu', 'dialog'].includes(v);
      },
      default: 'default'
    },
    virtualScrollItemSize: {
      type: [Number, String],
      default: void 0
    }
  },
  data: function data() {
    return {
      menu: false,
      dialog: false,
      optionIndex: -1,
      inputValue: '',
      dialogFieldFocused: false
    };
  },
  watch: {
    innerValue: {
      handler: function handler(val) {
        this.innerValueCache = val;
        if (this.useInput === true && this.fillInput === true && this.multiple !== true &&
        // Prevent re-entering in filter while filtering
        // Also prevent clearing inputValue while filtering
        this.innerLoading !== true && (this.dialog !== true && this.menu !== true || this.hasValue !== true)) {
          this.userInputValue !== true && this.__resetInputValue();
          if (this.dialog === true || this.menu === true) {
            this.filter('');
          }
        }
      },
      immediate: true
    },
    fillInput: function fillInput() {
      this.__resetInputValue();
    },
    menu: function menu(show) {
      this.__updateMenu(show);
    },
    virtualScrollLength: function virtualScrollLength(newLength, oldLength) {
      var _this = this;
      if (this.menu === true && this.innerLoading === false) {
        this.__resetVirtualScroll(-1, true);
        this.$nextTick(function () {
          if (_this.menu === true && _this.innerLoading === false) {
            if (newLength > oldLength) {
              _this.__resetVirtualScroll();
            } else {
              _this.__updateMenu(true);
            }
          }
        });
      }
    }
  },
  computed: {
    isOptionsDark: function isOptionsDark() {
      return this.optionsDark === null ? this.isDark : this.optionsDark;
    },
    virtualScrollLength: function virtualScrollLength() {
      return Array.isArray(this.options) ? this.options.length : 0;
    },
    fieldClass: function fieldClass() {
      return "q-select q-field--auto-height q-select--with".concat(this.useInput !== true ? 'out' : '', "-input") + " q-select--with".concat(this.useChips !== true ? 'out' : '', "-chips") + " q-select--".concat(this.multiple === true ? 'multiple' : 'single');
    },
    computedInputClass: function computedInputClass() {
      if (this.hideSelected === true || this.innerValue.length === 0) {
        return this.inputClass;
      }
      return this.inputClass === void 0 ? 'q-field__input--padding' : [this.inputClass, 'q-field__input--padding'];
    },
    menuContentClass: function menuContentClass() {
      return (this.virtualScrollHorizontal === true ? 'q-virtual-scroll--horizontal' : '') + (this.popupContentClass ? ' ' + this.popupContentClass : '');
    },
    innerValue: function innerValue() {
      var _this2 = this;
      var mapNull = this.mapOptions === true && this.multiple !== true,
        val = this.value !== void 0 && (this.value !== null || mapNull === true) ? this.multiple === true && Array.isArray(this.value) ? this.value : [this.value] : [];
      if (this.mapOptions === true && Array.isArray(this.options) === true) {
        var _cache = this.mapOptions === true && this.innerValueCache !== void 0 ? this.innerValueCache : [];
        var values = val.map(function (v) {
          return _this2.__getOption(v, _cache);
        });
        return this.value === null && mapNull === true ? values.filter(function (v) {
          return v !== null;
        }) : values;
      }
      return val;
    },
    noOptions: function noOptions() {
      return this.virtualScrollLength === 0;
    },
    selectedString: function selectedString() {
      var _this3 = this;
      return this.innerValue.map(function (opt) {
        return _this3.getOptionLabel(opt);
      }).join(', ');
    },
    ariaCurrentValue: function ariaCurrentValue() {
      return this.displayValue !== void 0 ? this.displayValue : this.selectedString;
    },
    sanitizeFn: function sanitizeFn() {
      return this.optionsSanitize === true ? function () {
        return true;
      } : function (opt) {
        return opt !== void 0 && opt !== null && opt.sanitize === true;
      };
    },
    displayAsText: function displayAsText() {
      return this.displayValueSanitize === true || this.displayValue === void 0 && (this.optionsSanitize === true || this.innerValue.some(this.sanitizeFn));
    },
    computedTabindex: function computedTabindex() {
      return this.focused === true ? this.tabindex : -1;
    },
    selectedScope: function selectedScope() {
      var _this4 = this;
      return this.innerValue.map(function (opt, i) {
        return {
          index: i,
          opt: opt,
          sanitize: _this4.sanitizeFn(opt),
          selected: true,
          removeAtIndex: _this4.__removeAtIndexAndFocus,
          toggleOption: _this4.toggleOption,
          tabindex: _this4.computedTabindex
        };
      });
    },
    optionScope: function optionScope() {
      var _this5 = this;
      if (this.virtualScrollLength === 0) {
        return [];
      }
      var _this$virtualScrollSl = this.virtualScrollSliceRange,
        from = _this$virtualScrollSl.from,
        to = _this$virtualScrollSl.to;
      var _this$__optionScopeCa = this.__optionScopeCache,
        options = _this$__optionScopeCa.options,
        optionEls = _this$__optionScopeCa.optionEls;
      return this.options.slice(from, to).map(function (opt, i) {
        var disable = _this5.isOptionDisabled(opt);
        var index = from + i;
        var itemProps = {
          clickable: true,
          active: false,
          activeClass: _this5.computedOptionsSelectedClass,
          manualFocus: true,
          focused: false,
          disable: disable,
          tabindex: -1,
          dense: _this5.optionsDense,
          dark: _this5.isOptionsDark
        };
        var itemAttrs = {
          role: 'option',
          id: "".concat(_this5.targetUid, "_").concat(index)
        };
        if (disable !== true) {
          _this5.isOptionSelected(opt) === true && (itemProps.active = true);
          itemAttrs['aria-selected'] = itemProps.active === true ? 'true' : 'false';
          _this5.optionIndex === index && (itemProps.focused = true);
        }
        var itemEvents = {
          click: function click() {
            _this5.toggleOption(opt);
          }
        };
        if (_this5.$q.platform.is.desktop === true) {
          itemEvents.mousemove = function () {
            _this5.menu === true && _this5.setOptionIndex(index);
          };
        }
        var option = {
          index: index,
          opt: opt,
          sanitize: _this5.sanitizeFn(opt),
          selected: itemProps.active,
          focused: itemProps.focused,
          toggleOption: _this5.toggleOption,
          setOptionIndex: _this5.setOptionIndex,
          itemProps: itemProps,
          itemAttrs: itemAttrs
        };
        if (options[i] === void 0 || Object(is["a" /* isDeepEqual */])(option, options[i]) !== true) {
          options[i] = option;
          optionEls[i] = void 0;
        }
        return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, option), {}, {
          itemEvents: itemEvents
        });
      });
    },
    dropdownArrowIcon: function dropdownArrowIcon() {
      return this.dropdownIcon !== void 0 ? this.dropdownIcon : this.$q.iconSet.arrow.dropdown;
    },
    squaredMenu: function squaredMenu() {
      return this.optionsCover === false && this.outlined !== true && this.standout !== true && this.borderless !== true && this.rounded !== true;
    },
    computedOptionsSelectedClass: function computedOptionsSelectedClass() {
      return this.optionsSelectedClass !== void 0 ? this.optionsSelectedClass : this.color !== void 0 ? "text-".concat(this.color) : '';
    },
    innerOptionsValue: function innerOptionsValue() {
      var _this6 = this;
      return this.innerValue.map(function (opt) {
        return _this6.getOptionValue(opt);
      });
    },
    // returns method to get value of an option;
    // takes into account 'option-value' prop
    getOptionValue: function getOptionValue() {
      return this.__getPropValueFn('optionValue', 'value');
    },
    // returns method to get label of an option;
    // takes into account 'option-label' prop
    getOptionLabel: function getOptionLabel() {
      return this.__getPropValueFn('optionLabel', 'label');
    },
    // returns method to tell if an option is disabled;
    // takes into account 'option-disable' prop
    isOptionDisabled: function isOptionDisabled() {
      var fn = this.__getPropValueFn('optionDisable', 'disable');
      return function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return fn.apply(null, args) === true;
      };
    },
    inputControlEvents: function inputControlEvents() {
      var _this7 = this;
      var on = {
        input: this.__onInput,
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        change: this.__onChange,
        keydown: this.__onTargetKeydown,
        keyup: this.__onTargetAutocomplete,
        keypress: this.__onTargetKeypress,
        focus: this.__selectInputText,
        click: function click(e) {
          _this7.hasDialog === true && Object(utils_event["i" /* stop */])(e);
        }
      };
      on.compositionstart = on.compositionupdate = on.compositionend = this.__onComposition;
      return on;
    },
    virtualScrollItemSizeComputed: function virtualScrollItemSizeComputed() {
      return this.virtualScrollItemSize === void 0 ? this.optionsDense === true ? 24 : 48 : this.virtualScrollItemSize;
    },
    comboboxAttrs: function comboboxAttrs() {
      var attrs = {
        tabindex: this.tabindex,
        role: 'combobox',
        'aria-label': this.label,
        'aria-readonly': this.readonly === true ? 'true' : 'false',
        'aria-autocomplete': this.useInput === true ? 'list' : 'none',
        'aria-expanded': this.menu === true ? 'true' : 'false',
        'aria-controls': "".concat(this.targetUid, "_lb")
      };
      if (this.optionIndex >= 0) {
        attrs['aria-activedescendant'] = "".concat(this.targetUid, "_").concat(this.optionIndex);
      }
      return attrs;
    },
    listboxAttrs: function listboxAttrs() {
      return {
        id: "".concat(this.targetUid, "_lb"),
        role: 'listbox',
        'aria-multiselectable': this.multiple === true ? 'true' : 'false'
      };
    }
  },
  methods: {
    getEmittingOptionValue: function getEmittingOptionValue(opt) {
      return this.emitValue === true ? this.getOptionValue(opt) : opt;
    },
    removeAtIndex: function removeAtIndex(index) {
      if (index > -1 && index < this.innerValue.length) {
        if (this.multiple === true) {
          var model = this.value.slice();
          this.$emit('remove', {
            index: index,
            value: model.splice(index, 1)[0]
          });
          this.$emit('input', model);
        } else {
          this.$emit('input', null);
        }
      }
    },
    __removeAtIndexAndFocus: function __removeAtIndexAndFocus(index) {
      this.removeAtIndex(index);
      this.__focus();
    },
    add: function add(opt, unique) {
      var val = this.getEmittingOptionValue(opt);
      if (this.multiple !== true) {
        this.fillInput === true && this.updateInputValue(this.getOptionLabel(opt), true, true);
        this.$emit('input', val);
        return;
      }
      if (this.innerValue.length === 0) {
        this.$emit('add', {
          index: 0,
          value: val
        });
        this.$emit('input', this.multiple === true ? [val] : val);
        return;
      }
      if (unique === true && this.isOptionSelected(opt) === true) {
        return;
      }
      if (this.maxValues !== void 0 && this.value.length >= this.maxValues) {
        return;
      }
      var model = this.value.slice();
      this.$emit('add', {
        index: model.length,
        value: val
      });
      model.push(val);
      this.$emit('input', model);
    },
    toggleOption: function toggleOption(opt, keepOpen) {
      if (this.editable !== true || opt === void 0 || this.isOptionDisabled(opt) === true) {
        return;
      }
      var optValue = this.getOptionValue(opt);
      if (this.multiple !== true) {
        if (keepOpen !== true) {
          this.updateInputValue(this.fillInput === true ? this.getOptionLabel(opt) : '', true, true);
          this.dialogFieldFocused = false;
          document.activeElement.blur();
          this.hidePopup();
        }
        this.$refs.target !== void 0 && this.$refs.target.focus();
        if (this.innerValue.length === 0 || Object(is["a" /* isDeepEqual */])(this.getOptionValue(this.innerValue[0]), optValue) !== true) {
          this.$emit('input', this.emitValue === true ? optValue : opt);
        }
        return;
      }
      (this.hasDialog !== true || this.dialogFieldFocused === true) && this.__focus();
      this.__selectInputText();
      if (this.innerValue.length === 0) {
        var val = this.emitValue === true ? optValue : opt;
        this.$emit('add', {
          index: 0,
          value: val
        });
        this.$emit('input', this.multiple === true ? [val] : val);
        return;
      }
      var model = this.value.slice(),
        index = this.innerOptionsValue.findIndex(function (v) {
          return Object(is["a" /* isDeepEqual */])(v, optValue);
        });
      if (index > -1) {
        this.$emit('remove', {
          index: index,
          value: model.splice(index, 1)[0]
        });
      } else {
        if (this.maxValues !== void 0 && model.length >= this.maxValues) {
          return;
        }
        var _val = this.emitValue === true ? optValue : opt;
        this.$emit('add', {
          index: model.length,
          value: _val
        });
        model.push(_val);
      }
      this.$emit('input', model);
    },
    setOptionIndex: function setOptionIndex(index) {
      if (this.$q.platform.is.desktop !== true) {
        return;
      }
      var val = index > -1 && index < this.virtualScrollLength ? index : -1;
      if (this.optionIndex !== val) {
        this.optionIndex = val;
      }
    },
    moveOptionSelection: function moveOptionSelection() {
      var _this8 = this;
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var skipInputValue = arguments.length > 1 ? arguments[1] : undefined;
      if (this.menu === true) {
        var index = this.optionIndex;
        do {
          index = normalizeToInterval(index + offset, -1, this.virtualScrollLength - 1);
        } while (index !== -1 && index !== this.optionIndex && this.isOptionDisabled(this.options[index]) === true);
        if (this.optionIndex !== index) {
          cancelAnimationFrame(this.moveAnimationFrame);
          this.moveAnimationFrame = requestAnimationFrame(function () {
            _this8.setOptionIndex(index);
            _this8.scrollTo(index);
            if (skipInputValue !== true && _this8.useInput === true && _this8.fillInput === true) {
              _this8.__setInputValue(index >= 0 ? _this8.getOptionLabel(_this8.options[index]) : _this8.defaultInputValue);
            }
          });
        }
      }
    },
    __getOption: function __getOption(value, innerValueCache) {
      var _this9 = this;
      var fn = function fn(opt) {
        return Object(is["a" /* isDeepEqual */])(_this9.getOptionValue(opt), value);
      };
      return this.options.find(fn) || innerValueCache.find(fn) || value;
    },
    __getPropValueFn: function __getPropValueFn(propName, defaultVal) {
      var val = this[propName] !== void 0 ? this[propName] : defaultVal;
      return typeof val === 'function' ? val : function (opt) {
        return opt !== null && Object(esm_typeof["a" /* default */])(opt) === 'object' && val in opt ? opt[val] : opt;
      };
    },
    isOptionSelected: function isOptionSelected(opt) {
      var val = this.getOptionValue(opt);
      return this.innerOptionsValue.find(function (v) {
        return Object(is["a" /* isDeepEqual */])(v, val);
      }) !== void 0;
    },
    __selectInputText: function __selectInputText(e) {
      if (this.useInput === true && this.$refs.target !== void 0 && (e === void 0 || this.$refs.target === e.target && e.target.value === this.selectedString)) {
        this.$refs.target.select();
      }
    },
    __onTargetKeyup: function __onTargetKeyup(e) {
      // if ESC and we have an opened menu
      // then stop propagation (might be caught by a QDialog
      // and so it will also close the QDialog, which is wrong)
      if (Object(key_composition["a" /* isKeyCode */])(e, 27) === true && this.menu === true) {
        Object(utils_event["i" /* stop */])(e);
        // on ESC we need to close the dialog also
        this.hidePopup();
        this.__resetInputValue();
      }
      this.$emit('keyup', e);
    },
    __onTargetAutocomplete: function __onTargetAutocomplete(e) {
      var _this10 = this;
      var value = e.target.value;
      if (e.keyCode !== void 0) {
        this.__onTargetKeyup(e);
        return;
      }
      e.target.value = '';
      clearTimeout(this.inputTimer);
      this.__resetInputValue();
      if (typeof value === 'string' && value.length > 0) {
        var needle = value.toLocaleLowerCase();
        var findFn = function findFn(extractFn) {
          var option = _this10.options.find(function (opt) {
            return extractFn(opt).toLocaleLowerCase() === needle;
          });
          if (option === void 0) {
            return false;
          }
          if (_this10.innerValue.indexOf(option) === -1) {
            _this10.toggleOption(option);
          } else {
            _this10.hidePopup();
          }
          return true;
        };
        var fillFn = function fillFn(afterFilter) {
          if (findFn(_this10.getOptionValue) === true) {
            return;
          }
          if (findFn(_this10.getOptionLabel) === true || afterFilter === true) {
            return;
          }
          _this10.filter(value, true, function () {
            return fillFn(true);
          });
        };
        fillFn();
      } else {
        this.__clearValue(e);
      }
    },
    __onTargetKeypress: function __onTargetKeypress(e) {
      this.$emit('keypress', e);
    },
    __onTargetKeydown: function __onTargetKeydown(e) {
      var _this11 = this;
      this.$emit('keydown', e);
      if (Object(key_composition["c" /* shouldIgnoreKey */])(e) === true) {
        return;
      }
      var newValueModeValid = this.inputValue.length > 0 && (this.newValueMode !== void 0 || this.qListeners['new-value'] !== void 0);
      var tabShouldSelect = e.shiftKey !== true && this.multiple !== true && (this.optionIndex > -1 || newValueModeValid === true);

      // escape
      if (e.keyCode === 27) {
        Object(utils_event["h" /* prevent */])(e); // prevent clearing the inputValue
        return;
      }

      // tab
      if (e.keyCode === 9 && tabShouldSelect === false) {
        this.__closeMenu();
        return;
      }
      if (e.target === void 0 || e.target.id !== this.targetUid) {
        return;
      }

      // down
      if (e.keyCode === 40 && this.innerLoading !== true && this.menu === false) {
        Object(utils_event["j" /* stopAndPrevent */])(e);
        this.showPopup();
        return;
      }

      // backspace
      if (e.keyCode === 8 && this.hideSelected !== true && this.inputValue.length === 0) {
        if (this.multiple === true && Array.isArray(this.value)) {
          this.removeAtIndex(this.value.length - 1);
        } else if (this.multiple !== true && this.value !== null) {
          this.$emit('input', null);
        }
        return;
      }

      // home, end - 36, 35
      if ((e.keyCode === 35 || e.keyCode === 36) && (typeof this.inputValue !== 'string' || this.inputValue.length === 0)) {
        Object(utils_event["j" /* stopAndPrevent */])(e);
        this.optionIndex = -1;
        this.moveOptionSelection(e.keyCode === 36 ? 1 : -1, this.multiple);
      }

      // pg up, pg down - 33, 34
      if ((e.keyCode === 33 || e.keyCode === 34) && this.virtualScrollSliceSizeComputed !== void 0) {
        Object(utils_event["j" /* stopAndPrevent */])(e);
        this.optionIndex = Math.max(-1, Math.min(this.virtualScrollLength, this.optionIndex + (e.keyCode === 33 ? -1 : 1) * this.virtualScrollSliceSizeComputed.view));
        this.moveOptionSelection(e.keyCode === 33 ? 1 : -1, this.multiple);
      }

      // up, down
      if (e.keyCode === 38 || e.keyCode === 40) {
        Object(utils_event["j" /* stopAndPrevent */])(e);
        this.moveOptionSelection(e.keyCode === 38 ? -1 : 1, this.multiple);
      }
      var optionsLength = this.virtualScrollLength;

      // clear search buffer if expired
      if (this.searchBuffer === void 0 || this.searchBufferExp < Date.now()) {
        this.searchBuffer = '';
      }

      // keyboard search when not having use-input
      if (optionsLength > 0 && this.useInput !== true && e.key !== void 0 && e.key.length === 1 &&
      // printable char
      e.altKey === false &&
      // not kbd shortcut
      e.ctrlKey === false &&
      // not kbd shortcut
      e.metaKey === false && (
      // not kbd shortcut, especially on macOS with Command key
      e.keyCode !== 32 || this.searchBuffer.length > 0) // space in middle of search
      ) {
        this.menu !== true && this.showPopup(e);
        var char = e.key.toLocaleLowerCase(),
          keyRepeat = this.searchBuffer.length === 1 && this.searchBuffer[0] === char;
        this.searchBufferExp = Date.now() + 1500;
        if (keyRepeat === false) {
          Object(utils_event["j" /* stopAndPrevent */])(e);
          this.searchBuffer += char;
        }
        var searchRe = new RegExp('^' + this.searchBuffer.split('').map(function (l) {
          return reEscapeList.indexOf(l) > -1 ? '\\' + l : l;
        }).join('.*'), 'i');
        var index = this.optionIndex;
        if (keyRepeat === true || index < 0 || searchRe.test(this.getOptionLabel(this.options[index])) !== true) {
          do {
            index = normalizeToInterval(index + 1, -1, optionsLength - 1);
          } while (index !== this.optionIndex && (this.isOptionDisabled(this.options[index]) === true || searchRe.test(this.getOptionLabel(this.options[index])) !== true));
        }
        if (this.optionIndex !== index) {
          this.$nextTick(function () {
            _this11.setOptionIndex(index);
            _this11.scrollTo(index);
            if (index >= 0 && _this11.useInput === true && _this11.fillInput === true) {
              _this11.__setInputValue(_this11.getOptionLabel(_this11.options[index]));
            }
          });
        }
        return;
      }

      // enter, space (when not using use-input and not in search), or tab (when not using multiple and option selected)
      // same target is checked above
      if (e.keyCode !== 13 && (e.keyCode !== 32 || this.useInput === true || this.searchBuffer !== '') && (e.keyCode !== 9 || tabShouldSelect === false)) {
        return;
      }
      e.keyCode !== 9 && Object(utils_event["j" /* stopAndPrevent */])(e);
      if (this.optionIndex > -1 && this.optionIndex < optionsLength) {
        this.toggleOption(this.options[this.optionIndex]);
        return;
      }
      if (newValueModeValid === true) {
        var done = function done(val, mode) {
          if (mode) {
            if (validateNewValueMode(mode) !== true) {
              return;
            }
          } else {
            mode = _this11.newValueMode;
          }
          if (val === void 0 || val === null) {
            return;
          }
          _this11.updateInputValue('', _this11.multiple !== true, true);
          _this11[mode === 'toggle' ? 'toggleOption' : 'add'](val, mode === 'add-unique');
          if (_this11.multiple !== true) {
            _this11.$refs.target !== void 0 && _this11.$refs.target.focus();
            _this11.hidePopup();
          }
        };
        if (this.qListeners['new-value'] !== void 0) {
          this.$emit('new-value', this.inputValue, done);
        } else {
          done(this.inputValue);
        }
        if (this.multiple !== true) {
          return;
        }
      }
      if (this.menu === true) {
        this.__closeMenu();
      } else if (this.innerLoading !== true) {
        this.showPopup();
      }
    },
    __getVirtualScrollEl: function __getVirtualScrollEl() {
      return this.hasDialog === true ? this.$refs.menuContent : this.$refs.menu !== void 0 && this.$refs.menu.__portal !== void 0 ? this.$refs.menu.__portal.$el : void 0;
    },
    __getVirtualScrollTarget: function __getVirtualScrollTarget() {
      return this.__getVirtualScrollEl();
    },
    __getSelection: function __getSelection(h) {
      var _this12 = this;
      if (this.hideSelected === true) {
        return [];
      }
      if (this.$scopedSlots['selected-item'] !== void 0) {
        return this.selectedScope.map(function (scope) {
          return _this12.$scopedSlots['selected-item'](scope);
        }).slice();
      }
      if (this.$scopedSlots.selected !== void 0) {
        return [].concat(this.$scopedSlots.selected());
      }
      if (this.useChips === true) {
        return this.selectedScope.map(function (scope, i) {
          return h(QChip, {
            key: 'rem#' + i,
            props: {
              removable: _this12.editable === true && _this12.isOptionDisabled(scope.opt) !== true,
              dense: true,
              textColor: _this12.color,
              tabindex: _this12.computedTabindex
            },
            on: Object(cache["a" /* default */])(_this12, 'rem#' + i, {
              remove: function remove() {
                scope.removeAtIndex(i);
              }
            })
          }, [h('span', {
            staticClass: 'ellipsis',
            domProps: Object(defineProperty["a" /* default */])({}, scope.sanitize === true ? 'textContent' : 'innerHTML', _this12.getOptionLabel(scope.opt))
          })]);
        });
      }
      return [h('span', {
        domProps: Object(defineProperty["a" /* default */])({}, this.displayAsText ? 'textContent' : 'innerHTML', this.ariaCurrentValue)
      })];
    },
    __getControl: function __getControl(h, fromDialog) {
      var child = this.__getSelection(h);
      var isTarget = fromDialog === true || this.dialog !== true || this.hasDialog !== true;
      if (this.useInput === true) {
        child.push(this.__getInput(h, fromDialog, isTarget));
      }
      // there can be only one (when dialog is opened the control in dialog should be target)
      else if (this.editable === true) {
        var _attrs = isTarget === true ? this.comboboxAttrs : void 0;
        child.push(h('input', {
          ref: isTarget === true ? 'target' : void 0,
          key: 'd_t',
          staticClass: 'q-select__focus-target',
          attrs: Object(objectSpread2["a" /* default */])({
            id: isTarget === true ? this.targetUid : void 0,
            readonly: true,
            'data-autofocus': (fromDialog === true ? isTarget === true : this.autofocus) || void 0
          }, _attrs),
          on: Object(cache["a" /* default */])(this, 'f-tget', {
            keydown: this.__onTargetKeydown,
            keyup: this.__onTargetKeyup,
            keypress: this.__onTargetKeypress
          })
        }));
        if (isTarget === true && typeof this.autocomplete === 'string' && this.autocomplete.length > 0) {
          child.push(h('input', {
            key: 'autoinp',
            staticClass: 'q-select__autocomplete-input',
            domProps: {
              value: this.ariaCurrentValue
            },
            attrs: {
              autocomplete: this.autocomplete,
              tabindex: -1
            },
            on: Object(cache["a" /* default */])(this, 'autoinp', {
              keyup: this.__onTargetAutocomplete
            })
          }));
        }
      }
      if (this.nameProp !== void 0 && this.disable !== true && this.innerOptionsValue.length > 0) {
        var opts = this.innerOptionsValue.map(function (value) {
          return h('option', {
            attrs: {
              value: value,
              selected: true
            }
          });
        });
        child.push(h('select', {
          staticClass: 'hidden',
          attrs: {
            name: this.nameProp,
            multiple: this.multiple
          }
        }, opts));
      }
      var attrs = this.useInput === true || isTarget !== true ? void 0 : this.qAttrs;
      return h('div', {
        staticClass: 'q-field__native row items-center',
        attrs: attrs
      }, child);
    },
    __getOptions: function __getOptions(h) {
      var _this13 = this;
      if (this.menu !== true) {
        return void 0;
      }
      if (this.noOptions === true) {
        return this.$scopedSlots['no-option'] !== void 0 ? this.$scopedSlots['no-option']({
          inputValue: this.inputValue
        }) : void 0;
      }
      if (this.$scopedSlots.option !== void 0 && this.__optionScopeCache.optionSlot !== this.$scopedSlots.option) {
        this.__optionScopeCache.optionSlot = this.$scopedSlots.option;
        this.__optionScopeCache.optionEls = [];
      }
      var fn = this.$scopedSlots.option !== void 0 ? this.$scopedSlots.option : function (scope) {
        return h(QItem["a" /* default */], {
          key: scope.index,
          props: scope.itemProps,
          attrs: scope.itemAttrs,
          on: scope.itemEvents
        }, [h(QItemSection["a" /* default */], [h(QItemLabel["a" /* default */], {
          domProps: Object(defineProperty["a" /* default */])({}, scope.sanitize === true ? 'textContent' : 'innerHTML', _this13.getOptionLabel(scope.opt))
        })])]);
      };
      var optionEls = this.__optionScopeCache.optionEls;
      var options = this.__padVirtualScroll(h, 'div', this.optionScope.map(function (scope, i) {
        if (optionEls[i] === void 0) {
          optionEls[i] = fn(scope);
        }
        return optionEls[i];
      }));
      if (this.$scopedSlots['before-options'] !== void 0) {
        options = this.$scopedSlots['before-options']().concat(options);
      }
      return Object(slot["a" /* mergeSlot */])(options, this, 'after-options');
    },
    __getInnerAppend: function __getInnerAppend(h) {
      return this.loading !== true && this.innerLoadingIndicator !== true && this.hideDropdownIcon !== true ? [h(QIcon["a" /* default */], {
        staticClass: 'q-select__dropdown-icon' + (this.menu === true ? ' rotate-180' : ''),
        props: {
          name: this.dropdownArrowIcon
        }
      })] : null;
    },
    __getInput: function __getInput(h, fromDialog, isTarget) {
      var attrs = isTarget === true ? Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.comboboxAttrs), this.qAttrs) : void 0;
      var options = {
        ref: isTarget === true ? 'target' : void 0,
        key: 'i_t',
        staticClass: 'q-field__input q-placeholder col',
        style: this.inputStyle,
        class: this.computedInputClass,
        domProps: {
          value: this.inputValue !== void 0 ? this.inputValue : ''
        },
        attrs: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({
          // required for Android in order to show ENTER key when in form
          type: 'search'
        }, attrs), {}, {
          id: isTarget === true ? this.targetUid : void 0,
          maxlength: this.maxlength,
          // this is converted to prop by QField
          autocomplete: this.autocomplete,
          'data-autofocus': (fromDialog === true ? isTarget === true : this.autofocus) || void 0,
          disabled: this.disable === true,
          readonly: this.readonly === true
        }),
        on: this.inputControlEvents
      };
      if (fromDialog !== true && this.hasDialog === true) {
        options.staticClass += ' no-pointer-events';
      }
      return h('input', options);
    },
    __onChange: function __onChange(e) {
      this.__onComposition(e);
    },
    __onInput: function __onInput(e) {
      var _this14 = this;
      clearTimeout(this.inputTimer);
      if (e && e.target && e.target.qComposing === true) {
        return;
      }
      this.__setInputValue(e.target.value || '');
      // mark it here as user input so that if updateInputValue is called
      // before filter is called the indicator is reset
      this.userInputValue = true;
      this.defaultInputValue = this.inputValue;
      if (this.focused !== true && (this.hasDialog !== true || this.dialogFieldFocused === true)) {
        this.__focus();
      }
      if (this.qListeners.filter !== void 0) {
        this.inputTimer = setTimeout(function () {
          _this14.filter(_this14.inputValue);
        }, this.inputDebounce);
      }
    },
    __setInputValue: function __setInputValue(inputValue) {
      if (this.inputValue !== inputValue) {
        this.inputValue = inputValue;
        this.$emit('input-value', inputValue);
      }
    },
    updateInputValue: function updateInputValue(val, noFiltering, internal) {
      this.userInputValue = internal !== true;
      if (this.useInput === true) {
        this.__setInputValue(val);
        if (noFiltering === true || internal !== true) {
          this.defaultInputValue = val;
        }
        noFiltering !== true && this.filter(val);
      }
    },
    filter: function filter(val, keepClosed, afterUpdateFn) {
      var _this15 = this;
      if (this.qListeners.filter === void 0 || keepClosed !== true && this.focused !== true) {
        return;
      }
      if (this.innerLoading === true) {
        this.$emit('filter-abort');
      } else {
        this.innerLoading = true;
        this.innerLoadingIndicator = true;
      }
      if (val !== '' && this.multiple !== true && this.innerValue.length > 0 && this.userInputValue !== true && val === this.getOptionLabel(this.innerValue[0])) {
        val = '';
      }
      var filterId = setTimeout(function () {
        _this15.menu === true && (_this15.menu = false);
      }, 10);
      clearTimeout(this.filterId);
      this.filterId = filterId;
      this.$emit('filter', val, function (fn, afterFn) {
        if ((keepClosed === true || _this15.focused === true) && _this15.filterId === filterId) {
          clearTimeout(_this15.filterId);
          typeof fn === 'function' && fn();

          // hide indicator to allow arrow to animate
          _this15.innerLoadingIndicator = false;
          _this15.$nextTick(function () {
            _this15.innerLoading = false;
            if (_this15.editable === true) {
              if (keepClosed === true) {
                _this15.menu === true && _this15.hidePopup();
              } else if (_this15.menu === true) {
                _this15.__updateMenu(true);
              } else {
                _this15.menu = true;
                _this15.hasDialog === true && (_this15.dialog = true);
              }
            }
            typeof afterFn === 'function' && _this15.$nextTick(function () {
              afterFn(_this15);
            });
            typeof afterUpdateFn === 'function' && _this15.$nextTick(function () {
              afterUpdateFn(_this15);
            });
          });
        }
      }, function () {
        if (_this15.focused === true && _this15.filterId === filterId) {
          clearTimeout(_this15.filterId);
          _this15.innerLoading = false;
          _this15.innerLoadingIndicator = false;
        }
        _this15.menu === true && (_this15.menu = false);
      });
    },
    __getControlEvents: function __getControlEvents() {
      var _this16 = this;
      var focusout = function focusout(e) {
        _this16.__onControlFocusout(e, function () {
          _this16.__resetInputValue();
          _this16.__closeMenu();
        });
      };
      return {
        focusin: this.__onControlFocusin,
        focusout: focusout,
        'popup-show': this.__onControlPopupShow,
        'popup-hide': function popupHide(e) {
          e !== void 0 && Object(utils_event["i" /* stop */])(e);
          _this16.$emit('popup-hide', e);
          _this16.hasPopupOpen = false;
          focusout(e);
        },
        click: function click(e) {
          // label from QField will propagate click on the input (except IE)
          Object(utils_event["h" /* prevent */])(e);
          if (_this16.hasDialog !== true && _this16.menu === true) {
            _this16.__closeMenu();
            _this16.$refs.target !== void 0 && _this16.$refs.target.focus();
            return;
          }
          _this16.showPopup(e);
        }
      };
    },
    __getControlChild: function __getControlChild(h) {
      if (this.editable !== false && (this.dialog === true ||
      // dialog always has menu displayed, so need to render it
      this.noOptions !== true || this.$scopedSlots['no-option'] !== void 0)) {
        return this["__get".concat(this.hasDialog === true ? 'Dialog' : 'Menu')](h);
      }
    },
    __getMenu: function __getMenu(h) {
      return h(QMenu["a" /* default */], {
        key: 'menu',
        ref: 'menu',
        props: {
          value: this.menu,
          fit: this.menuShrink !== true,
          cover: this.optionsCover === true && this.noOptions !== true && this.useInput !== true,
          anchor: this.menuAnchor,
          self: this.menuSelf,
          offset: this.menuOffset,
          contentClass: this.menuContentClass,
          contentStyle: this.popupContentStyle,
          dark: this.isOptionsDark,
          noParentEvent: true,
          noRefocus: true,
          noFocus: true,
          square: this.squaredMenu,
          transitionShow: this.transitionShow,
          transitionHide: this.transitionHide,
          separateClosePopup: true
        },
        attrs: this.listboxAttrs,
        on: Object(cache["a" /* default */])(this, 'menu', {
          '&scroll': this.__onVirtualScrollEvt,
          'before-hide': this.__closeMenu,
          show: this.__onMenuShow
        })
      }, this.__getOptions(h));
    },
    __onMenuShow: function __onMenuShow() {
      this.__setVirtualScrollSize();
    },
    __onDialogFieldFocus: function __onDialogFieldFocus(e) {
      Object(utils_event["i" /* stop */])(e);
      this.$refs.target !== void 0 && this.$refs.target.focus();
      this.dialogFieldFocused = true;
      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0);
    },
    __onDialogFieldBlur: function __onDialogFieldBlur(e) {
      var _this17 = this;
      Object(utils_event["i" /* stop */])(e);
      this.$nextTick(function () {
        _this17.dialogFieldFocused = false;
      });
    },
    __getDialog: function __getDialog(h) {
      var _this18 = this;
      var content = [h(QField["a" /* default */], {
        staticClass: "col-auto ".concat(this.fieldClass),
        props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.$props), {}, {
          for: this.targetUid,
          dark: this.isOptionsDark,
          square: true,
          filled: true,
          itemAligned: false,
          loading: this.innerLoadingIndicator,
          stackLabel: this.inputValue.length > 0
        }),
        on: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.qListeners), {}, {
          focus: this.__onDialogFieldFocus,
          blur: this.__onDialogFieldBlur
        }),
        scopedSlots: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.$scopedSlots), {}, {
          rawControl: function rawControl() {
            return _this18.__getControl(h, true);
          },
          before: void 0,
          after: void 0
        })
      })];
      this.menu === true && content.push(h('div', {
        key: 'virtMenu',
        ref: 'menuContent',
        staticClass: 'col scroll',
        class: this.menuContentClass,
        style: this.popupContentStyle,
        attrs: this.listboxAttrs,
        on: Object(cache["a" /* default */])(this, 'virtMenu', {
          click: utils_event["h" /* prevent */],
          '&scroll': this.__onVirtualScrollEvt
        })
      }, this.__getOptions(h)));
      return h(QDialog["a" /* default */], {
        key: 'dialog',
        ref: 'dialog',
        props: {
          value: this.dialog,
          dark: this.isOptionsDark,
          position: this.useInput === true ? 'top' : void 0,
          transitionShow: this.transitionShowComputed,
          transitionHide: this.transitionHide
        },
        on: Object(cache["a" /* default */])(this, 'dialog', {
          'before-hide': this.__onDialogBeforeHide,
          hide: this.__onDialogHide,
          show: this.__onDialogShow
        })
      }, [h('div', {
        staticClass: 'q-select__dialog' + (this.isOptionsDark === true ? ' q-select__dialog--dark q-dark' : '') + (this.dialogFieldFocused === true ? ' q-select__dialog--focused' : '')
      }, content)]);
    },
    __onDialogBeforeHide: function __onDialogBeforeHide() {
      if (this.useInput !== true || this.$q.platform.is.desktop === true) {
        this.$refs.dialog.__refocusTarget = this.$el.querySelector('.q-field__native > [tabindex]:last-child');
      }
      this.focused = false;
      this.dialogFieldFocused = false;
    },
    __onDialogHide: function __onDialogHide(e) {
      if (this.$q.platform.is.desktop !== true) {
        document.activeElement.blur();
      }
      this.hidePopup();
      this.focused === false && this.$emit('blur', e);
      this.__resetInputValue();
    },
    __onDialogShow: function __onDialogShow() {
      var el = document.activeElement;
      // IE can have null document.activeElement
      if ((el === null || el.id !== this.targetUid) && this.$refs.target !== el && this.$refs.target !== void 0) {
        this.$refs.target.focus();
      }
      this.__setVirtualScrollSize();
    },
    __closeMenu: function __closeMenu() {
      if (this.__optionScopeCache !== void 0) {
        this.__optionScopeCache.optionEls = [];
      }
      if (this.dialog === true) {
        return;
      }
      this.optionIndex = -1;
      if (this.menu === true) {
        this.menu = false;
      }
      if (this.focused === false) {
        clearTimeout(this.filterId);
        this.filterId = void 0;
        if (this.innerLoading === true) {
          this.$emit('filter-abort');
          this.innerLoading = false;
          this.innerLoadingIndicator = false;
        }
      }
    },
    showPopup: function showPopup(e) {
      var _this19 = this;
      if (this.editable !== true) {
        return;
      }
      if (this.hasDialog === true) {
        this.__onControlFocusin(e);
        this.dialog = true;
        this.$nextTick(function () {
          _this19.__focus();
        });
      } else {
        this.__focus();
      }
      if (this.qListeners.filter !== void 0) {
        this.filter(this.inputValue);
      } else if (this.noOptions !== true || this.$scopedSlots['no-option'] !== void 0) {
        this.menu = true;
      }
    },
    hidePopup: function hidePopup() {
      this.dialog = false;
      this.__closeMenu();
    },
    __resetInputValue: function __resetInputValue() {
      this.useInput === true && this.updateInputValue(this.multiple !== true && this.fillInput === true && this.innerValue.length > 0 ? this.getOptionLabel(this.innerValue[0]) || '' : '', true, true);
    },
    __updateMenu: function __updateMenu(show) {
      var _this20 = this;
      var optionIndex = -1;
      if (show === true) {
        if (this.innerValue.length > 0) {
          var val = this.getOptionValue(this.innerValue[0]);
          optionIndex = this.options.findIndex(function (v) {
            return Object(is["a" /* isDeepEqual */])(_this20.getOptionValue(v), val);
          });
        }
        this.__resetVirtualScroll(optionIndex);
      }
      this.setOptionIndex(optionIndex);
    },
    __onPreRender: function __onPreRender() {
      this.hasDialog = this.$q.platform.is.mobile !== true && this.behavior !== 'dialog' ? false : this.behavior !== 'menu' && (this.useInput === true ? this.$scopedSlots['no-option'] !== void 0 || this.qListeners.filter !== void 0 || this.noOptions === false : true);
      this.transitionShowComputed = this.hasDialog === true && this.useInput === true && this.$q.platform.is.ios === true ? 'fade' : this.transitionShow;
    },
    __onPostRender: function __onPostRender() {
      if (this.dialog === false && this.$refs.menu !== void 0) {
        this.$refs.menu.updatePosition();
      }
    },
    updateMenuPosition: function updateMenuPosition() {
      this.__onPostRender();
    }
  },
  beforeMount: function beforeMount() {
    this.__optionScopeCache = {
      optionSlot: this.$scopedSlots.option,
      options: [],
      optionEls: []
    };
  },
  beforeDestroy: function beforeDestroy() {
    this.__optionScopeCache = void 0;
    clearTimeout(this.inputTimer);
  }
}));

/***/ }),

/***/ "df06":
/***/ (function(module, exports) {

/*
Language: GLSL
Description: OpenGL Shading Language
Author: Sergey Tikhomirov <sergey@tikhomirov.io>
Website: https://en.wikipedia.org/wiki/OpenGL_Shading_Language
Category: graphics
*/

function glsl(hljs) {
  return {
    name: 'GLSL',
    keywords: {
      keyword:
        // Statements
        'break continue discard do else for if return while switch case default ' +
        // Qualifiers
        'attribute binding buffer ccw centroid centroid varying coherent column_major const cw ' +
        'depth_any depth_greater depth_less depth_unchanged early_fragment_tests equal_spacing ' +
        'flat fractional_even_spacing fractional_odd_spacing highp in index inout invariant ' +
        'invocations isolines layout line_strip lines lines_adjacency local_size_x local_size_y ' +
        'local_size_z location lowp max_vertices mediump noperspective offset origin_upper_left ' +
        'out packed patch pixel_center_integer point_mode points precise precision quads r11f_g11f_b10f ' +
        'r16 r16_snorm r16f r16i r16ui r32f r32i r32ui r8 r8_snorm r8i r8ui readonly restrict ' +
        'rg16 rg16_snorm rg16f rg16i rg16ui rg32f rg32i rg32ui rg8 rg8_snorm rg8i rg8ui rgb10_a2 ' +
        'rgb10_a2ui rgba16 rgba16_snorm rgba16f rgba16i rgba16ui rgba32f rgba32i rgba32ui rgba8 ' +
        'rgba8_snorm rgba8i rgba8ui row_major sample shared smooth std140 std430 stream triangle_strip ' +
        'triangles triangles_adjacency uniform varying vertices volatile writeonly',
      type:
        'atomic_uint bool bvec2 bvec3 bvec4 dmat2 dmat2x2 dmat2x3 dmat2x4 dmat3 dmat3x2 dmat3x3 ' +
        'dmat3x4 dmat4 dmat4x2 dmat4x3 dmat4x4 double dvec2 dvec3 dvec4 float iimage1D iimage1DArray ' +
        'iimage2D iimage2DArray iimage2DMS iimage2DMSArray iimage2DRect iimage3D iimageBuffer ' +
        'iimageCube iimageCubeArray image1D image1DArray image2D image2DArray image2DMS image2DMSArray ' +
        'image2DRect image3D imageBuffer imageCube imageCubeArray int isampler1D isampler1DArray ' +
        'isampler2D isampler2DArray isampler2DMS isampler2DMSArray isampler2DRect isampler3D ' +
        'isamplerBuffer isamplerCube isamplerCubeArray ivec2 ivec3 ivec4 mat2 mat2x2 mat2x3 ' +
        'mat2x4 mat3 mat3x2 mat3x3 mat3x4 mat4 mat4x2 mat4x3 mat4x4 sampler1D sampler1DArray ' +
        'sampler1DArrayShadow sampler1DShadow sampler2D sampler2DArray sampler2DArrayShadow ' +
        'sampler2DMS sampler2DMSArray sampler2DRect sampler2DRectShadow sampler2DShadow sampler3D ' +
        'samplerBuffer samplerCube samplerCubeArray samplerCubeArrayShadow samplerCubeShadow ' +
        'image1D uimage1DArray uimage2D uimage2DArray uimage2DMS uimage2DMSArray uimage2DRect ' +
        'uimage3D uimageBuffer uimageCube uimageCubeArray uint usampler1D usampler1DArray ' +
        'usampler2D usampler2DArray usampler2DMS usampler2DMSArray usampler2DRect usampler3D ' +
        'samplerBuffer usamplerCube usamplerCubeArray uvec2 uvec3 uvec4 vec2 vec3 vec4 void',
      built_in:
        // Constants
        'gl_MaxAtomicCounterBindings gl_MaxAtomicCounterBufferSize gl_MaxClipDistances gl_MaxClipPlanes ' +
        'gl_MaxCombinedAtomicCounterBuffers gl_MaxCombinedAtomicCounters gl_MaxCombinedImageUniforms ' +
        'gl_MaxCombinedImageUnitsAndFragmentOutputs gl_MaxCombinedTextureImageUnits gl_MaxComputeAtomicCounterBuffers ' +
        'gl_MaxComputeAtomicCounters gl_MaxComputeImageUniforms gl_MaxComputeTextureImageUnits ' +
        'gl_MaxComputeUniformComponents gl_MaxComputeWorkGroupCount gl_MaxComputeWorkGroupSize ' +
        'gl_MaxDrawBuffers gl_MaxFragmentAtomicCounterBuffers gl_MaxFragmentAtomicCounters ' +
        'gl_MaxFragmentImageUniforms gl_MaxFragmentInputComponents gl_MaxFragmentInputVectors ' +
        'gl_MaxFragmentUniformComponents gl_MaxFragmentUniformVectors gl_MaxGeometryAtomicCounterBuffers ' +
        'gl_MaxGeometryAtomicCounters gl_MaxGeometryImageUniforms gl_MaxGeometryInputComponents ' +
        'gl_MaxGeometryOutputComponents gl_MaxGeometryOutputVertices gl_MaxGeometryTextureImageUnits ' +
        'gl_MaxGeometryTotalOutputComponents gl_MaxGeometryUniformComponents gl_MaxGeometryVaryingComponents ' +
        'gl_MaxImageSamples gl_MaxImageUnits gl_MaxLights gl_MaxPatchVertices gl_MaxProgramTexelOffset ' +
        'gl_MaxTessControlAtomicCounterBuffers gl_MaxTessControlAtomicCounters gl_MaxTessControlImageUniforms ' +
        'gl_MaxTessControlInputComponents gl_MaxTessControlOutputComponents gl_MaxTessControlTextureImageUnits ' +
        'gl_MaxTessControlTotalOutputComponents gl_MaxTessControlUniformComponents ' +
        'gl_MaxTessEvaluationAtomicCounterBuffers gl_MaxTessEvaluationAtomicCounters ' +
        'gl_MaxTessEvaluationImageUniforms gl_MaxTessEvaluationInputComponents gl_MaxTessEvaluationOutputComponents ' +
        'gl_MaxTessEvaluationTextureImageUnits gl_MaxTessEvaluationUniformComponents ' +
        'gl_MaxTessGenLevel gl_MaxTessPatchComponents gl_MaxTextureCoords gl_MaxTextureImageUnits ' +
        'gl_MaxTextureUnits gl_MaxVaryingComponents gl_MaxVaryingFloats gl_MaxVaryingVectors ' +
        'gl_MaxVertexAtomicCounterBuffers gl_MaxVertexAtomicCounters gl_MaxVertexAttribs gl_MaxVertexImageUniforms ' +
        'gl_MaxVertexOutputComponents gl_MaxVertexOutputVectors gl_MaxVertexTextureImageUnits ' +
        'gl_MaxVertexUniformComponents gl_MaxVertexUniformVectors gl_MaxViewports gl_MinProgramTexelOffset ' +
        // Variables
        'gl_BackColor gl_BackLightModelProduct gl_BackLightProduct gl_BackMaterial ' +
        'gl_BackSecondaryColor gl_ClipDistance gl_ClipPlane gl_ClipVertex gl_Color ' +
        'gl_DepthRange gl_EyePlaneQ gl_EyePlaneR gl_EyePlaneS gl_EyePlaneT gl_Fog gl_FogCoord ' +
        'gl_FogFragCoord gl_FragColor gl_FragCoord gl_FragData gl_FragDepth gl_FrontColor ' +
        'gl_FrontFacing gl_FrontLightModelProduct gl_FrontLightProduct gl_FrontMaterial ' +
        'gl_FrontSecondaryColor gl_GlobalInvocationID gl_InstanceID gl_InvocationID gl_Layer gl_LightModel ' +
        'gl_LightSource gl_LocalInvocationID gl_LocalInvocationIndex gl_ModelViewMatrix ' +
        'gl_ModelViewMatrixInverse gl_ModelViewMatrixInverseTranspose gl_ModelViewMatrixTranspose ' +
        'gl_ModelViewProjectionMatrix gl_ModelViewProjectionMatrixInverse gl_ModelViewProjectionMatrixInverseTranspose ' +
        'gl_ModelViewProjectionMatrixTranspose gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 ' +
        'gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 ' +
        'gl_Normal gl_NormalMatrix gl_NormalScale gl_NumSamples gl_NumWorkGroups gl_ObjectPlaneQ ' +
        'gl_ObjectPlaneR gl_ObjectPlaneS gl_ObjectPlaneT gl_PatchVerticesIn gl_Point gl_PointCoord ' +
        'gl_PointSize gl_Position gl_PrimitiveID gl_PrimitiveIDIn gl_ProjectionMatrix gl_ProjectionMatrixInverse ' +
        'gl_ProjectionMatrixInverseTranspose gl_ProjectionMatrixTranspose gl_SampleID gl_SampleMask ' +
        'gl_SampleMaskIn gl_SamplePosition gl_SecondaryColor gl_TessCoord gl_TessLevelInner gl_TessLevelOuter ' +
        'gl_TexCoord gl_TextureEnvColor gl_TextureMatrix gl_TextureMatrixInverse gl_TextureMatrixInverseTranspose ' +
        'gl_TextureMatrixTranspose gl_Vertex gl_VertexID gl_ViewportIndex gl_WorkGroupID gl_WorkGroupSize gl_in gl_out ' +
        // Functions
        'EmitStreamVertex EmitVertex EndPrimitive EndStreamPrimitive abs acos acosh all any asin ' +
        'asinh atan atanh atomicAdd atomicAnd atomicCompSwap atomicCounter atomicCounterDecrement ' +
        'atomicCounterIncrement atomicExchange atomicMax atomicMin atomicOr atomicXor barrier ' +
        'bitCount bitfieldExtract bitfieldInsert bitfieldReverse ceil clamp cos cosh cross ' +
        'dFdx dFdy degrees determinant distance dot equal exp exp2 faceforward findLSB findMSB ' +
        'floatBitsToInt floatBitsToUint floor fma fract frexp ftransform fwidth greaterThan ' +
        'greaterThanEqual groupMemoryBarrier imageAtomicAdd imageAtomicAnd imageAtomicCompSwap ' +
        'imageAtomicExchange imageAtomicMax imageAtomicMin imageAtomicOr imageAtomicXor imageLoad ' +
        'imageSize imageStore imulExtended intBitsToFloat interpolateAtCentroid interpolateAtOffset ' +
        'interpolateAtSample inverse inversesqrt isinf isnan ldexp length lessThan lessThanEqual log ' +
        'log2 matrixCompMult max memoryBarrier memoryBarrierAtomicCounter memoryBarrierBuffer ' +
        'memoryBarrierImage memoryBarrierShared min mix mod modf noise1 noise2 noise3 noise4 ' +
        'normalize not notEqual outerProduct packDouble2x32 packHalf2x16 packSnorm2x16 packSnorm4x8 ' +
        'packUnorm2x16 packUnorm4x8 pow radians reflect refract round roundEven shadow1D shadow1DLod ' +
        'shadow1DProj shadow1DProjLod shadow2D shadow2DLod shadow2DProj shadow2DProjLod sign sin sinh ' +
        'smoothstep sqrt step tan tanh texelFetch texelFetchOffset texture texture1D texture1DLod ' +
        'texture1DProj texture1DProjLod texture2D texture2DLod texture2DProj texture2DProjLod ' +
        'texture3D texture3DLod texture3DProj texture3DProjLod textureCube textureCubeLod ' +
        'textureGather textureGatherOffset textureGatherOffsets textureGrad textureGradOffset ' +
        'textureLod textureLodOffset textureOffset textureProj textureProjGrad textureProjGradOffset ' +
        'textureProjLod textureProjLodOffset textureProjOffset textureQueryLevels textureQueryLod ' +
        'textureSize transpose trunc uaddCarry uintBitsToFloat umulExtended unpackDouble2x32 ' +
        'unpackHalf2x16 unpackSnorm2x16 unpackSnorm4x8 unpackUnorm2x16 unpackUnorm4x8 usubBorrow',
      literal: 'true false'
    },
    illegal: '"',
    contains: [
      hljs.C_LINE_COMMENT_MODE,
      hljs.C_BLOCK_COMMENT_MODE,
      hljs.C_NUMBER_MODE,
      {
        className: 'meta',
        begin: '#',
        end: '$'
      }
    ]
  };
}

module.exports = glsl;


/***/ }),

/***/ "df75":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "df7c":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("4362")))

/***/ }),

/***/ "df7e":
/***/ (function(module, exports, __webpack_require__) {

var lengthOfArrayLike = __webpack_require__("07fa");

// https://tc39.es/proposal-change-array-by-copy/#sec-array.prototype.toReversed
// https://tc39.es/proposal-change-array-by-copy/#sec-%typedarray%.prototype.toReversed
module.exports = function (O, C) {
  var len = lengthOfArrayLike(O);
  var A = new C(len);
  var k = 0;
  for (; k < len; k++) A[k] = O[len - k - 1];
  return A;
};


/***/ }),

/***/ "dfb9":
/***/ (function(module, exports, __webpack_require__) {

var lengthOfArrayLike = __webpack_require__("07fa");

module.exports = function (Constructor, list) {
  var index = 0;
  var length = lengthOfArrayLike(list);
  var result = new Constructor(length);
  while (length > index) result[index] = list[index++];
  return result;
};


/***/ }),

/***/ "e01a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__("23e7");
var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var uncurryThis = __webpack_require__("e330");
var hasOwn = __webpack_require__("1a2d");
var isCallable = __webpack_require__("1626");
var isPrototypeOf = __webpack_require__("3a9b");
var toString = __webpack_require__("577e");
var defineBuiltInAccessor = __webpack_require__("edd0");
var copyConstructorProperties = __webpack_require__("e893");

var NativeSymbol = global.Symbol;
var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;

if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
    var result = isPrototypeOf(SymbolPrototype, this)
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  SymbolWrapper.prototype = SymbolPrototype;
  SymbolPrototype.constructor = SymbolWrapper;

  var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';
  var thisSymbolValue = uncurryThis(SymbolPrototype.valueOf);
  var symbolDescriptiveString = uncurryThis(SymbolPrototype.toString);
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  var replace = uncurryThis(''.replace);
  var stringSlice = uncurryThis(''.slice);

  defineBuiltInAccessor(SymbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = thisSymbolValue(this);
      if (hasOwn(EmptyStringDescriptionStore, symbol)) return '';
      var string = symbolDescriptiveString(symbol);
      var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, constructor: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ "e065":
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__("428f");
var hasOwn = __webpack_require__("1a2d");
var wrappedWellKnownSymbolModule = __webpack_require__("e538");
var defineProperty = __webpack_require__("9bf2").f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "e163":
/***/ (function(module, exports, __webpack_require__) {

var hasOwn = __webpack_require__("1a2d");
var isCallable = __webpack_require__("1626");
var toObject = __webpack_require__("7b0b");
var sharedKey = __webpack_require__("f772");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "e177":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "e20c":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var clearImmediate = __webpack_require__("2cf4").clear;

// `clearImmediate` method
// http://w3c.github.io/setImmediate/#si-clearImmediate
$({ global: true, bind: true, enumerable: true, forced: global.clearImmediate !== clearImmediate }, {
  clearImmediate: clearImmediate
});


/***/ }),

/***/ "e260":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__("fc6a");
var addToUnscopables = __webpack_require__("44d2");
var Iterators = __webpack_require__("3f8c");
var InternalStateModule = __webpack_require__("69f3");
var defineProperty = __webpack_require__("9bf2").f;
var defineIterator = __webpack_require__("c6d2");
var createIterResultObject = __webpack_require__("4754");
var IS_PURE = __webpack_require__("c430");
var DESCRIPTORS = __webpack_require__("83ab");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return createIterResultObject(undefined, true);
  }
  if (kind == 'keys') return createIterResultObject(index, false);
  if (kind == 'values') return createIterResultObject(target[index], false);
  return createIterResultObject([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ "e267":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");
var isArray = __webpack_require__("e8b5");
var isCallable = __webpack_require__("1626");
var classof = __webpack_require__("c6b6");
var toString = __webpack_require__("577e");

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) == 'Number' || classof(element) == 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};


/***/ }),

/***/ "e277":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return slot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return uniqueSlot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mergeSlot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return mergeSlotSafely; });
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("99af");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0__);

function slot(vm, slotName, otherwise) {
  return vm.$scopedSlots[slotName] !== void 0 ? vm.$scopedSlots[slotName]() : otherwise;
}
function uniqueSlot(vm, slotName, otherwise) {
  return vm.$scopedSlots[slotName] !== void 0 ? [].concat(vm.$scopedSlots[slotName]()) : otherwise;
}

/**
 * Source definitely exists,
 * so it's merged with the possible slot
 */
function mergeSlot(source, vm, slotName) {
  return vm.$scopedSlots[slotName] !== void 0 ? source.concat(vm.$scopedSlots[slotName]()) : source;
}

/**
 * Merge with possible slot,
 * even if source might not exist
 */
function mergeSlotSafely(source, vm, slotName) {
  if (vm.$scopedSlots[slotName] === void 0) {
    return source;
  }
  var slot = vm.$scopedSlots[slotName]();
  return source !== void 0 ? source.concat(slot) : slot;
}

/***/ }),

/***/ "e2fa":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    tag: {
      type: String,
      default: 'div'
    }
  }
});

/***/ }),

/***/ "e330":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_BIND = __webpack_require__("40d5");

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "e391":
/***/ (function(module, exports, __webpack_require__) {

var toString = __webpack_require__("577e");

module.exports = function (argument, $default) {
  return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);
};


/***/ }),

/***/ "e3db":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "e439":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var toIndexedObject = __webpack_require__("fc6a");
var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
var DESCRIPTORS = __webpack_require__("83ab");

var FORCED = !DESCRIPTORS || fails(function () { nativeGetOwnPropertyDescriptor(1); });

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "e538":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "e54f":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "e58c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable es/no-array-prototype-lastindexof -- safe */
var apply = __webpack_require__("2ba4");
var toIndexedObject = __webpack_require__("fc6a");
var toIntegerOrInfinity = __webpack_require__("5926");
var lengthOfArrayLike = __webpack_require__("07fa");
var arrayMethodIsStrict = __webpack_require__("a640");

var min = Math.min;
var $lastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return apply($lastIndexOf, this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = lengthOfArrayLike(O);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toIntegerOrInfinity(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : $lastIndexOf;


/***/ }),

/***/ "e5cb":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__("d066");
var hasOwn = __webpack_require__("1a2d");
var createNonEnumerableProperty = __webpack_require__("9112");
var isPrototypeOf = __webpack_require__("3a9b");
var setPrototypeOf = __webpack_require__("d2bb");
var copyConstructorProperties = __webpack_require__("e893");
var proxyAccessor = __webpack_require__("aeb0");
var inheritIfRequired = __webpack_require__("7156");
var normalizeStringArgument = __webpack_require__("e391");
var installErrorCause = __webpack_require__("ab36");
var installErrorStack = __webpack_require__("6f19");
var DESCRIPTORS = __webpack_require__("83ab");
var IS_PURE = __webpack_require__("c430");

module.exports = function (FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
  var STACK_TRACE_LIMIT = 'stackTraceLimit';
  var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
  var path = FULL_NAME.split('.');
  var ERROR_NAME = path[path.length - 1];
  var OriginalError = getBuiltIn.apply(null, path);

  if (!OriginalError) return;

  var OriginalErrorPrototype = OriginalError.prototype;

  // V8 9.3- bug https://bugs.chromium.org/p/v8/issues/detail?id=12006
  if (!IS_PURE && hasOwn(OriginalErrorPrototype, 'cause')) delete OriginalErrorPrototype.cause;

  if (!FORCED) return OriginalError;

  var BaseError = getBuiltIn('Error');

  var WrappedError = wrapper(function (a, b) {
    var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);
    var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();
    if (message !== undefined) createNonEnumerableProperty(result, 'message', message);
    installErrorStack(result, WrappedError, result.stack, 2);
    if (this && isPrototypeOf(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
    if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
    return result;
  });

  WrappedError.prototype = OriginalErrorPrototype;

  if (ERROR_NAME !== 'Error') {
    if (setPrototypeOf) setPrototypeOf(WrappedError, BaseError);
    else copyConstructorProperties(WrappedError, BaseError, { name: true });
  } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
    proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
    proxyAccessor(WrappedError, OriginalError, 'prepareStackTrace');
  }

  copyConstructorProperties(WrappedError, OriginalError);

  if (!IS_PURE) try {
    // Safari 13- bug: WebAssembly errors does not have a proper `.name`
    if (OriginalErrorPrototype.name !== ERROR_NAME) {
      createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);
    }
    OriginalErrorPrototype.constructor = WrappedError;
  } catch (error) { /* empty */ }

  return WrappedError;
};


/***/ }),

/***/ "e667":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "e6cf":
/***/ (function(module, exports, __webpack_require__) {

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__("5e7e");
__webpack_require__("14e5");
__webpack_require__("cc98");
__webpack_require__("3529");
__webpack_require__("f22b");
__webpack_require__("7149");


/***/ }),

/***/ "e893":
/***/ (function(module, exports, __webpack_require__) {

var hasOwn = __webpack_require__("1a2d");
var ownKeys = __webpack_require__("56ef");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ "e8b0":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "e8b5":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ "e91f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $indexOf = __webpack_require__("4d64").indexOf;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "e95a":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var Iterators = __webpack_require__("3f8c");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "e9c1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a9e3");
/* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("e277");
/* harmony import */ var _utils_private_cache_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("d54d");




/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_1___default.a.extend({
  name: 'QSlideTransition',
  props: {
    appear: Boolean,
    duration: {
      type: Number,
      default: 300
    }
  },
  methods: {
    __begin: function __begin(el, height, done) {
      // here overflowY is 'hidden'
      if (height !== void 0) {
        el.style.height = "".concat(height, "px");
      }
      el.style.transition = "height ".concat(this.duration, "ms cubic-bezier(.25, .8, .50, 1)");
      this.animating = true;
      this.done = done;
    },
    __end: function __end(el, event) {
      el.style.overflowY = null;
      el.style.height = null;
      el.style.transition = null;
      this.__cleanup();
      event !== this.lastEvent && this.$emit(event);
    },
    __cleanup: function __cleanup() {
      this.done && this.done();
      this.done = null;
      this.animating = false;
      clearTimeout(this.timer);
      clearTimeout(this.timerFallback);
      this.el !== void 0 && this.el.removeEventListener('transitionend', this.animListener);
      this.animListener = null;
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.animating && this.__cleanup();
  },
  render: function render(h) {
    var _this = this;
    return h('transition', {
      props: {
        css: false,
        appear: this.appear
      },
      on: Object(_utils_private_cache_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(this, 'tr', {
        enter: function enter(el, done) {
          var pos = 0;
          _this.el = el;

          // if animationg overflowY is already 'hidden'
          if (_this.animating === true) {
            _this.__cleanup();
            pos = el.offsetHeight === el.scrollHeight ? 0 : void 0;
          } else {
            _this.lastEvent = 'hide';
            el.style.overflowY = 'hidden';
          }
          _this.__begin(el, pos, done);
          _this.timer = setTimeout(function () {
            el.style.height = "".concat(el.scrollHeight, "px");
            _this.animListener = function (evt) {
              if (Object(evt) !== evt || evt.target === el) {
                _this.__end(el, 'show');
              }
            };
            el.addEventListener('transitionend', _this.animListener);
            _this.timerFallback = setTimeout(_this.animListener, _this.duration * 1.1);
          }, 100);
        },
        leave: function leave(el, done) {
          var pos;
          _this.el = el;
          if (_this.animating === true) {
            _this.__cleanup();
          } else {
            _this.lastEvent = 'show';
            // we need to set overflowY 'hidden' before calculating the height
            // or else we get small differences
            el.style.overflowY = 'hidden';
            pos = el.scrollHeight;
          }
          _this.__begin(el, pos, done);
          _this.timer = setTimeout(function () {
            el.style.height = 0;
            _this.animListener = function (evt) {
              if (Object(evt) !== evt || evt.target === el) {
                _this.__end(el, 'hide');
              }
            };
            el.addEventListener('transitionend', _this.animListener);
            _this.timerFallback = setTimeout(_this.animListener, _this.duration * 1.1);
          }, 100);
        }
      })
    }, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_2__[/* slot */ "c"])(this, 'default'));
  }
}));

/***/ }),

/***/ "e9c4":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var getBuiltIn = __webpack_require__("d066");
var apply = __webpack_require__("2ba4");
var call = __webpack_require__("c65b");
var uncurryThis = __webpack_require__("e330");
var fails = __webpack_require__("d039");
var isCallable = __webpack_require__("1626");
var isSymbol = __webpack_require__("d9b5");
var arraySlice = __webpack_require__("f36a");
var getReplacerFunction = __webpack_require__("e267");
var NATIVE_SYMBOL = __webpack_require__("04f8");

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')();
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) != '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ "e9fd":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "ea5a":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "ea98":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("e330");
var requireObjectCoercible = __webpack_require__("1d80");
var toIntegerOrInfinity = __webpack_require__("5926");
var toString = __webpack_require__("577e");
var fails = __webpack_require__("d039");

var charAt = uncurryThis(''.charAt);

var FORCED = fails(function () {
  // eslint-disable-next-line es/no-array-string-prototype-at -- safe
  return '𠮷'.at(-2) !== '\uD842';
});

// `String.prototype.at` method
// https://github.com/tc39/proposal-relative-indexing-method
$({ target: 'String', proto: true, forced: FORCED }, {
  at: function at(index) {
    var S = toString(requireObjectCoercible(this));
    var len = S.length;
    var relativeIndex = toIntegerOrInfinity(index);
    var k = relativeIndex >= 0 ? relativeIndex : len + relativeIndex;
    return (k < 0 || k >= len) ? undefined : charAt(S, k);
  }
});


/***/ }),

/***/ "eac5":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

var floor = Math.floor;

// `IsIntegralNumber` abstract operation
// https://tc39.es/ecma262/#sec-isintegralnumber
// eslint-disable-next-line es/no-number-isinteger -- safe
module.exports = Number.isInteger || function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),

/***/ "eb85":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export margins */
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5530");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("99af");
/* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _mixins_dark_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("b7fa");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("87e8");





var insetMap = {
  true: 'inset',
  item: 'item-inset',
  'item-thumbnail': 'item-thumbnail-inset'
};
var margins = {
  xs: 2,
  sm: 4,
  md: 8,
  lg: 16,
  xl: 24
};
/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_2___default.a.extend({
  name: 'QSeparator',
  mixins: [_mixins_dark_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]],
  props: {
    spaced: [Boolean, String],
    inset: [Boolean, String],
    vertical: Boolean,
    color: String,
    size: String
  },
  computed: {
    orientation: function orientation() {
      return this.vertical === true ? 'vertical' : 'horizontal';
    },
    classPrefix: function classPrefix() {
      return " q-separator--".concat(this.orientation);
    },
    insetClass: function insetClass() {
      return this.inset !== false ? "".concat(this.classPrefix, "-").concat(insetMap[this.inset]) : '';
    },
    classes: function classes() {
      return "q-separator".concat(this.classPrefix).concat(this.insetClass) + (this.color !== void 0 ? " bg-".concat(this.color) : '') + (this.isDark === true ? ' q-separator--dark' : '');
    },
    style: function style() {
      var style = {};
      if (this.size !== void 0) {
        style[this.vertical === true ? 'width' : 'height'] = this.size;
      }
      if (this.spaced !== false) {
        var size = this.spaced === true ? "".concat(margins.md, "px") : this.spaced in margins ? "".concat(margins[this.spaced], "px") : this.spaced;
        var props = this.vertical === true ? ['Left', 'Right'] : ['Top', 'Bottom'];
        style["margin".concat(props[0])] = style["margin".concat(props[1])] = size;
      }
      return style;
    },
    attrs: function attrs() {
      return {
        'aria-orientation': this.orientation
      };
    }
  },
  render: function render(h) {
    return h('hr', {
      staticClass: 'q-separator',
      class: this.classes,
      style: this.style,
      attrs: this.attrs,
      on: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.qListeners)
    });
  }
}));

/***/ }),

/***/ "eb8f":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "ebb5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__("4b11");
var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var isCallable = __webpack_require__("1626");
var isObject = __webpack_require__("861d");
var hasOwn = __webpack_require__("1a2d");
var classof = __webpack_require__("f5df");
var tryToString = __webpack_require__("0d51");
var createNonEnumerableProperty = __webpack_require__("9112");
var defineBuiltIn = __webpack_require__("cb2d");
var defineBuiltInAccessor = __webpack_require__("edd0");
var isPrototypeOf = __webpack_require__("3a9b");
var getPrototypeOf = __webpack_require__("e163");
var setPrototypeOf = __webpack_require__("d2bb");
var wellKnownSymbol = __webpack_require__("b622");
var uid = __webpack_require__("90e3");
var InternalStateModule = __webpack_require__("69f3");

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var TypeError = global.TypeError;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQUIRED = false;
var NAME, Constructor, Prototype;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var getTypedArrayConstructor = function (it) {
  var proto = getPrototypeOf(it);
  if (!isObject(proto)) return;
  var state = getInternalState(proto);
  return (state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return hasOwn(TypedArrayConstructorsList, klass)
    || hasOwn(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
  throw TypeError(tryToString(C) + ' is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced, options) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) {
      // old WebKit bug - some methods are non-configurable
      try {
        TypedArrayConstructor.prototype[KEY] = property;
      } catch (error2) { /* empty */ }
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    defineBuiltIn(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      defineBuiltIn(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
  else NATIVE_ARRAY_BUFFER_VIEWS = false;
}

for (NAME in BigIntArrayConstructorsList) {
  Constructor = global[NAME];
  Prototype = Constructor && Constructor.prototype;
  if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQUIRED = true;
  defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
    configurable: true,
    get: function () {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    }
  });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  getTypedArrayConstructor: getTypedArrayConstructor,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ "ec5d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: defaultLang

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("5319");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// CONCATENATED MODULE: ./node_modules/quasar/lang/en-us.js
/* harmony default export */ var en_us = ({
  isoName: 'en-us',
  nativeName: 'English (US)',
  label: {
    clear: 'Clear',
    ok: 'OK',
    cancel: 'Cancel',
    close: 'Close',
    set: 'Set',
    select: 'Select',
    reset: 'Reset',
    remove: 'Remove',
    update: 'Update',
    create: 'Create',
    search: 'Search',
    filter: 'Filter',
    refresh: 'Refresh',
    expand: function expand(label) {
      return label ? "Expand \"".concat(label, "\"") : 'Expand';
    },
    collapse: function collapse(label) {
      return label ? "Collapse \"".concat(label, "\"") : 'Collapse';
    }
  },
  date: {
    days: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    daysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    firstDayOfWeek: 0,
    // 0-6, 0 - Sunday, 1 Monday, ...
    format24h: false,
    pluralDay: 'days'
  },
  table: {
    noData: 'No data available',
    noResults: 'No matching records found',
    loading: 'Loading...',
    selectedRecords: function selectedRecords(rows) {
      return rows === 1 ? '1 record selected.' : (rows === 0 ? 'No' : rows) + ' records selected.';
    },
    recordsPerPage: 'Records per page:',
    allRows: 'All',
    pagination: function pagination(start, end, total) {
      return start + '-' + end + ' of ' + total;
    },
    columns: 'Columns'
  },
  editor: {
    url: 'URL',
    bold: 'Bold',
    italic: 'Italic',
    strikethrough: 'Strikethrough',
    underline: 'Underline',
    unorderedList: 'Unordered List',
    orderedList: 'Ordered List',
    subscript: 'Subscript',
    superscript: 'Superscript',
    hyperlink: 'Hyperlink',
    toggleFullscreen: 'Toggle Fullscreen',
    quote: 'Quote',
    left: 'Left align',
    center: 'Center align',
    right: 'Right align',
    justify: 'Justify align',
    print: 'Print',
    outdent: 'Decrease indentation',
    indent: 'Increase indentation',
    removeFormat: 'Remove formatting',
    formatting: 'Formatting',
    fontSize: 'Font Size',
    align: 'Align',
    hr: 'Insert Horizontal Rule',
    undo: 'Undo',
    redo: 'Redo',
    heading1: 'Heading 1',
    heading2: 'Heading 2',
    heading3: 'Heading 3',
    heading4: 'Heading 4',
    heading5: 'Heading 5',
    heading6: 'Heading 6',
    paragraph: 'Paragraph',
    code: 'Code',
    size1: 'Very small',
    size2: 'A bit small',
    size3: 'Normal',
    size4: 'Medium-large',
    size5: 'Big',
    size6: 'Very big',
    size7: 'Maximum',
    defaultFont: 'Default Font',
    viewSource: 'View Source'
  },
  tree: {
    noNodes: 'No nodes available',
    noResults: 'No matching nodes found'
  }
});
// EXTERNAL MODULE: ./node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("0967");

// CONCATENATED MODULE: ./node_modules/quasar/src/lang.js








function getLocale() {
  if (Platform["e" /* isSSR */] === true) {
    return;
  }
  var val = navigator.language || navigator.languages[0] || navigator.browserLanguage || navigator.userLanguage || navigator.systemLanguage;
  if (val) {
    return val.toLowerCase();
  }
}
var Plugin = {
  getLocale: getLocale,
  install: function install($q, queues, lang) {
    var _this = this;
    var initialLang = lang || en_us;
    this.set = function () {
      var langObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : en_us;
      var ssrContext = arguments.length > 1 ? arguments[1] : undefined;
      var lang = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, langObject), {}, {
        rtl: langObject.rtl === true,
        getLocale: getLocale
      });
      if (Platform["e" /* isSSR */] === true) {
        if (ssrContext === void 0) {
          console.error('SSR ERROR: second param required: Quasar.lang.set(lang, ssrContext)');
          return;
        }
        var dir = lang.rtl === true ? 'rtl' : 'ltr';
        var attrs = "lang=".concat(lang.isoName, " dir=").concat(dir);
        lang.set = ssrContext.$q.lang.set;
        ssrContext.Q_HTML_ATTRS = ssrContext.Q_PREV_LANG !== void 0 ? ssrContext.Q_HTML_ATTRS.replace(ssrContext.Q_PREV_LANG, attrs) : attrs;
        ssrContext.Q_PREV_LANG = attrs;
        ssrContext.$q.lang = lang;
      } else {
        if (Platform["c" /* fromSSR */] === false) {
          var el = document.documentElement;
          el.setAttribute('dir', lang.rtl === true ? 'rtl' : 'ltr');
          el.setAttribute('lang', lang.isoName);
        }
        lang.set = _this.set;
        $q.lang = _this.props = lang;
        _this.isoName = lang.isoName;
        _this.nativeName = lang.nativeName;
      }
    };
    if (Platform["e" /* isSSR */] === true) {
      queues.server.push(function (q, ctx) {
        q.lang = {};
        q.lang.set = function (langObject) {
          _this.set(langObject, ctx.ssr);
        };
        q.lang.set(initialLang);
      });
      this.isoName = initialLang.isoName;
      this.nativeName = initialLang.nativeName;
      this.props = initialLang;
    } else {
      external_commonjs_vue_commonjs2_vue_root_Vue_default.a.util.defineReactive($q, 'lang', {});
      this.set(initialLang);
    }
  }
};
/* harmony default export */ var src_lang = __webpack_exports__["a"] = (Plugin);


/***/ }),

/***/ "edd0":
/***/ (function(module, exports, __webpack_require__) {

var makeBuiltIn = __webpack_require__("13d2");
var defineProperty = __webpack_require__("9bf2");

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ "edd4":
/***/ (function(module) {

module.exports = JSON.parse("{\"Dismiss\":\"Dismiss\",\"CodeBlock\":{\"Initial_Content\":\"Initial Content\"},\"CodeBlockContainer\":{\"DataBlock\":\"Sandbox Data\",\"ReloadResources\":\"No Resource Cache\",\"ReloadResources_detail\":\"Allways fetch resources from a Sandboxes resources()-Method before init is called.\",\"Order\":\"Order\",\"Display\":\"Display\",\"Lines\":\"Lines\",\"Lines_detail\":\"Number of Visible lines or <b>auto</b>.\",\"Prepopulate\":\"Prepopulate Answer\",\"Prepopulate_detail\":\"Define content that is displayed in a new answer.\",\"Behaviour\":\"Behaviour\",\"ScriptV\":\"Script Version\",\"ScriptV_detail\":\"API-Version for the Playground.\",\"AutoReset\":\"Auto Reset\",\"AutoReset_detail\":\"Recreate Playground-Object for each run\",\"GenerateTemplate\":\"Create Canvas\",\"GenerateTemplate_detail\":\"Create a Canvas-Element for this Playground\",\"Positioning\":\"Positioning\",\"Width\":\"Width\",\"Width_detail\":\"CSS Property for the canvas-width.\",\"Height\":\"Height\",\"Height_detail\":\"CSS Property for the canvas-height.\",\"Alignment\":\"Alignment\",\"Alignment_detail\":\"Horizontal Positioning of the canvas.\",\"Delete\":\"Delete\",\"Start\":\"Start\",\"Center\":\"Center\",\"End\":\"End\",\"ScriptVersion_1\":\"1.0 (original)\",\"ScriptVersion_2\":\"2.0 (since 2020)\",\"ScriptVersion_3\":\"3.0 (experimental)\",\"Canvas\":\"Playground\",\"Text\":\"Plain Text\",\"Hidden\":\"Code (Hidden)\",\"Static\":\"Code (Static)\",\"Block\":\"Solution\",\"Blockly\":\"Blockly (Experimental!!!)\",\"REPL\":\"Interactive Terminal\",\"Confirm\":\"Confirm\",\"DeleteQuestion\":\"Do you really want to delete the <span class='highlightedCard sample'>highlighted</span> Block?\",\"TypesCaption\":\"Block-Types\",\"Types\":\"The final Question is assembled using the following blocks. You my use the following block types:<ul><li><b>Plain Text</b>: Regular Text that is displayd as you Type it without any Syntax Highlighting. You may use <b>[code][/code]</b> and <b>[hl][/hl]</b> as a markup for inline source-code</li><li><b>Code (Static)</b>: read-only Source Code with Syntax highlighting. The content is used to assemble the final Program.</li><li><b>Code (Hidden)</b>: This Source Code is delivered to the client browser but invisible to the students. You may use this type for boiler-plate code you need for processing. The content is used to assemble the final Program.</li><li><b>Solution</b>: Source Code with Syntax highlighting. Should contain the best solution. The content is used to assemble the final Program.</li><li><b>Playgournd</b>: Enables you to execute predfined Code in th DOM. For example for a 2D-drawing area to visualize the results produced by the studen. The code you specify (for Version 2.0) <b> has to return a JavaScript Object</b> providing an <ul><li><code>init(canvasElement, outputElement, scope)</code> and</li><li><code>update(txt, json, canvasElement, outputElement)</code></li></ul> method.</li><li><b>Sanbox Data</b>: Allows you to specify JSON-Formated Data for your Sandboxes. The Data is accessible in your Sandbox using <b>this.DATA[name]</b>.</li></ul>\"},\"CodeBlocks\":{\"run_hint\":\"Press <code>Ctrl</code>+<code>W</code> or <code>Ctrl</code>+<code>J</code> when in a code box to run code.\",\"run\":\"Run\",\"start\":\"Start\",\"stop\":\"Stop\",\"AddBlock\":\"Add new Block\",\"UserCanceled\":\"Stopped By User\"},\"CodeBlocksSettings\":{\"Language\":\"Language\",\"AllowExec\":\"Allow Code Execution\",\"CVersion\":\"Version\",\"RunTime\":\"Max. Runtime in ms.\",\"Output\":\"Output\",\"MaxCharacters\":\"Max. Output Characters\",\"ExperimentalCompiler\":\"Experimental Language\",\"ExperimentalCompilerDesc\":\"This language version is experimental. The properties and behaviour of this version might changen in the next update. You should not use this version for production.\",\"DeprecatedCompiler\":\"Deprecated Language\",\"DeprecatedCompilerDesc\":\"This language version is deprecated and will be removed in upcoming updates. Please upgrade your project to a later version.\",\"Parser\":\"Output Parser\",\"Themes\":\"Themes\",\"TGeneral\":\"General Theme\",\"TSolution\":\"Solution Theme\",\"Libraries\":\"Libraries\",\"DomLibs\":\"DOM-Libraries\",\"WorkLibs\":\"Worker-Libraries\",\"PAutomatic\":\"Automatisch\",\"PText\":\"Text Passthrough\",\"PJSON\":\"JSON\",\"PMagic\":\"Text+JSON (seperated by '\\\\n\\\\n&lt;JSON>\\\\n')\",\"PData\":\"Text+Data (send using 'CodeBlocks.postResult(data)')\",\"NumberErr\":\"Muss ein gültiger Zahlenwert sein\",\"ContinousCompile\":\"Automatic Execution (while typing)\",\"PersistentArguments\":\"Persistente Arguments (between calls)\",\"MessagePassing\":\"Message exchange between DOM and Worker\",\"KeepAlive\":\"Keep Worker alive after main Finishes\",\"AllowArguments\":\"Supports Runtime-Arguments\",\"AllowArgumentsCaption\":\"Send Runtime-Arguments\",\"AllowArgumentsHint\":\"Using <code>addArgumentsTo(args)</code> in your <b>Playground</b> you can add data to the passed argument-object. The object is available in the worker-code as a variable named <code>args</code>.\",\"AllowArgumentsHintJava\":\"Using <code>addArgumentsTo(args)</code> in your <b>Playground</b> you can push strings to the passed arguments-array. The array is passed to <code>args</code>-parameter of the <code>main</code>-Method.\",\"UsePersistentArgumentsCaption\":\"Persistente Arguments\",\"UsePersistentArgumentsHint\":\"When set, the <args>args</args>-Value passed to <code>addArgumentsTo(args)</code> will contain the values written to <code>args</code> by the worker-code in the last run. If not set, the method will allways receiv an empty object.\",\"UsePersistentArgumentsHintJava\":\"When set, the <args>args</args>-Value passed to <code>addArgumentsTo(args)</code> will contain the values written to <code>args</code> by the java-code in the last run. If not set, the method will allways receiv an empty array.\",\"AllowMessagePassingCaption\":\"Message exchange\",\"AllowMessagePassingHint\":\"<b style=color:red>[EXPERIMENTAL]</b> When enabled, worker and DOM can exchange messages.<br><b>Canvas-Code:</b><ul><li><code>onMessage(cmd, data)</code>: Receives messages from the worker</li><li><code>runner.postMessage(cmd, data)</code>: sends a message to the worker. The runner instance is passed to your <code>init</code>-method.</li></ul><b>Worker-Code:</b><ul><li><code>CodeBlocks.startReceivingEvents((request) => {})</code>: the handler receives messages sent from the DOM</li><li><code>CodeBlocks.postMessage(cmd, data)</code>: sends a message to the DOM-Code.</li></ul>\",\"AllowMessagePassingHintJava\":\"<b style=color:red>[EXPERIMENTAL]</b> When enabled, worker and DOM can exchange messages.<br><b>Canvas-Code:</b><ul><li><code>onMessage(cmd, data)</code>: Receives messages from the worker</li><li><code>runner.postMessage(cmd, data)</code>: sends a message to the worker. The runner instance is passed to your <code>init</code>-method.</li></ul><b>Worker-Code:</b><ul><li><code>CodeBlocks.startReceivingEvents((CodeBlocksBaseMessage request) -> {})</code>: the handler receives messages sent from the DOM</li><li><code>CodeBlocks.postMessage(String cmd, Object data)</code>: sends a message to the DOM-Code.</li></ul>\",\"KeepAliveCaption\":\"Keep Worker alive\",\"KeepAliveHint\":\"<b style=color:red>[EXPERIMENTAL]</b> Workers are not automatically terminated when the student code finishes.<br><br>The worker is stopped by using the <em>Stop</em>-Button or by reaching the maximum execution time. Student-Code can also terminate the worker (and itself) by calling <code>process.exit(0)</code>.<br><br>The <code>whenFinished(args)</code>-Method in your <b>Playground</b> is called as soon as the student code finishes, which may be before the worker is terminated.\",\"KeepAliveHintJava\":\"<b style=color:red>[EXPERIMENTAL]</b> Workers are not automatically terminated when the students <code>main</code>-Method finishes.<br><br>The worker is stopped by using the <em>Stop</em>-Button or by reaching the maximum execution time. Student-Code can also terminate the worker (and itself) by calling <code>System.exit(0)</code>.<br><br>The <code>whenFinished(args)</code>-Method in your <b>Playground</b> is called as soon as the <code>main</code>-Method finishes, which may be before the worker is terminated.\"},\"CodePlayground\":{\"InvalidJson\":\"Output is not a valid JSON-Object\",\"Output\":\"Output:\",\"Message\":\"Message:\",\"ExperimentalScriptVersion\":\"Experimental Scripting Version\",\"ExperimentalScriptVersionDesc\":\"This scripting version is experimental. The properties and behaviour of this version might changen in the next update. You should not use this version for production.\",\"DeprecatedScriptVersion\":\"Deprecated Scripting Version\",\"DeprecatedScriptVersionDesc\":\"This scripting version is deprecated and will be removed in upcoming updates. Please upgrade your project to a later version.\"},\"Tagger\":{\"ConfirmRepl\":\"Confirm Tag Replacement\",\"ConfirmReplMsg\":\"Do you really want to replace <b>all</b> occurrences of {name} with the value below?\"},\"RandomizerSetEditor\":{\"Caption\":\"Edit Set {nr}\"},\"RandomizerSettings\":{\"Caption\":\"Randomizer\",\"Available\":\"Available Tags\",\"Sets\":\"Defined Sets\"},\"Blockly\":{\"CodePreviewLabel\":\"Code Preview\",\"CodePreviewCaption\":\"The source-code generated by the above sequence\",\"RAWToolboxLabel\":\"RAW Toolbox Definition\",\"RAWToolboxCaption\":\"The raw XML-Definition of your toolbox\",\"CustomBlocksLabel\":\"Custom Blocks\",\"CustomBlocksCaption\":\"Create and manage Custom Blocks\",\"ToolboxLabel\":\"Customize Toolbox\",\"ToolboxCaption\":\"Manage Categories and the general look of your toolbox\",\"ToolboxCategories\":\"Categories\",\"ToolboxItems\":\"Blocks\",\"Properties\":\"Properties\",\"UseCustomToolbox\":\"Define Customized Toolbox XML\",\"BlockTypeNames\":{\"controls_if\":\"controls_if\",\"logic_compare\":\"logic_compare\",\"logic_operation\":\"logic_operation\",\"logic_negate\":\"logic_negate\",\"logic_boolean\":\"logic_boolean\",\"logic_null\":\"logic_null\",\"logic_ternary\":\"logic_ternary\",\"controls_repeat_ext\":\"controls_repeat_ext\",\"controls_whileUntil\":\"controls_whileUntil\",\"controls_for\":\"controls_for\",\"controls_forEach\":\"controls_forEach\",\"controls_flow_statements\":\"controls_flow_statements\",\"math_number\":\"math_number\",\"math_arithmetic\":\"math_arithmetic\",\"math_single\":\"math_single\",\"math_trig\":\"math_trig\",\"math_constant\":\"math_constant\",\"math_number_property\":\"math_number_property\",\"math_round\":\"math_round\",\"math_on_list\":\"math_on_list\",\"math_modulo\":\"math_modulo\",\"math_constrain\":\"math_constrain\",\"math_random_int\":\"math_random_int\",\"math_random_float\":\"math_random_float\",\"text\":\"text\",\"text_join\":\"text_join\",\"text_append\":\"text_append\",\"text_length\":\"text_length\",\"text_isEmpty\":\"text_isEmpty\",\"text_indexOf\":\"text_indexOf\",\"variables_get\":\"variables_get\",\"text_charAt\":\"text_charAt\",\"text_getSubstring\":\"text_getSubstring\",\"text_changeCase\":\"text_changeCase\",\"text_trim\":\"text_trim\",\"text_print\":\"text_print\",\"text_prompt_ext\":\"text_prompt_ext\",\"lists_create_with\":\"lists_create_with\",\"lists_repeat\":\"lists_repeat\",\"lists_length\":\"lists_length\",\"lists_isEmpty\":\"lists_isEmpty\",\"lists_indexOf\":\"lists_indexOf\",\"lists_getIndex\":\"lists_getIndex\",\"lists_setIndex\":\"lists_setIndex\",\"lists_getSublist\":\"lists_getSublist\",\"lists_split\":\"lists_split\",\"lists_sort\":\"lists_sort\",\"colour_picker\":\"colour_picker\",\"colour_random\":\"colour_random\",\"colour_rgb\":\"colour_rgb\",\"colour_blend\":\"colour_blend\"}},\"DataBlock\":{\"InfoCaption\":\"Usage\",\"Info\":\"You can access this data in your Sandboxes using <b>this.DATA['{NAME}']</b>\"}}");

/***/ }),

/***/ "edda":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "ee8c":
/***/ (function(module, exports) {

const MODES = (hljs) => {
  return {
    IMPORTANT: {
      className: 'meta',
      begin: '!important'
    },
    HEXCOLOR: {
      className: 'number',
      begin: '#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})'
    },
    ATTRIBUTE_SELECTOR_MODE: {
      className: 'selector-attr',
      begin: /\[/,
      end: /\]/,
      illegal: '$',
      contains: [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE
      ]
    }
  };
};

const TAGS = [
  'a',
  'abbr',
  'address',
  'article',
  'aside',
  'audio',
  'b',
  'blockquote',
  'body',
  'button',
  'canvas',
  'caption',
  'cite',
  'code',
  'dd',
  'del',
  'details',
  'dfn',
  'div',
  'dl',
  'dt',
  'em',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'header',
  'hgroup',
  'html',
  'i',
  'iframe',
  'img',
  'input',
  'ins',
  'kbd',
  'label',
  'legend',
  'li',
  'main',
  'mark',
  'menu',
  'nav',
  'object',
  'ol',
  'p',
  'q',
  'quote',
  'samp',
  'section',
  'span',
  'strong',
  'summary',
  'sup',
  'table',
  'tbody',
  'td',
  'textarea',
  'tfoot',
  'th',
  'thead',
  'time',
  'tr',
  'ul',
  'var',
  'video'
];

const MEDIA_FEATURES = [
  'any-hover',
  'any-pointer',
  'aspect-ratio',
  'color',
  'color-gamut',
  'color-index',
  'device-aspect-ratio',
  'device-height',
  'device-width',
  'display-mode',
  'forced-colors',
  'grid',
  'height',
  'hover',
  'inverted-colors',
  'monochrome',
  'orientation',
  'overflow-block',
  'overflow-inline',
  'pointer',
  'prefers-color-scheme',
  'prefers-contrast',
  'prefers-reduced-motion',
  'prefers-reduced-transparency',
  'resolution',
  'scan',
  'scripting',
  'update',
  'width',
  // TODO: find a better solution?
  'min-width',
  'max-width',
  'min-height',
  'max-height'
];

// https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes
const PSEUDO_CLASSES = [
  'active',
  'any-link',
  'blank',
  'checked',
  'current',
  'default',
  'defined',
  'dir', // dir()
  'disabled',
  'drop',
  'empty',
  'enabled',
  'first',
  'first-child',
  'first-of-type',
  'fullscreen',
  'future',
  'focus',
  'focus-visible',
  'focus-within',
  'has', // has()
  'host', // host or host()
  'host-context', // host-context()
  'hover',
  'indeterminate',
  'in-range',
  'invalid',
  'is', // is()
  'lang', // lang()
  'last-child',
  'last-of-type',
  'left',
  'link',
  'local-link',
  'not', // not()
  'nth-child', // nth-child()
  'nth-col', // nth-col()
  'nth-last-child', // nth-last-child()
  'nth-last-col', // nth-last-col()
  'nth-last-of-type', //nth-last-of-type()
  'nth-of-type', //nth-of-type()
  'only-child',
  'only-of-type',
  'optional',
  'out-of-range',
  'past',
  'placeholder-shown',
  'read-only',
  'read-write',
  'required',
  'right',
  'root',
  'scope',
  'target',
  'target-within',
  'user-invalid',
  'valid',
  'visited',
  'where' // where()
];

// https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements
const PSEUDO_ELEMENTS = [
  'after',
  'backdrop',
  'before',
  'cue',
  'cue-region',
  'first-letter',
  'first-line',
  'grammar-error',
  'marker',
  'part',
  'placeholder',
  'selection',
  'slotted',
  'spelling-error'
];

const ATTRIBUTES = [
  'align-content',
  'align-items',
  'align-self',
  'animation',
  'animation-delay',
  'animation-direction',
  'animation-duration',
  'animation-fill-mode',
  'animation-iteration-count',
  'animation-name',
  'animation-play-state',
  'animation-timing-function',
  'auto',
  'backface-visibility',
  'background',
  'background-attachment',
  'background-clip',
  'background-color',
  'background-image',
  'background-origin',
  'background-position',
  'background-repeat',
  'background-size',
  'border',
  'border-bottom',
  'border-bottom-color',
  'border-bottom-left-radius',
  'border-bottom-right-radius',
  'border-bottom-style',
  'border-bottom-width',
  'border-collapse',
  'border-color',
  'border-image',
  'border-image-outset',
  'border-image-repeat',
  'border-image-slice',
  'border-image-source',
  'border-image-width',
  'border-left',
  'border-left-color',
  'border-left-style',
  'border-left-width',
  'border-radius',
  'border-right',
  'border-right-color',
  'border-right-style',
  'border-right-width',
  'border-spacing',
  'border-style',
  'border-top',
  'border-top-color',
  'border-top-left-radius',
  'border-top-right-radius',
  'border-top-style',
  'border-top-width',
  'border-width',
  'bottom',
  'box-decoration-break',
  'box-shadow',
  'box-sizing',
  'break-after',
  'break-before',
  'break-inside',
  'caption-side',
  'clear',
  'clip',
  'clip-path',
  'color',
  'column-count',
  'column-fill',
  'column-gap',
  'column-rule',
  'column-rule-color',
  'column-rule-style',
  'column-rule-width',
  'column-span',
  'column-width',
  'columns',
  'content',
  'counter-increment',
  'counter-reset',
  'cursor',
  'direction',
  'display',
  'empty-cells',
  'filter',
  'flex',
  'flex-basis',
  'flex-direction',
  'flex-flow',
  'flex-grow',
  'flex-shrink',
  'flex-wrap',
  'float',
  'font',
  'font-display',
  'font-family',
  'font-feature-settings',
  'font-kerning',
  'font-language-override',
  'font-size',
  'font-size-adjust',
  'font-smoothing',
  'font-stretch',
  'font-style',
  'font-variant',
  'font-variant-ligatures',
  'font-variation-settings',
  'font-weight',
  'height',
  'hyphens',
  'icon',
  'image-orientation',
  'image-rendering',
  'image-resolution',
  'ime-mode',
  'inherit',
  'initial',
  'justify-content',
  'left',
  'letter-spacing',
  'line-height',
  'list-style',
  'list-style-image',
  'list-style-position',
  'list-style-type',
  'margin',
  'margin-bottom',
  'margin-left',
  'margin-right',
  'margin-top',
  'marks',
  'mask',
  'max-height',
  'max-width',
  'min-height',
  'min-width',
  'nav-down',
  'nav-index',
  'nav-left',
  'nav-right',
  'nav-up',
  'none',
  'normal',
  'object-fit',
  'object-position',
  'opacity',
  'order',
  'orphans',
  'outline',
  'outline-color',
  'outline-offset',
  'outline-style',
  'outline-width',
  'overflow',
  'overflow-wrap',
  'overflow-x',
  'overflow-y',
  'padding',
  'padding-bottom',
  'padding-left',
  'padding-right',
  'padding-top',
  'page-break-after',
  'page-break-before',
  'page-break-inside',
  'perspective',
  'perspective-origin',
  'pointer-events',
  'position',
  'quotes',
  'resize',
  'right',
  'src', // @font-face
  'tab-size',
  'table-layout',
  'text-align',
  'text-align-last',
  'text-decoration',
  'text-decoration-color',
  'text-decoration-line',
  'text-decoration-style',
  'text-indent',
  'text-overflow',
  'text-rendering',
  'text-shadow',
  'text-transform',
  'text-underline-position',
  'top',
  'transform',
  'transform-origin',
  'transform-style',
  'transition',
  'transition-delay',
  'transition-duration',
  'transition-property',
  'transition-timing-function',
  'unicode-bidi',
  'vertical-align',
  'visibility',
  'white-space',
  'widows',
  'width',
  'word-break',
  'word-spacing',
  'word-wrap',
  'z-index'
  // reverse makes sure longer attributes `font-weight` are matched fully
  // instead of getting false positives on say `font`
].reverse();

/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
  if (!re) return null;
  if (typeof re === "string") return re;

  return re.source;
}

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function lookahead(re) {
  return concat('(?=', re, ')');
}

/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */
function concat(...args) {
  const joined = args.map((x) => source(x)).join("");
  return joined;
}

/*
Language: CSS
Category: common, css
Website: https://developer.mozilla.org/en-US/docs/Web/CSS
*/

/** @type LanguageFn */
function css(hljs) {
  const modes = MODES(hljs);
  const FUNCTION_DISPATCH = {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  };
  const VENDOR_PREFIX = {
    begin: /-(webkit|moz|ms|o)-(?=[a-z])/
  };
  const AT_MODIFIERS = "and or not only";
  const AT_PROPERTY_RE = /@-?\w[\w]*(-\w+)*/; // @-webkit-keyframes
  const IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';
  const STRINGS = [
    hljs.APOS_STRING_MODE,
    hljs.QUOTE_STRING_MODE
  ];

  return {
    name: 'CSS',
    case_insensitive: true,
    illegal: /[=|'\$]/,
    keywords: {
      keyframePosition: "from to"
    },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      hljs.C_BLOCK_COMMENT_MODE,
      VENDOR_PREFIX,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      hljs.CSS_NUMBER_MODE,
      {
        className: 'selector-id',
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: 'selector-class',
        begin: '\\.' + IDENT_RE,
        relevance: 0
      },
      modes.ATTRIBUTE_SELECTOR_MODE,
      {
        className: 'selector-pseudo',
        variants: [
          {
            begin: ':(' + PSEUDO_CLASSES.join('|') + ')'
          },
          {
            begin: '::(' + PSEUDO_ELEMENTS.join('|') + ')'
          }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      {
        className: 'attribute',
        begin: '\\b(' + ATTRIBUTES.join('|') + ')\\b'
      },
      // attribute values
      {
        begin: ':',
        end: '[;}]',
        contains: [
          modes.HEXCOLOR,
          modes.IMPORTANT,
          hljs.CSS_NUMBER_MODE,
          ...STRINGS,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0, // from keywords
            keywords: {
              built_in: "url data-uri"
            },
            contains: [
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: true,
                excludeEnd: true
              }
            ]
          },
          FUNCTION_DISPATCH
        ]
      },
      {
        begin: lookahead(/@/),
        end: '[{;]',
        relevance: 0,
        illegal: /:/, // break on Less variables @var: ...
        contains: [
          {
            className: 'keyword',
            begin: AT_PROPERTY_RE
          },
          {
            begin: /\s/,
            endsWithParent: true,
            excludeEnd: true,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: AT_MODIFIERS,
              attribute: MEDIA_FEATURES.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...STRINGS,
              hljs.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: 'selector-tag',
        begin: '\\b(' + TAGS.join('|') + ')\\b'
      }
    ]
  };
}

module.exports = css;


/***/ }),

/***/ "efec":
/***/ (function(module, exports, __webpack_require__) {

var hasOwn = __webpack_require__("1a2d");
var defineBuiltIn = __webpack_require__("cb2d");
var dateToPrimitive = __webpack_require__("51eb");
var wellKnownSymbol = __webpack_require__("b622");

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var DatePrototype = Date.prototype;

// `Date.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive
if (!hasOwn(DatePrototype, TO_PRIMITIVE)) {
  defineBuiltIn(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
}


/***/ }),

/***/ "f069":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aCallable = __webpack_require__("59ed");

var $TypeError = TypeError;

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw $TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aCallable(resolve);
  this.reject = aCallable(reject);
};

// `NewPromiseCapability` abstract operation
// https://tc39.es/ecma262/#sec-newpromisecapability
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "f09f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5530");
/* harmony import */ var core_js_modules_es_array_flat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0481");
/* harmony import */ var core_js_modules_es_array_flat_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_flat_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_unscopables_flat_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("4069");
/* harmony import */ var core_js_modules_es_array_unscopables_flat_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_unscopables_flat_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("8bbf");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _mixins_dark_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("b7fa");
/* harmony import */ var _mixins_tag_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("e2fa");
/* harmony import */ var _mixins_listeners_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("87e8");
/* harmony import */ var _utils_private_slot_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__("e277");








/* harmony default export */ __webpack_exports__["a"] = (vue__WEBPACK_IMPORTED_MODULE_3___default.a.extend({
  name: 'QCard',
  mixins: [_mixins_listeners_js__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"], _mixins_dark_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"], _mixins_tag_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]],
  props: {
    square: Boolean,
    flat: Boolean,
    bordered: Boolean
  },
  computed: {
    classes: function classes() {
      return 'q-card' + (this.isDark === true ? ' q-card--dark q-dark' : '') + (this.bordered === true ? ' q-card--bordered' : '') + (this.square === true ? ' q-card--square no-border-radius' : '') + (this.flat === true ? ' q-card--flat no-shadow' : '');
    }
  },
  render: function render(h) {
    return h(this.tag, {
      class: this.classes,
      on: Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_objectSpread2_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])({}, this.qListeners)
    }, Object(_utils_private_slot_js__WEBPACK_IMPORTED_MODULE_7__[/* slot */ "c"])(this, 'default'));
  }
}));

/***/ }),

/***/ "f183":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var uncurryThis = __webpack_require__("e330");
var hiddenKeys = __webpack_require__("d012");
var isObject = __webpack_require__("861d");
var hasOwn = __webpack_require__("1a2d");
var defineProperty = __webpack_require__("9bf2").f;
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertyNamesExternalModule = __webpack_require__("057f");
var isExtensible = __webpack_require__("4fad");
var uid = __webpack_require__("90e3");
var FREEZING = __webpack_require__("bb2f");

var REQUIRED = false;
var METADATA = uid('meta');
var id = 0;

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + id++, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!hasOwn(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && REQUIRED && isExtensible(it) && !hasOwn(it, METADATA)) setMetadata(it);
  return it;
};

var enable = function () {
  meta.enable = function () { /* empty */ };
  REQUIRED = true;
  var getOwnPropertyNames = getOwnPropertyNamesModule.f;
  var splice = uncurryThis([].splice);
  var test = {};
  test[METADATA] = 1;

  // prevent exposing of metadata key
  if (getOwnPropertyNames(test).length) {
    getOwnPropertyNamesModule.f = function (it) {
      var result = getOwnPropertyNames(it);
      for (var i = 0, length = result.length; i < length; i++) {
        if (result[i] === METADATA) {
          splice(result, i, 1);
          break;
        }
      } return result;
    };

    $({ target: 'Object', stat: true, forced: true }, {
      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f
    });
  }
};

var meta = module.exports = {
  enable: enable,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "f22b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var call = __webpack_require__("c65b");
var newPromiseCapabilityModule = __webpack_require__("f069");
var FORCED_PROMISE_CONSTRUCTOR = __webpack_require__("4738").CONSTRUCTOR;

// `Promise.reject` method
// https://tc39.es/ecma262/#sec-promise.reject
$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
  reject: function reject(r) {
    var capability = newPromiseCapabilityModule.f(this);
    call(capability.reject, undefined, r);
    return capability.promise;
  }
});


/***/ }),

/***/ "f249":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clearSelection; });
/* harmony import */ var _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0967");

function clearSelection() {
  if (window.getSelection !== void 0) {
    var selection = window.getSelection();
    if (selection.empty !== void 0) {
      selection.empty();
    } else if (selection.removeAllRanges !== void 0) {
      selection.removeAllRanges();
      _plugins_Platform_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"].is.mobile !== true && selection.addRange(document.createRange());
    }
  } else if (document.selection !== void 0) {
    document.selection.empty();
  }
}

/***/ }),

/***/ "f303":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export offset */
/* unused harmony export style */
/* unused harmony export height */
/* unused harmony export width */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return css; });
/* unused harmony export cssBatch */
/* unused harmony export ready */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return childHasFocus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getBodyFullscreenElement; });
/* harmony import */ var _Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("53ca");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("159b");
/* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("b64b");
/* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_3__);




function offset(el) {
  if (el === window) {
    return {
      top: 0,
      left: 0
    };
  }
  var _el$getBoundingClient = el.getBoundingClientRect(),
    top = _el$getBoundingClient.top,
    left = _el$getBoundingClient.left;
  return {
    top: top,
    left: left
  };
}
function style(el, property) {
  return window.getComputedStyle(el).getPropertyValue(property);
}
function height(el) {
  return el === window ? window.innerHeight : el.getBoundingClientRect().height;
}
function width(el) {
  return el === window ? window.innerWidth : el.getBoundingClientRect().width;
}
function css(element, css) {
  var style = element.style;
  Object.keys(css).forEach(function (prop) {
    style[prop] = css[prop];
  });
}
function cssBatch(elements, style) {
  elements.forEach(function (el) {
    return css(el, style);
  });
}
function ready(fn) {
  if (typeof fn !== 'function') {
    return;
  }
  if (document.readyState !== 'loading') {
    return fn();
  }
  document.addEventListener('DOMContentLoaded', fn, false);
}

// internal
function getElement(el) {
  var type = Object(_Users_sifrbaue_Documents_docker_ilias_data_assCodeQuestion_dev_codeblocks_js_node_modules_babel_runtime_helpers_esm_typeof_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(el);
  if (type === 'function') {
    el = el();
  }
  if (type === 'string') {
    try {
      el = document.querySelector(el);
    } catch (err) {}
  }
  if (el !== Object(el)) {
    return null;
  }
  return el._isVue === true && el.$el !== void 0 ? el.$el : el;
}

// internal
function childHasFocus(el, focusedEl) {
  if (el === void 0 || el.contains(focusedEl) === true) {
    return true;
  }
  for (var next = el.nextElementSibling; next !== null; next = next.nextElementSibling) {
    if (next.contains(focusedEl)) {
      return true;
    }
  }
  return false;
}

// internal
function getBodyFullscreenElement(activeEl) {
  return activeEl === document.documentElement || activeEl === null ? document.body : activeEl;
}
/* unused harmony default export */ var _unused_webpack_default_export = ({
  offset: offset,
  style: style,
  height: height,
  width: width,
  css: css,
  cssBatch: cssBatch,
  ready: ready
});

/***/ }),

/***/ "f354":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var DESCRIPTORS = __webpack_require__("83ab");
var IS_PURE = __webpack_require__("c430");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = !fails(function () {
  // eslint-disable-next-line unicorn/relative-url-style -- required for testing
  var url = new URL('b?a=1&b=2&c=3', 'http://a');
  var searchParams = url.searchParams;
  var searchParams2 = new URLSearchParams('a=1&a=2');
  var result = '';
  url.pathname = 'c%20d';
  searchParams.forEach(function (value, key) {
    searchParams['delete']('b');
    result += key + value;
  });
  searchParams2['delete']('a', 2);
  return (IS_PURE && (!url.toJSON || !searchParams2.has('a', 1) || searchParams2.has('a', 2)))
    || (!searchParams.size && (IS_PURE || !DESCRIPTORS))
    || !searchParams.sort
    || url.href !== 'http://a/c%20d?a=1&c=3'
    || searchParams.get('c') !== '3'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !searchParams[ITERATOR]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('http://тест').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('http://a#б').hash !== '#%D0%B1'
    // fails in Chrome 66-
    || result !== 'a1c3'
    // throws in Safari
    || new URL('http://x', undefined).host !== 'x';
});


/***/ }),

/***/ "f36a":
/***/ (function(module, exports, __webpack_require__) {

var uncurryThis = __webpack_require__("e330");

module.exports = uncurryThis([].slice);


/***/ }),

/***/ "f376":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ariaHidden; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return iconAsButton; });
/* harmony import */ var _utils_private_cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d54d");

var ariaHidden = {
  'aria-hidden': 'true'
};
var iconAsButton = {
  tabindex: 0,
  type: 'button',
  'aria-hidden': false,
  role: null
};
/* harmony default export */ __webpack_exports__["b"] = (Object(_utils_private_cache_js__WEBPACK_IMPORTED_MODULE_0__[/* getPropCacheMixin */ "b"])('$attrs', 'qAttrs'));

/***/ }),

/***/ "f445":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__("c39d")
var combining = __webpack_require__("a72d")

var DEFAULTS = {
  nul: 0,
  control: 0
}

module.exports = function wcwidth(str) {
  return wcswidth(str, DEFAULTS)
}

module.exports.config = function(opts) {
  opts = defaults(opts || {}, DEFAULTS)
  return function wcwidth(str) {
    return wcswidth(str, opts)
  }
}

/*
 *  The following functions define the column width of an ISO 10646
 *  character as follows:
 *  - The null character (U+0000) has a column width of 0.
 *  - Other C0/C1 control characters and DEL will lead to a return value
 *    of -1.
 *  - Non-spacing and enclosing combining characters (general category
 *    code Mn or Me in the
 *    Unicode database) have a column width of 0.
 *  - SOFT HYPHEN (U+00AD) has a column width of 1.
 *  - Other format characters (general category code Cf in the Unicode
 *    database) and ZERO WIDTH
 *    SPACE (U+200B) have a column width of 0.
 *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
 *    have a column width of 0.
 *  - Spacing characters in the East Asian Wide (W) or East Asian
 *    Full-width (F) category as
 *    defined in Unicode Technical Report #11 have a column width of 2.
 *  - All remaining characters (including all printable ISO 8859-1 and
 *    WGL4 characters, Unicode control characters, etc.) have a column
 *    width of 1.
 *  This implementation assumes that characters are encoded in ISO 10646.
*/

function wcswidth(str, opts) {
  if (typeof str !== 'string') return wcwidth(str, opts)

  var s = 0
  for (var i = 0; i < str.length; i++) {
    var n = wcwidth(str.charCodeAt(i), opts)
    if (n < 0) return -1
    s += n
  }

  return s
}

function wcwidth(ucs, opts) {
  // test for 8-bit control characters
  if (ucs === 0) return opts.nul
  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return opts.control

  // binary search in table of non-spacing characters
  if (bisearch(ucs)) return 0

  // if we arrive here, ucs is not a combining or C0/C1 control character
  return 1 +
      (ucs >= 0x1100 &&
       (ucs <= 0x115f ||                       // Hangul Jamo init. consonants
        ucs == 0x2329 || ucs == 0x232a ||
        (ucs >= 0x2e80 && ucs <= 0xa4cf &&
         ucs != 0x303f) ||                     // CJK ... Yi
        (ucs >= 0xac00 && ucs <= 0xd7a3) ||    // Hangul Syllables
        (ucs >= 0xf900 && ucs <= 0xfaff) ||    // CJK Compatibility Ideographs
        (ucs >= 0xfe10 && ucs <= 0xfe19) ||    // Vertical forms
        (ucs >= 0xfe30 && ucs <= 0xfe6f) ||    // CJK Compatibility Forms
        (ucs >= 0xff00 && ucs <= 0xff60) ||    // Fullwidth Forms
        (ucs >= 0xffe0 && ucs <= 0xffe6) ||
        (ucs >= 0x20000 && ucs <= 0x2fffd) ||
        (ucs >= 0x30000 && ucs <= 0x3fffd)));
}

function bisearch(ucs) {
  var min = 0
  var max = combining.length - 1
  var mid

  if (ucs < combining[0][0] || ucs > combining[max][1]) return false

  while (max >= min) {
    mid = Math.floor((min + max) / 2)
    if (ucs > combining[mid][1]) min = mid + 1
    else if (ucs < combining[mid][0]) max = mid - 1
    else return true
  }

  return false
}


/***/ }),

/***/ "f495":
/***/ (function(module, exports, __webpack_require__) {

var toPrimitive = __webpack_require__("c04e");

var $TypeError = TypeError;

// `ToBigInt` abstract operation
// https://tc39.es/ecma262/#sec-tobigint
module.exports = function (argument) {
  var prim = toPrimitive(argument, 'number');
  if (typeof prim == 'number') throw $TypeError("Can't convert number to bigint");
  // eslint-disable-next-line es/no-bigint -- safe
  return BigInt(prim);
};


/***/ }),

/***/ "f4d9":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "f517":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlock_vue_vue_type_style_index_0_id_8b34d9ea_prod_scoped_true_lang_sass___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("2448");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlock_vue_vue_type_style_index_0_id_8b34d9ea_prod_scoped_true_lang_sass___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlock_vue_vue_type_style_index_0_id_8b34d9ea_prod_scoped_true_lang_sass___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "f5d1":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "f5df":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var isCallable = __webpack_require__("1626");
var classofRaw = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "f6ba":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return addFocusWaitFlag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return removeFocusWaitFlag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addFocusFn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return removeFocusFn; });
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("4de4");
/* harmony import */ var core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("14d9");
/* harmony import */ var core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_push_js__WEBPACK_IMPORTED_MODULE_2__);



var queue = [];
var waitFlags = [];
function clearFlag(flag) {
  waitFlags = waitFlags.filter(function (entry) {
    return entry !== flag;
  });
}
function addFocusWaitFlag(flag) {
  clearFlag(flag);
  waitFlags.push(flag);
}
function removeFocusWaitFlag(flag) {
  clearFlag(flag);
  if (waitFlags.length === 0 && queue.length > 0) {
    // only call last focus handler (can't focus multiple things at once)
    queue[queue.length - 1]();
    queue = [];
  }
}
function addFocusFn(fn) {
  if (waitFlags.length === 0) {
    fn();
  } else {
    queue.push(fn);
  }
}
function removeFocusFn(fn) {
  queue = queue.filter(function (entry) {
    return entry !== fn;
  });
}

/***/ }),

/***/ "f6f8":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof = __webpack_require__("7037").default;
__webpack_require__("c73d");
/*!
 * Quasar Framework v1.22.10
 * (c) 2015-present Razvan Stoenescu
 * Released under the MIT License.
 */
!function (e, n) {
  "object" == ( false ? undefined : _typeof(exports)) && "undefined" != typeof module ? module.exports = n() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (n),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
}(this, function () {
  "use strict";

  return {
    isoName: "de",
    nativeName: "Deutsch",
    label: {
      clear: "Leeren",
      ok: "Ok",
      cancel: "Abbrechen",
      close: "Schließen",
      set: "Setzen",
      select: "Auswählen",
      reset: "Zurücksetzen",
      remove: "Löschen",
      update: "Aktualisieren",
      create: "Erstellen",
      search: "Suche",
      filter: "Filter",
      refresh: "Aktualisieren",
      expand: function expand(e) {
        return e ? 'Erweitern Sie "' + e + '"' : "Erweitern";
      },
      collapse: function collapse(e) {
        return e ? '"' + e + '" minimieren' : "Zusammenbruch";
      }
    },
    date: {
      days: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
      daysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
      months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
      monthsShort: "Jan_Feb_Mar_Apr_Mai_Jun_Jul_Aug_Sep_Okt_Nov_Dez".split("_"),
      firstDayOfWeek: 1,
      format24h: !0,
      pluralDay: "Tage"
    },
    table: {
      noData: "Keine Daten vorhanden.",
      noResults: "Keine Einträge gefunden",
      loading: "Lade...",
      selectedRecords: function selectedRecords(e) {
        return e > 1 ? e + " ausgewählte Zeilen" : (0 === e ? "Keine" : "1") + " ausgewählt.";
      },
      recordsPerPage: "Zeilen pro Seite",
      allRows: "Alle",
      pagination: function pagination(e, n, r) {
        return e + "-" + n + " von " + r;
      },
      columns: "Spalten"
    },
    editor: {
      url: "URL",
      bold: "Fett",
      italic: "Kursiv",
      strikethrough: "Durchgestrichen",
      underline: "Unterstrichen",
      unorderedList: "Ungeordnete Liste",
      orderedList: "Geordnete Liste",
      subscript: "tiefgestellt",
      superscript: "hochgestellt",
      hyperlink: "Link",
      toggleFullscreen: "Vollbild umschalten",
      quote: "Zitat",
      left: "linksbündig",
      center: "zentriert",
      right: "rechtsbündig",
      justify: "Ausrichten",
      print: "Drucken",
      outdent: "ausrücken",
      indent: "einrücken",
      removeFormat: "Entferne Formatierung",
      formatting: "Formatiere",
      fontSize: "Schriftgröße",
      align: "Ausrichten",
      hr: "Horizontale Linie einfügen",
      undo: "Rückgänging",
      redo: "Wiederherstellen",
      heading1: "Überschrift 1",
      heading2: "Überschrift 2",
      heading3: "Überschrift 3",
      heading4: "Überschrift 4",
      heading5: "Überschrift 5",
      heading6: "Überschrift 6",
      paragraph: "Absatz",
      code: "Code",
      size1: "Sehr klein",
      size2: "klein",
      size3: "Normal",
      size4: "Groß",
      size5: "Größer",
      size6: "Sehr groß",
      size7: "Maximum",
      defaultFont: "Standard Schrift",
      viewSource: "Quelltext anzeigen"
    },
    tree: {
      noNodes: "Keine Knoten verfügbar",
      noResults: "Keine passenden Knoten gefunden"
    }
  };
});

/***/ }),

/***/ "f772":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("5692");
var uid = __webpack_require__("90e3");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "f89c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FormFieldMixin; });
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("b0c0");
/* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ __webpack_exports__["b"] = ({
  props: {
    name: String
  },
  computed: {
    formAttrs: function formAttrs() {
      return {
        type: 'hidden',
        name: this.name,
        value: this.value
      };
    }
  },
  methods: {
    __injectFormInput: function __injectFormInput(child, action, className) {
      child[action](this.$createElement('input', {
        staticClass: 'hidden',
        class: className,
        attrs: this.formAttrs,
        domProps: this.formDomProps
      }));
    }
  }
});
var FormFieldMixin = {
  props: {
    name: String
  },
  computed: {
    nameProp: function nameProp() {
      return this.name || this.for;
    }
  }
};

/***/ }),

/***/ "f8c9":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var setToStringTag = __webpack_require__("d44e");

$({ global: true }, { Reflect: {} });

// Reflect[@@toStringTag] property
// https://tc39.es/ecma262/#sec-reflect-@@tostringtag
setToStringTag(global.Reflect, 'Reflect', true);


/***/ }),

/***/ "f8cd":
/***/ (function(module, exports, __webpack_require__) {

var toIntegerOrInfinity = __webpack_require__("5926");

var $RangeError = RangeError;

module.exports = function (it) {
  var result = toIntegerOrInfinity(it);
  if (result < 0) throw $RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ "f9d4":
/***/ (function(module, exports, __webpack_require__) {

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/5/LICENSE

(function(mod) {
  if (true) // CommonJS
    mod(__webpack_require__("56b3"));
  else {}
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var trackScope = parserConfig.trackScope !== false
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    return {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
      "await": C
    };
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (expressionAllowed(stream, state, 1)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eat("=");
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#" && stream.peek() == "!") {
      stream.skipToEnd();
      return ret("meta", "meta");
    } else if (ch == "#" && stream.eatWhile(wordRE)) {
      return ret("variable", "property")
    } else if (ch == "<" && stream.match("!--") ||
               (ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start)))) {
      stream.skipToEnd()
      return ret("comment", "comment")
    } else if (isOperatorChar.test(ch)) {
      if (ch != ">" || !state.lexical || state.lexical.type != ">") {
        if (stream.eat("=")) {
          if (ch == "!" || ch == "=") stream.eat("=")
        } else if (/[<>*+\-|&?]/.test(ch)) {
          stream.eat(ch)
          if (ch == ">") stream.eat(ch)
        }
      }
      if (ch == "?" && stream.eat(".")) return ret(".")
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current()
      if (state.lastType != ".") {
        if (keywords.propertyIsEnumerable(word)) {
          var kw = keywords[word]
          return ret(kw.type, kw.style, word)
        }
        if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
          return ret("async", "keyword", word)
      }
      return ret("variable", "variable", word)
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
      if (m) arrow = m.index
    }

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/`]/.test(ch)) {
        for (;; --pos) {
          if (pos == 0) return
          var next = stream.string.charAt(pos - 1)
          if (next == ch && stream.string.charAt(pos - 2) != "\\") { pos--; break }
        }
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true,
                     "regexp": true, "this": true, "import": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    if (!trackScope) return false
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function inList(name, list) {
    for (var v = list; v; v = v.next) if (v.name == name) return true
    return false;
  }
  function register(varname) {
    var state = cx.state;
    cx.marked = "def";
    if (!trackScope) return
    if (state.context) {
      if (state.lexical.info == "var" && state.context && state.context.block) {
        // FIXME function decls are also not block scoped
        var newContext = registerVarScoped(varname, state.context)
        if (newContext != null) {
          state.context = newContext
          return
        }
      } else if (!inList(varname, state.localVars)) {
        state.localVars = new Var(varname, state.localVars)
        return
      }
    }
    // Fall through means this is global
    if (parserConfig.globalVars && !inList(varname, state.globalVars))
      state.globalVars = new Var(varname, state.globalVars)
  }
  function registerVarScoped(varname, context) {
    if (!context) {
      return null
    } else if (context.block) {
      var inner = registerVarScoped(varname, context.prev)
      if (!inner) return null
      if (inner == context.prev) return context
      return new Context(inner, context.vars, true)
    } else if (inList(varname, context.vars)) {
      return context
    } else {
      return new Context(context.prev, new Var(varname, context.vars), false)
    }
  }

  function isModifier(name) {
    return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
  }

  // Combinators

  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }
  function Var(name, next) { this.name = name; this.next = next }

  var defaultVars = new Var("this", new Var("arguments", null))
  function pushcontext() {
    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)
    cx.state.localVars = defaultVars
  }
  function pushblockcontext() {
    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)
    cx.state.localVars = null
  }
  pushcontext.lex = pushblockcontext.lex = true
  function popcontext() {
    cx.state.localVars = cx.state.context.vars
    cx.state.context = cx.state.context.prev
  }
  popcontext.lex = true
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
    if (type == "debugger") return cont(expect(";"));
    if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
    if (type == "class" || (isTS && value == "interface")) {
      cx.marked = "keyword"
      return cont(pushlex("form", type == "class" ? type : value), className, poplex)
    }
    if (type == "variable") {
      if (isTS && value == "declare") {
        cx.marked = "keyword"
        return cont(statement)
      } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
        cx.marked = "keyword"
        if (value == "enum") return cont(enumdef);
        else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
        else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
      } else if (isTS && value == "namespace") {
        cx.marked = "keyword"
        return cont(pushlex("form"), expression, statement, poplex)
      } else if (isTS && value == "abstract") {
        cx.marked = "keyword"
        return cont(statement)
      } else {
        return cont(pushlex("stat"), maybelabel);
      }
    }
    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,
                                      block, poplex, poplex, popcontext);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
    if (type == "async") return cont(statement)
    if (value == "@") return cont(expression, statement)
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function maybeCatchBinding(type) {
    if (type == "(") return cont(funarg, expect(")"))
  }
  function expression(type, value) {
    return expressionInner(type, value, false);
  }
  function expressionNoComma(type, value) {
    return expressionInner(type, value, true);
  }
  function parenExpr(type) {
    if (type != "(") return pass()
    return cont(pushlex(")"), maybeexpression, expect(")"), poplex)
  }
  function expressionInner(type, value, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") return pass(quasi, maybeop);
    if (type == "new") return cont(maybeTarget(noComma));
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(maybeexpression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
      if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
    if (type == "regexp") {
      cx.state.lastType = cx.marked = "operator"
      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
      return cont(expr)
    }
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(maybeexpression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybeTarget(noComma) {
    return function(type) {
      if (type == ".") return cont(noComma ? targetNoComma : target);
      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
      else return pass(noComma ? expressionNoComma : expression);
    };
  }
  function target(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
  }
  function targetNoComma(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "async") {
      cx.marked = "property";
      return cont(objprop);
    } else if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
        cx.state.fatArrowAt = cx.stream.pos + m[0].length
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (isTS && isModifier(value)) {
      cx.marked = "keyword"
      return cont(objprop)
    } else if (type == "[") {
      return cont(expression, maybetype, expect("]"), afterprop);
    } else if (type == "spread") {
      return cont(expressionNoComma, afterprop);
    } else if (value == "*") {
      cx.marked = "keyword";
      return cont(objprop);
    } else if (type == ":") {
      return pass(afterprop)
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end, sep) {
    function proceed(type, value) {
      if (sep ? sep.indexOf(type) > -1 : type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(function(type, value) {
          if (type == end || value == end) return pass()
          return pass(what)
        }, proceed);
      }
      if (type == end || value == end) return cont();
      if (sep && sep.indexOf(";") > -1) return pass(what)
      return cont(expect(end));
    }
    return function(type, value) {
      if (type == end || value == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type, value) {
    if (isTS) {
      if (type == ":") return cont(typeexpr);
      if (value == "?") return cont(maybetype);
    }
  }
  function maybetypeOrIn(type, value) {
    if (isTS && (type == ":" || value == "in")) return cont(typeexpr)
  }
  function mayberettype(type) {
    if (isTS && type == ":") {
      if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
      else return cont(typeexpr)
    }
  }
  function isKW(_, value) {
    if (value == "is") {
      cx.marked = "keyword"
      return cont()
    }
  }
  function typeexpr(type, value) {
    if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
      cx.marked = "keyword"
      return cont(value == "typeof" ? expressionNoComma : typeexpr)
    }
    if (type == "variable" || value == "void") {
      cx.marked = "type"
      return cont(afterType)
    }
    if (value == "|" || value == "&") return cont(typeexpr)
    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
    if (type == "{") return cont(pushlex("}"), typeprops, poplex, afterType)
    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)
    if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
    if (type == "quasi") { return pass(quasiType, afterType); }
  }
  function maybeReturnType(type) {
    if (type == "=>") return cont(typeexpr)
  }
  function typeprops(type) {
    if (type.match(/[\}\)\]]/)) return cont()
    if (type == "," || type == ";") return cont(typeprops)
    return pass(typeprop, typeprops)
  }
  function typeprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property"
      return cont(typeprop)
    } else if (value == "?" || type == "number" || type == "string") {
      return cont(typeprop)
    } else if (type == ":") {
      return cont(typeexpr)
    } else if (type == "[") {
      return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop)
    } else if (type == "(") {
      return pass(functiondecl, typeprop)
    } else if (!type.match(/[;\}\)\],]/)) {
      return cont()
    }
  }
  function quasiType(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasiType);
    return cont(typeexpr, continueQuasiType);
  }
  function continueQuasiType(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasiType);
    }
  }
  function typearg(type, value) {
    if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
    if (type == ":") return cont(typeexpr)
    if (type == "spread") return cont(typearg)
    return pass(typeexpr)
  }
  function afterType(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    if (value == "|" || type == "." || value == "&") return cont(typeexpr)
    if (type == "[") return cont(typeexpr, expect("]"), afterType)
    if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
    if (value == "?") return cont(typeexpr, expect(":"), typeexpr)
  }
  function maybeTypeArgs(_, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
  }
  function typeparam() {
    return pass(typeexpr, maybeTypeDefault)
  }
  function maybeTypeDefault(_, value) {
    if (value == "=") return cont(typeexpr)
  }
  function vardef(_, value) {
    if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
    if (type == "variable") { register(value); return cont(); }
    if (type == "spread") return cont(pattern);
    if (type == "[") return contCommasep(eltpattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    if (type == "spread") return cont(pattern);
    if (type == "}") return pass();
    if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
    return cont(expect(":"), pattern, maybeAssign);
  }
  function eltpattern() {
    return pass(pattern, maybeAssign)
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type, value) {
    if (value == "await") return cont(forspec);
    if (type == "(") return cont(pushlex(")"), forspec1, poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, forspec2);
    if (type == "variable") return cont(forspec2);
    return pass(forspec2)
  }
  function forspec2(type, value) {
    if (type == ")") return cont()
    if (type == ";") return cont(forspec2)
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }
    return pass(expression, forspec2)
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
  }
  function functiondecl(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondecl);}
    if (type == "variable") {register(value); return cont(functiondecl);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)
  }
  function typename(type, value) {
    if (type == "keyword" || type == "variable") {
      cx.marked = "type"
      return cont(typename)
    } else if (value == "<") {
      return cont(pushlex(">"), commasep(typeparam, ">"), poplex)
    }
  }
  function funarg(type, value) {
    if (value == "@") cont(expression, funarg)
    if (type == "spread") return cont(funarg);
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
    if (isTS && type == "this") return cont(maybetype, maybeAssign)
    return pass(pattern, maybetype, maybeAssign);
  }
  function classExpression(type, value) {
    // Class expressions may have an optional name.
    if (type == "variable") return className(type, value);
    return classNameAfter(type, value);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
    if (value == "extends" || value == "implements" || (isTS && type == ",")) {
      if (value == "implements") cx.marked = "keyword";
      return cont(isTS ? typeexpr : expression, classNameAfter);
    }
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "async" ||
        (type == "variable" &&
         (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
         cx.stream.match(/^\s+#?[\w$\xa1-\uffff]/, false))) {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      return cont(classfield, classBody);
    }
    if (type == "number" || type == "string") return cont(classfield, classBody);
    if (type == "[")
      return cont(expression, maybetype, expect("]"), classfield, classBody)
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (isTS && type == "(") return pass(functiondecl, classBody)
    if (type == ";" || type == ",") return cont(classBody);
    if (type == "}") return cont();
    if (value == "@") return cont(expression, classBody)
  }
  function classfield(type, value) {
    if (value == "!") return cont(classfield)
    if (value == "?") return cont(classfield)
    if (type == ":") return cont(typeexpr, maybeAssign)
    if (value == "=") return cont(expressionNoComma)
    var context = cx.state.lexical.prev, isInterface = context && context.info == "interface"
    return pass(isInterface ? functiondecl : functiondef)
  }
  function afterExport(type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
    return pass(statement);
  }
  function exportField(type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
    if (type == "variable") return pass(expressionNoComma, exportField);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    if (type == "(") return pass(expression);
    if (type == ".") return pass(maybeoperatorComma);
    return pass(importSpec, maybeMoreImports, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    if (value == "*") cx.marked = "keyword";
    return cont(maybeAs);
  }
  function maybeMoreImports(type) {
    if (type == ",") return cont(importSpec, maybeMoreImports)
  }
  function maybeAs(_type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(commasep(expressionNoComma, "]"));
  }
  function enumdef() {
    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
  }
  function enummember() {
    return pass(pattern, maybeAssign);
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  function expressionAllowed(stream, state, backUp) {
    return state.tokenize == tokenBase &&
      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && new Context(null, null, false),
        indented: basecolumn || 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse && c != popcontext) break;
      }
      while ((lexical.type == "stat" || lexical.type == "form") &&
             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
        lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    blockCommentContinue: jsonMode ? null : " * ",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode,

    expressionAllowed: expressionAllowed,

    skipExpression: function(state) {
      parseJS(state, "atom", "atom", "true", new CodeMirror.StringStream("", 2, null))
    }
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", { name: "javascript", json: true });
CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });
CodeMirror.defineMIME("application/manifest+json", { name: "javascript", json: true })
CodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});


/***/ }),

/***/ "fa37":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "fae3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var setPublicPath_src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (setPublicPath_src) {
    __webpack_require__.p = setPublicPath_src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("5319");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.constructor.js
var es_regexp_constructor = __webpack_require__("4d63");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.dot-all.js
var es_regexp_dot_all = __webpack_require__("c607");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.sticky.js
var es_regexp_sticky = __webpack_require__("2c3e");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__("25f0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find.js
var es_array_find = __webpack_require__("7db0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// EXTERNAL MODULE: ./node_modules/reflect-metadata/Reflect.js
var reflect_metadata_Reflect = __webpack_require__("98db");

// EXTERNAL MODULE: ./node_modules/vue-uuid/dist/index.esm.js + 12 modules
var index_esm = __webpack_require__("9612");

// CONCATENATED MODULE: ./src/plugins/uuid.ts


external_commonjs_vue_commonjs2_vue_root_Vue_default.a.use(index_esm["a" /* default */]);
// EXTERNAL MODULE: ./src/styles/quasar.styl
var quasar = __webpack_require__("a4ac");

// EXTERNAL MODULE: ./node_modules/@quasar/extras/material-icons/material-icons.css
var material_icons = __webpack_require__("e54f");

// EXTERNAL MODULE: ./node_modules/@quasar/extras/animate/fadeInUp.css
var fadeInUp = __webpack_require__("4953");

// EXTERNAL MODULE: ./node_modules/@quasar/extras/animate/fadeInDown.css
var fadeInDown = __webpack_require__("e9fd");

// EXTERNAL MODULE: ./node_modules/@quasar/extras/animate/fadeOutUp.css
var fadeOutUp = __webpack_require__("1dba");

// EXTERNAL MODULE: ./node_modules/@quasar/extras/animate/fadeOutDown.css
var fadeOutDown = __webpack_require__("f5d1");

// EXTERNAL MODULE: ./node_modules/@quasar/extras/animate/fadeIn.css
var fadeIn = __webpack_require__("4848");

// EXTERNAL MODULE: ./node_modules/@quasar/extras/animate/fadeOut.css
var fadeOut = __webpack_require__("c382");

// EXTERNAL MODULE: ./node_modules/@quasar/extras/animate/zoomInDown.css
var zoomInDown = __webpack_require__("c00e");

// EXTERNAL MODULE: ./node_modules/@quasar/extras/animate/zoomInUp.css
var zoomInUp = __webpack_require__("f4d9");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var objectSpread2 = __webpack_require__("5530");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__("14d9");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/dialog/QDialog.js + 2 modules
var QDialog = __webpack_require__("24e8");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/btn/QBtn.js + 1 modules
var QBtn = __webpack_require__("9c40");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
var esm_defineProperty = __webpack_require__("ade3");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js + 3 modules
var toConsumableArray = __webpack_require__("2909");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__("e260");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.weak-map.js
var es_weak_map = __webpack_require__("10d1");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.flags.js
var es_regexp_flags = __webpack_require__("5377");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.js
var es_set = __webpack_require__("6062");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.map.js
var es_map = __webpack_require__("4ec9");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.assign.js
var es_object_assign = __webpack_require__("cca6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__("d81d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.keys.js
var es_object_keys = __webpack_require__("b64b");

// CONCATENATED MODULE: ./node_modules/quasar/src/utils/clone.js




















// adapted from https://stackoverflow.com/a/40294058

function cloneDeep(data) {
  var hash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new WeakMap();
  if (Object(data) !== data) return data;
  if (hash.has(data)) return hash.get(data);
  var result = data instanceof Date ? new Date(data) : data instanceof RegExp ? new RegExp(data.source, data.flags) : data instanceof Set ? new Set() : data instanceof Map ? new Map() : typeof data.constructor !== 'function' ? Object.create(null) : data.prototype !== void 0 && typeof data.prototype.constructor === 'function' ? data : new data.constructor();
  if (typeof data.constructor === 'function' && typeof data.valueOf === 'function') {
    var val = data.valueOf();
    if (Object(val) !== val) {
      var _result = new data.constructor(val);
      hash.set(data, _result);
      return _result;
    }
  }
  hash.set(data, result);
  if (data instanceof Set) {
    data.forEach(function (val) {
      result.add(cloneDeep(val, hash));
    });
  } else if (data instanceof Map) {
    data.forEach(function (val, key) {
      result.set(key, cloneDeep(val, hash));
    });
  }
  return Object.assign.apply(Object, [result].concat(Object(toConsumableArray["a" /* default */])(Object.keys(data).map(function (key) {
    return Object(esm_defineProperty["a" /* default */])({}, key, cloneDeep(data[key], hash));
  }))));
}
// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/key-composition.js
var key_composition = __webpack_require__("dc8a");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/card/QCard.js
var QCard = __webpack_require__("f09f");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/card/QCardSection.js
var QCardSection = __webpack_require__("a370");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/align.js
var align = __webpack_require__("99b6");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/listeners.js
var listeners = __webpack_require__("87e8");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/slot.js
var slot = __webpack_require__("e277");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/card/QCardActions.js






/* harmony default export */ var QCardActions = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QCardActions',
  mixins: [listeners["a" /* default */], align["a" /* default */]],
  props: {
    vertical: Boolean
  },
  computed: {
    classes: function classes() {
      return "q-card__actions--".concat(this.vertical === true ? 'vert column' : 'horiz row', " ").concat(this.alignClass);
    }
  },
  render: function render(h) {
    return h('div', {
      staticClass: 'q-card__actions',
      class: this.classes,
      on: Object(objectSpread2["a" /* default */])({}, this.qListeners)
    }, Object(slot["c" /* slot */])(this, 'default'));
  }
}));
// EXTERNAL MODULE: ./node_modules/quasar/src/components/separator/QSeparator.js
var QSeparator = __webpack_require__("eb85");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/input/QInput.js + 2 modules
var QInput = __webpack_require__("27f9");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.includes.js
var es_string_includes = __webpack_require__("2532");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__("fb6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__("b0c0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/icon/QIcon.js
var QIcon = __webpack_require__("0016");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/dark.js
var dark = __webpack_require__("b7fa");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/option-size.js
var option_size = __webpack_require__("ff7b");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/form.js
var mixins_form = __webpack_require__("f89c");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/refocus-target.js
var refocus_target = __webpack_require__("2b69");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/event.js
var utils_event = __webpack_require__("d882");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/private/cache.js
var cache = __webpack_require__("d54d");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/radio/QRadio.js














/* harmony default export */ var QRadio = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QRadio',
  mixins: [dark["a" /* default */], option_size["a" /* default */], mixins_form["b" /* default */], refocus_target["a" /* default */]],
  props: {
    value: {
      required: true
    },
    val: {
      required: true
    },
    label: String,
    leftLabel: Boolean,
    checkedIcon: String,
    uncheckedIcon: String,
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    disable: Boolean,
    tabindex: [String, Number]
  },
  computed: {
    isTrue: function isTrue() {
      return this.value === this.val;
    },
    classes: function classes() {
      return 'q-radio cursor-pointer no-outline row inline no-wrap items-center' + (this.disable === true ? ' disabled' : '') + (this.isDark === true ? ' q-radio--dark' : '') + (this.dense === true ? ' q-radio--dense' : '') + (this.leftLabel === true ? ' reverse' : '');
    },
    innerClass: function innerClass() {
      var color = this.color !== void 0 && (this.keepColor === true || this.isTrue === true) ? " text-".concat(this.color) : '';
      return "q-radio__inner--".concat(this.isTrue === true ? 'truthy' : 'falsy').concat(color);
    },
    computedIcon: function computedIcon() {
      return this.isTrue === true ? this.checkedIcon : this.uncheckedIcon;
    },
    computedTabindex: function computedTabindex() {
      return this.disable === true ? -1 : this.tabindex || 0;
    },
    formAttrs: function formAttrs() {
      var prop = {
        type: 'radio'
      };
      this.name !== void 0 && Object.assign(prop, {
        name: this.name,
        value: this.val
      });
      return prop;
    },
    formDomProps: function formDomProps() {
      if (this.name !== void 0 && this.isTrue === true) {
        return {
          checked: true
        };
      }
    },
    attrs: function attrs() {
      var attrs = {
        tabindex: this.computedTabindex,
        role: 'radio',
        'aria-label': this.label,
        'aria-checked': this.isTrue === true ? 'true' : 'false'
      };
      if (this.disable === true) {
        attrs['aria-disabled'] = 'true';
      }
      return attrs;
    }
  },
  methods: {
    set: function set(e) {
      if (e !== void 0) {
        Object(utils_event["j" /* stopAndPrevent */])(e);
        this.__refocusTarget(e);
      }
      if (this.disable !== true && this.isTrue !== true) {
        this.$emit('input', this.val, e);
      }
    }
  },
  render: function render(h) {
    var _this = this;
    var content = this.computedIcon !== void 0 ? [h('div', {
      key: 'icon',
      staticClass: 'q-radio__icon-container absolute-full flex flex-center no-wrap'
    }, [h(QIcon["a" /* default */], {
      staticClass: 'q-radio__icon',
      props: {
        name: this.computedIcon
      }
    })])] : [h('svg', {
      key: 'svg',
      staticClass: 'q-radio__bg absolute non-selectable',
      attrs: {
        focusable: 'false' /* needed for IE11 */,
        viewBox: '0 0 24 24'
      }
    }, [h('path', {
      attrs: {
        d: 'M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12'
      }
    }), h('path', {
      staticClass: 'q-radio__check',
      attrs: {
        d: 'M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6'
      }
    })])];
    this.disable !== true && this.__injectFormInput(content, 'unshift', 'q-radio__native q-ma-none q-pa-none');
    var child = [h('div', {
      staticClass: 'q-radio__inner relative-position',
      class: this.innerClass,
      style: this.sizeStyle,
      attrs: {
        'aria-hidden': 'true'
      }
    }, content)];
    if (this.__refocusTargetEl !== void 0) {
      child.push(this.__refocusTargetEl);
    }
    var label = this.label !== void 0 ? Object(slot["a" /* mergeSlot */])([this.label], this, 'default') : Object(slot["c" /* slot */])(this, 'default');
    label !== void 0 && child.push(h('div', {
      staticClass: 'q-radio__label q-anchor--skip'
    }, label));
    return h('div', {
      class: this.classes,
      attrs: this.attrs,
      on: Object(cache["a" /* default */])(this, 'inpExt', {
        click: this.set,
        keydown: function keydown(e) {
          if (e.keyCode === 13 || e.keyCode === 32) {
            Object(utils_event["j" /* stopAndPrevent */])(e);
          }
        },
        keyup: function keyup(e) {
          if (e.keyCode === 13 || e.keyCode === 32) {
            _this.set(e);
          }
        }
      })
    }, child);
  }
}));
// EXTERNAL MODULE: ./node_modules/quasar/src/components/checkbox/QCheckbox.js
var QCheckbox = __webpack_require__("8f8e");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/toggle/QToggle.js
var QToggle = __webpack_require__("9564");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/option-group/QOptionGroup.js















var components = {
  radio: QRadio,
  checkbox: QCheckbox["a" /* default */],
  toggle: QToggle["a" /* default */]
};
var typeValues = Object.keys(components);
/* harmony default export */ var QOptionGroup = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QOptionGroup',
  mixins: [dark["a" /* default */], listeners["a" /* default */]],
  props: {
    value: {
      required: true
    },
    options: {
      type: Array,
      validator: function validator(opts) {
        return opts.every(function (opt) {
          return 'value' in opt && 'label' in opt;
        });
      }
    },
    name: String,
    type: {
      default: 'radio',
      validator: function validator(v) {
        return typeValues.includes(v);
      }
    },
    color: String,
    keepColor: Boolean,
    dense: Boolean,
    size: String,
    leftLabel: Boolean,
    inline: Boolean,
    disable: Boolean
  },
  computed: {
    component: function component() {
      return components[this.type];
    },
    model: function model() {
      return Array.isArray(this.value) ? this.value.slice() : this.value;
    },
    classes: function classes() {
      return 'q-option-group q-gutter-x-sm' + (this.inline === true ? ' q-option-group--inline' : '');
    },
    attrs: function attrs() {
      if (this.type === 'radio') {
        var attrs = {
          role: 'radiogroup'
        };
        if (this.disable === true) {
          attrs['aria-disabled'] = 'true';
        }
        return attrs;
      }
      return {
        role: 'group'
      };
    }
  },
  methods: {
    __update: function __update(value) {
      this.$emit('input', value);
    }
  },
  created: function created() {
    var isArray = Array.isArray(this.value);
    if (this.type === 'radio') {
      if (isArray) {
        console.error('q-option-group: model should not be array');
      }
    } else if (isArray === false) {
      console.error('q-option-group: model should be array in your case');
    }
  },
  render: function render(h) {
    var _this = this;
    return h('div', {
      class: this.classes,
      attrs: this.attrs,
      on: Object(objectSpread2["a" /* default */])({}, this.qListeners)
    }, this.options.map(function (opt, i) {
      var child = _this.$scopedSlots['label-' + i] !== void 0 ? _this.$scopedSlots['label-' + i](opt) : _this.$scopedSlots.label !== void 0 ? _this.$scopedSlots.label(opt) : void 0;
      return h('div', [h(_this.component, {
        props: {
          value: _this.value,
          val: opt.value,
          name: opt.name === void 0 ? _this.name : opt.name,
          disable: _this.disable || opt.disable,
          label: child === void 0 ? opt.label : void 0,
          leftLabel: opt.leftLabel === void 0 ? _this.leftLabel : opt.leftLabel,
          color: opt.color === void 0 ? _this.color : opt.color,
          checkedIcon: opt.checkedIcon,
          uncheckedIcon: opt.uncheckedIcon,
          dark: opt.dark || _this.isDark,
          size: opt.size === void 0 ? _this.size : opt.size,
          dense: _this.dense,
          keepColor: opt.keepColor === void 0 ? _this.keepColor : opt.keepColor
        },
        on: Object(cache["a" /* default */])(_this, 'inp', {
          input: _this.__update
        })
      }, child)]);
    }));
  }
}));
// EXTERNAL MODULE: ./node_modules/quasar/src/components/spinner/QSpinner.js + 1 modules
var QSpinner = __webpack_require__("0d59");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/attrs.js
var mixins_attrs = __webpack_require__("f376");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/is.js
var is = __webpack_require__("5ff7");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/dialog-plugin/DialogPlugin.js



















/* harmony default export */ var DialogPlugin = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'DialogPlugin',
  mixins: [dark["a" /* default */], mixins_attrs["b" /* default */]],
  inheritAttrs: false,
  props: {
    title: String,
    message: String,
    prompt: Object,
    options: Object,
    progress: [Boolean, Object],
    html: Boolean,
    ok: {
      type: [String, Object, Boolean],
      default: true
    },
    cancel: [String, Object, Boolean],
    focus: {
      type: String,
      default: 'ok',
      validator: function validator(v) {
        return ['ok', 'cancel', 'none'].includes(v);
      }
    },
    stackButtons: Boolean,
    color: String,
    cardClass: [String, Array, Object],
    cardStyle: [String, Array, Object]
  },
  computed: {
    classes: function classes() {
      return 'q-dialog-plugin' + (this.isDark === true ? ' q-dialog-plugin--dark q-dark' : '') + (this.progress !== false ? ' q-dialog-plugin--progress' : '');
    },
    spinner: function spinner() {
      if (this.progress !== false) {
        return Object(is["b" /* isObject */])(this.progress) === true ? {
          component: this.progress.spinner || QSpinner["a" /* default */],
          props: {
            color: this.progress.color || this.vmColor
          }
        } : {
          component: QSpinner["a" /* default */],
          props: {
            color: this.vmColor
          }
        };
      }
    },
    hasForm: function hasForm() {
      return this.prompt !== void 0 || this.options !== void 0;
    },
    okLabel: function okLabel() {
      return Object(is["b" /* isObject */])(this.ok) === true ? this.$q.lang.label.ok : this.ok === true ? this.$q.lang.label.ok : this.ok;
    },
    cancelLabel: function cancelLabel() {
      return Object(is["b" /* isObject */])(this.cancel) === true ? this.$q.lang.label.cancel : this.cancel === true ? this.$q.lang.label.cancel : this.cancel;
    },
    vmColor: function vmColor() {
      return this.color || (this.isDark === true ? 'amber' : 'primary');
    },
    okDisabled: function okDisabled() {
      if (this.prompt !== void 0) {
        return this.prompt.isValid !== void 0 && this.prompt.isValid(this.prompt.model) !== true;
      }
      if (this.options !== void 0) {
        return this.options.isValid !== void 0 && this.options.isValid(this.options.model) !== true;
      }
    },
    okProps: function okProps() {
      return Object(objectSpread2["a" /* default */])({
        color: this.vmColor,
        label: this.okLabel,
        ripple: false,
        disable: this.okDisabled
      }, Object(is["b" /* isObject */])(this.ok) === true ? this.ok : {
        flat: true
      });
    },
    cancelProps: function cancelProps() {
      return Object(objectSpread2["a" /* default */])({
        color: this.vmColor,
        label: this.cancelLabel,
        ripple: false
      }, Object(is["b" /* isObject */])(this.cancel) === true ? this.cancel : {
        flat: true
      });
    }
  },
  methods: {
    show: function show() {
      this.$refs.dialog.show();
    },
    hide: function hide() {
      this.$refs.dialog.hide();
    },
    getPrompt: function getPrompt(h) {
      var _this = this;
      return [h(QInput["a" /* default */], {
        props: {
          value: this.prompt.model,
          type: this.prompt.type,
          label: this.prompt.label,
          stackLabel: this.prompt.stackLabel,
          outlined: this.prompt.outlined,
          filled: this.prompt.filled,
          standout: this.prompt.standout,
          rounded: this.prompt.rounded,
          square: this.prompt.square,
          counter: this.prompt.counter,
          maxlength: this.prompt.maxlength,
          prefix: this.prompt.prefix,
          suffix: this.prompt.suffix,
          color: this.vmColor,
          dense: true,
          autofocus: true,
          dark: this.isDark
        },
        attrs: this.prompt.attrs,
        on: Object(cache["a" /* default */])(this, 'prompt', {
          input: function input(v) {
            _this.prompt.model = v;
          },
          keyup: function keyup(evt) {
            // if ENTER key
            if (_this.okDisabled !== true && _this.prompt.type !== 'textarea' && Object(key_composition["a" /* isKeyCode */])(evt, 13) === true) {
              _this.onOk();
            }
          }
        })
      })];
    },
    getOptions: function getOptions(h) {
      var _this2 = this;
      return [h(QOptionGroup, {
        props: {
          value: this.options.model,
          type: this.options.type,
          color: this.vmColor,
          inline: this.options.inline,
          options: this.options.items,
          dark: this.isDark
        },
        on: Object(cache["a" /* default */])(this, 'opts', {
          input: function input(v) {
            _this2.options.model = v;
          }
        })
      })];
    },
    getButtons: function getButtons(h) {
      var child = [];
      this.cancel && child.push(h(QBtn["a" /* default */], {
        props: this.cancelProps,
        attrs: {
          'data-autofocus': this.focus === 'cancel' && this.hasForm !== true
        },
        on: Object(cache["a" /* default */])(this, 'cancel', {
          click: this.onCancel
        })
      }));
      this.ok && child.push(h(QBtn["a" /* default */], {
        props: this.okProps,
        attrs: {
          'data-autofocus': this.focus === 'ok' && this.hasForm !== true
        },
        on: Object(cache["a" /* default */])(this, 'ok', {
          click: this.onOk
        })
      }));
      if (child.length > 0) {
        return h(QCardActions, {
          staticClass: this.stackButtons === true ? 'items-end' : null,
          props: {
            vertical: this.stackButtons,
            align: 'right'
          }
        }, child);
      }
    },
    onOk: function onOk() {
      this.$emit('ok', cloneDeep(this.getData()));
      this.hide();
    },
    onCancel: function onCancel() {
      this.hide();
    },
    getData: function getData() {
      return this.prompt !== void 0 ? this.prompt.model : this.options !== void 0 ? this.options.model : void 0;
    },
    getSection: function getSection(h, staticClass, text) {
      return this.html === true ? h(QCardSection["a" /* default */], {
        staticClass: staticClass,
        domProps: {
          innerHTML: text
        }
      }) : h(QCardSection["a" /* default */], {
        staticClass: staticClass
      }, [text]);
    }
  },
  render: function render(h) {
    var _this3 = this;
    var child = [];
    this.title && child.push(this.getSection(h, 'q-dialog__title', this.title));
    this.progress !== false && child.push(h(QCardSection["a" /* default */], {
      staticClass: 'q-dialog__progress'
    }, [h(this.spinner.component, {
      props: this.spinner.props
    })]));
    this.message && child.push(this.getSection(h, 'q-dialog__message', this.message));
    if (this.prompt !== void 0) {
      child.push(h(QCardSection["a" /* default */], {
        staticClass: 'scroll q-dialog-plugin__form'
      }, this.getPrompt(h)));
    } else if (this.options !== void 0) {
      child.push(h(QSeparator["a" /* default */], {
        props: {
          dark: this.isDark
        }
      }), h(QCardSection["a" /* default */], {
        staticClass: 'scroll q-dialog-plugin__form'
      }, this.getOptions(h)), h(QSeparator["a" /* default */], {
        props: {
          dark: this.isDark
        }
      }));
    }
    if (this.ok || this.cancel) {
      child.push(this.getButtons(h));
    }
    return h(QDialog["a" /* default */], {
      ref: 'dialog',
      props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.qAttrs), {}, {
        value: this.value
      }),
      on: Object(cache["a" /* default */])(this, 'hide', {
        hide: function hide() {
          _this3.$emit('hide');
        }
      })
    }, [h(QCard["a" /* default */], {
      staticClass: this.classes,
      style: this.cardStyle,
      class: this.cardClass,
      props: {
        dark: this.isDark
      }
    }, child)]);
  }
}));
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__("a4d3");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js


function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
// EXTERNAL MODULE: ./node_modules/quasar/src/plugins/Platform.js
var Platform = __webpack_require__("0967");

// CONCATENATED MODULE: ./node_modules/quasar/src/utils/private/global-dialog.js


var _excluded = ["className", "class", "style", "component", "root", "parent"],
  _excluded2 = ["className", "class", "style", "component", "root", "parent"];





var ssrAPI = {
  onOk: function onOk() {
    return ssrAPI;
  },
  okCancel: function okCancel() {
    return ssrAPI;
  },
  hide: function hide() {
    return ssrAPI;
  },
  update: function update() {
    return ssrAPI;
  }
};
function merge(target, source) {
  for (var key in source) {
    if (key !== 'spinner' && Object(source[key]) === source[key]) {
      target[key] = Object(target[key]) !== target[key] ? {} : Object(objectSpread2["a" /* default */])({}, target[key]);
      merge(target[key], source[key]);
    } else {
      target[key] = source[key];
    }
  }
}
var appRoot;
function getDialogParent(parent, root) {
  if (parent !== void 0) {
    return parent;
  }
  if (root !== void 0) {
    return root;
  }
  if (appRoot === void 0) {
    var elRoot = document.getElementById('q-app');
    if (elRoot && elRoot.__vue__) {
      appRoot = elRoot.__vue__.$root;
    }
  }
  return appRoot;
}
/* harmony default export */ var global_dialog = (function (DefaultComponent) {
  return function (_ref) {
    var className = _ref.className,
      klass = _ref.class,
      style = _ref.style,
      component = _ref.component,
      root = _ref.root,
      parent = _ref.parent,
      props = _objectWithoutProperties(_ref, _excluded);
    if (Platform["e" /* isSSR */] === true) {
      return ssrAPI;
    }
    klass !== void 0 && (props.cardClass = klass);
    style !== void 0 && (props.cardStyle = style);
    var isCustom = component !== void 0;
    var DialogComponent, attrs;
    if (isCustom === true) {
      DialogComponent = component;
    } else {
      DialogComponent = DefaultComponent;
      attrs = props;
    }
    var okFns = [],
      cancelFns = [],
      API = {
        onOk: function onOk(fn) {
          okFns.push(fn);
          return API;
        },
        onCancel: function onCancel(fn) {
          cancelFns.push(fn);
          return API;
        },
        onDismiss: function onDismiss(fn) {
          okFns.push(fn);
          cancelFns.push(fn);
          return API;
        },
        hide: function hide() {
          vm.$refs.dialog.hide();
          return API;
        },
        update: function update(_ref2) {
          var className = _ref2.className,
            klass = _ref2.class,
            style = _ref2.style,
            component = _ref2.component,
            root = _ref2.root,
            parent = _ref2.parent,
            cfg = _objectWithoutProperties(_ref2, _excluded2);
          if (vm !== null) {
            klass !== void 0 && (cfg.cardClass = klass);
            style !== void 0 && (cfg.cardStyle = style);
            if (isCustom === true) {
              Object.assign(props, cfg);
            } else {
              merge(props, cfg);

              // need to change "attrs" reference to
              // actually reflect it in underlying component
              // when we force update it
              attrs = Object(objectSpread2["a" /* default */])({}, props);
            }
            vm.$forceUpdate();
          }
          return API;
        }
      };
    var node = document.createElement('div');
    document.body.appendChild(node);
    var emittedOK = false;
    var on = {
      ok: function ok(data) {
        emittedOK = true;
        okFns.forEach(function (fn) {
          fn(data);
        });
      },
      hide: function hide() {
        vm.$destroy();
        vm.$el.remove();
        vm = null;
        if (emittedOK !== true) {
          cancelFns.forEach(function (fn) {
            fn();
          });
        }
      }
    };
    var vm = new external_commonjs_vue_commonjs2_vue_root_Vue_default.a({
      name: 'QGlobalDialog',
      el: node,
      parent: getDialogParent(parent, root),
      render: function render(h) {
        return h(DialogComponent, {
          ref: 'dialog',
          props: props,
          attrs: attrs,
          on: on
        });
      },
      mounted: function mounted() {
        var _this = this;
        if (this.$refs.dialog !== void 0) {
          this.$refs.dialog.show();
        } else {
          on['hook:mounted'] = function () {
            _this.$refs.dialog !== void 0 && _this.$refs.dialog.show();
          };
        }
      }
    });
    return API;
  };
});
// CONCATENATED MODULE: ./node_modules/quasar/src/plugins/Dialog.js


/* harmony default export */ var Dialog = ({
  install: function install(_ref) {
    var $q = _ref.$q;
    this.create = $q.dialog = global_dialog(DialogPlugin);
  }
});
// EXTERNAL MODULE: ./node_modules/quasar/src/install.js + 4 modules
var src_install = __webpack_require__("81e7");

// EXTERNAL MODULE: ./node_modules/quasar/package.json
var quasar_package = __webpack_require__("c0a8");

// EXTERNAL MODULE: ./node_modules/quasar/src/lang.js + 1 modules
var src_lang = __webpack_require__("ec5d");

// EXTERNAL MODULE: ./node_modules/quasar/src/icon-set.js + 1 modules
var icon_set = __webpack_require__("9071");

// CONCATENATED MODULE: ./node_modules/quasar/src/ssr-update.js








var mixin = {
  mounted: function mounted() {
    var _this = this;
    src_install["c" /* queues */].takeover.forEach(function (run) {
      run(_this.$q);
    });
  }
};
/* harmony default export */ var ssr_update = (function (ctx) {
  if (ctx.ssr) {
    var q = Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, src_install["a" /* $q */]), {}, {
      ssrContext: ctx.ssr
    });
    Object.assign(ctx.ssr, {
      Q_HEAD_TAGS: '',
      Q_BODY_ATTRS: '',
      Q_BODY_TAGS: ''
    });
    ctx.app.$q = ctx.ssr.$q = q;
    src_install["c" /* queues */].server.forEach(function (run) {
      run(q, ctx);
    });
  } else {
    var mixins = ctx.app.mixins || [];
    if (mixins.includes(mixin) === false) {
      ctx.app.mixins = mixins.concat(mixin);
    }
  }
});
// CONCATENATED MODULE: ./node_modules/quasar/src/vue-plugin.js





/* harmony default export */ var vue_plugin = ({
  version: quasar_package["a" /* version */],
  install: src_install["b" /* default */],
  lang: src_lang["a" /* default */],
  iconSet: icon_set["a" /* default */],
  ssrUpdate: ssr_update
});
// EXTERNAL MODULE: ./node_modules/quasar/dist/lang/de.umd.min.js
var de_umd_min = __webpack_require__("f6f8");
var de_umd_min_default = /*#__PURE__*/__webpack_require__.n(de_umd_min);

// EXTERNAL MODULE: ./node_modules/quasar/dist/lang/en-gb.umd.min.js
var en_gb_umd_min = __webpack_require__("0680");
var en_gb_umd_min_default = /*#__PURE__*/__webpack_require__.n(en_gb_umd_min);

// CONCATENATED MODULE: ./src/plugins/quasar.ts













var quasar_lang = document.getElementsByTagName('html')[0].getAttribute('lang');


external_commonjs_vue_commonjs2_vue_root_Vue_default.a.use(vue_plugin, {
  config: {},
  components: {
    /* not needed if importStrategy is not 'manual' */
  },
  directives: {
    /* not needed if importStrategy is not 'manual' */
  },
  plugins: {
    Dialog: Dialog
  },
  animations: ['fadeIn', 'fadeOut'],
  lang: quasar_lang == 'de' ? de_umd_min_default.a : en_gb_umd_min_default.a
});
vue_plugin.lang.set(quasar_lang == 'de' ? de_umd_min_default.a : en_gb_umd_min_default.a);

// EXTERNAL MODULE: ./node_modules/vue-codemirror/dist/vue-codemirror.js
var vue_codemirror = __webpack_require__("8f94");

// EXTERNAL MODULE: ./node_modules/codemirror/lib/codemirror.css
var codemirror = __webpack_require__("a7be");

// CONCATENATED MODULE: ./src/plugins/codemirror.ts



Object(vue_codemirror["install"])(external_commonjs_vue_commonjs2_vue_root_Vue_default.a);
//Vue.use(VueCodeMirror, {})
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__("d4ec");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__("bee2");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
var es_string_trim = __webpack_require__("498a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.sort.js
var es_array_sort = __webpack_require__("4e82");

// EXTERNAL MODULE: ./src/lib/ICodeBlocks.ts
var ICodeBlocks = __webpack_require__("99f1");

// CONCATENATED MODULE: ./src/plugins/codeBlocks.ts











/**
 * This object defines the programming languages supported for code highlighting
 * using CodeMirror
 * @namespace cmMode The programminglanguages supported
 */
var mimeTypesForLanguage = {
  c: {
    mime: 'text/x-csrc',
    displayName: 'C'
  },
  'c++': {
    mime: 'text/x-c++src',
    displayName: 'C++'
  },
  'c#': {
    mime: 'text/x-csharp',
    displayName: 'C#'
  },
  css: {
    mime: 'text/css',
    displayName: 'CSS'
  },
  fortran: {
    mime: 'text/x-fortran',
    displayName: 'Fortran'
  },
  glsl: {
    mime: 'text/x-glsl',
    displayName: 'GLSL'
  },
  html: {
    mime: 'text/html',
    displayName: 'HTML'
  },
  java: {
    mime: 'text/x-java',
    displayName: 'Java'
  },
  javascript: {
    mime: 'text/javascript',
    displayName: 'JavaScript'
  },
  perl: {
    mime: 'text/x-perl',
    displayName: 'Perl'
  },
  php: {
    mime: 'application/x-httpd-php',
    displayName: 'PHP'
  },
  python: {
    mime: 'text/x-python',
    displayName: 'Python'
  },
  r: {
    mime: 'text/x-rsrc',
    displayName: 'R'
  } //(R)
};

function loadSettings(scope) {
  var options = {
    baseurl: ''
  };
  var settings = scope.querySelectorAll('meta[name^=codeblocks]');
  settings.forEach(function (opt) {
    var name = opt.getAttribute('name');
    var value = opt.getAttribute('content');
    if (name == 'codeblocks-baseurl' && value) {
      options.baseurl = value;
    }
  });
  return options;
}
var codeBlocks_GlobalState = /*#__PURE__*/function () {
  function GlobalState() {
    Object(classCallCheck["a" /* default */])(this, GlobalState);
    var options = loadSettings(document);
    this.baseurl = options.baseurl;
  }
  Object(createClass["a" /* default */])(GlobalState, [{
    key: "format_info",
    value: function format_info(text) {
      return '<span style="color:green">' + text + '</span>';
    }
  }, {
    key: "format_error",
    value: function format_error(text) {
      return '<span style="color:red">' + text + '</span>';
    }
    /**
     * Seperates an outputObject (like the one you will get in the update-method of a playground handler) into a string and a json object seperated by a magic String. Returns an object that contains
     *  <code>type</code> = <code>'dual'</code> parsed a magic string, <code>'json'</code> parsed as json, <code>'text'</code> plain text
     *  <code>json</code> = the JSON object that was sent after the magicString
     *  <code>text</code> = the String that was sent before the magicString
     * @param {*} outputObject  The outputObject generated by the student code
     * @param {*} type  'auto' = (default, try to determin what kind of output was generated), 'text', 'json' = (force json parsing), 'magic' = (force use of magic string seperator)
     * @param {*} magicString The seperating String. By default it is '\n\n<JSON>\n'
     */
  }, {
    key: "processMixedOutput",
    value: function processMixedOutput(outputObject, type, magicString, resultData) {
      if (outputObject !== undefined && Array.isArray(outputObject)) {
        return {
          type: 'json',
          json: outputObject,
          text: ''
        };
      }
      if (magicString === undefined) {
        magicString = '\n\n<JSON>\n';
      }
      var idx = outputObject.indexOf(magicString);
      if (type === ICodeBlocks["b" /* CodeOutputTypes */].DATA || type === ICodeBlocks["b" /* CodeOutputTypes */].AUTO && resultData != undefined) {
        return {
          type: 'dual',
          json: resultData,
          text: outputObject
        };
      } else if (type === ICodeBlocks["b" /* CodeOutputTypes */].AUTO && idx >= 0 || type === ICodeBlocks["b" /* CodeOutputTypes */].MAGIC) {
        var str = outputObject.substr(0, idx);
        var json = undefined;
        var pString = outputObject.substr(idx + magicString.length);
        try {
          json = JSON.parse(pString);
        } catch (ee) {
          var e = ee;
          e.parsedString = pString;
          console.log('catch');
          throw e;
        }
        return {
          type: 'dual',
          json: json,
          text: str
        };
      } else {
        if (type === ICodeBlocks["b" /* CodeOutputTypes */].JSON && resultData !== undefined) {
          return {
            type: ICodeBlocks["b" /* CodeOutputTypes */].JSON,
            json: resultData,
            text: ''
          };
        }
        var too = outputObject.trim();
        if (type === ICodeBlocks["b" /* CodeOutputTypes */].AUTO && (too.indexOf('[') == 0 || too.indexOf('{') == 0) || type === ICodeBlocks["b" /* CodeOutputTypes */].JSON) {
          return {
            type: ICodeBlocks["b" /* CodeOutputTypes */].JSON,
            json: JSON.parse(outputObject),
            text: ''
          };
        }
      }
      return {
        type: 'text',
        json: resultData,
        text: outputObject
      };
    }
  }, {
    key: "mimeType",
    value: function mimeType(language) {
      var o = mimeTypesForLanguage[language];
      if (o === undefined) {
        return 'text/javascript';
      }
      return o.mime;
    }
  }, {
    key: "knownLanguages",
    value: function knownLanguages() {
      return Object.keys(mimeTypesForLanguage).map(function (k) {
        return {
          label: mimeTypesForLanguage[k].displayName,
          value: k
        };
      }).sort(function (a, b) {
        return a.value < b.value ? -1 : 1;
      });
    }
  }, {
    key: "refreshAllCodeMirrorsSync",
    value: function refreshAllCodeMirrorsSync() {
      document.querySelectorAll('.CodeMirror').forEach(function (e) {
        return e.CodeMirror.refresh();
      });
    }
  }, {
    key: "refreshAllCodeMirrors",
    value: function refreshAllCodeMirrors() {
      var _this = this;
      setTimeout(function () {
        _this.refreshAllCodeMirrorsSync();
      }, 100);
      setTimeout(function () {
        _this.refreshAllCodeMirrorsSync();
      }, 500);
    }
  }, {
    key: "itemForValue",
    value: function itemForValue(items, value) {
      var ret = items.find(function (i) {
        return i.value == value;
      });
      if (ret === undefined) {
        return {
          label: '???',
          value: '???'
        };
      }
      return ret;
    }
  }]);
  return GlobalState;
}();
var globalState = new codeBlocks_GlobalState();
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.prototype.$CodeBlock = globalState;
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$CodeBlock = globalState;
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$GlobalEventHub = new external_commonjs_vue_commonjs2_vue_root_Vue_default.a();
// EXTERNAL MODULE: ./src/lib/ICompilerRegistry.ts
var ICompilerRegistry = __webpack_require__("6e19");

// CONCATENATED MODULE: ./src/plugins/compilerState.ts


external_commonjs_vue_commonjs2_vue_root_Vue_default.a.prototype.SEVERITY_ERROR = ICompilerRegistry["a" /* ErrorSeverity */].Error;
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.prototype.SEVERITY_WARNING = ICompilerRegistry["a" /* ErrorSeverity */].Warning;
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$SEVERITY_ERROR = ICompilerRegistry["a" /* ErrorSeverity */].Error;
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$SEVERITY_WARNING = ICompilerRegistry["a" /* ErrorSeverity */].Warning;
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.prototype.$compilerState = new external_commonjs_vue_commonjs2_vue_root_Vue_default.a({
  data: function data() {
    return {
      globalStateHidden: true,
      globalStateMessage: '',
      runButtonForceHide: false
    };
  },
  methods: {
    hideGlobalState: function hideGlobalState() {
      this.displayGlobalState(null);
    },
    setAllRunButtons: function setAllRunButtons(what) {
      this.runButtonForceHide = !what;
    },
    displayGlobalState: function displayGlobalState(message) {
      this.globalStateHidden = message === null || message === undefined || message === '';
      this.globalStateMessage = message ? message : '';
    }
  }
});
// EXTERNAL MODULE: ./node_modules/highlight.js/lib/core.js
var core = __webpack_require__("1020");
var core_default = /*#__PURE__*/__webpack_require__.n(core);

// EXTERNAL MODULE: ./node_modules/highlight.js/styles/tomorrow.css
var tomorrow = __webpack_require__("0dbe");

// EXTERNAL MODULE: ./src/styles/highlight.styl
var highlight = __webpack_require__("d8af");

// CONCATENATED MODULE: ./src/plugins/highlight.ts






//import 'highlight.js/styles/ocean.css'


core_default.a.configure({
  useBR: false
});
core_default.a.registerLanguage('c', __webpack_require__("0209"));
core_default.a.registerLanguage('c++', __webpack_require__("0209"));
core_default.a.registerLanguage('c#', __webpack_require__("98af"));
core_default.a.registerLanguage('css', __webpack_require__("ee8c"));
core_default.a.registerLanguage('fortran', __webpack_require__("485f"));
core_default.a.registerLanguage('glsl', __webpack_require__("df06"));
core_default.a.registerLanguage('java', __webpack_require__("332f"));
core_default.a.registerLanguage('javascript', __webpack_require__("4dd1"));
core_default.a.registerLanguage('perl', __webpack_require__("6a51"));
core_default.a.registerLanguage('php', __webpack_require__("2907"));
core_default.a.registerLanguage('python', __webpack_require__("9510"));
core_default.a.registerLanguage('r', __webpack_require__("26bc"));
var reg_hl = /(\[hl\]|\[hl\s+language="?(.*?)"?\])(.*?)(\[\/hl\])/gm;
var reg_code = /(\[code\]|\[code\s+language="?(.*?)"?\])([\s\S]*?)(\[\/code\])/gm;
core_default.a.$vue = {
  processElements: function processElements(scope, inLang) {
    var _this = this;
    if (scope === undefined) {
      scope = document;
    }
    var elements = scope.querySelectorAll('[highlight]');
    elements.forEach(function (el) {
      if (inLang === undefined && el.hasAttribute('highlight')) {
        var lang = el.getAttribute('highlight');
        inLang = lang === null ? undefined : lang;
      }
      _this.processElement(el, inLang);
    });
  },
  /////The Folowing Code will not replace tags on a string level as this will
  /////destroy attached objects in the DOM but aims to replace the strings in
  /////TextNodes only. Changes ar recorded in the q and applied once all nodes
  /////Were visited. This is probably a lot slower than the pure string version
  // processTextElement: function(el, inLang, q){
  //     let txt = el.textContent.replace(reg_hl, function(m1, m2, m3, m4, m5){
  //         const lang = m3===undefined?inLang:m3;
  //         //console.log("m1", m1, "m2", m2, "m3", m3, "m4", m4, "m5", m5, "in", inLang, "res", lang)
  //         if (lang) return '<span is-code>'+hljs.highlight(lang, m4).value + '</span>';
  //         else return '<span is-code>'+hljs.highlightAuto(m4).value + '</span>';
  //     });
  //     txt = txt.replace(reg_code, function(m1, m2, m3, m4, m5){
  //         const lang = m3===undefined?inLang:m3;
  //         m4 = m4.replace(/<br( +\/)?>/g, "\n").replace(/&nbsp;/g, " ");
  //         if (lang) return '<pre is-code>'+hljs.highlight(lang, m4).value + '</pre>';
  //         else return '<pre is-code>'+hljs.highlightAuto(m4).value + '</pre>';
  //     });
  //     if (txt != el.textContent) {
  //       q.push(()=>{
  //          let nel = document.createElement('span');
  //          nel.innerHTML = txt;
  //          el.parentNode.replaceChild(nel, el);
  //       })
  //     }
  // },
  // processElementRec: function(el, inLang, updateList){
  //     let q = updateList;
  //     if (q === undefined) q = [];
  //     if (inLang === undefined && el.hasAttribute('highlight')){
  //         inLang = el.getAttribute('highlight');
  //     }
  //     el.innerHTML = el.innerHTML;
  //     el.childNodes.forEach(c => {
  //        if (c.nodeType==Node.TEXT_NODE) {
  //            this.processTextElement(c, inLang, q);
  //        } else {
  //            this.processElement(c, inLang, q);
  //        }
  //     })
  //     if (updateList === undefined){
  //         q.forEach(f => f());
  //     }
  // },
  processElementSimple: function processElementSimple(el, inLang) {
    if (inLang === undefined && el.hasAttribute('highlight')) {
      var lang = el.getAttribute('highlight');
      inLang = lang === null ? 'javascript' : lang;
    }
    var txt = el.innerHTML.replace(reg_hl, function (m1, m2, m3, m4, m5) {
      var lang = m3 === undefined ? inLang : m3;
      //console.log("m1", m1, "m2", m2, "m3", m3, "m4", m4, "m5", m5, "in", inLang, "res", lang)
      if (lang) {
        return '<span is-code>' + core_default.a.highlight(lang, m4).value + '</span>';
      } else {
        return '<span is-code>' + core_default.a.highlightAuto(m4).value + '</span>';
      }
    });
    txt = txt.replace(reg_code, function (m1, m2, m3, m4, m5) {
      var lang = m3 === undefined ? inLang : m3;
      m4 = m4.replace(/<br( +\/)?>/g, '\n').replace(/&nbsp;/g, ' ').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
      if (lang) {
        return '<pre is-code>' + core_default.a.highlight(lang, m4).value + '</pre>';
      } else {
        return '<pre is-code>' + core_default.a.highlightAuto(m4).value + '</pre>';
      }
    });
    el.innerHTML = txt;
  },
  processElement: function processElement(el, inLang) {
    var _this2 = this;
    if (window.MathJax === undefined) {
      this.processElementSimple(el, inLang);
    } else {
      MathJax.Hub.Register.StartupHook('End', function () {
        _this2.processElementSimple(el, inLang);
      });
    }
  }
};
window.highlightAll = function () {
  core_default.a.$vue.processElements();
};
window.highlightElement = function (el) {
  core_default.a.$vue.processElement(el, el.getAttribute('highlight'));
};
window.hljs = core_default.a;
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$hljs = core_default.a;
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.directive('highlight', {
  //deep: true,
  bind: function bind(el, binding) {
    console.log('DIRECTIVE - bind', el, binding);
    core_default.a.$vue.processElement(el, binding.value);
  },
  componentUpdated: function componentUpdated(el, binding) {
    console.log('DIRECTIVE - update', el, binding);
    core_default.a.$vue.processElement(el, binding.value);
  }
});
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js
var inherits = __webpack_require__("262e");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js + 2 modules
var createSuper = __webpack_require__("2caf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.self.js
var web_self = __webpack_require__("c73d");

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__("9ab4");

// EXTERNAL MODULE: ./node_modules/vue-property-decorator/lib/index.js + 15 modules
var lib = __webpack_require__("1b40");

// EXTERNAL MODULE: ./src/plugins/i18n.ts + 1 modules
var i18n = __webpack_require__("fe0b");

// EXTERNAL MODULE: ./src/styles/tagger.styl
var tagger = __webpack_require__("ea5a");

// CONCATENATED MODULE: ./src/plugins/tagger.ts





















//!!! make sure to also change the expression in ilias-builder.js !!!
var randomAndTemplateTag = /\{(:|!)([\w]*)}/g;

var tagger_Tagger = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(Tagger, _Vue);
  var _super = Object(createSuper["a" /* default */])(Tagger);
  function Tagger() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, Tagger);
    _this = _super.apply(this, arguments);
    _this.className = {
      rnd: 'random-tag-placeholder',
      templ: 'template-tag-placeholder'
    };
    return _this;
  }
  Object(createClass["a" /* default */])(Tagger, [{
    key: "getMarkers",
    value: function getMarkers(s) {
      if (s === undefined || s === null) {
        return [];
      }
      var lines = s.split('\n');
      var markers = [];
      var m;
      for (var i = 0; i < lines.length; i++) {
        var regex = new RegExp(randomAndTemplateTag);
        while ((m = regex.exec(lines[i])) !== null) {
          if (m.index === regex.lastIndex) {
            regex.lastIndex++;
          }
          var marker = {
            start: {
              line: i,
              ch: m.index
            },
            end: {
              line: i,
              ch: regex.lastIndex
            },
            type: m[1] == ':' ? 'rnd' : 'templ',
            name: m[2]
          };
          markers.push(marker);
        }
      }
      return markers;
    }
  }, {
    key: "processElements",
    value: function processElements(scope) {
      var _this2 = this;
      var uuid = '';
      if (scope === undefined) {
        scope = document;
      } else {
        var h = scope;
        if (!h.hasAttribute('uuid')) {
          uuid = this.$uuid.v4();
          h.setAttribute('uuid', uuid);
        } else {
          uuid = h.getAttribute('uuid');
        }
      }
      var elements = scope.querySelectorAll('[tagged]');
      var calle = function calle() {
        elements.forEach(function (el) {
          _this2.processElement(el, uuid);
        });
      };
      if (window.MathJax === undefined) {
        calle();
      } else {
        MathJax.Hub.Register.StartupHook('End', calle);
      }
    }
  }, {
    key: "processElement",
    value: function processElement(el, scopeUUID) {
      el.innerHTML = this.processString(el.innerHTML, scopeUUID);
      this.hookClick(el, scopeUUID);
    }
  }, {
    key: "processString",
    value: function processString(str, scopeUUID) {
      var _this3 = this;
      return str.replace(randomAndTemplateTag, function (m0, m1, m2) {
        var className = m1 === ':' ? _this3.className.rnd : _this3.className.templ;
        return "<span class=\"q-mb-xs  tag-mark-start tag-mark-end ".concat(className, "\" >") + m0 + '</span>';
      });
    }
  }, {
    key: "hookClick",
    value: function hookClick(el, scopeUUID) {
      var _this4 = this;
      var tags = el.querySelectorAll('.' + this.className.templ);
      tags.forEach(function (inTag) {
        var tag = inTag;
        var name = tag.innerText.replace(randomAndTemplateTag, function (m0, m1, m2) {
          return m2;
        });
        tag.onclick = function () {
          _this4.clickFunction(name, tag, scopeUUID);
        };
      });
    }
  }, {
    key: "replaceTemplateTag",
    value: function replaceTemplateTag(scope, name, newValue) {
      var _this5 = this;
      if (scope === undefined) {
        scope = document;
      }
      var tags = scope.querySelectorAll('.' + this.className.templ);
      tags.forEach(function (tag) {
        tag.innerHTML = _this5.replaceTemplateTagInString(tag.innerHTML, name, newValue);
      });
    }
  }, {
    key: "replaceTemplateTagInString",
    value: function replaceTemplateTagInString(str, name, newValue) {
      return str.replace(randomAndTemplateTag, function (m0, m1, m2) {
        if (m1 == '!' && m2 == name) {
          return newValue;
        }
        return m0;
      });
    }
  }, {
    key: "replaceRandomTagsInString",
    value: function replaceRandomTagsInString(str, tagSet) {
      return str.replace(randomAndTemplateTag, function (m0, m1, m2) {
        if (m1 == ':') {
          var tag = tagSet.values.find(function (t) {
            return t.tag == m2;
          });
          if (tag !== undefined) {
            return tag.value;
          }
          return m0;
        }
        return m0;
      });
    }
  }, {
    key: "clickFunction",
    value: function clickFunction(name, tagEl, scopeUUID) {
      var _this6 = this;
      //console.log(i18n)
      lib["c" /* Vue */].prototype.$q.dialog({
        title: i18n["a" /* default */].t('Tagger.ConfirmRepl'),
        message: i18n["a" /* default */].t('Tagger.ConfirmReplMsg', {
          name: '<span class="template-tag-placeholder-noclick">' + name + '</span>'
        }),
        html: true,
        persistent: true,
        prompt: {
          model: '{!' + name + '}',
          type: 'text' // optional
        },

        ok: {
          push: true,
          color: 'negative',
          icon: 'warning'
        },
        cancel: {
          push: true,
          color: 'positive'
        }
      }).onOk(function (data) {
        //this.replaceTemplateTag($(tagEl).parents(".codeblocks").get(0), name, data)
        _this6.replaceTemplateTag($("[uuid=".concat(scopeUUID, "]")).get(0), name, data);
        console.log(scopeUUID);
        _this6.$emit('replace-template-tag', {
          name: name,
          newValue: data,
          scopeUUID: scopeUUID
        });
      }).onCancel(function () {}).onDismiss(function () {
        var me = self;
        me.highlighted = false;
      });
    }
  }]);
  return Tagger;
}(lib["c" /* Vue */]);
tagger_Tagger = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], tagger_Tagger);
/* harmony default export */ var plugins_tagger = (tagger_Tagger);
lib["c" /* Vue */].directive('tagged', {
  //deep: true,
  bind: function bind(el, binding) {
    lib["c" /* Vue */].$tagger.processElement(el, binding.value);
  },
  componentUpdated: function componentUpdated(el, binding) {
    //console.log("DIRECTIVE - update", el, binding)
    lib["c" /* Vue */].$tagger.processElement(el, binding.value);
  }
});
lib["c" /* Vue */].$tagger = new tagger_Tagger();
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.error.cause.js
var es_error_cause = __webpack_require__("d9e2");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__("7e84");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
var setPrototypeOf = __webpack_require__("b380");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js


function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.reflect.construct.js
var es_reflect_construct = __webpack_require__("4ae1");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.reflect.to-string-tag.js
var es_reflect_to_string_tag = __webpack_require__("f8c9");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
var isNativeReflectConstruct = __webpack_require__("d967");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/construct.js






function construct_construct(Parent, args, Class) {
  if (Object(isNativeReflectConstruct["a" /* default */])()) {
    construct_construct = Reflect.construct.bind();
  } else {
    construct_construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) Object(setPrototypeOf["a" /* default */])(instance, Class.prototype);
      return instance;
    };
  }
  return construct_construct.apply(null, arguments);
}
// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js










function wrapNativeSuper_wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  wrapNativeSuper_wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return construct_construct(Class, arguments, Object(getPrototypeOf["a" /* default */])(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return Object(setPrototypeOf["a" /* default */])(Wrapper, Class);
  };
  return wrapNativeSuper_wrapNativeSuper(Class);
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
var es_array_splice = __webpack_require__("a434");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.promise.js
var es_promise = __webpack_require__("e6cf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.unscopables.js
var es_symbol_unscopables = __webpack_require__("81b8");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("e01a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
var es_array_filter = __webpack_require__("4de4");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url.js
var web_url = __webpack_require__("2b3d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.js
var web_url_search_params = __webpack_require__("9861");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.size.js
var web_url_search_params_size = __webpack_require__("5494");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("13d5");

// CONCATENATED MODULE: ./src/compiler/doppio.v001.js









/**
 * The overhead time we need to spin up the execution environment. The value is added to the execution time defined for this question
 * @type {int} javaRunOverhead execution overhead in ms
 */
var javaRunOverhead = 4000;
function runJavaWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB) {
  var forceReload = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
  var exp = new RegExp('public[ \n]*class[ \n]*([a-zA-Z_$0-9]*)[ \n]*({|implements|extends)');
  var match = exp.exec(code);
  if (match == null) {
    console.error('Unable to determine class Name!', match, code);
    return;
  }
  var className = match[1];
  var worker = new Worker(external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$CodeBlock.baseurl + 'js/doppio/v001/javaWorker.js');
  var timer = null;
  worker.addEventListener('message', function (e) {
    var data = e.data;
    //console.log(data)
    switch (data.event) {
      case 'finished':
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }

        /*if (data.stderr && data.stderr != '') err_callback(data.stderr + "\n") ;
        if (data.stdout && data.stdout != '') log_callback(data.stdout);*/

        console.log('Done', data.stdout, data.stderr, finishedExecutionCB);
        finishedExecutionCB();
        break;
      case 'startTimer':
        timer = setTimeout(function (e) {
          console.log('Sending kill command');
          worker.postMessage({
            cmd: 'kill'
          });
          timer = setTimeout(function () {
            console.log('Terminating Worker');
            worker.terminate();
          }, 5000);
          err_callback('Terminated long running Process (>' + Math.round((max_ms + javaRunOverhead) / 1000) + 's).');
          JavaExec.setRunButton(true, 'run');
          JavaExec.setRunButton(true);
          JavaExec.showMessage(null);
        }, max_ms + javaRunOverhead); //we need about 4000ms to spin up the execution unit
        break;
      case 'showMessage':
        //console.log("showMessage", data)
        JavaExec.showMessage(data.msg);
        break;
      case 'output':
        if (data.type == 'err') {
          err_callback(data.msg);
        } else if (data.type == 'nfo') {
          info_callback(data.msg);
        } else {
          log_callback(data.msg);
        }
        break;
      case 'setRunButton':
        //console.log("setRunButton", data)
        JavaExec.setRunButton(data.enabled, data.info);
        break;
      case 'cleanCache':
        //log_callback('')
        if (!forceReload) {
          worker.postMessage({
            cmd: 'kill'
          });
          console.log('Restarting...');
          setTimeout(function () {
            runJavaWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB, true);
          }, 500);
        } else {
          JavaExec.setRunButton(false);
          JavaExec.showMessage('Failed to initialize JVM.');
        }
        break;
    }
  }, false);
  worker.postMessage({
    cmd: 'run',
    code: code,
    className: className,
    max_ms: max_ms + 1000,
    questionID: questionID,
    forceReload: forceReload
  });
}
var singleton = new external_commonjs_vue_commonjs2_vue_root_Vue_default.a({
  data: function data() {
    return {
      loadedlibs: 0,
      version: '001',
      language: 'java',
      canRun: true,
      canStop: true,
      allowsContinousCompilation: false,
      allowsPersistentArguments: false,
      allowsMessagePassing: false,
      acceptsJSONArgument: false,
      allowsREPL: false,
      didPreload: false,
      requestedPreload: false,
      isReady: false,
      isRunning: false
    };
  },
  methods: {
    preload: function preload() {
      if (this.loadedlibs < 3) {
        if (this.requestedPreload == false) {
          this.requestedPreload = true;
          this.triggerResourceLoad();
        }
        return;
      }
      if (this.didPreload) {
        return;
      }
      this.didPreload = true;
      console.log('[Preloading Doppio]');
      try {
        JavaExec.showMessage = function (msg) {
          this.$compilerState.displayGlobalState(msg);
        }.bind(this);
        var lock = [];
        JavaExec.setRunButton = function (enabled) {
          var info = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
          if (info && !enabled && lock.indexOf(info) == -1) {
            lock.push(info);
          }
          if (info && enabled && lock.indexOf(info) > -1) {
            lock.splice(lock.indexOf(info), 1);
          }
          if (!enabled || lock.length == 0) {
            this.$compilerState.setAllRunButtons(enabled);
          }
        }.bind(this);
        var self = this;
        JavaExec.initialize(function () {
          console.log('Initializing Filesystem');
          JavaExec.initFileSystems(external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$CodeBlock.baseurl + 'js/doppio/v001/', false, function () {
            //JavaExec.printDirContent('sys/vendor');

            JavaExec.reroutStdStreams();
            JavaExec.ready = true;
            self.isReady = true;
          });
        });
      } catch (e) {
        console.error(e);
      }
    },
    compileAndRun: function compileAndRun(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB, args) {
      var runCreate = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : false;
      if (!this.isReady) {
        return;
      }
      return runJavaWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB, runCreate);
    },
    triggerResourceLoad: function triggerResourceLoad() {
      console.log('[Preparing Dependencies for Doppio]');
      var script = document.createElement('script');
      script.src = external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$CodeBlock.baseurl + 'js/doppio/v001/browserfs/browserfs.min.js';
      script.onload = function () {
        this.loadedlibs++;
        console.log('[BrowserFS loaded]');
        var script = document.createElement('script');
        script.src = external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$CodeBlock.baseurl + 'js/doppio/v001/doppio/doppio.js';
        script.onload = function () {
          this.loadedlibs++;
          console.log('[Doppio loaded]');
          var script = document.createElement('script');
          script.src = external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$CodeBlock.baseurl + 'js/doppio/v001/JavaExec.js';
          script.onload = function () {
            this.loadedlibs++;
            console.log('[JavaExec loaded]');
            if (this.requestedPreload) {
              this.preload();
            }
          }.bind(this);
          document.head.appendChild(script);
        }.bind(this);
        document.head.appendChild(script);
      }.bind(this);
      document.head.appendChild(script);
    }
  },
  created: function created() {}
});
/* harmony default export */ var doppio_v001 = (singleton);
// CONCATENATED MODULE: ./src/compiler/teavm.v100.ts











var teaVMRunOverhead = 30000;
//ICompilerInstance
var teavm_v100_JavaV100Compiler = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(JavaV100Compiler, _Vue);
  var _super = Object(createSuper["a" /* default */])(JavaV100Compiler);
  function JavaV100Compiler() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, JavaV100Compiler);
    _this = _super.apply(this, arguments);
    _this.version = '100';
    _this.language = 'java';
    _this.canRun = true;
    _this.canStop = true;
    _this.allowsContinousCompilation = false;
    _this.allowsPersistentArguments = false;
    _this.allowsMessagePassing = false;
    _this.acceptsJSONArgument = true;
    _this.allowsREPL = false;
    _this.experimental = false;
    _this.deprecated = false;
    _this.didPreload = false;
    _this.teaworker = undefined;
    _this.isReady = false;
    _this.isRunning = false;
    _this.sessionCompileListener = undefined;
    _this.sessionID = '-1';
    _this.sessionWorker = undefined;
    return _this;
  }
  Object(createClass["a" /* default */])(JavaV100Compiler, [{
    key: "preload",
    value: function preload() {
      var _this2 = this;
      if (this.didPreload) {
        return;
      }
      this.didPreload = true;
      this.$compilerState.setAllRunButtons(false);
      console.log("[Preloading TeaVM ".concat(this.version, " for Java]"));
      this.isRunning = true;
      this.createTeaWorker(function () {
        _this2.isRunning = false;
        _this2.$compilerState.hideGlobalState();
        _this2.$compilerState.setAllRunButtons(true);
        //console.log('setAllRun', true)
      });
    }
  }, {
    key: "createTeaWorker",
    value: function createTeaWorker(whenReady) {
      var _this3 = this;
      if (this.teaworker === undefined) {
        this.$compilerState.setAllRunButtons(false);
        this.$compilerState.displayGlobalState('Initializing Runtime');
        try {
          this.teaworker = new Worker("".concat(this.$CodeBlock.baseurl, "js/teavm/v").concat(this.version, "/worker.js"));
        } catch (e) {
          //this should throw in the offline environment, thus we look for the worker at a different
          this.teaworker = new Worker('../assCodeQuestion/js/teavm/worker.js');
        }
        this.teaworker.addEventListener('message', function (e) {
          //console.log('teastuff', e.data)
          if (e.data.command == 'ok' && e.data.id == 'didload-classlib') {
            if (_this3.teaworker) {
              _this3.teaworker.postMessage({
                command: 'compile',
                id: 'prep',
                text: 'public class Bootstrap { public static void main(String[] args){}}',
                mainClass: 'Bootstrap'
              });
            }
            _this3.isReady = true;
            if (whenReady) {
              //console.log("loopback to initial caller");
              whenReady();
            } else {
              _this3.$compilerState.setAllRunButtons(true);
              _this3.$compilerState.hideGlobalState();
            }
          } else if (e.data.id == 'prep' && e.data.command == 'compilation-complete') {
            /* We could finish initialization here if there appear to be races when compiling multiple sources at once */
          }
        });
        //bootstrap environment
        this.teaworker.postMessage({
          command: 'load-classlib',
          id: 'didload-classlib',
          url: 'classlib.txt'
        });
        return true;
      }
      return false;
    }
  }, {
    key: "compileAndRun",
    value: function compileAndRun(questionID, code, callingCodeBlocks, options) {
      var _this4 = this;
      var runCreate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var max_ms = options.max_ms,
        log_callback = options.log_callback,
        info_callback = options.info_callback,
        err_callback = options.err_callback,
        compileFailedCallback = options.compileFailedCallback,
        finishedExecutionCB = options.finishedExecutionCB,
        args = options.args;
      var start = Date.now();
      var executionFinished = false;
      var booted = false;
      if (this.isRunning) {
        err_callback('System is busy. Please wait until compilation finishes or call a tutor.');
        return;
      }
      this.isRunning = true;
      if (runCreate) {
        if (this.createTeaWorker(function () {
          _this4.isRunning = false;
          _this4.compileAndRun(questionID, code, callingCodeBlocks, options, false);
        })) {
          return;
        }
      }
      if (!this.isReady) {
        err_callback('System is not yet ready. Please wait until Initialization finishes or call a tutor.');
        return;
      }
      var compilerTimeout = setTimeout(function () {
        if (!booted) {
          var time = Date.now() - start;
          if (_this4.teaworker) {
            _this4.teaworker.end('TimeoutError:  Compilation took too long (>' + time + 'ms) and was terminated. Trying to reset the System. Please re-run your code and call a Tutor if this Problem persists.');
          }
          _this4.teaworker = undefined;
        }
      }, teaVMRunOverhead);
      var text = code.replace(/"(?:[^"\\]|\\.)*"|\/\*[\s\S]*?\*\//gm, '').replace(/(^.*)\/\/.*$/gm, '$1'); //replace strings and comments
      //let text = code.replace(/"(?:[^"\\]+?|(?!")"|\\{2}|\\[\s\S])*?"|^.*(\/\/.*$)|\/\*[\s\S]*?\*\//gm, ''); //replace strings and comments
      text = text.replaceRec(/(\{[^{}]*\})/gm, '[]'); //replace parentheses
      var getMainClass = function getMainClass(_code) {
        var ret = 'Unknown';
        //above replaces all {} with [], so look for public class <name> []
        var regexpMainClass = /public\s+?class\s+?([a-zA-Z_$0-9]+?)\s*?(\[|\simplements|\sextends)/gm;
        var match;
        while ((match = regexpMainClass.exec(_code)) !== null) {
          if (match[1]) {
            ret = match[1];
            break;
          }
        }
        return ret;
      };
      var mainClass = getMainClass(text);
      //fallback if the above regExps mangled the student code and we can not find the main class
      if (mainClass == 'Unknown') {
        mainClass = getMainClass(code.replace('{', '['));
      }
      //console.log(mainClass, code);
      var myListener = function myListener(e) {
        //console.log('this.teaworker', questionID, e.data);
        if (e.data.id == '' + questionID) {
          if (e.data.command == 'phase') {
            if (e.data.phase == 'DEPENDENCY_ANALYSIS') {
              _this4.$compilerState.displayGlobalState('Compiling & Analyzing <b>' + mainClass + '.java</b>');
            } else if (e.data.phase == 'LINKING') {
              _this4.$compilerState.displayGlobalState('Linking <b>' + mainClass + '.java</b>');
            } else if (e.data.phase == 'OPTIMIZATION') {
              _this4.$compilerState.displayGlobalState('Optimizing <b>' + mainClass + '.java</b>');
            } else if (e.data.phase == 'RENDERING') {
              _this4.$compilerState.displayGlobalState('Creating <b>' + mainClass + '.class</b>');
            }
          } else if (e.data.command == 'diagnostic') {
            if (compileFailedCallback) {
              compileFailedCallback({
                message: e.data.text,
                start: {
                  line: e.data.lineNumber,
                  column: 0
                },
                end: {
                  line: e.data.lineNumber,
                  column: 0
                },
                severity: e.data.severity == 'ERROR' ? ICompilerRegistry["a" /* ErrorSeverity */].Error : ICompilerRegistry["a" /* ErrorSeverity */].Warning
              });
            }
            var msg = e.data.text + '\n';
            if (e.data.severity == 'ERROR') {
              err_callback(msg + '\n');
            } else {
              info_callback(msg + '\n');
            }
          } else if (e.data.command == 'compiler-diagnostic') {
            if (compileFailedCallback) {
              compileFailedCallback({
                message: e.data.message,
                start: {
                  line: e.data.startLineNumber,
                  column: e.data.startColumn
                },
                end: {
                  line: e.data.endLineNumber,
                  column: e.data.endColumn
                },
                severity: e.data.kind == 'ERROR' ? ICompilerRegistry["a" /* ErrorSeverity */].Error : ICompilerRegistry["a" /* ErrorSeverity */].Warning
              });
            }
            var _msg = e.data.humanReadable + '\n';
            if (e.data.kind == 'ERROR') {
              err_callback(_msg + '\n');
            } else {
              info_callback(_msg + '\n');
            }
          } else if (e.data.command == 'error') {
            if (_this4.teaworker) {
              _this4.teaworker.end('Error:  An internal compiler Error occured');
            }
            _this4.teaworker = undefined;
          } else if (e.data.command == 'compilation-complete') {
            booted = true;
            var runTimeout = undefined;
            if (_this4.teaworker) {
              _this4.teaworker.removeEventListener('message', myListener);
              _this4.sessionCompileListener = undefined;
            }
            try {
              clearTimeout(compilerTimeout);
            } catch (e) {
              /* nothing to report */
            }
            if (e.data.status == 'errors') {
              finishedExecutionCB(false);
              _this4.isRunning = false;
            } else {
              var runListener = function runListener(ee) {
                //console.log('JAVA-WORKER-MSG', ee.data)
                //console.log('tearunner', questionID, ee.data);
                if (ee.data.command == 'run-finished-setup') {
                  //Nothing to do here
                } else if (ee.data.command == 'run-completed') {
                  finishedExecutionCB(true);
                  console.i('Execution finished in ' + (Date.now() - start) + ' ms\n');
                  // info_callback(
                  //     'Info: Execution finished in ' + (Date.now() - start) + ' ms\n'
                  // )
                  executionFinished = true;
                  _this4.isRunning = false;
                  workerrun.end();
                } else if (ee.data.command == 'stdout') {
                  log_callback(ee.data.line + '\n');
                } else if (ee.data.command == 'stderr') {
                  err_callback(ee.data.line + '\n');
                }
              };
              _this4.$compilerState.displayGlobalState('Executing <b>' + mainClass + '</b>');
              var workerrun = new Worker("".concat(_this4.$CodeBlock.baseurl, "js/teavm/v").concat(_this4.version, "/workerrun.js?&v=001"));
              _this4.sessionWorker = workerrun;
              workerrun.addEventListener('message', runListener.bind(_this4));
              workerrun.postMessage({
                command: 'run',
                id: '' + questionID,
                code: e.data.script,
                args: args
              });
              workerrun.end = function (msg) {
                _this4.sessionWorker = undefined;
                //when we end it IS over, no matter how often we tried :)
                try {
                  workerrun.terminate();
                  if (runTimeout) {
                    clearTimeout(runTimeout);
                  }
                } catch (e) {
                  /* nothing to report */
                }
                if (executionFinished) {
                  return;
                }
                executionFinished = true;
                finishedExecutionCB(false);
                _this4.isRunning = false;
                if (msg) {
                  err_callback(msg + '\n');
                }
              };
              var runStart = Date.now();
              runTimeout = setTimeout(function () {
                var time = Date.now() - runStart;
                workerrun.end('TimeoutError:  Execution took too long (>' + time + 'ms) and was terminated. There might be an endless loop in your code.');
              }, max_ms);
            }
          }
        }
      };
      if (this.teaworker) {
        this.sessionID = questionID;
        this.sessionCompileListener = myListener;
        this.teaworker.addEventListener('message', myListener);
      }
      //console.log(code);
      this.$compilerState.setAllRunButtons(false);
      this.$compilerState.displayGlobalState('Starting Compiler for <b>' + mainClass + '.java</b>');
      if (this.teaworker) {
        this.teaworker.postMessage({
          command: 'compile',
          id: '' + questionID,
          text: code,
          mainClass: mainClass
        });
      }
      if (this.teaworker) {
        this.teaworker.end = function (msg) {
          var terminate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          try {
            clearTimeout(compilerTimeout);
          } catch (e) {
            //nothing to see here
          }
          if (booted) {
            return;
          }
          if (_this4.teaworker && terminate) {
            console.log('TERMINATING');
            _this4.teaworker.terminate();
          }
          finishedExecutionCB(false);
          _this4.isRunning = false;
          _this4.isReady = true;
          if (msg) {
            err_callback(msg + '\n');
          }
        };
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      console.d('FORCE STOPPING');
      if (this.sessionWorker) {
        this.sessionWorker.end(lib["c" /* Vue */].$l('CodeBlocks.UserCanceled'));
      } else if (this.teaworker) {
        if (this.sessionCompileListener) {
          // this.sessionCompileListener({
          //     data: {
          //         id: '' + this.sessionID,
          //         command: 'compilation-complete',
          //         status: 'errors',
          //         errors: [Vue.$l('CodeBlocks.UserCanceled')]
          //     }
          // })
          this.teaworker.removeEventListener('message', this.sessionCompileListener);
          this.sessionCompileListener = undefined;
        }
        this.teaworker.end(lib["c" /* Vue */].$l('CodeBlocks.UserCanceled'), false);
      }
    }
  }]);
  return JavaV100Compiler;
}(lib["c" /* Vue */]);
teavm_v100_JavaV100Compiler = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], teavm_v100_JavaV100Compiler);

var javaCompiler_V100 = new teavm_v100_JavaV100Compiler();
/* harmony default export */ var teavm_v100 = (javaCompiler_V100);
// CONCATENATED MODULE: ./src/compiler/teavm.v101.ts













var teavm_v101_teaVMRunOverhead = 30000;
//ICompilerInstance
var teavm_v101_JavaV101Compiler = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(JavaV101Compiler, _Vue);
  var _super = Object(createSuper["a" /* default */])(JavaV101Compiler);
  function JavaV101Compiler() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, JavaV101Compiler);
    _this = _super.apply(this, arguments);
    _this.version = '101';
    _this.language = 'java';
    _this.canRun = true;
    _this.canStop = true;
    _this.allowsContinousCompilation = false;
    _this.allowsPersistentArguments = true;
    _this.allowsMessagePassing = true;
    _this.acceptsJSONArgument = true;
    _this.allowsREPL = false;
    _this.experimental = true;
    _this.deprecated = false;
    _this.didPreload = false;
    _this.teaworker = undefined;
    _this.isReady = false;
    _this.isRunning = false;
    _this.sessionCompileListener = undefined;
    _this.sessionID = '-1';
    _this.sessionWorker = undefined;
    return _this;
  }
  Object(createClass["a" /* default */])(JavaV101Compiler, [{
    key: "preload",
    value: function preload() {
      var _this2 = this;
      if (this.didPreload) {
        return;
      }
      this.didPreload = true;
      this.$compilerState.setAllRunButtons(false);
      console.log("[Preloading TeaVM ".concat(this.version, " for Java]"));
      this.isRunning = true;
      this.createTeaWorker(function () {
        _this2.isRunning = false;
        _this2.$compilerState.hideGlobalState();
        _this2.$compilerState.setAllRunButtons(true);
        //console.log('setAllRun', true)
      });
    }
  }, {
    key: "createTeaWorker",
    value: function createTeaWorker(whenReady) {
      var _this3 = this;
      if (this.teaworker === undefined) {
        this.$compilerState.setAllRunButtons(false);
        this.$compilerState.displayGlobalState('Initializing Runtime');
        try {
          this.teaworker = new Worker("".concat(this.$CodeBlock.baseurl, "js/teavm/v").concat(this.version, "/worker.js"));
        } catch (e) {
          //this should throw in the offline environment, thus we look for the worker at a different
          this.teaworker = new Worker('../assCodeQuestion/js/teavm/worker.js');
        }
        this.teaworker.addEventListener('message', function (e) {
          //console.log('teastuff', e.data)
          if (e.data.command == 'ok' && e.data.id == 'didload-classlib') {
            if (_this3.teaworker) {
              _this3.teaworker.postMessage({
                command: 'compile',
                id: 'prep',
                text: 'public class Bootstrap { public static void main(String[] args){}}',
                mainClass: 'Bootstrap'
              });
            }
            _this3.isReady = true;
            if (whenReady) {
              //console.log("loopback to initial caller");
              whenReady();
            } else {
              _this3.$compilerState.setAllRunButtons(true);
              _this3.$compilerState.hideGlobalState();
            }
          } else if (e.data.id == 'prep' && e.data.command == 'compilation-complete') {
            /* We could finish initialization here if there appear to be races when compiling multiple sources at once */
          }
        });
        //bootstrap environment
        this.teaworker.postMessage({
          command: 'load-classlib',
          id: 'didload-classlib',
          url: 'classlib.txt'
        });
        return true;
      }
      return false;
    }
  }, {
    key: "compileAndRun",
    value: function compileAndRun(questionID, code, callingCodeBlocks, options) {
      var _this4 = this;
      var runCreate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var max_ms = options.max_ms,
        log_callback = options.log_callback,
        info_callback = options.info_callback,
        err_callback = options.err_callback,
        compileFailedCallback = options.compileFailedCallback,
        finishedExecutionCB = options.finishedExecutionCB,
        args = options.args,
        keepAlive = options.keepAlive;
      console.log("[Starting TeaVM".concat(options.keepAlive ? ' keepAlive' : '', "]"), args);
      var start = Date.now();
      var executionFinished = false;
      var booted = false;
      if (this.isRunning) {
        err_callback('System is busy. Please wait until compilation finishes or call a tutor.');
        return;
      }
      this.isRunning = true;
      if (runCreate) {
        if (this.createTeaWorker(function () {
          _this4.isRunning = false;
          _this4.compileAndRun(questionID, code, callingCodeBlocks, options, false);
        })) {
          return;
        }
      }
      if (!this.isReady) {
        err_callback('System is not yet ready. Please wait until Initialization finishes or call a tutor.');
        return;
      }
      var compilerTimeout = setTimeout(function () {
        if (!booted) {
          var time = Date.now() - start;
          if (_this4.teaworker) {
            _this4.teaworker.end('TimeoutError:  Compilation took too long (>' + time + 'ms) and was terminated. Trying to reset the System. Please re-run your code and call a Tutor if this Problem persists.');
          }
          _this4.teaworker = undefined;
        }
      }, teavm_v101_teaVMRunOverhead);
      var text = code.replace(/"(?:[^"\\]|\\.)*"|\/\*[\s\S]*?\*\//gm, '').replace(/(^.*)\/\/.*$/gm, '$1'); //replace strings and comments
      //let text = code.replace(/"(?:[^"\\]+?|(?!")"|\\{2}|\\[\s\S])*?"|^.*(\/\/.*$)|\/\*[\s\S]*?\*\//gm, ''); //replace strings and comments
      text = text.replaceRec(/(\{[^{}]*\})/gm, '[]'); //replace parentheses
      var getMainClass = function getMainClass(_code) {
        var ret = 'Unknown';
        //above replaces all {} with [], so look for public class <name> []
        var regexpMainClass = /public\s+?class\s+?([a-zA-Z_$0-9]+?)\s*?(\[|\simplements|\sextends)/gm;
        var match;
        while ((match = regexpMainClass.exec(_code)) !== null) {
          if (match[1]) {
            ret = match[1];
            break;
          }
        }
        return ret;
      };
      var mainClass = getMainClass(text);
      //fallback if the above regExps mangled the student code and we can not find the main class
      if (mainClass == 'Unknown') {
        mainClass = getMainClass(code.replace('{', '['));
      }
      //console.log(mainClass, code);
      var myListener = function myListener(e) {
        //console.log('this.teaworker', questionID, e.data);
        if (e.data.id == '' + questionID) {
          if (e.data.command == 'phase') {
            if (e.data.phase == 'DEPENDENCY_ANALYSIS') {
              _this4.$compilerState.displayGlobalState('Compiling & Analyzing <b>' + mainClass + '.java</b>');
            } else if (e.data.phase == 'LINKING') {
              _this4.$compilerState.displayGlobalState('Linking <b>' + mainClass + '.java</b>');
            } else if (e.data.phase == 'OPTIMIZATION') {
              _this4.$compilerState.displayGlobalState('Optimizing <b>' + mainClass + '.java</b>');
            } else if (e.data.phase == 'RENDERING') {
              _this4.$compilerState.displayGlobalState('Creating <b>' + mainClass + '.class</b>');
            }
          } else if (e.data.command == 'diagnostic') {
            if (compileFailedCallback) {
              compileFailedCallback({
                message: e.data.text,
                start: {
                  line: e.data.lineNumber,
                  column: 0
                },
                end: {
                  line: e.data.lineNumber,
                  column: 0
                },
                severity: e.data.severity == 'ERROR' ? ICompilerRegistry["a" /* ErrorSeverity */].Error : ICompilerRegistry["a" /* ErrorSeverity */].Warning
              });
            }
            var msg = e.data.text + '\n';
            if (e.data.severity == 'ERROR') {
              err_callback(msg + '\n');
            } else {
              info_callback(msg + '\n');
            }
          } else if (e.data.command == 'compiler-diagnostic') {
            if (compileFailedCallback) {
              compileFailedCallback({
                message: e.data.message,
                start: {
                  line: e.data.startLineNumber,
                  column: e.data.startColumn
                },
                end: {
                  line: e.data.endLineNumber,
                  column: e.data.endColumn
                },
                severity: e.data.kind == 'ERROR' ? ICompilerRegistry["a" /* ErrorSeverity */].Error : ICompilerRegistry["a" /* ErrorSeverity */].Warning
              });
            }
            var _msg = e.data.humanReadable + '\n';
            if (e.data.kind == 'ERROR') {
              err_callback(_msg + '\n');
            } else {
              info_callback(_msg + '\n');
            }
          } else if (e.data.command == 'error') {
            if (_this4.teaworker) {
              _this4.teaworker.end('Error:  An internal compiler Error occured');
            }
            _this4.teaworker = undefined;
          } else if (e.data.command == 'compilation-complete') {
            booted = true;
            var runTimeout = undefined;
            if (_this4.teaworker) {
              _this4.teaworker.removeEventListener('message', myListener);
              _this4.sessionCompileListener = undefined;
            }
            try {
              clearTimeout(compilerTimeout);
            } catch (e) {
              /* nothing to report */
            }
            if (e.data.status == 'errors') {
              finishedExecutionCB(false, undefined, options.args);
              _this4.isRunning = false;
            } else {
              _this4.$compilerState.displayGlobalState('Executing <b>' + mainClass + '</b>');
              var workerrun = new Worker("".concat(_this4.$CodeBlock.baseurl, "js/teavm/v").concat(_this4.version, "/workerrun.js?&v=001"));
              _this4.sessionWorker = workerrun;
              var runListener = function runListener(ee) {
                //console.log('JAVA-WORKER-MSG', ee.data)
                console.d('tearunner message', questionID, ee.data, ee.data.command);
                if (ee.data.command == 'run-finished-setup') {
                  //Nothing to do here
                } else if (ee.data.command == 'w-exit-keepalive' || ee.data.command == 'exit-keepalive') {
                  //Make sure a keep-alive session can do proper cleanup
                  if (options.keepAlive) {
                    workerrun.postMessage({
                      command: 'session-ended',
                      id: '' + questionID
                    });
                  }
                } else if (ee.data.command == 'run-completed') {
                  if (ee.data.args) {
                    options.args['return'] = ee.data.args;
                  }
                  finishedExecutionCB(true, undefined, options.args['return']);
                  console.i('Execution finished in ' + (Date.now() - start) + ' ms\n');
                  // info_callback(
                  //     'Info: Execution finished in ' + (Date.now() - start) + ' ms\n'
                  // )
                  executionFinished = true;
                  _this4.isRunning = false;
                  workerrun.end();
                } else if (ee.data.command == 'stdout') {
                  log_callback(ee.data.line + '\n');
                } else if (ee.data.command == 'stderr') {
                  err_callback(ee.data.line + '\n');
                } else if (ee.data.command.indexOf('w-') === 0) {
                  //Message sent from the workter to the playground
                  var cmd = ee.data.command.substr(2);
                  ee.data.command = cmd;
                  options.didReceiveMessage(cmd, ee.data);
                } else if (ee.data.command == 'main-finished') {
                  console.d('MESSAGE - Main Finished');
                  //set up the real message handler
                  options.postMessageFunction = function (cmd, data) {
                    data = Object.assign({}, data);
                    console.d('MESSAGE - TeaVM Post ', cmd, data);
                    data.command = cmd;
                    data.id = questionID;
                    wr.postMessage(data);
                  };
                  options.postMessageFunction('main-finished', {});
                  //make sure to send all queued messages now
                  options.dequeuePostponedMessages();
                  options.whenFinishedHandler(ee.data.args);
                } else if (ee.data.command == 'main-will-start') {
                  options.beforeStartHandler();
                } else if (ee.data.command == 'f-FINAL') {
                  options.resultData = JSON.parse(ee.data.value);
                } else {
                  console.log('Unknown Message', ee.data);
                }
              };
              workerrun.addEventListener('message', runListener.bind(_this4));
              workerrun.postMessage({
                command: 'run',
                id: '' + questionID,
                code: e.data.script,
                args: args,
                messagePosting: options.allowMessagePassing,
                keepAlive: options.keepAlive
              });
              var wr = workerrun;
              workerrun.end = function (msg) {
                _this4.sessionWorker = undefined;
                //when we end it IS over, no matter how often we tried :)
                try {
                  workerrun.terminate();
                  if (runTimeout) {
                    clearTimeout(runTimeout);
                  }
                } catch (e) {
                  /* nothing to report */
                }
                if (executionFinished) {
                  return;
                }
                executionFinished = true;
                finishedExecutionCB(false, undefined, options.args);
                _this4.isRunning = false;
                if (msg) {
                  err_callback(msg + '\n');
                }
              };
              var runStart = Date.now();
              if (!keepAlive) {
                runTimeout = setTimeout(function () {
                  var time = Date.now() - runStart;
                  workerrun.end('TimeoutError:  Execution took too long (>' + time + 'ms) and was terminated. There might be an endless loop in your code.');
                }, max_ms);
              }
            }
          }
        }
      };
      if (this.teaworker) {
        this.sessionID = questionID;
        this.sessionCompileListener = myListener;
        this.teaworker.addEventListener('message', myListener);
      }
      //console.log(code);
      this.$compilerState.setAllRunButtons(false);
      this.$compilerState.displayGlobalState('Starting Compiler for <b>' + mainClass + '.java</b>');
      if (this.teaworker) {
        this.teaworker.postMessage({
          command: 'compile',
          id: '' + questionID,
          text: code,
          mainClass: mainClass
        });
      }
      if (this.teaworker) {
        this.teaworker.end = function (msg) {
          var terminate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          try {
            clearTimeout(compilerTimeout);
          } catch (e) {
            //nothing to see here
          }
          if (booted) {
            return;
          }
          if (_this4.teaworker && terminate) {
            console.log('TERMINATING');
            _this4.teaworker.terminate();
          }
          finishedExecutionCB(false, undefined, options.args);
          _this4.isRunning = false;
          _this4.isReady = true;
          if (msg) {
            err_callback(msg + '\n');
          }
        };
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      console.d('FORCE STOPPING');
      if (this.sessionWorker) {
        this.sessionWorker.end(lib["c" /* Vue */].$l('CodeBlocks.UserCanceled'));
      } else if (this.teaworker) {
        if (this.sessionCompileListener) {
          // this.sessionCompileListener({
          //     data: {
          //         id: '' + this.sessionID,
          //         command: 'compilation-complete',
          //         status: 'errors',
          //         errors: [Vue.$l('CodeBlocks.UserCanceled')]
          //     }
          // })
          this.teaworker.removeEventListener('message', this.sessionCompileListener);
          this.sessionCompileListener = undefined;
        }
        this.teaworker.end(lib["c" /* Vue */].$l('CodeBlocks.UserCanceled'), false);
      }
    }
  }]);
  return JavaV101Compiler;
}(lib["c" /* Vue */]);
teavm_v101_JavaV101Compiler = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], teavm_v101_JavaV101Compiler);

var javaCompiler_V101 = new teavm_v101_JavaV101Compiler();
/* harmony default export */ var teavm_v101 = (javaCompiler_V101);
// CONCATENATED MODULE: ./src/compiler/java.ts







//load all versions



var java_JavaCompilerInfo = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(JavaCompilerInfo, _Vue);
  var _super = Object(createSuper["a" /* default */])(JavaCompilerInfo);
  function JavaCompilerInfo() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, JavaCompilerInfo);
    _this = _super.apply(this, arguments);
    _this.type = 'java';
    _this.displayName = 'Java';
    //attach all version
    _this.versions = [doppio_v001, teavm_v100, teavm_v101];
    //declare the default one
    _this.default = teavm_v100;
    return _this;
  }
  return Object(createClass["a" /* default */])(JavaCompilerInfo);
}(lib["c" /* Vue */]);
java_JavaCompilerInfo = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], java_JavaCompilerInfo);

var JavaCompilers = new java_JavaCompilerInfo();
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.join.js
var es_array_join = __webpack_require__("a15b");

// CONCATENATED MODULE: ./src/compiler/javascript.v100.ts
















//function runJavaScriptWorker( code, log_callback, max_ms, questionID){
function runJavaScriptWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB) {
  log_callback('');
  if (!window.Worker) {
    err_callback('CRITICAL-ERROR: your browser does not support WebWorkers!! (please consult a Tutor).');
    return;
  }
  var not_allowed_keywords = ['postMessage', 'close', 'onmessage', 'debugger']; // blacklist (can be evaded, ... see below)
  for (var key in not_allowed_keywords) {
    if (code.indexOf(not_allowed_keywords[key]) != -1) {
      // the user is not allowed to use the functionallity of the WebWorker
      err_callback("PermissionError: The usage of '" + not_allowed_keywords[key] + "' is not allowed (reserved keyword)!");
      return;
    }
  }
  var lines = code.split('\n').length;
  // The user-code is sourrounded by webworker start and finish code (one line each)
  // additionally, the console.log fnc is replaced, because the original log fnc is consuming much cpu ressources,
  //      and continues logging, even after the worker was terminated.
  var prefixCode = ['for(var c in console) console[c]=null;', "for(var t in this) if(t!='close' && t!='postMessage' && t!='console') this[t]=null;", 'this.console = {};', 'console.log = function(s){', "   postMessage(['log',''+s]);", '};', 'console.error = function(s){', "   postMessage(['err',''+s]);", '};', 'console.warn = console.log;', 'onmessage = function(input){', "   postMessage(['finished',", "   ''+(function(input){", "           'use strict';", '\n'];
  var postfixCode = ['\n', '})(input.data[1])]);', '   close();', '};'];
  code = prefixCode.join('') + code + postfixCode.join('');
  //TODO:: creating a WebWorker from an URL is throwing a SecurityError in  IE 11  ...
  //          is there any workaround?
  var worker = new Worker(URL.createObjectURL(new Blob([code], {
    type: 'text/javascript'
  })));
  var executionFinished = false;
  worker.end = function (msg) {
    if (executionFinished) {
      return;
    }
    worker.terminate();
    executionFinished = true;
    finishedExecutionCB(false);
    if (msg) {
      err_callback(msg + '\n');
    }
  };
  var start = Date.now();
  var testTimeout = function testTimeout() {
    var time = Date.now() - start;
    worker.end('TimeoutError:  Execution took too long (>' + time + 'ms) and was terminated. There might be an endless loop in your code.');
  };
  var testTimeoutIntern = function testTimeoutIntern() {
    var time = Date.now() - start;
    if (time > max_ms) {
      testTimeout;
    }
  };
  worker.onmessage = function (e) {
    if (executionFinished) {
      return;
    }
    //only accept messages, when worker not terminated (workers do not immetiately terminate)
    testTimeoutIntern();
    if (e.data[0] == 'finished') {
      finishedExecutionCB(true);
      info_callback('Info: Execution finished in ' + (Date.now() - start) + ' ms\n');
      worker.end();
    } else if (e.data[0] == 'log') {
      log_callback(e.data[1] + '\n');
    } else if (e.data[0] == 'err') {
      err_callback(e.data[1] + '\n');
    } else {
      worker.end('HackerError: Great! You invaded our System. Sadly this will lead you nowhere. Please focus on the Test.');
    }
  };
  worker.onerror = function (e) {
    if (e.lineno == 1) {
      compileFailedCallback({
        start: {
          line: -1,
          column: -1
        },
        end: {
          line: -1,
          column: -1
        },
        message: e.message,
        severity: ICompilerRegistry["a" /* ErrorSeverity */].Error
      });
      worker.end('Error: ' + e.message);
    } else if (e.lineno >= lines + 2) {
      compileFailedCallback({
        start: {
          line: lines + 2,
          column: 0
        },
        end: {
          line: lines + 2,
          column: 0
        },
        message: e.message,
        severity: ICompilerRegistry["a" /* ErrorSeverity */].Error
      });
      worker.end('EndOfFile: ' + e.message);
    } else {
      compileFailedCallback({
        start: {
          line: e.lineno - 2,
          column: e.colno - 1
        },
        end: {
          line: e.lineno - 2,
          column: e.colno
        },
        message: e.message,
        severity: ICompilerRegistry["a" /* ErrorSeverity */].Error
      });
      worker.end('Line ' + (e.lineno - 2) + ': ' + e.message);
    }
  };
  worker.postMessage(['start', [10, 200]]); //start worker execution
  setTimeout(testTimeout, max_ms);
}
//ICompilerInstance
var javascript_v100_JavascriptV100Compiler = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(JavascriptV100Compiler, _Vue);
  var _super = Object(createSuper["a" /* default */])(JavascriptV100Compiler);
  function JavascriptV100Compiler() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, JavascriptV100Compiler);
    _this = _super.apply(this, arguments);
    _this.version = '100';
    _this.language = 'javascript';
    _this.canRun = true;
    _this.canStop = false;
    _this.allowsContinousCompilation = false;
    _this.allowsPersistentArguments = false;
    _this.allowsMessagePassing = false;
    _this.acceptsJSONArgument = false;
    _this.allowsREPL = false;
    _this.experimental = false;
    _this.deprecated = true;
    _this.isReady = true;
    _this.isRunning = false;
    return _this;
  }
  Object(createClass["a" /* default */])(JavascriptV100Compiler, [{
    key: "preload",
    value: function preload() {}
  }, {
    key: "compileAndRun",
    value: function compileAndRun(questionID, code, callingCodeBlocks, options) {
      var max_ms = options.max_ms,
        log_callback = options.log_callback,
        info_callback = options.info_callback,
        err_callback = options.err_callback,
        compileFailedCallback = options.compileFailedCallback,
        finishedExecutionCB = options.finishedExecutionCB,
        args = options.args;
      return runJavaScriptWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB);
    }
  }]);
  return JavascriptV100Compiler;
}(lib["c" /* Vue */]);
javascript_v100_JavascriptV100Compiler = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], javascript_v100_JavascriptV100Compiler);

var javascriptCompiler_V100 = new javascript_v100_JavascriptV100Compiler();
/* harmony default export */ var javascript_v100 = (javascriptCompiler_V100);
// CONCATENATED MODULE: ./src/compiler/javascript.v101.ts










function javascript_v101_runJavaScriptWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB, args) {
  //WebWorkers need to be supported
  if (!window.Worker) {
    err_callback('CRITICAL-ERROR: your browser does not support WebWorkers! (please consult a Tutor).');
    return;
  }
  //const lines = code.split('\n').length;
  var startTime = performance.now();
  var executionFinished = false;
  var worker = new Worker(lib["c" /* Vue */].$CodeBlock.baseurl + 'js/javascript/v101/jsWorker.js');
  worker.onmessage = function (msg) {
    //only accept messages, as long as the worker is not terminated
    if (executionFinished) {
      return;
    }
    var time = performance.now() - startTime;
    if (time > max_ms) {
      triggerTimeout();
    }
    switch (msg.data[0]) {
      case 'finished':
        if (msg && msg.data && msg.data.length >= 3) {
          args['return'] = msg.data[2];
        } else {
          args['return'] = {};
        }
        console.d('returned msg:', msg, ', args:', args);
        executionFinished = true;
        finishedExecutionCB(true, undefined, args['return']);
        console.i('Execution finished in ' + time + ' ms\n');
        //info_callback('Info: Execution finished in ' + time + ' ms\n')
        worker.end();
        break;
      case 'log':
        log_callback(msg.data[1] + '\n');
        break;
      case 'err':
        err_callback(msg.data[1] + '\n');
        break;
      default:
        worker.end('HackerError: Great! You invaded our System. Sadly this will lead you nowhere. Please focus on the Test.');
        break;
    }
  };
  worker.onerror = function (e) {
    compileFailedCallback({
      start: {
        line: e.lineno - 3,
        column: e.colno - 1
      },
      end: {
        line: e.lineno - 3,
        column: e.colno
      },
      message: e.message,
      severity: ICompilerRegistry["a" /* ErrorSeverity */].Error
    });
    worker.end('Line ' + (e.lineno - 3) + ': ' + e.message);
  };
  worker.end = function (msg) {
    if (executionFinished) {
      return;
    }
    worker.terminate();
    executionFinished = true;
    //when aborting, the result is 'undefined'
    if (msg) {
      err_callback(msg + '\n');
    }
    finishedExecutionCB(false);
  };
  function triggerTimeout() {
    worker.end('TimeoutError:  Execution took too long (>' + (performance.now() - startTime) + 'ms) and was terminated. There might be an endless loop in your code.');
  }
  var startExecution = function startExecution(args) {
    //start worker execution
    worker.postMessage(['start', {
      code: code,
      args: args
    }]);
    //stop Worker execution when the time limit is exceeded;
    setTimeout(triggerTimeout, max_ms);
  };
  var willStartExecution = false;
  callingCodeBlocks.workerLibraries.forEach(function (l) {
    if (l === 'd3-101') {
      willStartExecution = true;
      callingCodeBlocks.$compilerRegistry.loadLibraries(['d3-5.13.4', 'd3proxy-101'], function () {
        worker.postMessage(['importD3']);
        startExecution(args);
      });
    } else if (l === 'brain-2.0.0') {
      willStartExecution = true;
      callingCodeBlocks.$compilerRegistry.loadLibraries([], function () {
        worker.postMessage(['importBrain']);
        startExecution(args);
      });
    }
  });
  if (!willStartExecution) {
    startExecution(args);
  }
  return worker;
}
var javascript_v101_JavascriptV101Compiler = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(JavascriptV101Compiler, _Vue);
  var _super = Object(createSuper["a" /* default */])(JavascriptV101Compiler);
  function JavascriptV101Compiler() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, JavascriptV101Compiler);
    _this = _super.apply(this, arguments);
    _this.version = '101';
    _this.language = 'javascript';
    _this.canRun = true;
    _this.isReady = true;
    _this.isRunning = false;
    _this.canStop = true;
    _this.allowsContinousCompilation = true;
    _this.allowsPersistentArguments = true;
    _this.allowsMessagePassing = false;
    _this.acceptsJSONArgument = true;
    _this.allowsREPL = false;
    _this.experimental = false;
    _this.deprecated = false;
    _this.libraries = [{
      key: 'd3-101',
      name: 'd3',
      version: '5.14.3',
      displayName: 'D3 - Proxy'
    }, {
      key: 'brain-2.0.0',
      name: 'Brain.js',
      version: '2.0.0-alpha',
      displayName: 'Brain.js'
    }];
    _this.worker = undefined;
    return _this;
  }
  Object(createClass["a" /* default */])(JavascriptV101Compiler, [{
    key: "registerLibs",
    value: function registerLibs(compilerRegistry) {
      compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/javascript/v101/d3DomProxyToHTML.js'], 'd3proxy', '101', 'D3 - Proxy', true //makes it a utility lib => not selectable by users
      );
    }
  }, {
    key: "preload",
    value: function preload() {}
  }, {
    key: "compileAndRun",
    value: function compileAndRun(questionID, code, callingCodeBlocks, options) {
      var max_ms = options.max_ms,
        log_callback = options.log_callback,
        info_callback = options.info_callback,
        err_callback = options.err_callback,
        compileFailedCallback = options.compileFailedCallback,
        finishedExecutionCB = options.finishedExecutionCB,
        args = options.args;
      this.worker = javascript_v101_runJavaScriptWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB, args);
    }
  }, {
    key: "stop",
    value: function stop() {
      console.d('FORCE STOPPING');
      if (this.worker) {
        this.worker.end(lib["c" /* Vue */].$l('CodeBlocks.UserCanceled'));
      }
    }
  }]);
  return JavascriptV101Compiler;
}(lib["c" /* Vue */]);
javascript_v101_JavascriptV101Compiler = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], javascript_v101_JavascriptV101Compiler);

var javascriptCompiler_V101 = new javascript_v101_JavascriptV101Compiler();
/* harmony default export */ var javascript_v101 = (javascriptCompiler_V101);
// CONCATENATED MODULE: ./src/compiler/javascript.v102.ts











function javascript_v102_runJavaScriptWorker(questionID, code, callingCodeBlocks, options) {
  var max_ms = options.max_ms,
    log_callback = options.log_callback,
    info_callback = options.info_callback,
    err_callback = options.err_callback,
    compileFailedCallback = options.compileFailedCallback,
    finishedExecutionCB = options.finishedExecutionCB,
    args = options.args,
    keepAlive = options.keepAlive;
  //WebWorkers need to be supported
  if (!window.Worker) {
    err_callback('CRITICAL-ERROR: your browser does not support WebWorkers! (please consult a Tutor).');
    return;
  }
  //const lines = code.split('\n').length;
  var startTime = performance.now();
  var executionFinished = false;
  var worker = new Worker(lib["c" /* Vue */].$CodeBlock.baseurl + 'js/javascript/v102/jsWorker.js');
  worker.onmessage = function (msg) {
    console.d('jsrunner message', questionID, executionFinished, msg.data, msg.data.command);
    //only accept messages, as long as the worker is not terminated
    if (executionFinished) {
      return;
    }
    var time = performance.now() - startTime;
    if (time > max_ms && !keepAlive) {
      triggerTimeout();
    }
    if (msg.data.command == 'finished') {
      if (options.allowMessagePassing) {
        options.whenFinishedHandler(msg.data.args);
      }
      if (msg && msg.data && msg.data.args) {
        args['return'] = msg.data.args;
      } else {
        args['return'] = {};
      }
      console.d('returned msg:', msg, ', args:', args);
      executionFinished = true;
      finishedExecutionCB(true, undefined, args['return']);
      console.i('Execution finished in ' + time + ' ms\n');
      //info_callback('Info: Execution finished in ' + time + ' ms\n')
      worker.end();
    } else if (msg.data.command == 'log') {
      log_callback(msg.data.s + '\n');
    } else if (msg.data.command == 'err') {
      err_callback(msg.data.s + '\n');
    } else if (msg.data.command == 'main-will-start') {
      options.beforeStartHandler();
    } else if (msg.data.command == 'main-finished') {
      console.d('MESSAGE - Main Finished');
      //set up the real message handler
      options.postMessageFunction = function (cmd, data) {
        data = Object.assign({}, data);
        console.d('MESSAGE - JS Post ', cmd, data);
        data.command = cmd;
        data.id = questionID;
        worker.postMessage(data);
      };
      options.postMessageFunction('main-finished', {});
      //make sure to send all queued messages now
      options.dequeuePostponedMessages();
      options.whenFinishedHandler(msg.data.args);
    } else if (msg.data.command == 'w-exit-keepalive' || msg.data.command == 'exit-keepalive') {
      //Make sure a keep-alive session can do proper cleanup
      if (options.keepAlive) {
        worker.postMessage({
          command: 'session-ended',
          id: '' + questionID
        });
      }
    } else if (msg.data.command.indexOf('w-') == 0) {
      msg.data.command = msg.data.command.substr(2);
    } else if (msg.data.command == 'f-FINAL') {
      options.resultData = msg.data.value;
    } else {
      console.i('MESSAGE - ', msg.data);
      worker.end('HackerError: Great! You invaded our System. Sadly this will lead you nowhere. Please focus on the Test.');
    }
  };
  worker.onerror = function (e) {
    compileFailedCallback({
      start: {
        line: e.lineno - 3,
        column: e.colno - 1
      },
      end: {
        line: e.lineno - 3,
        column: e.colno
      },
      message: e.message,
      severity: ICompilerRegistry["a" /* ErrorSeverity */].Error
    });
    worker.end('Line ' + (e.lineno - 3) + ': ' + e.message);
  };
  worker.end = function (msg) {
    if (executionFinished) {
      return;
    }
    worker.terminate();
    executionFinished = true;
    //when aborting, the result is 'undefined'
    if (msg) {
      err_callback(msg + '\n');
    }
    finishedExecutionCB(false);
  };
  function triggerTimeout() {
    worker.end('TimeoutError:  Execution took too long (>' + (performance.now() - startTime) + 'ms) and was terminated. There might be an endless loop in your code.');
  }
  var startExecution = function startExecution(args, options) {
    //start worker execution
    worker.postMessage({
      command: 'start',
      code: code,
      args: args,
      messagePosting: options.allowMessagePassing,
      keepAlive: options.keepAlive
    });
    if (!keepAlive) {
      //stop Worker execution when the time limit is exceeded;
      setTimeout(triggerTimeout, max_ms);
    }
  };
  var willStartExecution = false;
  callingCodeBlocks.workerLibraries.forEach(function (l) {
    if (l === 'd3-101') {
      willStartExecution = true;
      callingCodeBlocks.$compilerRegistry.loadLibraries(['d3-5.13.4', 'd3proxy-101'], function () {
        worker.postMessage({
          command: 'importD3'
        });
        startExecution(args, options);
      });
    } else if (l === 'brain-2.0.0') {
      willStartExecution = true;
      callingCodeBlocks.$compilerRegistry.loadLibraries([], function () {
        worker.postMessage({
          command: 'importBrain'
        });
        startExecution(args, options);
      });
    } else if (l === 'tf-2.0.0') {
      willStartExecution = true;
      callingCodeBlocks.$compilerRegistry.loadLibraries([], function () {
        worker.postMessage({
          command: 'importTF'
        });
        startExecution(args, options);
      });
    }
  });
  if (!willStartExecution) {
    startExecution(args, options);
  }
  return worker;
}
var javascript_v102_JavascriptV102Compiler = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(JavascriptV102Compiler, _Vue);
  var _super = Object(createSuper["a" /* default */])(JavascriptV102Compiler);
  function JavascriptV102Compiler() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, JavascriptV102Compiler);
    _this = _super.apply(this, arguments);
    _this.version = '102';
    _this.language = 'javascript';
    _this.canRun = true;
    _this.isReady = true;
    _this.isRunning = false;
    _this.canStop = true;
    _this.allowsContinousCompilation = true;
    _this.allowsPersistentArguments = true;
    _this.allowsMessagePassing = true;
    _this.acceptsJSONArgument = true;
    _this.allowsREPL = false;
    _this.experimental = true;
    _this.deprecated = false;
    _this.libraries = [{
      key: 'd3-101',
      name: 'd3',
      version: '5.14.3',
      displayName: 'D3 - Proxy'
    }, {
      key: 'brain-2.0.0',
      name: 'Brain.js',
      version: '2.0.0-alpha',
      displayName: 'Brain.js'
    }, {
      key: 'tf-2.0.0',
      name: 'tf',
      version: '2.0.0',
      displayName: 'TensorFlow.js'
    }];
    _this.worker = undefined;
    return _this;
  }
  Object(createClass["a" /* default */])(JavascriptV102Compiler, [{
    key: "registerLibs",
    value: function registerLibs(compilerRegistry) {
      compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/javascript/v101/d3DomProxyToHTML.js'], 'd3proxy', '101', 'D3 - Proxy', true //makes it a utility lib => not selectable by users
      );
    }
  }, {
    key: "preload",
    value: function preload() {}
  }, {
    key: "compileAndRun",
    value: function compileAndRun(questionID, code, callingCodeBlocks, options) {
      this.worker = javascript_v102_runJavaScriptWorker(questionID, code, callingCodeBlocks, options);
    }
  }, {
    key: "stop",
    value: function stop() {
      console.d('FORCE STOPPING');
      if (this.worker) {
        this.worker.end(lib["c" /* Vue */].$l('CodeBlocks.UserCanceled'));
      }
    }
  }]);
  return JavascriptV102Compiler;
}(lib["c" /* Vue */]);
javascript_v102_JavascriptV102Compiler = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], javascript_v102_JavascriptV102Compiler);

var javascriptCompiler_V102 = new javascript_v102_JavascriptV102Compiler();
/* harmony default export */ var javascript_v102 = (javascriptCompiler_V102);
// CONCATENATED MODULE: ./src/compiler/javascript.ts







//load all versions



var javascript_JavascriptCompilerInfo = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(JavascriptCompilerInfo, _Vue);
  var _super = Object(createSuper["a" /* default */])(JavascriptCompilerInfo);
  function JavascriptCompilerInfo() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, JavascriptCompilerInfo);
    _this = _super.apply(this, arguments);
    _this.type = 'javascript';
    _this.displayName = 'JavaScript';
    //attach all version
    _this.versions = [javascript_v100, javascript_v101, javascript_v102];
    //declare the default one
    _this.default = javascript_v101;
    return _this;
  }
  return Object(createClass["a" /* default */])(JavascriptCompilerInfo);
}(lib["c" /* Vue */]);
javascript_JavascriptCompilerInfo = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], javascript_JavascriptCompilerInfo);

var JavascriptCompilers = new javascript_JavascriptCompilerInfo();
// CONCATENATED MODULE: ./src/compiler/python.v100.ts









function runPythonWorker(questionID, prog, callingCodeBlocks, maxRuntime, logCallback, infoCallback, errCallback, compileFailedCallback, finishCallback) {
  // the Python program
  prog = prog.replaceAllPoly('\t', '    ');
  if (!window.Worker) {
    errCallback('CRITICAL-ERROR: your browser does not support WebWorkers!! (please consult a Tutor).');
    return;
  }
  var worker = new Worker(lib["c" /* Vue */].$CodeBlock.baseurl + 'js/python/v100/pyWorker.js');
  // construct message for worker
  var pyInp = []; // not used jet
  var messageData = {
    pyProg: prog,
    pyInp: pyInp,
    maxMS: maxRuntime
  };
  worker.postMessage(['b8e493ca02970aeb0ef734555526bf9b', messageData]);
  var start = Date.now();
  var testTimeout = function testTimeout() {
    var time = Date.now() - start;
    worker.end('TimeoutError:  Execution took too long (> ' + time + ' ms) and was terminated. There might be an endless loop in your code.');
  };
  var testTimeoutIntern = function testTimeoutIntern() {
    var time = Date.now() - start;
    if (time > maxRuntime) {
      testTimeout();
      return true;
    }
    return false;
  };
  var executionFinished = false;
  worker.end = function (msg) {
    if (executionFinished) {
      return;
    }
    worker.terminate();
    executionFinished = true;
    finishCallback(false);
    if (msg) {
      errCallback(msg);
    }
  };
  worker.onmessage = function (e) {
    if (executionFinished) {
      return;
    }
    //only accept messages, when worker not terminated (workers do not immetiately terminate)
    if (testTimeoutIntern() === true) {
      return;
    }
    if (e.data[0] == 'finished') {
      logCallback(e.data[1].stdOut);
      finishCallback(true);
      infoCallback('Info: Execution finished in : ' + (Date.now() - start) + ' ms');
      worker.end();
    } else if (e.data[0] === 'err') {
      var err = JSON.parse(e.data[2]);
      if (err && err.lineno !== undefined && err.colno !== undefined) {
        compileFailedCallback({
          start: {
            line: err.lineno - 1,
            column: err.colno
          },
          end: {
            line: err.lineno - 1,
            column: err.colno + 1
          },
          message: err.message,
          severity: ICompilerRegistry["a" /* ErrorSeverity */].Error
        });
      } else {
        if (err && err.lineno !== undefined) {
          compileFailedCallback({
            start: {
              line: err.lineno - 1,
              column: 0
            },
            end: {
              line: err.lineno - 1,
              column: 0
            },
            message: err.message,
            severity: ICompilerRegistry["a" /* ErrorSeverity */].Error
          });
        }
      }
      worker.end('ERROR: ' + e.data[1]);
    } else {
      worker.end('Unknown error: ' + e.data[1]);
    }
  };
  // in any case use the window timeout to terminate the worker
  setTimeout(testTimeout, maxRuntime);
}
//ICompilerInstance
var python_v100_PythonV100Compiler = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(PythonV100Compiler, _Vue);
  var _super = Object(createSuper["a" /* default */])(PythonV100Compiler);
  function PythonV100Compiler() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, PythonV100Compiler);
    _this = _super.apply(this, arguments);
    _this.version = '100';
    _this.language = 'python';
    _this.canRun = true;
    _this.canStop = false;
    _this.allowsContinousCompilation = false;
    _this.allowsPersistentArguments = false;
    _this.allowsMessagePassing = false;
    _this.acceptsJSONArgument = false;
    _this.allowsREPL = false;
    _this.experimental = false;
    _this.deprecated = true;
    _this.isReady = true;
    _this.isRunning = false;
    return _this;
  }
  Object(createClass["a" /* default */])(PythonV100Compiler, [{
    key: "preload",
    value: function preload() {}
  }, {
    key: "compileAndRun",
    value: function compileAndRun(questionID, code, callingCodeBlocks, options) {
      var max_ms = options.max_ms,
        log_callback = options.log_callback,
        info_callback = options.info_callback,
        err_callback = options.err_callback,
        compileFailedCallback = options.compileFailedCallback,
        finishedExecutionCB = options.finishedExecutionCB,
        args = options.args;
      return runPythonWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB);
    }
  }]);
  return PythonV100Compiler;
}(lib["c" /* Vue */]);
python_v100_PythonV100Compiler = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], python_v100_PythonV100Compiler);

var pythonCompiler_V100 = new python_v100_PythonV100Compiler();
/* harmony default export */ var python_v100 = (pythonCompiler_V100);
// CONCATENATED MODULE: ./src/compiler/python.v101.ts









function python_v101_runPythonWorker(questionID, prog, callingCodeBlocks, maxRuntime, logCallback, infoCallback, errCallback, compileFailedCallback, finishCallback, legacy) {
  console.log('Python Version:', legacy ? '2.7' : '3');
  // the Python program
  prog = prog.replaceAllPoly('\t', '    ');
  if (!window.Worker) {
    errCallback('CRITICAL-ERROR: your browser does not support WebWorkers!! (please consult a Tutor).');
    return;
  }
  var worker = new Worker(lib["c" /* Vue */].$CodeBlock.baseurl + 'js/python/v101/pyWorker.js');
  // construct message for worker
  var pyInp = []; // not used jet
  var messageData = {
    pyProg: prog,
    pyInp: pyInp,
    maxMS: maxRuntime,
    legacy: legacy
  };
  worker.postMessage(['b8e493ca02970aeb0ef734556526bf9b', messageData]);
  var start = Date.now();
  var testTimeout = function testTimeout() {
    var time = Date.now() - start;
    worker.end('TimeoutError:  Execution took too long (> ' + time + ' ms) and was terminated. There might be an endless loop in your code.');
  };
  var testTimeoutIntern = function testTimeoutIntern() {
    var time = Date.now() - start;
    if (time > maxRuntime) {
      testTimeout();
      return true;
    }
    return false;
  };
  var executionFinished = false;
  worker.end = function (msg) {
    if (executionFinished) {
      return;
    }
    worker.terminate();
    executionFinished = true;
    finishCallback(false);
    if (msg) {
      errCallback(msg);
    }
  };
  worker.onmessage = function (e) {
    if (executionFinished) {
      return;
    }
    //only accept messages, when worker not terminated (workers do not immetiately terminate)
    if (testTimeoutIntern() === true) {
      return;
    }
    if (e.data[0] == 'finished') {
      logCallback(e.data[1].stdOut);
      finishCallback(true);
      console.i('Execution finished in ' + (Date.now() - start) + ' ms\n');
      //infoCallback('Info: Execution finished in : ' + (Date.now() - start) + ' ms')
      worker.end();
    } else if (e.data[0] === 'err') {
      var err = JSON.parse(e.data[2]);
      if (err && err.lineno !== undefined && err.colno !== undefined) {
        compileFailedCallback({
          start: {
            line: err.lineno - 1,
            column: err.colno
          },
          end: {
            line: err.lineno - 1,
            column: err.colno + 1
          },
          message: err.message,
          severity: ICompilerRegistry["a" /* ErrorSeverity */].Error
        });
      } else {
        if (err && err.lineno !== undefined) {
          compileFailedCallback({
            start: {
              line: err.lineno - 1,
              column: 0
            },
            end: {
              line: err.lineno - 1,
              column: 0
            },
            message: err.message,
            severity: ICompilerRegistry["a" /* ErrorSeverity */].Error
          });
        }
      }
      worker.end('ERROR: ' + e.data[1]);
    } else {
      worker.end('Unknown error: ' + e.data[1]);
    }
  };
  // in any case use the window timeout to terminate the worker
  setTimeout(testTimeout, maxRuntime);
  return worker;
}
//ICompilerInstance
var python_v101_PythonV101LegacyCompiler = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(PythonV101LegacyCompiler, _Vue);
  var _super = Object(createSuper["a" /* default */])(PythonV101LegacyCompiler);
  function PythonV101LegacyCompiler() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, PythonV101LegacyCompiler);
    _this = _super.apply(this, arguments);
    _this.version = '101';
    _this.language = 'python';
    _this.canRun = true;
    _this.canStop = true;
    _this.allowsContinousCompilation = true;
    _this.allowsPersistentArguments = false;
    _this.allowsMessagePassing = false;
    _this.acceptsJSONArgument = false;
    _this.allowsREPL = false;
    _this.experimental = false;
    _this.deprecated = false;
    _this.isReady = true;
    _this.isRunning = false;
    _this.worker = undefined;
    return _this;
  }
  Object(createClass["a" /* default */])(PythonV101LegacyCompiler, [{
    key: "preload",
    value: function preload() {}
  }, {
    key: "compileAndRun",
    value: function compileAndRun(questionID, code, callingCodeBlocks, options) {
      var max_ms = options.max_ms,
        log_callback = options.log_callback,
        info_callback = options.info_callback,
        err_callback = options.err_callback,
        compileFailedCallback = options.compileFailedCallback,
        finishedExecutionCB = options.finishedExecutionCB,
        args = options.args;
      this.worker = python_v101_runPythonWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB, true);
    }
  }, {
    key: "stop",
    value: function stop() {
      console.d('FORCE STOPPING');
      if (this.worker) {
        this.worker.end(lib["c" /* Vue */].$l('CodeBlocks.UserCanceled'));
      }
    }
  }]);
  return PythonV101LegacyCompiler;
}(lib["c" /* Vue */]);
python_v101_PythonV101LegacyCompiler = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], python_v101_PythonV101LegacyCompiler);

//ICompilerInstance
var python_v101_PythonV101Compiler = /*#__PURE__*/function (_Vue2) {
  Object(inherits["a" /* default */])(PythonV101Compiler, _Vue2);
  var _super2 = Object(createSuper["a" /* default */])(PythonV101Compiler);
  function PythonV101Compiler() {
    var _this2;
    Object(classCallCheck["a" /* default */])(this, PythonV101Compiler);
    _this2 = _super2.apply(this, arguments);
    _this2.version = '101';
    _this2.language = 'python';
    _this2.canRun = true;
    _this2.canStop = true;
    _this2.allowsContinousCompilation = true;
    _this2.allowsPersistentArguments = false;
    _this2.allowsMessagePassing = false;
    _this2.acceptsJSONArgument = false;
    _this2.allowsREPL = false;
    _this2.experimental = false;
    _this2.deprecated = false;
    _this2.isReady = true;
    _this2.isRunning = false;
    _this2.worker = undefined;
    return _this2;
  }
  Object(createClass["a" /* default */])(PythonV101Compiler, [{
    key: "preload",
    value: function preload() {}
  }, {
    key: "compileAndRun",
    value: function compileAndRun(questionID, code, callingCodeBlocks, options) {
      var max_ms = options.max_ms,
        log_callback = options.log_callback,
        info_callback = options.info_callback,
        err_callback = options.err_callback,
        compileFailedCallback = options.compileFailedCallback,
        finishedExecutionCB = options.finishedExecutionCB,
        args = options.args;
      this.worker = python_v101_runPythonWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB, false);
    }
  }, {
    key: "stop",
    value: function stop() {
      console.d('FORCE STOPPING');
      if (this.worker) {
        this.worker.end(lib["c" /* Vue */].$l('CodeBlocks.UserCanceled'));
      }
    }
  }]);
  return PythonV101Compiler;
}(lib["c" /* Vue */]);
python_v101_PythonV101Compiler = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], python_v101_PythonV101Compiler);

var pythonCompiler_V101 = new python_v101_PythonV101Compiler();
var pythonLegacyCompiler_V101 = new python_v101_PythonV101LegacyCompiler();
/* harmony default export */ var python_v101 = ({
  legacyPython: pythonLegacyCompiler_V101,
  python3: pythonCompiler_V101
});
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __webpack_require__("d28b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.async-iterator.js
var es_symbol_async_iterator = __webpack_require__("b636");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.to-string-tag.js
var es_symbol_to_string_tag = __webpack_require__("944a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.json.to-string-tag.js
var es_json_to_string_tag = __webpack_require__("0c47");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.math.to-string-tag.js
var es_math_to_string_tag = __webpack_require__("23dc");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-prototype-of.js
var es_object_get_prototype_of = __webpack_require__("3410");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.set-prototype-of.js
var es_object_set_prototype_of = __webpack_require__("131a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.proto.js
var es_object_proto = __webpack_require__("1f68");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__("53ca");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js





















function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == Object(esm_typeof["a" /* default */])(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function value(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function stop() {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.sub.js
var es_string_sub = __webpack_require__("4c53");

// CONCATENATED MODULE: ./src/compiler/python.v102.ts














var spareWorker;
var runningWorker;
function getWorker(setReady) {
  if (!window.Worker) {
    return undefined;
  }
  setReady(false);
  if (runningWorker !== undefined) {
    console.d('FORCE STOPPING ON RERUN');
    runningWorker.end(lib["c" /* Vue */].$l('CodeBlocks.UserCanceled'));
    runningWorker = undefined;
  }
  runningWorker = spareWorker;
  console.i('Starting Spare Pyodide Server');
  spareWorker = new Worker(lib["c" /* Vue */].$CodeBlock.baseurl + 'js/python/v102/pyWorker.js');
  spareWorker.onmessage = function (msg) {
    if (msg.data.command == 'finished-init') {
      setReady(true);
    }
  };
  spareWorker.interpreter = function () {};
  spareWorker.postMessage({
    command: 'initialize',
    id: '0'
  });
  return runningWorker;
}
function python_v102_runPythonWorker(questionID, code, callingCodeBlocks, options, setReady) {
  var max_ms = options.max_ms,
    log_callback = options.log_callback,
    info_callback = options.info_callback,
    err_callback = options.err_callback,
    compileFailedCallback = options.compileFailedCallback,
    finishedExecutionCB = options.finishedExecutionCB,
    args = options.args,
    keepAlive = options.keepAlive;
  //WebWorkers need to be supported
  if (!window.Worker) {
    err_callback('CRITICAL-ERROR: your browser does not support WebWorkers! (please consult a Tutor).');
    return;
  }
  //const lines = code.split('\n').length;
  var startTime = performance.now();
  var executionFinished = false;
  var worker = getWorker(setReady);
  if (worker === undefined) {
    err_callback('CRITICAL-ERROR: Unable to get background worker.');
    return;
  }
  worker.onmessage = function (msg) {
    console.d('pyrunner message', questionID, executionFinished, msg.data, msg.data.command);
    //only accept messages, as long as the worker is not terminated
    if (executionFinished) {
      return;
    }
    var time = performance.now() - startTime;
    if (time > max_ms && !keepAlive) {
      triggerTimeout();
    }
    if (msg.data.command == 'finished') {
      if (options.allowMessagePassing) {
        options.whenFinishedHandler(msg.data.args);
      }
      if (msg && msg.data && msg.data.args) {
        args['return'] = msg.data.args;
      } else {
        args['return'] = {};
      }
      console.d('returned msg:', msg, ', args:', args);
      executionFinished = true;
      finishedExecutionCB(true, undefined, args['return']);
      console.i('Execution finished in ' + time + ' ms\n');
      //info_callback('Info: Execution finished in ' + time + ' ms\n')
      worker.end();
    } else if (msg.data.command == 'exception') {
      if (compileFailedCallback) {
        compileFailedCallback({
          message: msg.data.text,
          start: {
            line: msg.data.lineNumber,
            column: 0
          },
          end: {
            line: msg.data.lineNumber,
            column: 0
          },
          severity: msg.data.severity == 'ERROR' ? ICompilerRegistry["a" /* ErrorSeverity */].Error : ICompilerRegistry["a" /* ErrorSeverity */].Warning
        });
      }
    } else if (msg.data.command == 'log') {
      log_callback(msg.data.s + '\n');
    } else if (msg.data.command == 'err') {
      err_callback(msg.data.s + '\n');
    } else if (msg.data.command == 'loaded-imports') {
      if (spareWorker !== undefined) {
        spareWorker.postMessage({
          command: 'preload-imports',
          names: msg.data.names
        });
      }
    } else if (msg.data.command == 'main-will-start') {
      options.beforeStartHandler();
    } else if (msg.data.command == 'main-finished') {
      console.d('MESSAGE - Main Finished');
      //set up the real message handler
      options.postMessageFunction = function (cmd, data) {
        data = Object.assign({}, data);
        console.d('MESSAGE - JS Post ', cmd, data);
        data.command = cmd;
        data.id = questionID;
        worker.postMessage(data);
      };
      options.postMessageFunction('main-finished', {});
      //make sure to send all queued messages now
      options.dequeuePostponedMessages();
      options.whenFinishedHandler(msg.data.args);
    } else if (msg.data.command == 'interpreter') {
      worker.interpreter(msg.data);
    } else if (msg.data.command == 'w-exit-keepalive' || msg.data.command == 'exit-keepalive') {
      //Make sure a keep-alive session can do proper cleanup
      if (options.keepAlive) {
        worker.postMessage({
          command: 'session-ended',
          id: '' + questionID
        });
      }
    } else if (msg.data.command.indexOf('w-') == 0) {
      msg.data.command = msg.data.command.substr(2);
    } else {
      console.i('MESSAGE - ', msg.data);
      worker.end('HackerError: Great! You invaded our System. Sadly this will lead you nowhere. Please focus on the Test.');
    }
  };
  worker.onerror = function (e) {
    compileFailedCallback({
      start: {
        line: e.lineno - 3,
        column: e.colno - 1
      },
      end: {
        line: e.lineno - 3,
        column: e.colno
      },
      message: e.message,
      severity: ICompilerRegistry["a" /* ErrorSeverity */].Error
    });
    worker.end('Line ' + (e.lineno - 3) + ': ' + e.message);
  };
  worker.end = function (msg) {
    if (executionFinished) {
      return;
    }
    worker.terminate();
    executionFinished = true;
    //when aborting, the result is 'undefined'
    if (msg) {
      err_callback(msg + '\n');
    }
    finishedExecutionCB(false);
  };
  function triggerTimeout() {
    if (worker !== undefined) {
      worker.end('TimeoutError:  Execution took too long (>' + (performance.now() - startTime) + 'ms) and was terminated. There might be an endless loop in your code.');
    }
  }
  var startExecution = function startExecution(args, options) {
    //start worker execution
    worker.postMessage({
      command: 'start',
      code: code,
      args: args,
      messagePosting: options.allowMessagePassing,
      keepAlive: options.keepAlive,
      withREPL: options.withREPL
    });
    //stop Worker execution when the time limit is exceeded;
    if (!keepAlive) {
      setTimeout(triggerTimeout, max_ms);
    }
  };
  var willStartExecution = false;
  callingCodeBlocks.workerLibraries.forEach(function (l) {
    if (l === 'd3-101') {
      willStartExecution = true;
      callingCodeBlocks.$compilerRegistry.loadLibraries(['d3-5.13.4', 'd3proxy-101'], function () {
        worker.postMessage({
          command: 'importD3'
        });
        startExecution(args, options);
      });
    } else if (l === 'brain-2.0.0') {
      willStartExecution = true;
      callingCodeBlocks.$compilerRegistry.loadLibraries([], function () {
        worker.postMessage({
          command: 'importBrain'
        });
        startExecution(args, options);
      });
    }
  });
  if (!willStartExecution) {
    startExecution(args, options);
  }
  return worker;
}
//ICompilerInstance
var python_v102_PythonV102Compiler = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(PythonV102Compiler, _Vue);
  var _super = Object(createSuper["a" /* default */])(PythonV102Compiler);
  function PythonV102Compiler() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, PythonV102Compiler);
    _this = _super.apply(this, arguments);
    _this.version = '102';
    _this.language = 'python';
    _this.canRun = true;
    _this.canStop = true;
    _this.allowsContinousCompilation = true;
    _this.allowsPersistentArguments = true;
    _this.allowsMessagePassing = true;
    _this.acceptsJSONArgument = true;
    _this.allowsREPL = true;
    _this.experimental = true;
    _this.deprecated = false;
    _this.isReady = false;
    _this.isRunning = false;
    _this.worker = undefined;
    return _this;
  }
  Object(createClass["a" /* default */])(PythonV102Compiler, [{
    key: "preload",
    value: function preload() {
      getWorker(this.setReady.bind(this)); //this will initialize our first worker
    }
  }, {
    key: "setReady",
    value: function setReady(val) {
      console.i('Changing READY-State to ' + val);
      this.isReady = val;
    }
  }, {
    key: "compileAndRun",
    value: function compileAndRun(questionID, code, callingCodeBlocks, options) {
      this.worker = python_v102_runPythonWorker(questionID, code, callingCodeBlocks, options, this.setReady.bind(this));
    }
  }, {
    key: "stop",
    value: function stop() {
      console.d('FORCE STOPPING');
      if (this.worker) {
        this.worker.end(lib["c" /* Vue */].$l('CodeBlocks.UserCanceled'));
      }
    }
  }, {
    key: "interpreter",
    value: function interpreter(command, onStateChange, onLog, onError) {
      return Object(tslib_es6["a" /* __awaiter */])(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var self;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              self = this;
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                if (self.worker === undefined) {
                  reject('Interpreter not Running');
                  return;
                }
                self.worker.interpreter = function (msg) {
                  console.log('Message: ' + msg);
                  switch (msg.sub) {
                    case 'did-push':
                      onStateChange(msg.incomplete);
                      break;
                    case 'out':
                      onLog(msg.value);
                      break;
                    case 'err':
                      onError(msg.value);
                      break;
                    case 'exception':
                      if (msg.fatal) {
                        reject(msg.value);
                      } else {
                        onError(msg.value);
                      }
                      break;
                    case 'finished':
                      resolve({});
                      break;
                    default:
                      console.log('Unknown Message: ' + msg.sub);
                  }
                };
                self.worker.postMessage({
                  command: 'interpreter',
                  code: command
                });
              }));
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
    }
  }]);
  return PythonV102Compiler;
}(lib["c" /* Vue */]);
python_v102_PythonV102Compiler = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], python_v102_PythonV102Compiler);

var pythonCompiler_V102 = new python_v102_PythonV102Compiler();
/* harmony default export */ var python_v102 = ({
  python3: pythonCompiler_V102
});
// CONCATENATED MODULE: ./src/compiler/python.ts







//load all versions



var python_PythonCompilerInfo = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(PythonCompilerInfo, _Vue);
  var _super = Object(createSuper["a" /* default */])(PythonCompilerInfo);
  function PythonCompilerInfo() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, PythonCompilerInfo);
    _this = _super.apply(this, arguments);
    _this.type = 'python';
    _this.displayName = 'Python 2.7';
    //attach all version
    _this.versions = [python_v100, python_v101.legacyPython];
    //declare the default one
    _this.default = python_v101.legacyPython;
    return _this;
  }
  return Object(createClass["a" /* default */])(PythonCompilerInfo);
}(lib["c" /* Vue */]);
python_PythonCompilerInfo = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], python_PythonCompilerInfo);

var python_Python3CompilerInfo = /*#__PURE__*/function (_Vue2) {
  Object(inherits["a" /* default */])(Python3CompilerInfo, _Vue2);
  var _super2 = Object(createSuper["a" /* default */])(Python3CompilerInfo);
  function Python3CompilerInfo() {
    var _this2;
    Object(classCallCheck["a" /* default */])(this, Python3CompilerInfo);
    _this2 = _super2.apply(this, arguments);
    _this2.type = 'python3';
    _this2.displayName = 'Python 3';
    //attach all version
    _this2.versions = [python_v101.python3, python_v102.python3];
    //declare the default one
    _this2.default = python_v101.python3;
    return _this2;
  }
  return Object(createClass["a" /* default */])(Python3CompilerInfo);
}(lib["c" /* Vue */]);
python_Python3CompilerInfo = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], python_Python3CompilerInfo);

var PythonCompilers = [new python_PythonCompilerInfo(), new python_Python3CompilerInfo()];
// CONCATENATED MODULE: ./src/compiler/glsl.v100.ts











function runGLSLWorker(questionID, prog, callingCodeBlocks, maxRuntime, logCallback, infoCallback, errCallback, compileFailedCallback, finishCallback) {
  var outputData = [];
  callingCodeBlocks.blocks.filter(function (b) {
    return b.hasCode;
  }).forEach(function (block) {
    return outputData.push(block.content);
  });
  /*$("[data-contains-code][data-question="+questionID+"]").each(function(i, block) {
      if (block.getAttribute('data-ignore')) return;
      if (!blockHasProgramCode(block)) return;
      const editor = editors[block.id];
      if (editor) {
          outputData.push(block.value);
      } else {
          outputData.push(block.innerHTML);
      }
  });*/
  finishCallback(true, outputData);
}
var glsl_v100_GLSLV100Compiler = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(GLSLV100Compiler, _Vue);
  var _super = Object(createSuper["a" /* default */])(GLSLV100Compiler);
  function GLSLV100Compiler() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, GLSLV100Compiler);
    _this = _super.apply(this, arguments);
    _this.version = '100';
    _this.language = 'glsl';
    _this.canRun = true;
    _this.canStop = false;
    _this.allowsContinousCompilation = false;
    _this.allowsPersistentArguments = false;
    _this.acceptsJSONArgument = false;
    _this.allowsMessagePassing = false;
    _this.allowsREPL = false;
    _this.deprecated = false;
    _this.experimental = false;
    _this.isReady = true;
    _this.isRunning = false;
    return _this;
  }
  Object(createClass["a" /* default */])(GLSLV100Compiler, [{
    key: "preload",
    value: function preload() {}
  }, {
    key: "compileAndRun",
    value: function compileAndRun(questionID, code, callingCodeBlocks, options) {
      var max_ms = options.max_ms,
        log_callback = options.log_callback,
        info_callback = options.info_callback,
        err_callback = options.err_callback,
        compileFailedCallback = options.compileFailedCallback,
        finishedExecutionCB = options.finishedExecutionCB,
        args = options.args;
      return runGLSLWorker(questionID, code, callingCodeBlocks, max_ms, log_callback, info_callback, err_callback, compileFailedCallback, finishedExecutionCB);
    }
  }]);
  return GLSLV100Compiler;
}(lib["c" /* Vue */]);
glsl_v100_GLSLV100Compiler = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], glsl_v100_GLSLV100Compiler);

var v100 = new glsl_v100_GLSLV100Compiler();
// CONCATENATED MODULE: ./src/compiler/glsl.ts







//load all versions

var glsl_GLSLCompilerInfo = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(GLSLCompilerInfo, _Vue);
  var _super = Object(createSuper["a" /* default */])(GLSLCompilerInfo);
  function GLSLCompilerInfo() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, GLSLCompilerInfo);
    _this = _super.apply(this, arguments);
    _this.type = 'glsl';
    _this.displayName = 'GLSL Shader';
    //attach all version
    _this.versions = [v100];
    //declare the default one
    _this.default = v100;
    return _this;
  }
  return Object(createClass["a" /* default */])(GLSLCompilerInfo);
}(lib["c" /* Vue */]);
glsl_GLSLCompilerInfo = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], glsl_GLSLCompilerInfo);

var GLSLCompilers = new glsl_GLSLCompilerInfo();
// CONCATENATED MODULE: ./src/lib/CompilerRegistry.ts

















//prepare Compiler Registry
var CompilerRegistry_CompilerRegistry = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(CompilerRegistry, _Vue);
  var _super = Object(createSuper["a" /* default */])(CompilerRegistry);
  function CompilerRegistry() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, CompilerRegistry);
    _this = _super.apply(this, arguments);
    _this.compilers = {};
    _this.libraries = [];
    _this.loadedURIs = [];
    _this.updateMappings = {};
    _this.afterLoadFinished = [];
    _this.isLoadingLibs = false;
    return _this;
  }
  Object(createClass["a" /* default */])(CompilerRegistry, [{
    key: "languages",
    get: function get() {
      var _this2 = this;
      var langs = Object.keys(this.compilers).map(function (k) {
        return _this2.compilers[k];
      }).map(function (c) {
        return {
          label: c.displayName,
          value: c.type
        };
      }).sort(function (a, b) {
        return a.label < b.label ? -1 : 1;
      });
      return langs;
    }
  }, {
    key: "domLibraries",
    get: function get() {
      var libs = this.libraries.filter(function (l) {
        return !l.utility;
      });
      return libs.map(function (l) {
        return {
          label: l.displayName + ' (' + l.version + ')',
          value: l.key
        };
      });
    }
  }, {
    key: "register",
    value: function register(compilers) {
      var _this3 = this;
      if (Array.isArray(compilers)) {
        compilers.forEach(function (c) {
          return _this3.registerSingle(c);
        });
      } else {
        this.registerSingle(compilers);
      }
    }
  }, {
    key: "registerSingle",
    value: function registerSingle(c) {
      var _this4 = this;
      this.compilers[c.type] = c;
      c.versions.forEach(function (v) {
        if (v.registerLibs) {
          v.registerLibs(_this4);
        }
      });
    }
  }, {
    key: "getCompiler",
    value: function getCompiler(compilerInfo) {
      var cmps = this.compilers[compilerInfo.languageType];
      if (!cmps) {
        return undefined;
      }
      if (compilerInfo.version === undefined) {
        return cmps.default;
      }
      var res = cmps.versions.find(function (e) {
        return e.version == compilerInfo.version;
      });
      if (res === undefined) {
        res = cmps.default;
      }
      return res;
    }
  }, {
    key: "versionsForLanguage",
    value: function versionsForLanguage(languageType) {
      var c = this.compilers[languageType];
      if (c === undefined) {
        return ['none'];
      }
      return c.versions.map(function (v) {
        return v.version;
      });
    }
  }, {
    key: "addUpdateMapping",
    value: function addUpdateMapping(name, oldVersion, newVersion) {
      var oldName = "".concat(name, "-").concat(oldVersion);
      var newName = "".concat(name, "-").concat(newVersion);
      this.updateMappings[oldName] = newName;
    }
  }, {
    key: "mapLibrary",
    value: function mapLibrary(loadedName) {
      var name = this.updateMappings[loadedName];
      return name === undefined ? loadedName : name;
    }
  }, {
    key: "registerDOMLib",
    value: function registerDOMLib(uri, name, version, displayName) {
      var utility = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var order = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var onBuildSandboxEnv = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : function () {};
      this.libraries.push({
        key: name + '-' + version,
        uri: uri,
        name: name,
        version: version,
        displayName: displayName,
        didLoad: false,
        utility: utility,
        order: order,
        onBuildSandboxEnv: onBuildSandboxEnv
      });
    }
  }, {
    key: "addLoadedToSandbox",
    value: function addLoadedToSandbox(sandbox) {
      this.libraries.filter(function (l) {
        return l.didLoad;
      }).forEach(function (l) {
        return l.onBuildSandboxEnv(sandbox);
      });
    }
  }, {
    key: "getLibObjects",
    value: function getLibObjects(domLibs) {
      return this.libraries.filter(function (l) {
        return domLibs.indexOf(l.key) >= 0;
      });
    }
  }, {
    key: "urisForDOMLibs",
    value: function urisForDOMLibs(domLibs) {
      var libs = this.getLibObjects(domLibs);
      var uris = libs.filter(function (l) {
        return !l.didLoad;
      }).sort(function (a, b) {
        return a.order < b.order ? 1 : -1;
      }).map(function (l) {
        return l.uri;
      }).reduce(function (p, c) {
        return c.concat(p);
      }, []);
      return uris;
    }
  }, {
    key: "loadLibraries",
    value: function loadLibraries(domLibraries, whenLoaded) {
      var libs = this.urisForDOMLibs(domLibraries);
      var dlibs = this.getLibObjects(domLibraries);
      this.loadURIs(libs, function () {
        dlibs.forEach(function (l) {
          return l.didLoad = true;
        });
        if (window.MathJax === undefined) {
          whenLoaded();
        } else {
          MathJax.Hub.Register.StartupHook('End', function () {
            whenLoaded();
          });
        }
      }.bind(this));
    }
  }, {
    key: "loadURIsIter",
    value: function loadURIsIter(libs, whenLoaded) {
      var _this5 = this;
      console.log(libs);
      var loadCount = 0;
      var didLoad = function didLoad(u) {
        loadCount++;
        if (loadCount == libs.length) {
          whenLoaded();
        }
      };
      libs.forEach(function (uri) {
        if (_this5.loadedURIs.indexOf(uri) >= 0) {
          didLoad(uri);
          return;
        }
        _this5.loadedURIs.push(uri);
        var script = document.createElement('script');
        script.src = uri;
        console.log('[Loading Library from ' + uri + ']');
        script.onload = function () {
          console.log('[Loaded ' + uri + ']');
          didLoad(uri);
        };
        document.head.appendChild(script);
      });
    }
  }, {
    key: "loadURIs",
    value: function loadURIs(libs, whenLoaded) {
      var _this6 = this;
      //make sure we serialize all loads !!!
      if (this.isLoadingLibs) {
        //queue the load
        this.afterLoadFinished.push(function () {
          _this6.loadURIs(libs, whenLoaded);
        });
        return;
      }
      this.isLoadingLibs = true;
      var self = this;
      var loadLib = function loadLib(uris, idx) {
        if (idx >= uris.length) {
          whenLoaded();
          //something tried to queue another load
          // => dequeu it and run it now
          self.isLoadingLibs = false;
          if (self.afterLoadFinished.length > 0) {
            var next = self.afterLoadFinished.shift();
            if (next) {
              next();
            }
          }
          return;
        }
        var uri = uris[idx];
        //already loaded
        if (self.loadedURIs.indexOf(uri) >= 0) {
          loadLib(uris, idx + 1);
          return;
        }
        self.loadedURIs.push(uri);
        var script = document.createElement('script');
        script.src = uri;
        console.log('[Loading Library from ' + uri + ']');
        script.onload = function () {
          loadLib(uris, idx + 1);
        };
        document.head.appendChild(script);
      };
      loadLib(libs, 0);
    }
  }]);
  return CompilerRegistry;
}(lib["c" /* Vue */]);
CompilerRegistry_CompilerRegistry = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], CompilerRegistry_CompilerRegistry);

var CompilerRegistry_compilerRegistry = new CompilerRegistry_CompilerRegistry();
//load all available compilers

CompilerRegistry_compilerRegistry.register(JavaCompilers);

CompilerRegistry_compilerRegistry.register(JavascriptCompilers);

CompilerRegistry_compilerRegistry.register(PythonCompilers);

CompilerRegistry_compilerRegistry.register(GLSLCompilers);
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/chart.js/3.6.0/chart.min.js'], 'chart', '3.6.0', 'Chart.JS', false, 1000, function (sandbox) {
  sandbox.Chart = window.Chart;
});
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/three.js/r0/three.min.js', lib["c" /* Vue */].$CodeBlock.baseurl + 'js/three.js/r0/controls/OrbitControls.js', lib["c" /* Vue */].$CodeBlock.baseurl + 'js/three.js/r0/controls/TrackballControls.js', lib["c" /* Vue */].$CodeBlock.baseurl + 'js/three.js/r0/Detector.js', lib["c" /* Vue */].$CodeBlock.baseurl + 'js/three.js/helper.r0.js'], '3js', 'r0', 'Three.JS', false, 2000, function (sandbox) {
  sandbox.THREE = window.THREE;
});
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/three.js/r140/three.min.js', lib["c" /* Vue */].$CodeBlock.baseurl + 'js/three.js/r140/js/controls/OrbitControls.js', lib["c" /* Vue */].$CodeBlock.baseurl + 'js/three.js/r140/js/controls/TrackballControls.js'], '3js', 'r140', 'Three.JS', false, 2000, function (sandbox) {
  sandbox.THREE = window.THREE;
});
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/lil-gui/0.16/lil-gui.min.js'], 'lil-gui', '0.16', 'lil GUI', false, 2000, function (sandbox) {
  sandbox.lil = window.lil;
});
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/phaser/3.54.0/phaser.min.js', lib["c" /* Vue */].$CodeBlock.baseurl + 'js/phaser/3.54.0/support.js'], 'phaser', '3.54', 'Phaser', false, 3000, function (sandbox) {
  sandbox.Phaser = window.Phaser;
  sandbox.IsometricMapGame = window.IsometricMapGame;
});
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/d3/5.16.0/d3.v5.min.js', lib["c" /* Vue */].$CodeBlock.baseurl + 'js/d3/5.3.8/helper.js'], 'd3', '5.16.0', 'D3', false, 4210, function (sandbox) {
  sandbox.d3 = window.d3;
});
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/d3/5.3.8/d3.v5.min.js', lib["c" /* Vue */].$CodeBlock.baseurl + 'js/d3/5.3.8/helper.js'], 'd3', '5.3.8', 'D3', false, 4200, function (sandbox) {
  sandbox.d3 = window.d3;
});
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/d3/6.7.0/d3.v6.min.js'
//Vue.$CodeBlock.baseurl + 'js/d3/6.2.0/helper.v6.js'
], 'd3', '6.7.0', 'D3', false, 4010, function (sandbox) {
  sandbox.d3 = window.d3;
});
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/d3/7.1.1/d3.v7.min.js'], 'd3', '7.1.1', 'D3', false, 4100, function (sandbox) {
  sandbox.d3 = window.d3;
});
CompilerRegistry_compilerRegistry.addUpdateMapping('d3', '5.13.4', '5.16.0');
CompilerRegistry_compilerRegistry.addUpdateMapping('d3', '6.2.0', '6.7.0');
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/brain.js/2.0.0-alpha/brain-browser.min.js'], 'brain', '2.0.0', 'Brain.JS', false, 5000, function (sandbox) {
  sandbox.brain = window.brain;
});
CompilerRegistry_compilerRegistry.registerDOMLib([lib["c" /* Vue */].$CodeBlock.baseurl + 'js/tensorflow.js/2.0.0/tf.min.js'
//Vue.$CodeBlock.baseurl + 'js/tensorflow.js/2.0.0/tfjs-vis.umd.min.js',
], 'tf', '2.0.0', 'TensorFlow.JS', false, 6000, function (sandbox) {
  sandbox.tf = window.tf;
  //sandbox.tfvis = (window as any).tfvis
});

/* harmony default export */ var lib_CompilerRegistry = (CompilerRegistry_compilerRegistry);
// CONCATENATED MODULE: ./src/lib/scriptBlock.ts

































var legacyCodeTemplate = {
  prefix: 'let editors=[]; $(".CodeMirror").toArray().forEach(cm =>  {if (!cm.CodeMirror.getTextArea().hasAttribute("is-editmode")) editors[cm.CodeMirror.getTextArea().id] = cm.CodeMirror}); return function(){ return {o:',
  postfix: '}.o}.call({})'
};
var v101CodeTemplate = {
  prefix: '"use strict"; return function(){ return {o:',
  postfix: '}.o}.call({})'
};
var v102CodeTemplate = {
  prefix: 'with(sandbox) { return function(){ return {o:',
  postfix: '}.o}.call({})}'
};
var jsErrorParser = function jsErrorParser(e, templ) {
  console.error(e);
  var line = undefined;
  var column = undefined;
  if (e.line) {
    line = e.line;
  } else if (e.lineNumber) {
    line = e.lineNumber;
  }
  if (e.column) {
    column = e.column;
  } else if (e.columnNumber) {
    column = e.columnNumber;
  }
  if (line === undefined) {
    var lines = e.stack.split('\n');
    if (lines.length > 1) {
      var regex = /<anonymous>:(\d+):(\d+)/gm;
      var m = null;
      if ((m = regex.exec(lines[1])) !== null) {
        line = Number(m[1]) - 1;
        column = Number(m[2]) - 1;
      }
    }
  }
  if (line !== undefined) {
    line--;
    if (line == 1) {
      if (column === undefined) {
        column = 0;
      }
      if (templ !== undefined) {
        column -= templ.prefix.length;
      }
    }
  }
  return {
    line: line,
    column: column,
    msg: e.message
  };
};
lib["c" /* Vue */].prototype.$jsErrorParser = jsErrorParser;
var sandboxProxies = new WeakMap();
function compileCode(src) {
  var code = new Function('sandbox', src);
  return function (sandbox) {
    lib_CompilerRegistry.addLoadedToSandbox(sandbox);
    sandbox.$ = function (input) {
      if (typeof input === 'string') {
        console.error("You can not use JQuerry globally from this context. Please try scope.find('".concat(input, "') instead."));
      } else {
        if (input.getAttribute === undefined) {
          console.error('You may only wrap DOMElements using $');
          return;
        }
        return $(input);
      }
    };
    //const oldFetch = fetch
    var oldRequestAnimationFrame = requestAnimationFrame;
    // sandbox.fetch = (uri, options) => {
    //     console.i('Fetching', uri, 'from Sandbox')
    //     return oldFetch(uri, options)
    // }
    sandbox.requestAnimationFrame = function (callback) {
      oldRequestAnimationFrame(callback);
    };
    sandbox.jQuery = sandbox.$;
    sandbox.console = console;
    sandbox.Promise = Promise;
    sandbox.Number = Number;
    sandbox.Map = Map;
    sandbox.String = String;
    sandbox.Array = Array;
    sandbox.RegExp = RegExp;
    sandbox.Math = Math;
    sandbox.document = {
      create$: function create$(what) {
        return $(document.createElement(what));
      },
      createElement: function createElement(what) {
        return document.createElement(what);
      },
      createTextNode: function createTextNode(what) {
        return document.createTextNode(what);
      },
      getElementById: function getElementById(id) {
        return console.error("document.getElementById is not supported. Please use scope.find('#".concat(id, "') instead"));
      },
      getElementsByTagName: function getElementsByTagName(tag) {
        return console.error("document.getElementsByTagName is not supported. Please use scope.find('".concat(tag, "') instead"));
      },
      getElementsByClassName: function getElementsByClassName(cl) {
        return console.error("document.getElementsByClassName is not supported. Please use scope.find('.".concat(cl, "') instead"));
      }
    };
    sandbox.window = {
      devicePixelRatio: window.devicePixelRatio
    };
    if (!sandboxProxies.has(sandbox)) {
      var sandboxProxy = new Proxy(sandbox, {
        has: has,
        get: scriptBlock_get
      });
      sandboxProxies.set(sandbox, sandboxProxy);
    }
    return code(sandboxProxies.get(sandbox));
  };
}
function has(target, key) {
  return true;
}
function scriptBlock_get(target, key) {
  if (key === Symbol.unscopables) {
    return undefined;
  }
  return target[key];
}
var scriptBlock_ScriptBlock = /*#__PURE__*/function () {
  function ScriptBlock(script, version) {
    Object(classCallCheck["a" /* default */])(this, ScriptBlock);
    this.version = version;
    this.err = [];
    this.src = undefined;
    this.fkt = undefined;
    this.obj = undefined;
    this.didInit = false;
    this._runConfig = null;
    this.queuedMessages = [];
    this.queuedIncomingMessages = [];
    this.DATA = [];
    this.RESOURCES = undefined;
    //this.rebuild(script)
    this.didInit = false;
    this.src = script;
    this.obj = {
      init: function init() {
        console.error('FAILED INIT ATTEMPT');
      },
      update: function update() {
        console.error('FAILED UPDATE ATTEMPT');
        return undefined;
      }
    };
  }
  Object(createClass["a" /* default */])(ScriptBlock, [{
    key: "requestsOriginalVersion",
    value: function requestsOriginalVersion() {
      return this.version == '100' || this.version == '' || this.version === undefined;
    }
  }, {
    key: "invalidate",
    value: function invalidate() {
      this.obj = undefined;
    }
  }, {
    key: "rebuild",
    value: function rebuild(code) {
      if (code !== undefined) {
        try {
          this.err = [];
          console.i('!!! REBUILDING !!!');
          this.src = code;
          //wrap the users code in a helper object, otherwise
          //evaluating would fail if the code does not start in the first line
          //we also return a function to make and call (.call({})) it with a clean object
          //to ensure that 'this' is will allways be in a defined state inside the users code
          if (this.requestsOriginalVersion()) {
            this.fkt = new Function(legacyCodeTemplate.prefix + code + legacyCodeTemplate.postfix);
          } else if (this.version === '101') {
            this.fkt = new Function(v101CodeTemplate.prefix + code + v101CodeTemplate.postfix);
          } else {
            this.fkt = compileCode(v102CodeTemplate.prefix + code + v102CodeTemplate.postfix);
          }
          this.obj = this.fkt({});
          this.dequeueIncoming();
        } catch (e) {
          this.pushError(e);
        }
      } else if (this.fkt !== undefined) {
        this.obj = this.fkt({});
        this.dequeueIncoming();
      }
    }
  }, {
    key: "pushError",
    value: function pushError(e) {
      this.err.push(jsErrorParser(e));
    }
  }, {
    key: "lazyInit",
    value: function lazyInit() {
      if (!this.didInit) {
        this.obj = undefined;
        this.rebuild(this.src);
        this.didInit = true;
      }
    }
  }, {
    key: "addArgumentsTo",
    value: function addArgumentsTo(args) {
      this.lazyInit();
      if (this.obj && !this.requestsOriginalVersion()) {
        var o = this.obj;
        if (o.addArgumentsTo) {
          try {
            o.addArgumentsTo(args);
          } catch (e) {
            this.pushError(e);
          }
        }
      }
    }
  }, {
    key: "runConfig",
    get: function get() {
      return this._runConfig;
    },
    set: function set(cfg) {
      if (this._runConfig) {
        this._runConfig.dequeuePostponedMessages = function () {};
      }
      this._runConfig = cfg;
      if (this._runConfig) {
        var self = this;
        this._runConfig.dequeuePostponedMessages = function () {
          var msg = Object(toConsumableArray["a" /* default */])(self.queuedMessages);
          self.queuedMessages = [];
          msg.forEach(function (args) {
            return self.doPostMessageToWorker(args.c, args.d);
          });
        };
        if (this._runConfig.postMessageFunction !== null) {
          this._runConfig.dequeuePostponedMessages();
        }
      }
    }
  }, {
    key: "doPostMessageToWorker",
    value: function doPostMessageToWorker(cmd, data) {
      if (data === undefined) {
        data = {};
      }
      if (this._runConfig !== undefined && this._runConfig !== null && this._runConfig.postMessageFunction !== null) {
        cmd = "d-".concat(cmd);
        data.command = cmd;
        console.i('MESSAGE - Posted to Worker', cmd, data);
        this._runConfig.postMessageFunction(cmd, data);
      } else {
        console.i('MESSAGE - Posted to Queue', cmd);
        this.queuedMessages.push({
          c: cmd,
          d: data
        });
      }
    }
  }, {
    key: "didReceiveMessage",
    value: function didReceiveMessage(cmd, data) {
      this.lazyInit();
      if (this.obj && !this.requestsOriginalVersion()) {
        var o = this.obj;
        if (o.onMessage === undefined) {
          console.i('MESSAGE - Received to Queue', cmd);
          this.queuedIncomingMessages.push({
            c: cmd,
            d: data
          });
        } else {
          console.i('MESSAGE - Received from Worker', cmd, data);
          o.onMessage(cmd, data);
        }
      } else {
        console.i('MESSAGE - Received to Queue', cmd);
        this.queuedIncomingMessages.push({
          c: cmd,
          d: data
        });
      }
    }
  }, {
    key: "dequeueIncoming",
    value: function dequeueIncoming() {
      var _this = this;
      console.i('MESSAGE - Dequeue Incoming');
      var msg = Object(toConsumableArray["a" /* default */])(this.queuedIncomingMessages);
      this.queuedIncomingMessages = [];
      msg.forEach(function (args) {
        return _this.didReceiveMessage(args.c, args.d);
      });
    }
  }, {
    key: "beforeStart",
    value: function beforeStart() {
      this.lazyInit();
      if (this.obj && !this.requestsOriginalVersion()) {
        var o = this.obj;
        if (o.beforeStart) {
          console.i('MESSAGE - beforeStart');
          o.beforeStart();
        }
      }
    }
  }, {
    key: "whenFinished",
    value: function whenFinished(args, resultData) {
      this.lazyInit();
      if (this.obj && !this.requestsOriginalVersion()) {
        var o = this.obj;
        if (o.whenFinished) {
          console.i('MESSAGE - whenFinished');
          o.whenFinished(args, resultData);
        }
      }
    }
  }, {
    key: "resetBlockData",
    value: function resetBlockData(blocks) {
      this.DATA = [];
      if (blocks !== undefined) {
        this.addBlockDataFromBlocks(blocks);
      }
    }
  }, {
    key: "addBlockDataFromBlocks",
    value: function addBlockDataFromBlocks(blocks) {
      var _this2 = this;
      blocks.filter(function (b) {
        return b.type == 'DATA';
      }).forEach(function (b) {
        return _this2.addBlockDataFromBlock(b);
      });
    }
  }, {
    key: "addBlockDataFromBlock",
    value: function addBlockDataFromBlock(block) {
      this.addBlockData(block.name, block.content);
    }
  }, {
    key: "addBlockData",
    value: function addBlockData(name, content) {
      try {
        this.DATA[name] = JSON.parse(content);
      } catch (e) {
        this.DATA[name] = undefined;
        console.error("Unable to parse JSON from '".concat(name, "'"), e);
      }
    }
  }, {
    key: "resetResources",
    value: function resetResources() {
      this.RESOURCES = undefined;
    }
  }, {
    key: "setupDOM",
    value: function setupDOM(canvasElement, scope) {
      var self = this;
      this.queuedMessages = [];
      this.queuedIncomingMessages = [];
      this.lazyInit();
      console.i('MESSAGE - Reset Queue from Init');
      if (this.obj === undefined) {
        return;
      }
      try {
        if (!this.requestsOriginalVersion()) {
          var o = this.obj;
          o.DATA = this.DATA;
          console.i('!!! SETUP CANVAS !!!');
          if (o.setupDOM) {
            var outputElement = undefined;
            if (scope === undefined || scope.length === 0) {
              scope = canvasElement.parents('.codeblocks');
            }
            if (scope !== undefined) {
              outputElement = scope.find('div.runner pre.output');
            }
            o.setupDOM(canvasElement, outputElement, scope);
          }
        }
      } catch (e) {
        this.pushError(e);
      }
    }
  }, {
    key: "init",
    value: function init(canvasElement, scope, runner) {
      var self = this;
      this.queuedMessages = [];
      this.queuedIncomingMessages = [];
      this.lazyInit();
      console.i('MESSAGE - Reset Queue from Init');
      if (this.obj === undefined) {
        return;
      }
      try {
        if (this.requestsOriginalVersion()) {
          console.i('!!! INIT CANVAS (original) !!!');
          var o = this.obj;
          o.init(canvasElement);
        } else {
          var _o = this.obj;
          _o.DATA = this.DATA;
          if (_o.getResources) {
            if (self.RESOURCES === undefined) {
              console.i('!!! FETCHING RESOURCES !!!');
              self.RESOURCES = [];
              var requests = _o.getResources().map(function (res, idx, array) {
                return fetch(res.uri).then(function (response) {
                  if (!response.ok) {
                    throw new Error('Unable to retrive ' + res.uri);
                  }
                  if (res.type === 'json') {
                    return response.json();
                  } else if (res.type === 'text') {
                    return response.text();
                  } else if (res.type === 'image') {
                    return response.blob();
                  } else if (res.type === 'buffer') {
                    return response.arrayBuffer();
                  }
                  return response.blob();
                }).then(function (data) {
                  if (res.type === 'image') {
                    data = URL.createObjectURL(data);
                  }
                  if (self.RESOURCES === undefined) {
                    self.RESOURCES = [];
                  }
                  self.RESOURCES[idx] = data;
                  if (res.name) {
                    self.RESOURCES[res.name] = data;
                    var a = _o;
                    a[res.name] = data;
                  }
                  return data;
                });
              });
              Promise.all(requests).then(function (values) {
                if (self.RESOURCES === undefined) {
                  self.RESOURCES = [];
                }
                _o.RESOURCES = self.RESOURCES;
                self._runInit(canvasElement, scope, runner);
              }).catch(function (e) {
                return console.error(e);
              });
            } else {
              console.i('!!! READING CACHED RESOURCES !!!');
              _o.RESOURCES = self.RESOURCES;
              _o.getResources().forEach(function (res) {
                if (res.name) {
                  var a = _o;
                  if (self.RESOURCES !== undefined) {
                    a[res.name] = self.RESOURCES[res.name];
                  }
                }
              });
              self._runInit(canvasElement, scope, runner);
            }
          } else {
            _o.RESOURCES = [];
            this._runInit(canvasElement, scope, runner);
          }
        }
      } catch (e) {
        this.pushError(e);
      }
    }
  }, {
    key: "_runInit",
    value: function _runInit(canvasElement, scope, runner) {
      console.i('!!! INIT CANVAS !!!');
      var arunner = runner;
      arunner.run = runner;
      arunner.postMessage = this.doPostMessageToWorker.bind(this);
      var outputElement = undefined;
      if (scope === undefined || scope.length === 0) {
        scope = canvasElement.parents('.codeblocks');
      }
      if (scope !== undefined) {
        outputElement = scope.find('div.runner pre.output');
      }
      if (outputElement === undefined) {
        console.error('[Internal Error] No Output Element found!');
        this.pushError('[Internal Error] No Output Element found!');
      } else {
        var o = this.obj;
        o.init(canvasElement, outputElement, scope, runner);
      }
    }
  }, {
    key: "reset",
    value: function reset(canvasElement) {
      this.queuedMessages = [];
      this.queuedIncomingMessages = [];
      this.lazyInit();
      console.i('MESSAGE - Reset Queue from Reset');
      if (this.obj && this.obj.reset && !this.requestsOriginalVersion()) {
        this.obj.reset(canvasElement);
      }
    }
  }, {
    key: "update",
    value: function update(outputObject, canvasElement) {
      this.lazyInit();
      if (this.obj === undefined) {
        return outputObject.output;
      }
      try {
        if (this.obj.update) {
          //console.log(this.obj.update.length, outputObject, this.obj);
          //this is the old behaviour
          if (this.obj.update.length == 2 || this.requestsOriginalVersion()) {
            var o = this.obj;
            if (outputObject.processedOutput.type == 'json') {
              console.i('!!! UPDATE (org, json) !!!');
              return o.update(outputObject.processedOutput.json, canvasElement);
            } else {
              console.i('!!! UPDATE (org, text) !!!');
              return o.update(outputObject.output, canvasElement);
            }
          } else {
            var _o2 = this.obj;
            console.i('!!! UPDATE (v' + this.version + ')!!!');
            return _o2.update(outputObject.processedOutput.text, outputObject.processedOutput.json, canvasElement, outputObject.outputElement);
          }
        }
      } catch (e) {
        this.pushError(e);
      }
      return outputObject.initialOutput;
    }
  }, {
    key: "onParseError",
    value: function onParseError(initialOutput, parseError) {
      this.lazyInit();
      if (this.obj === undefined) {
        return false;
      }
      try {
        if (this.obj.onParseError) {
          this.obj.onParseError(initialOutput, parseError);
        } else {
          console.error(parseError);
          return false;
        }
      } catch (e) {
        this.pushError(e);
        return false;
      }
      return true;
    }
  }]);
  return ScriptBlock;
}();
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=template&id=eaf51832&
var Appvue_type_template_id_eaf51832_render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c('q-layout', {
    staticStyle: {
      "min-height": "0"
    },
    attrs: {
      "view": "hHh lpR fFf"
    }
  }, [_c('q-page-container', [_c('CodeBlocks', {
    attrs: {
      "blockInfo": _vm.blocks
    }
  })], 1)], 1);
};
var staticRenderFns = [];

// CONCATENATED MODULE: ./src/App.vue?vue&type=template&id=eaf51832&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlocks.vue?vue&type=template&id=7e42fd95&

var CodeBlocksvue_type_template_id_7e42fd95_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', {
    class: "codeblocks ".concat(_vm.addonClass, "  ").concat(_vm.backgroundColorClass, " q-mx-sm q-mb-md"),
    attrs: {
      "data-question": _vm.blockInfo.id,
      "uuid": _vm.blockInfo.uuid
    }
  }, [_c('CodePanel', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.hasBookmark && _vm.editMode,
      expression: "hasBookmark && editMode"
    }],
    attrs: {
      "editMode": _vm.editMode,
      "visibleLines": "auto",
      "block": _vm.panelBlock
    }
  }), _vm.editMode ? _c('CodeBlocksSettings', {
    attrs: {
      "options": _vm.options
    },
    on: {
      "compiler-change": _vm.onCompilerChange,
      "compiler-version-change": _vm.onCompilerVersionChange,
      "run-state-change": _vm.onRunStateChange,
      "continuous-compile-change": _vm.onContinousCompileStateChange,
      "message-passing-change": _vm.onMessagePassingChange,
      "keep-alive-change": _vm.onKeepAliveChange,
      "persistent-arguments-change": _vm.onPersistentArgumentsChange,
      "language-change": _vm.onLanguageChange,
      "character-limit-change": _vm.onCharacterLimitChange,
      "timeout-change": _vm.onTimeoutChange,
      "worker-libs-change": _vm.onWorkerLibChange,
      "dom-libs-change": _vm.onDomLibChange,
      "theme-change": _vm.onThemeChange,
      "output-parser-change": _vm.onOutputParserChange
    }
  }) : _vm._e(), _vm._l(_vm.blocks, function (block) {
    return _c('CodeBlockContainer', {
      key: block.id,
      attrs: {
        "block": block,
        "editMode": _vm.editMode
      },
      on: {
        "type-change": _vm.onTypeChange,
        "visible-lines-change": _vm.onVisibleLinesChange,
        "placement-change": _vm.onPlacementChange,
        "script-version-change": _vm.onScriptVersionChange,
        "move-up": _vm.moveUp,
        "move-down": _vm.moveDown,
        "remove-block": _vm.removeBlock,
        "auto-reset-change": _vm.onSetAutoReset,
        "reload-resources-change": _vm.onReloadResources,
        "generate-template-change": _vm.onSetGenerateTemplate,
        "change-order": _vm.onChangeOrder
      }
    }, [block.hasCode && block.type != 'BLOCKLY' ? _c('CodeBlock', {
      attrs: {
        "block": block,
        "theme": _vm.themeForBlock(block),
        "mode": _vm.mimeType,
        "visibleLines": block.visibleLines,
        "editMode": _vm.editMode,
        "readonly": _vm.readonly,
        "tagSet": _vm.activeTagSet,
        "emitWhenTypingInViewMode": _vm.continuousCompile
      },
      on: {
        "ready": _vm.blockBecameReady,
        "build": _vm.run,
        "code-changed-in-view-mode": _vm.onViewCodeChange
      }
    }) : block.type == 'PLAYGROUND' ? _c('CodePlayground', {
      attrs: {
        "block": block,
        "editMode": _vm.editMode,
        "finalOutputObject": _vm.finalOutputObject,
        "theme": _vm.themeForBlock(block),
        "tagSet": _vm.activeTagSet,
        "eventHub": _vm.eventHub
      },
      on: {
        "changeOutput": _vm.onPlaygroundChangedOutput,
        "ready": _vm.blockBecameReady,
        "run": _vm.onRunFromPlayground
      }
    }) : block.type == 'TEXT' ? _c('SimpleText', {
      attrs: {
        "block": block,
        "previewValue": block.actualContent(),
        "editMode": _vm.editMode,
        "name": "block[".concat(block.parentID, "][").concat(block.id, "]"),
        "scopeUUID": block.scopeUUID,
        "tagSet": _vm.activeTagSet,
        "language": _vm.language
      },
      on: {
        "ready": _vm.blockBecameReady
      },
      model: {
        value: block.content,
        callback: function callback($$v) {
          _vm.$set(block, "content", $$v);
        },
        expression: "block.content"
      }
    }) : block.type == 'BLOCKLY' ? _c('Blockly', {
      attrs: {
        "block": block,
        "mode": _vm.mimeType,
        "theme": _vm.themeForBlock(block),
        "editMode": _vm.editMode,
        "readonly": _vm.readonly,
        "tagSet": _vm.activeTagSet,
        "emitWhenTypingInViewMode": _vm.continuousCompile,
        "blockInfo": _vm.blockInfo
      },
      on: {
        "code-changed-in-view-mode": _vm.onViewCodeChange
      }
    }) : _vm._e(), block.type == 'REPL' ? _c('CodeREPL', {
      attrs: {
        "block": block,
        "eventHub": _vm.eventHub,
        "blockInfo": _vm.blockInfo,
        "isReady": _vm.isReady,
        "canStop": _vm.canStop,
        "showGlobalMessages": _vm.showGlobalMessages,
        "globalStateMessage": _vm.$compilerState.globalStateMessage
      },
      on: {
        "ready": _vm.blockBecameReady,
        "run": _vm.run,
        "stop": _vm.stop
      }
    }) : block.type == 'DATA' ? _c('DataBlock', {
      attrs: {
        "block": block,
        "editMode": _vm.editMode,
        "finalOutputObject": _vm.finalOutputObject,
        "theme": _vm.themeForBlock(block),
        "tagSet": _vm.activeTagSet,
        "eventHub": _vm.eventHub
      },
      on: {
        "ready": _vm.blockBecameReady
      }
    }) : _vm._e()], 1);
  }), _vm.editMode ? _c('div', {
    staticClass: "row justify-end"
  }, [_c('div', [_c('q-btn', {
    attrs: {
      "push": "",
      "color": "green"
    },
    on: {
      "click": _vm.addNewBlock
    }
  }, [_vm._v(_vm._s(_vm.$t('CodeBlocks.AddBlock')) + " "), _c('q-icon', {
    staticClass: "q-ml-sm",
    attrs: {
      "name": "library_add"
    }
  })], 1)], 1)]) : _vm._e(), _vm.canRun ? _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: !_vm.hasREPL,
      expression: "!hasREPL"
    }],
    class: "runner ".concat(_vm.editMode ? 'q-pt-lg q-mx-lg' : ''),
    attrs: {
      "id": "runContainer",
      "data-question": _vm.blockInfo.id
    }
  }, [_c('div', {
    staticClass: "row runnerState",
    attrs: {
      "id": "stateBox",
      "data-question": _vm.blockInfo.id
    }
  }, [_c('q-btn', {
    staticClass: "white--text",
    staticStyle: {
      "border-radius": "0px"
    },
    attrs: {
      "id": "allow_run_button",
      "loading": !_vm.isReady,
      "disabled": !_vm.isReady,
      "color": "primary",
      "ripple": {
        center: true
      },
      "data-question": _vm.blockInfo.id
    },
    on: {
      "click": _vm.run
    }
  }, [_vm._v(" " + _vm._s(_vm.$t('CodeBlocks.run')) + " "), _c('q-icon', {
    attrs: {
      "right": "",
      "dark": "",
      "name": "play_arrow"
    }
  }), _vm.editMode ? _c('q-tooltip', {
    attrs: {
      "delay": 200
    }
  }, [_c('span', {
    domProps: {
      "innerHTML": _vm._s(_vm.$t('CodeBlocks.run_hint'))
    }
  })]) : _vm._e()], 1), _c('div', {
    staticClass: "animated fadeIn"
  }), _c('transition', {
    attrs: {
      "appear": "",
      "enter-active-class": "animated fadeIn",
      "leave-active-class": "animated fadeOut"
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.canStop,
      expression: "canStop"
    }],
    staticClass: "q-pl-sm"
  }, [_c('q-btn', {
    staticStyle: {
      "border-radius": "0px"
    },
    attrs: {
      "id": "cancel_button",
      "color": "negative",
      "ripple": {
        center: true
      },
      "data-question": _vm.blockInfo.id
    },
    on: {
      "click": _vm.stop
    }
  }, [_vm._v(" " + _vm._s(_vm.$t('CodeBlocks.stop')) + " "), _c('q-icon', {
    attrs: {
      "right": "",
      "dark": "",
      "name": "stop"
    }
  })], 1)], 1)]), _c('transition', {
    attrs: {
      "appear": "",
      "enter-active-class": "animated fadeIn",
      "leave-active-class": "animated fadeOut"
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.showGlobalMessages,
      expression: "showGlobalMessages"
    }],
    staticClass: "globalState col-grow",
    staticStyle: {
      "align-self": "center"
    }
  }, [_c('div', {
    attrs: {
      "id": "message"
    },
    domProps: {
      "innerHTML": _vm._s(_vm.$compilerState.globalStateMessage)
    }
  })])])], 1), _c('q-slide-transition', [_vm.hasOutput ? _c('pre', {
    ref: "output",
    staticClass: "output",
    attrs: {
      "id": "".concat(_vm.blockInfo.id, "Output")
    }
  }, [_c('div', {
    attrs: {
      "id": "out"
    },
    domProps: {
      "innerHTML": _vm._s(_vm.outputHTML)
    }
  })]) : _vm._e()])], 1) : _vm._e()], 2);
};
var CodeBlocksvue_type_template_id_7e42fd95_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/CodeBlocks.vue?vue&type=template&id=7e42fd95&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlockContainer.vue?vue&type=template&id=6bc47167&

var CodeBlockContainervue_type_template_id_6bc47167_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', {
    staticClass: "block-container",
    attrs: {
      "data-question": _vm.block.parentID,
      "data-nr": _vm.block.id,
      "uuid": _vm.block.uuid
    }
  }, [_vm.editMode ? _c('q-card', {
    class: "q-mx-none q-my-xs q-pa-none editModeBlockContainer ".concat(_vm.colorClass, " ").concat(_vm.bgClass)
  }, [_c('q-card-section', {
    staticClass: "q-mb-none q-pb-sm q-pt-sm"
  }, [_c('div', {
    staticClass: "row q-my-none q-py-none",
    attrs: {
      "dense": ""
    }
  }, [_c('div', {
    staticClass: "col-xs-12 col-sm-4 col-md-4 q-my-none q-py-none"
  }, [_c('q-select', {
    staticStyle: {
      "margin-top": "-5px !important"
    },
    attrs: {
      "options": _vm.types,
      "dense": ""
    },
    scopedSlots: _vm._u([{
      key: "after",
      fn: function fn() {
        return [_c('q-btn', {
          attrs: {
            "flat": "",
            "round": "",
            "color": "primary",
            "icon": "info",
            "size": "xs"
          },
          on: {
            "click": _vm.showTypeInfoDialog
          }
        })];
      },
      proxy: true
    }], null, false, 3671508059),
    model: {
      value: _vm.typeObj,
      callback: function callback($$v) {
        _vm.typeObj = $$v;
      },
      expression: "typeObj"
    }
  })], 1), _c('div', {
    staticClass: "col-grow"
  }), _c('div', {
    staticClass: "order-xs-first order-sm-last col-xs-12 col-sm-8 col-md-5 q-my-none q-py-none rightContentContainerHeader"
  }, [_vm.hasExtendedSettings ? _c('q-btn', {
    attrs: {
      "icon": "settings",
      "color": "blue-7",
      "push": "",
      "dense": ""
    }
  }, [_c('q-popup-proxy', [_vm.canSetLineNumbers ? _c('div', {
    staticClass: "q-pa-md"
  }, [_c('div', {
    staticClass: "row no-wrap q-pt-none q-pb-md"
  }, [_c('div', {
    staticClass: "text-overline"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Display')) + " ")])]), _c('div', {
    staticClass: "row no-wrap q-pl-md"
  }, [_c('div', {
    staticClass: "col-7"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Lines')) + " ")]), _c('div', {
    staticClass: "text-caption text-blue-grey-4",
    domProps: {
      "innerHTML": _vm._s(_vm.$l('CodeBlockContainer.Lines_detail'))
    }
  })]), _c('div', {
    staticClass: "col-5 q-pl-sm"
  }, [_c('q-input', {
    staticStyle: {
      "width": "132px"
    },
    attrs: {
      "rules": [_vm.validNumber],
      "maxlength": "4"
    },
    model: {
      value: _vm.visibleLines,
      callback: function callback($$v) {
        _vm.visibleLines = $$v;
      },
      expression: "visibleLines"
    }
  })], 1)]), _vm.canHaveAlternativeContent ? _c('div', {
    staticClass: "row no-wrap q-pl-md"
  }, [_c('div', {
    staticClass: "col-7"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Prepopulate')) + " ")]), _c('div', {
    staticClass: "text-caption text-blue-grey-4",
    attrs: {
      "lines": "2"
    }
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Prepopulate_detail')) + " ")])]), _c('div', {
    staticClass: "col-5 q-pl-sm"
  }, [_c('q-toggle', {
    model: {
      value: _vm.hasAltComntent,
      callback: function callback($$v) {
        _vm.hasAltComntent = $$v;
      },
      expression: "hasAltComntent"
    }
  })], 1)]) : _vm._e()]) : _vm._e(), _vm.isVersionedPlayground ? _c('div', {
    staticClass: "q-pa-md"
  }, [_c('div', {
    staticClass: "row no-wrap q-pt-none q-pb-md"
  }, [_c('div', {
    staticClass: "text-overline"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Behaviour')) + " ")])]), _c('div', {
    staticClass: "row no-wrap q-pl-md"
  }, [_c('div', {
    staticClass: "col-7"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.ScriptV')) + " ")]), _c('div', {
    staticClass: "text-caption text-blue-grey-4"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.ScriptV_detail')) + " ")])]), _c('div', {
    staticClass: "col-5 q-pl-sm"
  }, [_c('q-select', {
    attrs: {
      "options": _vm.scriptVersions
    },
    model: {
      value: _vm.scriptVersionObj,
      callback: function callback($$v) {
        _vm.scriptVersionObj = $$v;
      },
      expression: "scriptVersionObj"
    }
  })], 1)]), _c('div', {
    staticClass: "row no-wrap q-pl-md"
  }, [_c('div', {
    staticClass: "col-7"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.AutoReset')) + " ")]), _c('div', {
    staticClass: "text-caption text-blue-grey-4"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.AutoReset_detail')) + " ")])]), _c('div', {
    staticClass: "col-5 q-pl-sm"
  }, [_c('q-toggle', {
    model: {
      value: _vm.shouldAutoReset,
      callback: function callback($$v) {
        _vm.shouldAutoReset = $$v;
      },
      expression: "shouldAutoReset"
    }
  })], 1)]), _vm.canLoadResources ? _c('div', {
    staticClass: "row no-wrap q-pl-md"
  }, [_c('div', {
    staticClass: "col-7"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.ReloadResources')) + " ")]), _c('div', {
    staticClass: "text-caption text-blue-grey-4"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.ReloadResources_detail')) + " ")])]), _c('div', {
    staticClass: "col-5 q-pl-sm"
  }, [_c('q-toggle', {
    model: {
      value: _vm.shouldReloadResources,
      callback: function callback($$v) {
        _vm.shouldReloadResources = $$v;
      },
      expression: "shouldReloadResources"
    }
  })], 1)]) : _vm._e(), _c('div', {
    staticClass: "row no-wrap q-pl-md"
  }, [_c('div', {
    staticClass: "col-7"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.GenerateTemplate')) + " ")]), _c('div', {
    staticClass: "text-caption text-blue-grey-4"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.GenerateTemplate_detail')) + " ")])]), _c('div', {
    staticClass: "col-5 q-pl-sm"
  }, [_c('q-toggle', {
    model: {
      value: _vm.shouldGenerateTemplate,
      callback: function callback($$v) {
        _vm.shouldGenerateTemplate = $$v;
      },
      expression: "shouldGenerateTemplate"
    }
  })], 1)])]) : _vm._e(), _vm.canDefinePlacement && _vm.shouldGenerateTemplate ? _c('div', {
    staticClass: "q-pa-md"
  }, [_c('div', {
    staticClass: "row no-wrap q-pt-none q-pb-md"
  }, [_c('div', {
    staticClass: "text-overline"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Positioning')) + " ")])]), _c('div', {
    staticClass: "row no-wrap q-pl-md q-pb-md"
  }, [_c('div', {
    staticClass: "col-7"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Width')) + " ")]), _c('div', {
    staticClass: "text-caption text-blue-grey-4"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Width_detail')) + " ")])]), _c('div', {
    staticClass: "col-5 q-pl-sm"
  }, [_c('q-input', {
    attrs: {
      "maxlength": "7",
      "dense": ""
    },
    model: {
      value: _vm.width,
      callback: function callback($$v) {
        _vm.width = $$v;
      },
      expression: "width"
    }
  })], 1)]), _c('div', {
    staticClass: "row no-wrap q-pl-md q-pb-md"
  }, [_c('div', {
    staticClass: "col-7"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Height')) + " ")]), _c('div', {
    staticClass: "text-caption text-blue-grey-4"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Height_detail')) + " ")])]), _c('div', {
    staticClass: "col-5 q-pl-sm"
  }, [_c('q-input', {
    attrs: {
      "maxlength": "7",
      "dense": ""
    },
    model: {
      value: _vm.height,
      callback: function callback($$v) {
        _vm.height = $$v;
      },
      expression: "height"
    }
  })], 1)]), _c('div', {
    staticClass: "row no-wrap q-pl-md"
  }, [_c('div', {
    staticClass: "col-7"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Alignment')) + " ")]), _c('div', {
    staticClass: "text-caption text-blue-grey-4"
  }, [_vm._v(" " + _vm._s(_vm.$l('CodeBlockContainer.Alignment_detail')) + " ")])]), _c('div', {
    staticClass: "col-5 q-pl-sm"
  }, [_c('q-select', {
    attrs: {
      "options": _vm.alignments,
      "dense": ""
    },
    model: {
      value: _vm.align,
      callback: function callback($$v) {
        _vm.align = $$v;
      },
      expression: "align"
    }
  })], 1)])]) : _vm._e()])], 1) : _vm._e(), _c('q-btn', {
    staticClass: "q-ml-md q-mr-xs",
    attrs: {
      "disable": !_vm.canMoveUp,
      "icon": "arrow_drop_up",
      "push": "",
      "dense": "",
      "color": "orange-6",
      "ripple": {
        center: true
      }
    },
    on: {
      "click": _vm.moveUp
    }
  }), _c('div', {
    staticClass: "inlined-input q-pl-sm q-pr-md q-m-none",
    staticStyle: {
      "width": "80px"
    }
  }, [_c('q-select', {
    staticStyle: {
      "margin-top": "-5px !important"
    },
    attrs: {
      "options": _vm.positions,
      "dense": ""
    },
    model: {
      value: _vm.order,
      callback: function callback($$v) {
        _vm.order = $$v;
      },
      expression: "order"
    }
  })], 1), _c('q-btn', {
    staticClass: "q-mr-md",
    attrs: {
      "disabled": !_vm.canMoveDown,
      "icon": "arrow_drop_down",
      "push": "",
      "dense": "",
      "color": "orange-6",
      "ripple": {
        center: true
      }
    },
    on: {
      "click": _vm.moveDown
    }
  }), _c('q-btn', {
    staticClass: "gt-xs q-mr-sm-sm q-mr-md-lg q-pr-sm",
    attrs: {
      "label": _vm.$l('CodeBlockContainer.Delete'),
      "icon": "warning",
      "push": "",
      "dense": "",
      "color": "red-6",
      "right": "",
      "ripple": {
        center: true
      }
    },
    on: {
      "click": _vm.removeBlock
    }
  }), _c('q-btn', {
    staticClass: "lt-sm q-mr-lg q-pr-none",
    attrs: {
      "icon": "warning",
      "push": "",
      "dense": "",
      "color": "red-6",
      "right": "",
      "ripple": {
        center: true
      }
    },
    on: {
      "click": _vm.removeBlock
    }
  }), _c('q-btn', {
    staticStyle: {
      "margin-right": "-9px"
    },
    attrs: {
      "icon": _vm.expanded ? 'expand_less' : 'expand_more',
      "color": "primary",
      "small": "",
      "flat": "",
      "round": ""
    },
    on: {
      "click": _vm.toggleExpanded
    }
  })], 1)]), _c('textarea', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: _vm.serializedOptions,
      expression: "serializedOptions"
    }],
    staticClass: "blockoptions",
    attrs: {
      "name": "block_options[".concat(this.block.parentID, "][").concat(this.block.id, "]")
    },
    domProps: {
      "value": _vm.serializedOptions
    },
    on: {
      "input": function input($event) {
        if ($event.target.composing) return;
        _vm.serializedOptions = $event.target.value;
      }
    }
  })]), _c('q-slide-transition', [this.isExperimentalScriptVersion ? _c('q-card-section', [_c('q-banner', {
    staticClass: "bg-orange text-white col-12 q-mt-xs q-mb-md",
    attrs: {
      "rounded": "",
      "dense": ""
    }
  }, [_c('q-item', [_c('q-item-section', {
    attrs: {
      "avatar": ""
    }
  }, [_c('q-icon', {
    staticStyle: {
      "font-size": "3em"
    },
    attrs: {
      "name": "whatshot"
    }
  })], 1), _c('q-item-section', [_c('q-item-label', {
    attrs: {
      "overline": ""
    }
  }, [_vm._v(" " + _vm._s(_vm.$t('CodePlayground.ExperimentalScriptVersion')) + " ")]), _c('q-item-label', [_vm._v(" " + _vm._s(_vm.$t('CodePlayground.ExperimentalScriptVersionDesc')) + " ")])], 1)], 1)], 1)], 1) : _vm._e()], 1), _c('q-slide-transition', [this.isDeprecatedScriptVersion ? _c('q-card-section', [_c('q-banner', {
    staticClass: "bg-yellow-12 text-black col-12 q-mt-xs q-mb-md",
    attrs: {
      "rounded": "",
      "dense": ""
    }
  }, [_c('q-item', [_c('q-item-section', {
    attrs: {
      "avatar": ""
    }
  }, [_c('q-icon', {
    staticStyle: {
      "font-size": "3em"
    },
    attrs: {
      "name": "hourglass_disabled"
    }
  })], 1), _c('q-item-section', [_c('q-item-label', {
    attrs: {
      "overline": ""
    }
  }, [_vm._v(" " + _vm._s(_vm.$t('CodePlayground.DeprecatedScriptVersion')) + " ")]), _c('q-item-label', [_vm._v(" " + _vm._s(_vm.$t('CodePlayground.DeprecatedScriptVersionDesc')) + " ")])], 1)], 1)], 1)], 1) : _vm._e()], 1), _c('q-slide-transition', [_c('q-card-section', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.expanded,
      expression: "expanded"
    }],
    staticClass: "my-0 q-pt-1 q-pb-0"
  }, [_vm._t("default")], 2)], 1)], 1) : _c('div', {
    staticClass: "ma-0 pa-0"
  }, [_vm._t("default")], 2)], 1);
};
var CodeBlockContainervue_type_template_id_6bc47167_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/CodeBlockContainer.vue?vue&type=template&id=6bc47167&

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.json.stringify.js
var es_json_stringify = __webpack_require__("e9c4");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
var es_string_match = __webpack_require__("466d");

// EXTERNAL MODULE: ./src/lib/BlocklyHelper.ts
var BlocklyHelper = __webpack_require__("2541");

// CONCATENATED MODULE: ./src/lib/BlockloadManagers/PositioningManager.ts


var PositioningManager_PositioninLoadManager = /*#__PURE__*/function () {
  function PositioninLoadManager() {
    Object(classCallCheck["a" /* default */])(this, PositioninLoadManager);
  }
  Object(createClass["a" /* default */])(PositioninLoadManager, [{
    key: "loadFromDatablock",
    value: function loadFromDatablock(bl, inBlock, block) {
      block.width = bl.getAttribute('width') ? bl.getAttribute('width') : inBlock.width ? inBlock.width : '100%';
      block.height = bl.getAttribute('height') ? bl.getAttribute('height') : inBlock.height ? inBlock.height : '300px';
      block.align = bl.getAttribute('align') ? bl.getAttribute('align') : inBlock.align ? inBlock.align : 'center';
    }
  }]);
  return PositioninLoadManager;
}();
var positioninLoadManager = new PositioningManager_PositioninLoadManager();
// CONCATENATED MODULE: ./src/lib/BlockloadManagers/BlocklyManager.ts








var BlocklyManager_BlocklyLoadManager = /*#__PURE__*/function () {
  function BlocklyLoadManager() {
    Object(classCallCheck["a" /* default */])(this, BlocklyLoadManager);
  }
  Object(createClass["a" /* default */])(BlocklyLoadManager, [{
    key: "blockTag",
    get: function get() {
      return 'BLOCKLY';
    }
  }, {
    key: "loadCustomBlocks",
    value: function loadCustomBlocks(bl, inBlock, block) {
      var customBlocks = bl.querySelectorAll('script#customblocks'); //bl.getElementsByTagName('CUSTOMBLOCKS')
      if (customBlocks.length > 0) {
        var str = customBlocks[0].innerHTML ? customBlocks[0].innerHTML : '{}';
        try {
          var arr = new Function(BlocklyHelper["e" /* blocklyHelper */].prepareCode(str))();
          arr.forEach(function (bl) {
            if (bl.JSON === undefined) {
              bl.JSON = {
                type: '',
                message0: '',
                args0: [],
                nextStatement: null,
                previousStatement: null,
                colour: ''
              };
            }
            if (bl.uuid === undefined || bl.uuid === '') {
              bl.uuid = index_esm["b" /* uuid */].v4();
            }
            if (bl.codeString === undefined && bl._code !== undefined) {
              bl.codeString = bl._code.toString();
            }
            bl._code = undefined;
          });
          block.blockly.blocks = arr;
        } catch (e) {
          console.error('Error parsing Blocks JSON', e);
        }
      }
    }
  }, {
    key: "loadToolbox",
    value: function loadToolbox(bl, inBlock, block) {
      var toolboxInput = bl.getElementsByTagName('TOOLBOX');
      if (toolboxInput.length > 0) {
        var toolboxStr = toolboxInput[0].innerHTML ? toolboxInput[0].innerHTML : '';
        if (toolboxStr === '') {
          block.blockly.toolbox = this.defaultToolbox;
        } else {
          try {
            var obj = new Function(BlocklyHelper["e" /* blocklyHelper */].prepareCode(toolboxStr))();
            obj.categories.forEach(function (c) {
              if (c.uuid === undefined || c.uuid === '') {
                c.uuid = index_esm["b" /* uuid */].v4();
              }
              if (c.color === undefined) {
                c.color = '';
              }
              c.items.forEach(function (i) {
                if (i.uuid === undefined || i.uuid === '') {
                  i.uuid = index_esm["b" /* uuid */].v4();
                }
              });
            });
            block.blockly.toolbox = obj;
          } catch (e) {
            console.error('Error Parsing ToolboxJSON', e);
          }
        }
      } else {
        block.blockly.toolbox = this.defaultToolbox;
      }
    }
  }, {
    key: "loadOverrideToolbox",
    value: function loadOverrideToolbox(bl, inBlock, block) {
      var toolboxOverride = bl.querySelectorAll('script#toolboxoverride'); //bl.getElementsByTagName('TOOLBOXOVERRIDE')
      if (toolboxOverride.length > 0) {
        block.blockly.toolboxOverride = toolboxOverride[0].innerHTML ? toolboxOverride[0].innerHTML : '';
        block.blockly.useOverride = toolboxOverride[0].hasAttribute('use') && toolboxOverride[0].getAttribute('use') != 'false' && toolboxOverride[0].getAttribute('use') != '0';
      }
    }
  }, {
    key: "loadCode",
    value: function loadCode(bl, inBlock, block) {
      var codes = bl.querySelectorAll('script#content'); //bl.getElementsByTagName('SCRIPT')
      if (codes.length > 0) {
        block.content = codes[0].innerHTML ? codes[0].innerHTML : '';
      } else {
        block.content = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
      }
      block.hasCode = true;
    }
  }, {
    key: "isTrue",
    value: function isTrue(val) {
      return val !== undefined && val != 'false' && val != '0';
    }
  }, {
    key: "loadFromDatablock",
    value: function loadFromDatablock(bl, inBlock, block, editMode) {
      block.obj = null;
      positioninLoadManager.loadFromDatablock(bl, inBlock, block);
      block.blockly.showControls = this.isTrue(inBlock.showControls);
      this.loadCustomBlocks(bl, inBlock, block);
      this.loadToolbox(bl, inBlock, block);
      this.loadOverrideToolbox(bl, inBlock, block);
      this.loadCode(bl, inBlock, block);
    }
  }, {
    key: "defaultToolbox",
    get: function get() {
      var tb = {
        categories: [{
          uuid: index_esm["b" /* uuid */].v4(),
          name: 'Logic',
          color: '{!PrimaryColors.Logic}',
          items: [{
            _expanded: false,
            type: 'controls_if',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'logic_compare',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'logic_operation',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'logic_negate',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'logic_boolean',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'math_arithmetic',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'lists_create_empty',
            uuid: index_esm["b" /* uuid */].v4()
          }]
        }, {
          uuid: index_esm["b" /* uuid */].v4(),
          name: 'Loops',
          color: '{!PrimaryColors.Loop}',
          items: [{
            _expanded: false,
            type: 'controls_repeat_ext',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'controls_whileUntil',
            uuid: index_esm["b" /* uuid */].v4()
          }]
        }, {
          uuid: index_esm["b" /* uuid */].v4(),
          name: 'Math',
          color: '{!PrimaryColors.Math}',
          items: [{
            _expanded: false,
            type: 'math_number',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'math_arithmetic',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'math_single',
            uuid: index_esm["b" /* uuid */].v4()
          }]
        }, {
          uuid: index_esm["b" /* uuid */].v4(),
          name: 'Text',
          color: '{!PrimaryColors.Text}',
          items: [{
            _expanded: false,
            type: 'text',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'text_length',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'text_print',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'text_join',
            uuid: index_esm["b" /* uuid */].v4()
          }, {
            _expanded: false,
            type: 'colour_rgb',
            uuid: index_esm["b" /* uuid */].v4()
          }]
        }, {
          uuid: index_esm["b" /* uuid */].v4(),
          name: 'Variables',
          custom: 'VARIABLE',
          color: '{!PrimaryColors.Variable}',
          items: []
        }, {
          uuid: index_esm["b" /* uuid */].v4(),
          name: 'Procedures',
          custom: 'PROCEDURE',
          color: '{!PrimaryColors.Procedure}',
          items: []
        }]
      };
      return tb;
    }
  }]);
  return BlocklyLoadManager;
}();
var blocklyLoader = new BlocklyManager_BlocklyLoadManager();
/* harmony default export */ var BlocklyManager = (function (loaders) {
  loaders[blocklyLoader.blockTag] = blocklyLoader;
});
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlockContainer.vue?vue&type=script&lang=ts&



















var CodeBlockContainervue_type_script_lang_ts_CodeBlocksContainer = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(CodeBlocksContainer, _Vue);
  var _super = Object(createSuper["a" /* default */])(CodeBlocksContainer);
  function CodeBlocksContainer() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, CodeBlocksContainer);
    _this = _super.apply(this, arguments);
    _this.frank = 'hello';
    _this.settingsMenu = false;
    _this.highlighted = false;
    return _this;
  }
  Object(createClass["a" /* default */])(CodeBlocksContainer, [{
    key: "types",
    get: function get() {
      return [{
        label: this.$l('CodeBlockContainer.Canvas'),
        value: ICodeBlocks["c" /* KnownBlockTypes */].PLAYGROUND
      }, {
        label: this.$l('CodeBlockContainer.DataBlock'),
        value: ICodeBlocks["c" /* KnownBlockTypes */].DATA
      }, {
        label: this.$l('CodeBlockContainer.Text'),
        value: ICodeBlocks["c" /* KnownBlockTypes */].TEXT
      }, {
        label: this.$l('CodeBlockContainer.Hidden'),
        value: ICodeBlocks["c" /* KnownBlockTypes */].BLOCKHIDDEN
      }, {
        label: this.$l('CodeBlockContainer.Static'),
        value: ICodeBlocks["c" /* KnownBlockTypes */].BLOCKSTATIC
      }, {
        label: this.$l('CodeBlockContainer.Block'),
        value: ICodeBlocks["c" /* KnownBlockTypes */].BLOCK
      }, {
        label: this.$l('CodeBlockContainer.Blockly'),
        value: ICodeBlocks["c" /* KnownBlockTypes */].BLOCKLY
      }, {
        label: this.$l('CodeBlockContainer.REPL'),
        value: ICodeBlocks["c" /* KnownBlockTypes */].REPL
      }];
    }
  }, {
    key: "alignments",
    get: function get() {
      return [{
        label: this.$l('CodeBlockContainer.Start'),
        value: 'left'
      }, {
        label: this.$l('CodeBlockContainer.Center'),
        value: 'center'
      }, {
        label: this.$l('CodeBlockContainer.End'),
        value: 'right'
      }];
    }
  }, {
    key: "scriptVersions",
    get: function get() {
      return [{
        label: this.$l('CodeBlockContainer.ScriptVersion_1'),
        value: '100'
      }, {
        label: this.$l('CodeBlockContainer.ScriptVersion_2'),
        value: '101'
      }, {
        label: this.$l('CodeBlockContainer.ScriptVersion_3'),
        value: '102'
      }];
    }
  }, {
    key: "positions",
    get: function get() {
      return this.block.appSettings.blocks.map(function (bl) {
        return {
          label: "".concat(bl.id + 1),
          value: "".concat(bl.id)
        };
      });
    }
  }, {
    key: "isDeprecatedScriptVersion",
    get: function get() {
      return this.scriptVersion === '100';
    }
  }, {
    key: "isExperimentalScriptVersion",
    get: function get() {
      return this.scriptVersion === '102';
    }
  }, {
    key: "validNumber",
    value: function validNumber(v) {
      //console.log(v, isNaN(v), v!='auto');
      if (v != 'auto' && isNaN(v)) {
        return "Must be a valid Number or 'auto'.";
      }
      return true;
    }
  }, {
    key: "toggleExpanded",
    value: function toggleExpanded() {
      this.$CodeBlock.refreshAllCodeMirrors();
      this.expanded = !this.expanded;
    }
  }, {
    key: "moveUp",
    value: function moveUp() {
      this.$emit('move-up', this.block.id);
    }
  }, {
    key: "moveDown",
    value: function moveDown() {
      this.$emit('move-down', this.block.id);
    }
  }, {
    key: "order",
    get: function get() {
      return lib["c" /* Vue */].$CodeBlock.itemForValue(this.positions, this.block.id);
    },
    set: function set(val) {
      var data = {
        id: this.block.id,
        newID: +val.value
      };
      this.$emit('change-order', data);
    }
  }, {
    key: "showTypeInfoDialog",
    value: function showTypeInfoDialog() {
      this.$q.dialog({
        title: this.$l('CodeBlockContainer.TypesCaption'),
        message: this.$l('CodeBlockContainer.Types'),
        html: true,
        style: 'width:75%'
      }).onOk(function () {
        // console.log('OK')
      }).onCancel(function () {
        // console.log('Cancel')
      }).onDismiss(function () {
        // console.log('I am triggered on both OK and Cancel')
      });
    }
  }, {
    key: "removeBlock",
    value: function removeBlock() {
      var _this2 = this;
      var self = this;
      self.highlighted = true;
      this.$q.dialog({
        title: this.$l('CodeBlockContainer.Confirm'),
        message: this.$l('CodeBlockContainer.DeleteQuestion'),
        html: true,
        ok: {
          push: true,
          color: 'negative',
          icon: 'warning'
        },
        cancel: {
          push: true,
          color: 'positive'
        },
        persistent: true
      }).onOk(function () {
        _this2.$emit('remove-block', _this2.block.id);
      }).onCancel(function () {}).onDismiss(function () {
        self.highlighted = false;
      });
    }
  }, {
    key: "expanded",
    get: function get() {
      return this.block.expanded;
    },
    set: function set(v) {
      this.block.expanded = v;
    }
  }, {
    key: "canMoveUp",
    get: function get() {
      return this.block.id > 0;
    }
  }, {
    key: "canMoveDown",
    get: function get() {
      return !this.block.isLast;
    }
  }, {
    key: "filteredCopy",
    value: function filteredCopy(objIn) {
      var _this3 = this;
      var extended = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'this';
      var obj = {};
      Object.keys(objIn).filter(function (k) {
        return k.indexOf('appSettings') != 0 && k.indexOf('$') != 0 && k.indexOf('_') != 0 && (!extended || k != 'obj' && k != 'errors' && k != 'content' && k != 'firstLine' && k != 'nextLine' && k != 'lineCount' && k != 'hasCode' && k != 'isLast' && k != 'readyCount' && k != 'noContent' && (_this3.block.type === ICodeBlocks["c" /* KnownBlockTypes */].BLOCKLY || k != 'blockly')) && k != 'uuid' && k != 'scopeUUID' && k != 'scopeSelector';
      }).forEach(function (k) {
        var v = objIn[k];
        if (v !== undefined && v !== null && Object(esm_typeof["a" /* default */])(v) === 'object') {
          if (Array.isArray(v)) {
            v = v.map(function (item, nr) {
              return _this3.filteredCopy(item, false, path + '.' + k + "[".concat(nr, "]"));
            });
          } else {
            v = _this3.filteredCopy(v, false, path + '.' + k);
          }
        }
        obj[k] = v;
      });
      return obj;
    }
  }, {
    key: "serializedOptions",
    get: function get() {
      return JSON.stringify(this.filteredCopy(this.block));
    },
    set: function set(v) {}
  }, {
    key: "hasExtendedSettings",
    get: function get() {
      return this.type == ICodeBlocks["c" /* KnownBlockTypes */].PLAYGROUND || this.type == ICodeBlocks["c" /* KnownBlockTypes */].BLOCK || this.type == ICodeBlocks["c" /* KnownBlockTypes */].BLOCKLY;
    }
  }, {
    key: "isVersionedPlayground",
    get: function get() {
      return this.type == ICodeBlocks["c" /* KnownBlockTypes */].PLAYGROUND;
    }
  }, {
    key: "canSetLineNumbers",
    get: function get() {
      return this.type == ICodeBlocks["c" /* KnownBlockTypes */].BLOCK;
    }
  }, {
    key: "canHaveAlternativeContent",
    get: function get() {
      return this.type == ICodeBlocks["c" /* KnownBlockTypes */].BLOCK;
    }
  }, {
    key: "canDefinePlacement",
    get: function get() {
      return this.type == ICodeBlocks["c" /* KnownBlockTypes */].PLAYGROUND || this.type == ICodeBlocks["c" /* KnownBlockTypes */].BLOCKLY;
    }
  }, {
    key: "shouldAutoReset",
    get: function get() {
      return this.block.shouldAutoreset;
    },
    set: function set(v) {
      this.$emit('auto-reset-change', {
        shouldAutoreset: v,
        id: this.block.id
      });
    }
  }, {
    key: "shouldReloadResources",
    get: function get() {
      return this.block.shouldReloadResources;
    },
    set: function set(v) {
      var data = {
        shouldReloadResources: v,
        id: this.block.id
      };
      this.$emit('reload-resources-change', data);
    }
  }, {
    key: "shouldGenerateTemplate",
    get: function get() {
      return this.block.generateTemplate;
    },
    set: function set(v) {
      this.$emit('generate-template-change', {
        generateTemplate: v,
        id: this.block.id
      });
    }
  }, {
    key: "scriptVersion",
    get: function get() {
      if (this.block === undefined || this.block.version === undefined || this.block.version == '') {
        return '100';
      }
      return this.block.version;
    }
  }, {
    key: "scriptVersionObj",
    get: function get() {
      return lib["c" /* Vue */].$CodeBlock.itemForValue(this.scriptVersions, this.scriptVersion);
    },
    set: function set(v) {
      this.$emit('script-version-change', {
        version: v.value,
        id: this.block.id
      });
    }
  }, {
    key: "canLoadResources",
    get: function get() {
      return +this.scriptVersion > 100;
    }
  }, {
    key: "hasAltComntent",
    get: function get() {
      return this.block.hasAlternativeContent;
    },
    set: function set(v) {
      if (v != this.block.hasAlternativeContent && v) {
        this.$nextTick(function () {
          setTimeout(function () {
            $('.CodeMirror').toArray().forEach(function (cm) {
              var element = cm;
              element.CodeMirror.refresh();
            });
          }, 200);
        });
      }
      this.block.hasAlternativeContent = v;
    }
  }, {
    key: "colorClass",
    get: function get() {
      var t = this.type;
      if (t == ICodeBlocks["c" /* KnownBlockTypes */].TEXT) {
        return 'text-border';
      } else if (t == ICodeBlocks["c" /* KnownBlockTypes */].PLAYGROUND) {
        return 'playground-border';
      } else if (t == ICodeBlocks["c" /* KnownBlockTypes */].DATA) {
        return 'data-border';
      } else if (t == ICodeBlocks["c" /* KnownBlockTypes */].BLOCK) {
        return 'block-border';
      } else if (t == ICodeBlocks["c" /* KnownBlockTypes */].BLOCKHIDDEN) {
        return 'block-hidden-border';
      } else if (t == ICodeBlocks["c" /* KnownBlockTypes */].BLOCKSTATIC) {
        return 'block-static-border';
      } else if (t == ICodeBlocks["c" /* KnownBlockTypes */].REPL) {
        return 'repl-border';
      }
      return 'default-border';
    }
  }, {
    key: "bgClass",
    get: function get() {
      if (this.highlighted) {
        return 'highlightedCard';
      }
      return '';
    }
  }, {
    key: "type",
    get: function get() {
      if (this.block.type == ICodeBlocks["c" /* KnownBlockTypes */].BLOCK) {
        if (this.block.hidden) {
          return ICodeBlocks["c" /* KnownBlockTypes */].BLOCKHIDDEN;
        }
        if (this.block.static) {
          return ICodeBlocks["c" /* KnownBlockTypes */].BLOCKSTATIC;
        }
      }
      return this.block.type;
    }
  }, {
    key: "typeObj",
    get: function get() {
      return lib["c" /* Vue */].$CodeBlock.itemForValue(this.types, this.type);
    },
    set: function set(val) {
      var v = val.value;
      var ret = {
        type: v.match(/([^-]*)/)[0],
        hidden: v == ICodeBlocks["c" /* KnownBlockTypes */].BLOCKHIDDEN,
        static: v == ICodeBlocks["c" /* KnownBlockTypes */].BLOCKSTATIC,
        id: this.block.id,
        hasCode: false
      };
      ret.hasCode = ret.type == ICodeBlocks["c" /* KnownBlockTypes */].BLOCK;
      if (ret.type == ICodeBlocks["c" /* KnownBlockTypes */].PLAYGROUND && this.block.content === '' && this.editMode) {
        if (this.block.scriptVersion == '100') {
          this.block.content = '{\n    init: function(canvasElement) {\n\n    },\n    update: function(output, canvasElement) {\n\n    }\n}';
        } else {
          this.block.content = '{\n    init: function(canvasElement, outputElement, scope, runner) {\n\n    },\n    addArgumentsTo(args) {},\n    reset(canvasElement) {},\n    update: function(txt, json, canvasElement, outputElement) {\n\n    }\n}';
        }
      } else if (ret.type == ICodeBlocks["c" /* KnownBlockTypes */].BLOCKLY && this.block.blockly.toolbox.categories.length === 0 && this.editMode) {
        this.block.blockly.toolbox = blocklyLoader.defaultToolbox;
      }
      this.$emit('type-change', ret);
    }
  }, {
    key: "visibleLines",
    get: function get() {
      var v = this.block.visibleLines;
      if (v == 'auto' || isNaN(v)) {
        return 'auto';
      }
      return v;
    },
    set: function set(v) {
      if (v == 'auto' || isNaN(v)) {
        v = 'auto';
      }
      console.log('set', v);
      this.$emit('visible-lines-change', {
        visibleLines: v,
        id: this.block.id
      });
    }
  }, {
    key: "width",
    get: function get() {
      return this.block.width;
    },
    set: function set(v) {
      this.$emit('placement-change', {
        width: v,
        height: this.block.height,
        align: this.block.align,
        id: this.block.id
      });
    }
  }, {
    key: "height",
    get: function get() {
      return this.block.height;
    },
    set: function set(v) {
      this.$emit('placement-change', {
        width: this.block.width,
        height: v,
        align: this.block.align,
        id: this.block.id
      });
    }
  }, {
    key: "align",
    get: function get() {
      return lib["c" /* Vue */].$CodeBlock.itemForValue(this.alignments, this.block.align);
    },
    set: function set(v) {
      this.$emit('placement-change', {
        width: this.block.width,
        height: this.block.height,
        align: v.value,
        id: this.block.id
      });
    }
  }]);
  return CodeBlocksContainer;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodeBlockContainervue_type_script_lang_ts_CodeBlocksContainer.prototype, "block", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], CodeBlockContainervue_type_script_lang_ts_CodeBlocksContainer.prototype, "editMode", void 0);
CodeBlockContainervue_type_script_lang_ts_CodeBlocksContainer = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], CodeBlockContainervue_type_script_lang_ts_CodeBlocksContainer);
/* harmony default export */ var CodeBlockContainervue_type_script_lang_ts_ = (CodeBlockContainervue_type_script_lang_ts_CodeBlocksContainer);
// CONCATENATED MODULE: ./src/components/CodeBlockContainer.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_CodeBlockContainervue_type_script_lang_ts_ = (CodeBlockContainervue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/CodeBlockContainer.vue?vue&type=style&index=0&id=6bc47167&prod&lang=sass&
var CodeBlockContainervue_type_style_index_0_id_6bc47167_prod_lang_sass_ = __webpack_require__("fc0f");

// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__("2877");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/select/QSelect.js + 3 modules
var QSelect = __webpack_require__("ddd8");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/menu/QMenu.js + 2 modules
var QMenu = __webpack_require__("4e73");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/anchor.js
var mixins_anchor = __webpack_require__("c474");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/popup-proxy/QPopupProxy.js











/* harmony default export */ var QPopupProxy = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QPopupProxy',
  mixins: [mixins_attrs["b" /* default */], listeners["a" /* default */], mixins_anchor["a" /* default */]],
  props: {
    breakpoint: {
      type: [String, Number],
      default: 450
    }
  },
  data: function data() {
    var breakpoint = parseInt(this.breakpoint, 10);
    return {
      type: this.$q.screen.width < breakpoint || this.$q.screen.height < breakpoint ? 'dialog' : 'menu'
    };
  },
  computed: {
    parsedBreakpoint: function parsedBreakpoint() {
      return parseInt(this.breakpoint, 10);
    },
    onEvents: function onEvents() {
      return Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, this.qListeners), {}, {
        hide: this.__onHide
      });
    }
  },
  watch: {
    '$q.screen.width': function $qScreenWidth(width) {
      if (this.$refs.popup.showing !== true) {
        this.__updateType(width, this.$q.screen.height, this.parsedBreakpoint);
      }
    },
    '$q.screen.height': function $qScreenHeight(height) {
      if (this.$refs.popup.showing !== true) {
        this.__updateType(this.$q.screen.width, height, this.parsedBreakpoint);
      }
    },
    breakpoint: function breakpoint(_breakpoint) {
      if (this.$refs.popup.showing !== true) {
        this.__updateType(this.$q.screen.width, this.$q.screen.height, parseInt(_breakpoint, 10));
      }
    }
  },
  methods: {
    toggle: function toggle(evt) {
      this.$refs.popup.toggle(evt);
    },
    show: function show(evt) {
      this.$refs.popup.show(evt);
    },
    hide: function hide(evt) {
      this.$refs.popup.hide(evt);
    },
    __onHide: function __onHide(evt) {
      this.__updateType(this.$q.screen.width, this.$q.screen.height, this.parsedBreakpoint);
      this.$emit('hide', evt);
    },
    __updateType: function __updateType(width, height, breakpoint) {
      var type = width < breakpoint || height < breakpoint ? 'dialog' : 'menu';
      if (this.type !== type) {
        this.type = type;
      }
    }
  },
  render: function render(h) {
    var def = Object(slot["c" /* slot */])(this, 'default');
    var props = this.type === 'menu' && def !== void 0 && def[0] !== void 0 && def[0].componentOptions !== void 0 && def[0].componentOptions.Ctor !== void 0 && def[0].componentOptions.Ctor.sealedOptions !== void 0 && ['QDate', 'QTime', 'QCarousel', 'QColor'].includes(def[0].componentOptions.Ctor.sealedOptions.name) ? {
      cover: true,
      maxHeight: '99vh'
    } : {};
    var data = {
      ref: 'popup',
      props: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, props), this.qAttrs),
      on: this.onEvents
    };
    var component;
    if (this.type === 'dialog') {
      component = QDialog["a" /* default */];
    } else {
      component = QMenu["a" /* default */];
      data.props.target = this.target;
      data.props.contextMenu = this.contextMenu;
      data.props.noParentEvent = true;
      data.props.separateClosePopup = true;
    }
    return h(component, data, def);
  }
}));
// EXTERNAL MODULE: ./node_modules/quasar/src/components/slide-transition/QSlideTransition.js
var QSlideTransition = __webpack_require__("e9c1");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/banner/QBanner.js
var QBanner = __webpack_require__("54e1");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/item/QItem.js
var QItem = __webpack_require__("66e5");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/item/QItemSection.js
var QItemSection = __webpack_require__("4074");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/item/QItemLabel.js
var QItemLabel = __webpack_require__("0170");

// EXTERNAL MODULE: ./node_modules/vue-cli-plugin-quasar/lib/runtime.auto-import.js
var runtime_auto_import = __webpack_require__("93dc");
var runtime_auto_import_default = /*#__PURE__*/__webpack_require__.n(runtime_auto_import);

// CONCATENATED MODULE: ./src/components/CodeBlockContainer.vue






/* normalize component */

var CodeBlockContainer_component = Object(componentNormalizer["a" /* default */])(
  components_CodeBlockContainervue_type_script_lang_ts_,
  CodeBlockContainervue_type_template_id_6bc47167_render,
  CodeBlockContainervue_type_template_id_6bc47167_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var CodeBlockContainer = (CodeBlockContainer_component.exports);














runtime_auto_import_default()(CodeBlockContainer_component, 'components', {QCard: QCard["a" /* default */],QCardSection: QCardSection["a" /* default */],QSelect: QSelect["a" /* default */],QBtn: QBtn["a" /* default */],QPopupProxy: QPopupProxy,QInput: QInput["a" /* default */],QToggle: QToggle["a" /* default */],QSlideTransition: QSlideTransition["a" /* default */],QBanner: QBanner["a" /* default */],QItem: QItem["a" /* default */],QItemSection: QItemSection["a" /* default */],QIcon: QIcon["a" /* default */],QItemLabel: QItemLabel["a" /* default */]});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlocksSettings.vue?vue&type=template&id=644cb51f&scoped=true&

var CodeBlocksSettingsvue_type_template_id_644cb51f_scoped_true_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', {
    staticClass: "row q-pa-none q-mb-md"
  }, [_c('div', {
    staticClass: "col-xs-12 col-sm-12 col-md-6"
  }, [_c('q-card', {
    staticClass: "q-mb-sm q-mr-sm-none q-mr-md-sm"
  }, [_c('q-card-section', {
    staticClass: "text-overline"
  }, [_vm._v(_vm._s(_vm.$t('CodeBlocksSettings.Language')))]), _c('q-card-section', {
    staticClass: "q-ml-md"
  }, [_c('div', {
    staticClass: "row"
  }, [_c('div', {
    staticClass: "col-12"
  }, [_c('q-toggle', {
    attrs: {
      "disabled": !_vm.languageHasCompiler,
      "label": _vm.$t('CodeBlocksSettings.AllowExec')
    },
    model: {
      value: _vm.runCode,
      callback: function callback($$v) {
        _vm.runCode = $$v;
      },
      expression: "runCode"
    }
  })], 1), _c('div', {
    staticClass: "col-12"
  }, [_c('q-toggle', {
    attrs: {
      "disabled": !_vm.canContinousCompile,
      "label": _vm.$t('CodeBlocksSettings.ContinousCompile')
    },
    model: {
      value: _vm.continuousCompile,
      callback: function callback($$v) {
        _vm.continuousCompile = $$v;
      },
      expression: "continuousCompile"
    }
  })], 1), _c('div', {
    class: "col-xs-12 col-sm-".concat(_vm.runCode ? 6 : 12, " col-md-").concat(_vm.runCode ? 8 : 12, " ").concat(_vm.runCode ? 'q-pr-md-sm' : '')
  }, [_c('q-select', {
    attrs: {
      "options": _vm.compiledLanguages,
      "label": _vm.$t('CodeBlocksSettings.Language')
    },
    model: {
      value: _vm.compilerLanguageObj,
      callback: function callback($$v) {
        _vm.compilerLanguageObj = $$v;
      },
      expression: "compilerLanguageObj"
    }
  })], 1), _vm.runCode ? _c('div', {
    staticClass: "col-xs-12 col-sm-12 col-md-6"
  }, [_c('q-select', {
    attrs: {
      "options": _vm.compilerVersions,
      "stack-label": "",
      "label": _vm.$t('CodeBlocksSettings.CVersion')
    },
    scopedSlots: _vm._u([{
      key: "selected",
      fn: function fn() {
        return [_vm._v(" " + _vm._s(_vm.compilerVersion) + " "), _vm.isDeprecated ? _c('q-avatar', {
          staticClass: "q-ml-xs",
          attrs: {
            "rounded": "",
            "size": "xs",
            "color": "yellow",
            "text-color": "brown-10",
            "icon": "hourglass_disabled"
          }
        }) : _vm._e(), _vm.isExperimental ? _c('q-avatar', {
          staticClass: "q-ml-xs",
          attrs: {
            "rounded": "",
            "size": "xs",
            "color": "orange",
            "text-color": "white",
            "icon": "whatshot"
          }
        }) : _vm._e()];
      },
      proxy: true
    }, {
      key: "option",
      fn: function fn(scope) {
        return [_c('q-item', _vm._g(_vm._b({}, 'q-item', scope.itemProps, false), scope.itemEvents), [_c('q-item-section', [_c('q-item-label', [_vm._v(" " + _vm._s(scope.opt) + " "), _vm.isDeprecatedVersion(_vm.compilerLanguage, scope.opt) ? _c('q-avatar', {
          staticClass: "q-ml-xs",
          attrs: {
            "rounded": "",
            "size": "xs",
            "color": "yellow",
            "text-color": "brown-10",
            "icon": "hourglass_disabled"
          }
        }) : _vm._e(), _vm.isExperimentalVersion(_vm.compilerLanguage, scope.opt) ? _c('q-avatar', {
          staticClass: "q-ml-xs",
          attrs: {
            "rounded": "",
            "size": "xs",
            "color": "orange",
            "text-color": "white",
            "icon": "whatshot"
          }
        }) : _vm._e()], 1)], 1)], 1)];
      }
    }], null, false, 541447989),
    model: {
      value: _vm.compilerVersion,
      callback: function callback($$v) {
        _vm.compilerVersion = $$v;
      },
      expression: "compilerVersion"
    }
  })], 1) : _vm._e(), _c('q-slide-transition', [_vm.isExperimental ? _c('q-banner', {
    staticClass: "bg-orange text-white col-12 q-mt-xs q-mb-md",
    attrs: {
      "rounded": "",
      "dense": ""
    }
  }, [_c('q-item', [_c('q-item-section', {
    attrs: {
      "avatar": ""
    }
  }, [_c('q-icon', {
    staticStyle: {
      "font-size": "3em"
    },
    attrs: {
      "name": "whatshot"
    }
  })], 1), _c('q-item-section', [_c('q-item-label', {
    attrs: {
      "overline": ""
    }
  }, [_vm._v(" " + _vm._s(_vm.$t('CodeBlocksSettings.ExperimentalCompiler')) + " ")]), _c('q-item-label', [_vm._v(" " + _vm._s(_vm.$t('CodeBlocksSettings.ExperimentalCompilerDesc')) + " ")])], 1)], 1)], 1) : _vm._e()], 1), _c('q-slide-transition', [_vm.isDeprecated ? _c('q-banner', {
    staticClass: "bg-yellow-12 text-black col-12 q-mt-xs q-mb-md",
    attrs: {
      "rounded": "",
      "dense": ""
    }
  }, [_c('q-item', [_c('q-item-section', {
    attrs: {
      "avatar": ""
    }
  }, [_c('q-icon', {
    staticStyle: {
      "font-size": "3em"
    },
    attrs: {
      "name": "hourglass_disabled"
    }
  })], 1), _c('q-item-section', [_c('q-item-label', {
    attrs: {
      "overline": ""
    }
  }, [_vm._v(" " + _vm._s(_vm.$t('CodeBlocksSettings.DeprecatedCompiler')) + " ")]), _c('q-item-label', [_vm._v(" " + _vm._s(_vm.$t('CodeBlocksSettings.DeprecatedCompilerDesc')) + " ")])], 1)], 1)], 1) : _vm._e()], 1), _vm.showMaxRuntime ? _c('div', {
    staticClass: "col-12"
  }, [_c('q-input', {
    attrs: {
      "rules": [_vm.validNumber],
      "label": _vm.$t('CodeBlocksSettings.RunTime'),
      "maxlength": "6"
    },
    model: {
      value: _vm.maxRuntime,
      callback: function callback($$v) {
        _vm.maxRuntime = $$v;
      },
      expression: "maxRuntime"
    }
  })], 1) : _vm._e(), _vm.runCode && (_vm.accepstArguments || _vm.allowsMessagePassing) ? _c('div', {
    staticClass: "col-12 text-body2"
  }, [_vm._v(" " + _vm._s(_vm.$t('CodeBlocksSettings.AllowArguments')) + " "), _c('q-btn', {
    attrs: {
      "flat": "",
      "round": "",
      "color": "primary",
      "icon": "info",
      "size": "xs"
    },
    on: {
      "click": _vm.showArgsInfoDialog
    }
  })], 1) : _vm._e(), _vm.runCode && _vm.accepstArguments ? _c('div', {
    staticClass: "col-12"
  }, [_c('q-toggle', {
    attrs: {
      "disabled": !_vm.canPersistentArguments,
      "label": _vm.$t('CodeBlocksSettings.PersistentArguments')
    },
    model: {
      value: _vm.persistentArguments,
      callback: function callback($$v) {
        _vm.persistentArguments = $$v;
      },
      expression: "persistentArguments"
    }
  }), _c('q-btn', {
    attrs: {
      "flat": "",
      "round": "",
      "color": "primary",
      "icon": "info",
      "size": "xs"
    },
    on: {
      "click": _vm.showPersistentArgsInfoDialog
    }
  })], 1) : _vm._e(), _vm.runCode && _vm.allowsMessagePassing ? _c('div', {
    staticClass: "col-12"
  }, [_c('q-toggle', {
    attrs: {
      "disabled": !_vm.allowsMessagePassing,
      "label": _vm.$t('CodeBlocksSettings.MessagePassing')
    },
    model: {
      value: _vm.messagePassing,
      callback: function callback($$v) {
        _vm.messagePassing = $$v;
      },
      expression: "messagePassing"
    }
  }), _c('q-btn', {
    attrs: {
      "flat": "",
      "round": "",
      "color": "primary",
      "icon": "info",
      "size": "xs"
    },
    on: {
      "click": _vm.showMessagesInfoDialog
    }
  })], 1) : _vm._e(), _vm.runCode && _vm.allowsMessagePassing ? _c('div', {
    staticClass: "col-12 q-pl-lg"
  }, [_c('q-toggle', {
    attrs: {
      "disabled": !_vm.allowsMessagePassing || !_vm.messagePassing,
      "label": _vm.$t('CodeBlocksSettings.KeepAlive')
    },
    model: {
      value: _vm.keepAlive,
      callback: function callback($$v) {
        _vm.keepAlive = $$v;
      },
      expression: "keepAlive"
    }
  }), _c('q-btn', {
    attrs: {
      "flat": "",
      "round": "",
      "color": "primary",
      "icon": "info",
      "size": "xs"
    },
    on: {
      "click": _vm.showAliveInfoDialog
    }
  })], 1) : _vm._e()], 1)])], 1)], 1), _c('div', {
    staticClass: "col-xs-12 col-sm-12 col-md-6"
  }, [_c('q-slide-transition', [_vm.runCode ? _c('q-card', {
    staticClass: "q-mb-sm q-mr-none"
  }, [_c('q-card-section', {
    staticClass: "text-overline"
  }, [_vm._v(_vm._s(_vm.$t('CodeBlocksSettings.Output')))]), _c('q-card-section', {
    staticClass: "q-ml-md"
  }, [_c('div', {
    staticClass: "row"
  }, [_c('div', {
    staticClass: "col-xs-12 col-md-6 col-12 q-pr-md-sm"
  }, [_c('q-input', {
    attrs: {
      "rules": [_vm.validNumber],
      "label": _vm.$t('CodeBlocksSettings.MaxCharacters'),
      "maxlength": "6"
    },
    model: {
      value: _vm.maxCharacters,
      callback: function callback($$v) {
        _vm.maxCharacters = $$v;
      },
      expression: "maxCharacters"
    }
  })], 1), _c('div', {
    staticClass: "col-xs-12 col-md-6"
  }, [_c('q-select', {
    attrs: {
      "options": _vm.outputParsers,
      "label": _vm.$t('CodeBlocksSettings.Parser')
    },
    model: {
      value: _vm.outputParser,
      callback: function callback($$v) {
        _vm.outputParser = $$v;
      },
      expression: "outputParser"
    }
  })], 1)])])], 1) : _vm._e()], 1), _c('q-card', {
    staticClass: "q-mr-none"
  }, [_c('q-card-section', {
    staticClass: "text-overline"
  }, [_vm._v(_vm._s(_vm.$t('CodeBlocksSettings.Themes')))]), _c('q-card-section', {
    staticClass: "q-ml-md"
  }, [_c('div', {
    staticClass: "row",
    attrs: {
      "dense": ""
    }
  }, [_c('div', {
    staticClass: "col-xs-12 col-md-6 q-pr-md-sm"
  }, [_c('q-select', {
    attrs: {
      "options": _vm.themes,
      "label": _vm.$t('CodeBlocksSettings.TGeneral')
    },
    model: {
      value: _vm.codeTheme,
      callback: function callback($$v) {
        _vm.codeTheme = $$v;
      },
      expression: "codeTheme"
    }
  })], 1), _c('div', {
    staticClass: "col-xs-12 col-md-6"
  }, [_c('q-select', {
    attrs: {
      "options": _vm.themes,
      "label": _vm.$t('CodeBlocksSettings.TSolution')
    },
    model: {
      value: _vm.solutionTheme,
      callback: function callback($$v) {
        _vm.solutionTheme = $$v;
      },
      expression: "solutionTheme"
    }
  })], 1)])])], 1), _c('q-slide-transition', [_c('q-card', {
    staticClass: "q-mr-sm-none q-mt-sm"
  }, [_c('q-card-section', {
    staticClass: "text-overline"
  }, [_vm._v(_vm._s(_vm.$t('CodeBlocksSettings.Libraries')))]), _c('q-card-section', {
    staticClass: "q-ml-md"
  }, [_c('div', {
    staticClass: "row q-my-none q-py-none",
    attrs: {
      "dense": ""
    }
  }, [_c('div', {
    staticClass: "col-xs-12 col-sm-12 q-my-none q-py-none"
  }, [_c('q-select', {
    attrs: {
      "options": _vm.domLibraries,
      "multiple": "",
      "use-chips": "",
      "stack-label": "",
      "deletable-chips": "",
      "label": _vm.$t('CodeBlocksSettings.DomLibs')
    },
    model: {
      value: _vm.domLibrary,
      callback: function callback($$v) {
        _vm.domLibrary = $$v;
      },
      expression: "domLibrary"
    }
  })], 1), _vm.runCode && _vm.workerLibraries.length > 0 ? _c('div', {
    staticClass: "col-xs-12 col-sm-12 q-my-none q-py-none"
  }, [_c('q-select', {
    attrs: {
      "options": _vm.workerLibraries,
      "multiple": "",
      "use-chips": "",
      "stack-label": "",
      "deletable-chips": "",
      "label": _vm.$t('CodeBlocksSettings.WorkLibs')
    },
    model: {
      value: _vm.workerLibrary,
      callback: function callback($$v) {
        _vm.workerLibrary = $$v;
      },
      expression: "workerLibrary"
    }
  })], 1) : _vm._e()])])], 1)], 1)], 1), _c('div', {
    class: "col-xs-".concat(_vm.options.randomizer.active ? '12' : '12', " q-mt-sm")
  }, [_c('RandomizerSettings', {
    attrs: {
      "options": _vm.options
    }
  })], 1), _c('div', {
    staticClass: "col-xs-12"
  }, [_c('textarea', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: _vm.serializedOptions,
      expression: "serializedOptions"
    }],
    staticClass: "blocksettings",
    attrs: {
      "name": "block_settings[".concat(this.options.id, "]")
    },
    domProps: {
      "value": _vm.serializedOptions
    },
    on: {
      "input": function input($event) {
        if ($event.target.composing) return;
        _vm.serializedOptions = $event.target.value;
      }
    }
  })])]);
};
var CodeBlocksSettingsvue_type_template_id_644cb51f_scoped_true_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/CodeBlocksSettings.vue?vue&type=template&id=644cb51f&scoped=true&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/RandomizerSettings.vue?vue&type=template&id=8b99c0d6&scoped=true&




var RandomizerSettingsvue_type_template_id_8b99c0d6_scoped_true_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', [_c('q-card', [_c('q-card-section', {
    staticClass: "text-overline"
  }, [_vm._v(_vm._s(_vm.$t('RandomizerSettings.Caption')) + " "), _c('q-toggle', {
    model: {
      value: _vm.options.randomizer.active,
      callback: function callback($$v) {
        _vm.$set(_vm.options.randomizer, "active", $$v);
      },
      expression: "options.randomizer.active"
    }
  })], 1), _c('q-slide-transition', [_c('q-card-section', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.options.randomizer.active,
      expression: "options.randomizer.active"
    }],
    staticClass: "q-ml-md"
  }, [_c('div', {
    staticClass: "tagList"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$t('RandomizerSettings.Available')) + " "), _c('q-btn', {
    staticClass: "gt-xs",
    attrs: {
      "color": "primary",
      "size": "12px",
      "flat": "",
      "dense": "",
      "round": "",
      "icon": "add"
    },
    on: {
      "click": _vm.addTag
    }
  })], 1), _c('div', {
    staticClass: "row q-mb-sm"
  }, _vm._l(_vm.options.randomizer.knownTags, function (tag, i) {
    return _c('div', {
      key: tag,
      class: "tagItem q-ml-sm ".concat(_vm.tagClass)
    }, [_c('div', {
      staticClass: "row no-wrap"
    }, [_c('div', {
      staticClass: "tagInfo col-shrink"
    }, [_c('div', {
      staticClass: "tagName"
    }, [_vm._v(_vm._s(tag))]), _c('div', {
      staticClass: "tagString"
    }, [_vm._v("{:" + _vm._s(tag) + "}")])]), _c('div', {
      staticClass: "tagAction col-4 q-pl-sm text-right"
    }, [_c('q-btn', {
      staticClass: "gt-xs",
      attrs: {
        "size": "12px",
        "flat": "",
        "dense": "",
        "round": "",
        "icon": "delete"
      },
      on: {
        "click": function click($event) {
          return _vm.removeTag(i);
        }
      }
    })], 1)])]);
  }), 0)]), _c('div', {
    staticClass: "tagList q-mt-lg"
  }, [_c('div', {
    staticClass: "text-subtitle2"
  }, [_vm._v(" " + _vm._s(_vm.$t('RandomizerSettings.Sets')) + " "), _c('q-btn', {
    staticClass: "gt-xs",
    attrs: {
      "color": "primary",
      "size": "12px",
      "flat": "",
      "dense": "",
      "round": "",
      "icon": "add"
    },
    on: {
      "click": _vm.addSet
    }
  })], 1), _c('q-list', {
    staticClass: "setList"
  }, _vm._l(_vm.options.randomizer.sets, function (s, i) {
    return _c('q-item', {
      key: s.uuid
    }, [_c('q-item-section', {
      attrs: {
        "avatar": ""
      }
    }, [_c('q-avatar', {
      attrs: {
        "color": "primary",
        "text-color": "white",
        "disabled": !_vm.isVisible(i)
      }
    }, [_vm._v(" " + _vm._s(i) + " ")])], 1), _c('q-item-section', [_c('q-item-label', [_vm._v(_vm._s(s.title))]), _c('q-item-label', {
      attrs: {
        "caption": "",
        "lines": "2"
      }
    }, [_c('div', {
      staticClass: "row q-mb-sm"
    }, _vm._l(s.values, function (tag) {
      return _c('div', {
        key: tag.name,
        class: "tagItem q-ml-sm ".concat(_vm.tagClass)
      }, [_c('div', {
        staticClass: "row no-wrap"
      }, [_c('div', {
        staticClass: "tagInfo col-shrink"
      }, [_c('div', {
        staticClass: "tagName"
      }, [_vm._v(_vm._s(tag.tag))]), _c('div', {
        staticClass: "tagString"
      }, [_vm._v(_vm._s(tag.value))])])])]);
    }), 0)])], 1), _c('q-item-section', {
      attrs: {
        "side": "",
        "top": ""
      }
    }, [_c('div', {
      staticClass: "text-grey-8 q-gutter-xs"
    }, [_c('q-icon', {
      staticClass: "q-mr-lg",
      attrs: {
        "name": _vm.isCompleteSet(s) ? 'check' : 'warning',
        "color": _vm.isCompleteSet(s) ? 'positive' : 'negative',
        "size": "24px"
      }
    }), _c('q-btn', {
      staticClass: "gt-xs",
      attrs: {
        "size": "12px",
        "flat": "",
        "dense": "",
        "round": "",
        "icon": _vm.isVisible(i) ? 'visibility' : 'visibility_off'
      },
      on: {
        "click": function click($event) {
          return _vm.setVisible(i);
        }
      }
    }, [_c('q-tooltip', {
      attrs: {
        "delay": 200,
        "offset": [0, 10]
      }
    }, [_vm._v(" Use this set when running code in preview or editMode. ")])], 1), _c('q-btn', {
      staticClass: "gt-xs",
      attrs: {
        "size": "12px",
        "flat": "",
        "dense": "",
        "round": "",
        "icon": "edit"
      }
    }, [_c('RandomizerSetEditor', {
      attrs: {
        "options": _vm.options,
        "tagSet": _vm.getFullSet(s),
        "nr": i
      }
    })], 1), _c('q-btn', {
      staticClass: "gt-xs",
      attrs: {
        "size": "12px",
        "flat": "",
        "dense": "",
        "round": "",
        "icon": "delete"
      },
      on: {
        "click": function click($event) {
          return _vm.removeSet(i);
        }
      }
    })], 1)])], 1);
  }), 1)], 1)])], 1)], 1)], 1);
};
var RandomizerSettingsvue_type_template_id_8b99c0d6_scoped_true_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/RandomizerSettings.vue?vue&type=template&id=8b99c0d6&scoped=true&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/RandomizerSetEditor.vue?vue&type=template&id=7b045cf1&



var RandomizerSetEditorvue_type_template_id_7b045cf1_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('q-popup-proxy', {
    attrs: {
      "transition-show": "flip-up",
      "transition-hide": "flip-down"
    },
    on: {
      "before-show": _vm.onShow
    }
  }, [_c('div', {
    staticClass: "q-pa-md"
  }, [_c('div', {
    staticClass: "row no-wrap q-pt-none q-pb-md"
  }, [_c('div', {
    staticClass: "text-overline"
  }, [_vm._v(_vm._s(_vm.$t('RandomizerSetEditor.Caption', {
    nr: _vm.nr
  })))])]), _vm._l(_vm.tagSet.values, function (tag) {
    return _c('div', {
      key: tag.tag,
      staticClass: "q-pl-md"
    }, [_c('q-input', {
      attrs: {
        "label": tag.tag
      },
      model: {
        value: tag.value,
        callback: function callback($$v) {
          _vm.$set(tag, "value", $$v);
        },
        expression: "tag.value"
      }
    })], 1);
  })], 2)]);
};
var RandomizerSetEditorvue_type_template_id_7b045cf1_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/RandomizerSetEditor.vue?vue&type=template&id=7b045cf1&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/RandomizerSetEditor.vue?vue&type=script&lang=ts&















var RandomizerSetEditorvue_type_script_lang_ts_RandomizerSetEditor = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(RandomizerSetEditor, _Vue);
  var _super = Object(createSuper["a" /* default */])(RandomizerSetEditor);
  function RandomizerSetEditor() {
    Object(classCallCheck["a" /* default */])(this, RandomizerSetEditor);
    return _super.apply(this, arguments);
  }
  Object(createClass["a" /* default */])(RandomizerSetEditor, [{
    key: "tags",
    get: function get() {
      return this.tagSet.values.map(function (v) {
        return v.tag;
      });
    }
  }, {
    key: "onShow",
    value: function onShow(o) {
      var _this = this;
      this.tagSet.values = this.tagSet.values.filter(function (v) {
        return _this.options.randomizer.knownTags.indexOf(v.tag) >= 0;
      });
      this.options.randomizer.knownTags.forEach(function (t) {
        if (_this.tagSet.values.find(function (v) {
          return v.tag == t;
        }) === undefined) {
          _this.tagSet.values.push({
            tag: t,
            value: ''
          });
        }
      });
    }
  }]);
  return RandomizerSetEditor;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], RandomizerSetEditorvue_type_script_lang_ts_RandomizerSetEditor.prototype, "options", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], RandomizerSetEditorvue_type_script_lang_ts_RandomizerSetEditor.prototype, "tagSet", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], RandomizerSetEditorvue_type_script_lang_ts_RandomizerSetEditor.prototype, "nr", void 0);
RandomizerSetEditorvue_type_script_lang_ts_RandomizerSetEditor = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], RandomizerSetEditorvue_type_script_lang_ts_RandomizerSetEditor);
/* harmony default export */ var RandomizerSetEditorvue_type_script_lang_ts_ = (RandomizerSetEditorvue_type_script_lang_ts_RandomizerSetEditor);
// CONCATENATED MODULE: ./src/components/RandomizerSetEditor.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_RandomizerSetEditorvue_type_script_lang_ts_ = (RandomizerSetEditorvue_type_script_lang_ts_); 
// CONCATENATED MODULE: ./src/components/RandomizerSetEditor.vue





/* normalize component */

var RandomizerSetEditor_component = Object(componentNormalizer["a" /* default */])(
  components_RandomizerSetEditorvue_type_script_lang_ts_,
  RandomizerSetEditorvue_type_template_id_7b045cf1_render,
  RandomizerSetEditorvue_type_template_id_7b045cf1_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var components_RandomizerSetEditor = (RandomizerSetEditor_component.exports);



runtime_auto_import_default()(RandomizerSetEditor_component, 'components', {QPopupProxy: QPopupProxy,QInput: QInput["a" /* default */]});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/RandomizerSettings.vue?vue&type=script&lang=ts&

















var RandomizerSettingsvue_type_script_lang_ts_RandomizerSettings = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(RandomizerSettings, _Vue);
  var _super = Object(createSuper["a" /* default */])(RandomizerSettings);
  function RandomizerSettings() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, RandomizerSettings);
    _this = _super.apply(this, arguments);
    _this._newTagName = '';
    return _this;
  }
  Object(createClass["a" /* default */])(RandomizerSettings, [{
    key: "tagClass",
    get: function get() {
      return lib["c" /* Vue */].$tagger.className.rnd + ' tag-mark-start tag-mark-end tag-mark-shadow';
    }
  }, {
    key: "isVisible",
    value: function isVisible(nr) {
      return nr == this.options.randomizer.previewIndex;
    }
  }, {
    key: "setVisible",
    value: function setVisible(nr) {
      this.options.randomizer.previewIndex = nr;
    }
  }, {
    key: "isValidTag",
    value: function isValidTag(tag) {
      return this.options.randomizer.knownTags.find(function (t) {
        return t == tag;
      }) !== undefined;
    }
  }, {
    key: "isCompleteSet",
    value: function isCompleteSet(s) {
      var _this2 = this;
      if (s.values.filter(function (v) {
        return _this2.options.randomizer.knownTags.indexOf(v.tag) < 0;
      }).length > 0) {
        return false;
      }
      if (this.options.randomizer.knownTags.filter(function (t) {
        return s.values.find(function (v) {
          return v.tag == t;
        }) === undefined;
      }).length > 0) {
        return false;
      }
      return true;
    }
  }, {
    key: "getFullSet",
    value: function getFullSet(s) {
      return s;
    }
  }, {
    key: "removeSet",
    value: function removeSet(nr) {
      this.options.randomizer.sets.splice(nr, 1);
    }
  }, {
    key: "addSet",
    value: function addSet() {
      this.options.randomizer.sets.push({
        uuid: this.$uuid.v4(),
        values: []
      });
    }
  }, {
    key: "removeTag",
    value: function removeTag(nr) {
      this.options.randomizer.knownTags.splice(nr, 1);
    }
  }, {
    key: "addTag",
    value: function addTag() {
      var _this3 = this;
      this.$q.dialog({
        title: 'Create Tag',
        message: 'This will generate a new randomizer-Tag with the below name.',
        html: true,
        persistent: true,
        prompt: {
          model: 'tag_name',
          type: 'text'
        },
        ok: {
          push: true
        },
        cancel: {
          flat: true,
          color: 'gray'
        }
      }).onOk(function (data) {
        data = data.replace(/\W/g, '_');
        //have this name
        if (_this3.options.randomizer.knownTags.filter(function (t) {
          return t == data;
        }).length > 0) {
          var ct = 1;
          var odata = data;
          do {
            data = odata + '_' + ct;
            ct++;
          } while (_this3.options.randomizer.knownTags.filter(function (t) {
            return t == data;
          }).length > 0);
        }
        _this3.options.randomizer.knownTags.push(data);
      }).onCancel(function () {}).onDismiss(function () {
        //self.highlighted = false;
      });
    }
  }]);
  return RandomizerSettings;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], RandomizerSettingsvue_type_script_lang_ts_RandomizerSettings.prototype, "options", void 0);
RandomizerSettingsvue_type_script_lang_ts_RandomizerSettings = Object(tslib_es6["b" /* __decorate */])([Object(lib["a" /* Component */])({
  components: {
    RandomizerSetEditor: components_RandomizerSetEditor
  }
})], RandomizerSettingsvue_type_script_lang_ts_RandomizerSettings);
/* harmony default export */ var RandomizerSettingsvue_type_script_lang_ts_ = (RandomizerSettingsvue_type_script_lang_ts_RandomizerSettings);
// CONCATENATED MODULE: ./src/components/RandomizerSettings.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_RandomizerSettingsvue_type_script_lang_ts_ = (RandomizerSettingsvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/RandomizerSettings.vue?vue&type=style&index=0&id=8b99c0d6&prod&lang=stylus&scoped=true&
var RandomizerSettingsvue_type_style_index_0_id_8b99c0d6_prod_lang_stylus_scoped_true_ = __webpack_require__("ad10");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/item/QList.js
var QList = __webpack_require__("1c1c");

// EXTERNAL MODULE: ./node_modules/quasar/src/mixins/size.js
var size = __webpack_require__("6642");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/avatar/QAvatar.js







/* harmony default export */ var QAvatar = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QAvatar',
  mixins: [listeners["a" /* default */], size["a" /* default */]],
  props: {
    fontSize: String,
    color: String,
    textColor: String,
    icon: String,
    square: Boolean,
    rounded: Boolean
  },
  computed: {
    classes: function classes() {
      var _ref;
      return _ref = {}, Object(esm_defineProperty["a" /* default */])(_ref, "bg-".concat(this.color), this.color), Object(esm_defineProperty["a" /* default */])(_ref, "text-".concat(this.textColor, " q-chip--colored"), this.textColor), Object(esm_defineProperty["a" /* default */])(_ref, 'q-avatar--square', this.square), Object(esm_defineProperty["a" /* default */])(_ref, 'rounded-borders', this.rounded), _ref;
    },
    contentStyle: function contentStyle() {
      if (this.fontSize) {
        return {
          fontSize: this.fontSize
        };
      }
    }
  },
  render: function render(h) {
    var icon = this.icon !== void 0 ? [h(QIcon["a" /* default */], {
      props: {
        name: this.icon
      }
    })] : void 0;
    return h('div', {
      staticClass: 'q-avatar',
      style: this.sizeStyle,
      class: this.classes,
      on: Object(objectSpread2["a" /* default */])({}, this.qListeners)
    }, [h('div', {
      staticClass: 'q-avatar__content row flex-center overflow-hidden',
      style: this.contentStyle
    }, Object(slot["b" /* mergeSlotSafely */])(icon, this, 'default'))]);
  }
}));
// EXTERNAL MODULE: ./node_modules/quasar/src/components/tooltip/QTooltip.js
var QTooltip = __webpack_require__("05c0");

// CONCATENATED MODULE: ./src/components/RandomizerSettings.vue






/* normalize component */

var RandomizerSettings_component = Object(componentNormalizer["a" /* default */])(
  components_RandomizerSettingsvue_type_script_lang_ts_,
  RandomizerSettingsvue_type_template_id_8b99c0d6_scoped_true_render,
  RandomizerSettingsvue_type_template_id_8b99c0d6_scoped_true_staticRenderFns,
  false,
  null,
  "8b99c0d6",
  null
  
)

/* harmony default export */ var components_RandomizerSettings = (RandomizerSettings_component.exports);













runtime_auto_import_default()(RandomizerSettings_component, 'components', {QCard: QCard["a" /* default */],QCardSection: QCardSection["a" /* default */],QToggle: QToggle["a" /* default */],QSlideTransition: QSlideTransition["a" /* default */],QBtn: QBtn["a" /* default */],QList: QList["a" /* default */],QItem: QItem["a" /* default */],QItemSection: QItemSection["a" /* default */],QAvatar: QAvatar,QItemLabel: QItemLabel["a" /* default */],QIcon: QIcon["a" /* default */],QTooltip: QTooltip["a" /* default */]});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlocksSettings.vue?vue&type=script&lang=ts&


















var CodeBlocksSettingsvue_type_script_lang_ts_CodeBlocksSettings = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(CodeBlocksSettings, _Vue);
  var _super = Object(createSuper["a" /* default */])(CodeBlocksSettings);
  function CodeBlocksSettings() {
    Object(classCallCheck["a" /* default */])(this, CodeBlocksSettings);
    return _super.apply(this, arguments);
  }
  Object(createClass["a" /* default */])(CodeBlocksSettings, [{
    key: "themes",
    get: function get() {
      return [{
        label: 'Solarized',
        value: 'solarized light'
      }, {
        label: 'Solarized (dark)',
        value: 'solarized dark'
      }, {
        label: 'Base16 (dark)',
        value: 'base16-dark'
      }, {
        label: 'Base16 (light)',
        value: 'base16-light'
      }, {
        label: 'Duotone (dark)',
        value: 'duotone-dark'
      }, {
        label: 'Duotone (light)',
        value: 'duotone-light'
      }, {
        label: 'XQ (dark)',
        value: 'xq-dark'
      }, {
        label: 'XQ (light)',
        value: 'xq-light'
      }, {
        label: 'Blackboard',
        value: 'blackboard'
      }, {
        label: 'neo',
        value: 'neo'
      }, {
        label: 'mbo',
        value: 'mbo'
      }, {
        label: 'mdn like',
        value: 'mdn-like'
      }];
    }
  }, {
    key: "outputParsers",
    get: function get() {
      return [{
        label: this.$l('CodeBlocksSettings.PAutomatic'),
        value: ICodeBlocks["b" /* CodeOutputTypes */].AUTO
      }, {
        label: this.$l('CodeBlocksSettings.PText'),
        value: ICodeBlocks["b" /* CodeOutputTypes */].TEXT
      }, {
        label: this.$l('CodeBlocksSettings.PJSON'),
        value: ICodeBlocks["b" /* CodeOutputTypes */].JSON
      }, {
        label: this.$l('CodeBlocksSettings.PData'),
        value: ICodeBlocks["b" /* CodeOutputTypes */].DATA
      }, {
        label: this.$l('CodeBlocksSettings.PMagic'),
        value: ICodeBlocks["b" /* CodeOutputTypes */].MAGIC
      }];
    }
  }, {
    key: "validNumber",
    value: function validNumber(v) {
      if (isNaN(v)) {
        return 'Must be a valid Number.';
      }
      return true;
    }
  }, {
    key: "serializedOptions",
    get: function get() {
      var o = Object.assign({}, this.options);
      o.randomizer = Object.assign({}, this.options.randomizer);
      o.randomizer.sets = this.options.randomizer.sets.map(function (s) {
        var values = {};
        s.values.forEach(function (v) {
          return values[v.tag] = v.value;
        });
        return values;
      });
      return JSON.stringify(o);
    },
    set: function set(v) {}
  }, {
    key: "domLibraries",
    get: function get() {
      return this.$compilerRegistry.domLibraries;
    }
  }, {
    key: "compiledLanguages",
    get: function get() {
      if (this.options.runCode === false) {
        return this.languages;
      }
      return this.$compilerRegistry.languages;
    }
  }, {
    key: "workerLibraries",
    get: function get() {
      var c = this.$compilerRegistry.getCompiler({
        languageType: this.compilerLanguage,
        version: this.compilerVersion
      });
      if (c === undefined || c.libraries === undefined) {
        return [];
      }
      return c.libraries.map(function (l) {
        return {
          label: l.displayName,
          value: l.key
        };
      });
    }
  }, {
    key: "languages",
    get: function get() {
      return this.$CodeBlock.knownLanguages();
    }
  }, {
    key: "compilerVersions",
    get: function get() {
      return this.$compilerRegistry.versionsForLanguage(this.compilerLanguage);
    }
  }, {
    key: "isExperimentalVersion",
    value: function isExperimentalVersion(language, version) {
      var c = this.$compilerRegistry.getCompiler({
        languageType: language,
        version: version
      });
      if (c === undefined) {
        return false;
      }
      return c.experimental;
    }
  }, {
    key: "isDeprecatedVersion",
    value: function isDeprecatedVersion(language, version) {
      var c = this.$compilerRegistry.getCompiler({
        languageType: language,
        version: version
      });
      if (c === undefined) {
        return false;
      }
      return c.deprecated;
    }
  }, {
    key: "isExperimental",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp) {
        return cmp.experimental;
      }
      return false;
    }
  }, {
    key: "isDeprecated",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp) {
        return cmp.deprecated;
      }
      return false;
    }
  }, {
    key: "languageHasCompiler",
    get: function get() {
      if (this.runCode) {
        return true;
      }
      var c = this.$compilerRegistry.getCompiler({
        languageType: this.compilerLanguage
      });
      return c !== undefined;
    }
  }, {
    key: "compilerLanguage",
    get: function get() {
      if (this.options.runCode === false) {
        return this.options.language;
      }
      return this.options.compiler.languageType;
    }
  }, {
    key: "compilerLanguageObj",
    get: function get() {
      return lib["c" /* Vue */].$CodeBlock.itemForValue(this.compiledLanguages, this.compilerLanguage);
    },
    set: function set(v) {
      if (this.options.runCode === false) {
        this.$emit('language-change', v.value);
      }
      this.$emit('compiler-change', v.value);
    }
  }, {
    key: "compilerVersion",
    get: function get() {
      return this.options.compiler.version;
    },
    set: function set(v) {
      this.$emit('compiler-version-change', v);
    }
  }, {
    key: "runCode",
    get: function get() {
      return this.options.runCode;
    },
    set: function set(v) {
      this.$emit('run-state-change', v);
    }
  }, {
    key: "maxRuntime",
    get: function get() {
      return this.options.executionTimeout;
    },
    set: function set(v) {
      this.$emit('timeout-change', v);
    }
  }, {
    key: "maxCharacters",
    get: function get() {
      return this.options.maxCharacters;
    },
    set: function set(v) {
      this.$emit('character-limit-change', v);
    }
  }, {
    key: "domLibrary",
    get: function get() {
      var _this = this;
      return this.options.domLibs.map(function (d) {
        return _this.domLibraries.find(function (k) {
          return k.value == d;
        });
      }).filter(function (v) {
        return v !== undefined;
      });
    },
    set: function set(v) {
      this.$emit('dom-libs-change', v.map(function (vv) {
        return vv.value;
      }));
    }
  }, {
    key: "workerLibrary",
    get: function get() {
      var _this2 = this;
      return this.options.workerLibs.map(function (d) {
        return _this2.workerLibraries.find(function (k) {
          return k.value == d;
        });
      }).filter(function (v) {
        return v !== undefined;
      });
    },
    set: function set(v) {
      this.$emit('worker-libs-change', v.map(function (vv) {
        return vv.value;
      }));
    }
  }, {
    key: "solutionTheme",
    get: function get() {
      return lib["c" /* Vue */].$CodeBlock.itemForValue(this.themes, this.options.solutionTheme);
    },
    set: function set(v) {
      this.$emit('theme-change', {
        solution: v.value,
        code: this.options.codeTheme
      });
    }
  }, {
    key: "codeTheme",
    get: function get() {
      return lib["c" /* Vue */].$CodeBlock.itemForValue(this.themes, this.options.codeTheme);
    },
    set: function set(v) {
      this.$emit('theme-change', {
        solution: this.options.solutionTheme,
        code: v.value
      });
    }
  }, {
    key: "outputParser",
    get: function get() {
      return lib["c" /* Vue */].$CodeBlock.itemForValue(this.outputParsers, this.options.outputParser);
    },
    set: function set(v) {
      this.$emit('output-parser-change', v.value);
    }
  }, {
    key: "continuousCompile",
    get: function get() {
      return this.options.continuousCompilation;
    },
    set: function set(v) {
      this.$emit('continuous-compile-change', v);
    }
  }, {
    key: "compiler",
    get: function get() {
      return this.options.compiler;
    }
  }, {
    key: "canContinousCompile",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      console.d('Continuous Compile - ', 'can', cmp, cmp ? cmp.allowsContinousCompilation : false, cmp ? cmp.canRun : false);
      if (cmp) {
        console.d('Continuous Compile - ', 'can', cmp.allowsContinousCompilation && cmp.canRun);
        return cmp.allowsContinousCompilation && cmp.canRun;
      }
      return false;
    }
  }, {
    key: "allowsMessagePassing",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp) {
        console.d('Message Passing - ', 'can', cmp.allowsContinousCompilation && cmp.canRun);
        return cmp.allowsMessagePassing && cmp.canRun;
      }
      return false;
    }
  }, {
    key: "messagePassing",
    get: function get() {
      return this.options.messagePassing;
    },
    set: function set(v) {
      this.$emit('message-passing-change', v);
    }
  }, {
    key: "keepAlive",
    get: function get() {
      return this.options.keepAlive;
    },
    set: function set(v) {
      this.$emit('keep-alive-change', v);
    }
  }, {
    key: "showMaxRuntime",
    get: function get() {
      return this.runCode && !(this.keepAlive && this.messagePassing);
    }
  }, {
    key: "allowsREPL",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp) {
        console.d('REPL - ', 'can', cmp.allowsREPL && cmp.allowsMessagePassing && cmp.canRun);
        return cmp.allowsREPL && cmp.allowsMessagePassing && cmp.canRun;
      }
      return false;
    }
  }, {
    key: "persistentArguments",
    get: function get() {
      return this.options.persistentArguments;
    },
    set: function set(v) {
      this.$emit('persistent-arguments-change', v);
    }
  }, {
    key: "canPersistentArguments",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp) {
        console.d('Persistent Arguments - ', 'can', cmp.acceptsJSONArgument && cmp.allowsPersistentArguments && cmp.canRun);
        return cmp.acceptsJSONArgument && cmp.allowsPersistentArguments && cmp.canRun;
      }
      return false;
    }
  }, {
    key: "accepstArguments",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp) {
        return cmp.acceptsJSONArgument;
      }
      return false;
    }
  }, {
    key: "showArgsInfoDialog",
    value: function showArgsInfoDialog() {
      this.showInfoDialog('CodeBlocksSettings.AllowArgumentsCaption', this.compiler.languageType == 'java' ? 'CodeBlocksSettings.AllowArgumentsHintJava' : 'CodeBlocksSettings.AllowArgumentsHint');
    }
  }, {
    key: "showPersistentArgsInfoDialog",
    value: function showPersistentArgsInfoDialog() {
      this.showInfoDialog('CodeBlocksSettings.UsePersistentArgumentsCaption', this.compiler.languageType == 'java' ? 'CodeBlocksSettings.UsePersistentArgumentsHintJava' : 'CodeBlocksSettings.UsePersistentArgumentsHint');
    }
  }, {
    key: "showMessagesInfoDialog",
    value: function showMessagesInfoDialog() {
      this.showInfoDialog('CodeBlocksSettings.AllowMessagePassingCaption', this.compiler.languageType == 'java' ? 'CodeBlocksSettings.AllowMessagePassingHintJava' : 'CodeBlocksSettings.AllowMessagePassingHint');
    }
  }, {
    key: "showAliveInfoDialog",
    value: function showAliveInfoDialog() {
      this.showInfoDialog('CodeBlocksSettings.KeepAliveCaption', this.compiler.languageType == 'java' ? 'CodeBlocksSettings.KeepAliveHintJava' : 'CodeBlocksSettings.KeepAliveHint');
    }
  }, {
    key: "showInfoDialog",
    value: function showInfoDialog(title, message) {
      this.$q.dialog({
        title: this.$l(title),
        message: this.$l(message),
        html: true,
        style: 'width:75%'
      }).onOk(function () {
        // console.log('OK')
      }).onCancel(function () {
        // console.log('Cancel')
      }).onDismiss(function () {
        // console.log('I am triggered on both OK and Cancel')
      });
    }
  }]);
  return CodeBlocksSettings;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodeBlocksSettingsvue_type_script_lang_ts_CodeBlocksSettings.prototype, "options", void 0);
CodeBlocksSettingsvue_type_script_lang_ts_CodeBlocksSettings = Object(tslib_es6["b" /* __decorate */])([Object(lib["a" /* Component */])({
  components: {
    RandomizerSettings: components_RandomizerSettings
  }
})], CodeBlocksSettingsvue_type_script_lang_ts_CodeBlocksSettings);
/* harmony default export */ var CodeBlocksSettingsvue_type_script_lang_ts_ = (CodeBlocksSettingsvue_type_script_lang_ts_CodeBlocksSettings);
// CONCATENATED MODULE: ./src/components/CodeBlocksSettings.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_CodeBlocksSettingsvue_type_script_lang_ts_ = (CodeBlocksSettingsvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/CodeBlocksSettings.vue?vue&type=style&index=0&id=644cb51f&prod&lang=sass&scoped=true&
var CodeBlocksSettingsvue_type_style_index_0_id_644cb51f_prod_lang_sass_scoped_true_ = __webpack_require__("4949");

// CONCATENATED MODULE: ./src/components/CodeBlocksSettings.vue






/* normalize component */

var CodeBlocksSettings_component = Object(componentNormalizer["a" /* default */])(
  components_CodeBlocksSettingsvue_type_script_lang_ts_,
  CodeBlocksSettingsvue_type_template_id_644cb51f_scoped_true_render,
  CodeBlocksSettingsvue_type_template_id_644cb51f_scoped_true_staticRenderFns,
  false,
  null,
  "644cb51f",
  null
  
)

/* harmony default export */ var components_CodeBlocksSettings = (CodeBlocksSettings_component.exports);














runtime_auto_import_default()(CodeBlocksSettings_component, 'components', {QCard: QCard["a" /* default */],QCardSection: QCardSection["a" /* default */],QToggle: QToggle["a" /* default */],QSelect: QSelect["a" /* default */],QAvatar: QAvatar,QItem: QItem["a" /* default */],QItemSection: QItemSection["a" /* default */],QItemLabel: QItemLabel["a" /* default */],QSlideTransition: QSlideTransition["a" /* default */],QBanner: QBanner["a" /* default */],QIcon: QIcon["a" /* default */],QInput: QInput["a" /* default */],QBtn: QBtn["a" /* default */]});

// EXTERNAL MODULE: ./src/components/CodeBlock.vue + 14 modules
var CodeBlock = __webpack_require__("800b");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodePanel.vue?vue&type=template&id=f34c54ee&scoped=true&
var CodePanelvue_type_template_id_f34c54ee_scoped_true_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.editMode,
      expression: "editMode"
    }],
    staticClass: "blocksEditorPanelContainer",
    style: "width:".concat(_vm.width, "px")
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.block !== null,
      expression: "block !== null"
    }],
    staticClass: "blocksEditorPanelLeft"
  }, [_c('q-btn', {
    staticClass: "expander",
    attrs: {
      "icon": _vm.expanded ? 'chevron_right' : 'chevron_left',
      "size": "sm",
      "unelevated": "",
      "align": "center",
      "color": "blue-grey-4"
    },
    on: {
      "click": _vm.onExpandClick
    }
  }), _c('CodeBlock', {
    attrs: {
      "block": _vm.saveBlock,
      "theme": _vm.themeForBlock(_vm.block),
      "mode": "",
      "visibleLines": _vm.visibleLinesNow,
      "editMode": true,
      "muteReadyState": true,
      "isBookmarkPanel": true,
      "namePrefix": "panel_"
    },
    on: {
      "code-changed-in-edit-mode": _vm.onCodeChange
    }
  })], 1)]);
};
var CodePanelvue_type_template_id_f34c54ee_scoped_true_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/CodePanel.vue?vue&type=template&id=f34c54ee&scoped=true&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodePanel.vue?vue&type=script&lang=ts&









var CodePanelvue_type_script_lang_ts_CodePanel = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(CodePanel, _Vue);
  var _super = Object(createSuper["a" /* default */])(CodePanel);
  function CodePanel() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, CodePanel);
    _this = _super.apply(this, arguments);
    _this.expanded = false;
    return _this;
  }
  Object(createClass["a" /* default */])(CodePanel, [{
    key: "saveBlock",
    get: function get() {
      if (this.block !== null && this.block !== undefined && this.block.content !== null && this.block.content !== undefined) {
        return this.block;
      }
      var ret = {
        hasCode: false,
        type: ICodeBlocks["c" /* KnownBlockTypes */].BLOCKSTATIC,
        content: '',
        alternativeContent: '',
        noContent: true,
        id: -1,
        uuid: '',
        parentID: -2,
        expanded: true,
        codeExpanded: ICodeBlocks["a" /* CodeExpansionType */].AUTO,
        obj: null,
        version: '',
        readyCount: 0,
        errors: [],
        visibleLines: 'auto',
        hasAlternativeContent: false,
        shouldAutoreset: false,
        shouldReloadResources: false,
        generateTemplate: true,
        firstLine: 1,
        actualContent: '',
        actualAltContent: '',
        width: '100%',
        height: '200px',
        align: 'center',
        readonly: true,
        static: true,
        hidden: false,
        themeForCodeBlock: '',
        lineCountHint: -0,
        name: '',
        getThemeForBlock: function getThemeForBlock(bl) {
          return '';
        },
        blockly: {
          _blockErrors: [],
          useOverride: false,
          toolbox: {
            categories: []
          },
          showControls: false,
          toolboxOverride: '',
          blocks: []
        }
      };
      return ret;
    }
  }, {
    key: "visibleLinesNow",
    get: function get() {
      if (this.visibleLines === 'auto') {
        return 'auto';
      }
      if (this.visibleLines <= 2) {
        return 2;
      }
      return this.visibleLines;
    }
  }, {
    key: "onCodeChange",
    value: function onCodeChange() {}
  }, {
    key: "width",
    get: function get() {
      if (this.expanded) {
        return 2 * this.panelWidth;
      }
      return this.panelWidth;
    }
  }, {
    key: "onExpandClick",
    value: function onExpandClick() {
      this.expanded = !this.expanded;
    }
  }, {
    key: "themeForBlock",
    value: function themeForBlock(bl) {
      if (bl === null || bl === undefined) {
        return '';
      }
      return bl.themeForCodeBlock;
    }
  }]);
  return CodePanel;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], CodePanelvue_type_script_lang_ts_CodePanel.prototype, "editMode", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: 'auto'
})], CodePanelvue_type_script_lang_ts_CodePanel.prototype, "visibleLines", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodePanelvue_type_script_lang_ts_CodePanel.prototype, "block", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: 400
})], CodePanelvue_type_script_lang_ts_CodePanel.prototype, "panelWidth", void 0);
CodePanelvue_type_script_lang_ts_CodePanel = Object(tslib_es6["b" /* __decorate */])([Object(lib["a" /* Component */])({
  components: {
    CodeBlock: CodeBlock["a" /* default */]
  }
})], CodePanelvue_type_script_lang_ts_CodePanel);
/* harmony default export */ var CodePanelvue_type_script_lang_ts_ = (CodePanelvue_type_script_lang_ts_CodePanel);
// CONCATENATED MODULE: ./src/components/CodePanel.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_CodePanelvue_type_script_lang_ts_ = (CodePanelvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/CodePanel.vue?vue&type=style&index=0&id=f34c54ee&prod&lang=sass&scoped=true&
var CodePanelvue_type_style_index_0_id_f34c54ee_prod_lang_sass_scoped_true_ = __webpack_require__("0fa8");

// CONCATENATED MODULE: ./src/components/CodePanel.vue






/* normalize component */

var CodePanel_component = Object(componentNormalizer["a" /* default */])(
  components_CodePanelvue_type_script_lang_ts_,
  CodePanelvue_type_template_id_f34c54ee_scoped_true_render,
  CodePanelvue_type_template_id_f34c54ee_scoped_true_staticRenderFns,
  false,
  null,
  "f34c54ee",
  null
  
)

/* harmony default export */ var components_CodePanel = (CodePanel_component.exports);


runtime_auto_import_default()(CodePanel_component, 'components', {QBtn: QBtn["a" /* default */]});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodePlayground.vue?vue&type=template&id=0fa31c20&scoped=true&
var CodePlaygroundvue_type_template_id_0fa31c20_scoped_true_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', [_c('PlaygroundCanvas', {
    key: _vm.runCount,
    ref: "playgroundContainer",
    attrs: {
      "output": _vm.finalOutputObject.initialOutput,
      "obj": _vm.block.obj,
      "block": _vm.block,
      "eventHub": _vm.eventHub,
      "tagSet": _vm.tagSet,
      "data-question": _vm.block.parentID,
      "runner": _vm.emitRun
    },
    on: {
      "canvas-change": _vm.onCanvasChange,
      "did-init": _vm.onDidInit
    }
  }), _c('div', {
    staticClass: "row justify-end"
  }, [_vm.editMode ? _c('q-btn-group', {
    staticClass: "q-mb-sm",
    attrs: {
      "rounded": ""
    }
  }, [_c('q-btn', {
    attrs: {
      "color": _vm.isExpandedAuto ? 'primary' : 'blue-grey-4',
      "small": "",
      "label": "Auto",
      "icon": "video_label"
    },
    on: {
      "click": _vm.setExpandedAuto
    }
  }), _c('q-btn', {
    attrs: {
      "color": _vm.isExpandedLarge ? 'primary' : 'blue-grey-4',
      "small": "",
      "label": "Large",
      "icon": "call_to_action"
    },
    on: {
      "click": _vm.setExpandedLarge
    }
  }), _c('q-btn', {
    attrs: {
      "color": _vm.isExpandedTiny ? 'primary' : 'blue-grey-4',
      "small": "",
      "label": "Small",
      "icon": "visibility_off"
    },
    on: {
      "click": _vm.setExpandedTiny
    }
  })], 1) : _vm._e()], 1), _c('q-slide-transition', [_vm.editMode ? _c('CodeBlock', {
    attrs: {
      "block": _vm.block,
      "theme": _vm.options.theme,
      "mode": _vm.options.mode,
      "visibleLines": _vm.visibleLinesNow,
      "editMode": this.editMode,
      "muteReadyState": true
    },
    on: {
      "code-changed-in-edit-mode": _vm.onCodeChange
    }
  }) : _vm._e()], 1)], 1);
};
var CodePlaygroundvue_type_template_id_0fa31c20_scoped_true_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/CodePlayground.vue?vue&type=template&id=0fa31c20&scoped=true&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/PlaygroundCanvas.vue?vue&type=template&id=09d07b72&scoped=true&

var PlaygroundCanvasvue_type_template_id_09d07b72_scoped_true_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', {
    staticClass: "row ma-0 pa-0 block-playground",
    attrs: {
      "data-question": _vm.block.parentID,
      "data-nr": _vm.block.id
    }
  }, [_vm.block.generateTemplate ? _c('div', {
    class: "col-12 text-".concat(_vm.block.align)
  }, [_c('div', {
    ref: "innerPlaygroundContainer",
    staticClass: "playground",
    style: "width:".concat(_vm.block.width, ";height:").concat(_vm.block.height),
    attrs: {
      "data-question": _vm.block.parentID,
      "data-nr": _vm.block.id
    }
  }, [_vm._v(" " + _vm._s(_vm.output) + " ")])]) : _vm._e()]);
};
var PlaygroundCanvasvue_type_template_id_09d07b72_scoped_true_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/PlaygroundCanvas.vue?vue&type=template&id=09d07b72&scoped=true&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/PlaygroundCanvas.vue?vue&type=script&lang=ts&







var PlaygroundCanvasvue_type_script_lang_ts_PlaygroundCanvas = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(PlaygroundCanvas, _Vue);
  var _super = Object(createSuper["a" /* default */])(PlaygroundCanvas);
  function PlaygroundCanvas() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, PlaygroundCanvas);
    _this = _super.apply(this, arguments);
    _this.output = '';
    return _this;
  }
  Object(createClass["a" /* default */])(PlaygroundCanvas, [{
    key: "canvas",
    get: function get() {
      return this.$refs.innerPlaygroundContainer;
    }
  }, {
    key: "whenMounted",
    value: function whenMounted() {
      var _this2 = this;
      if (this.obj) {
        console.d('Will Init', this.canvas, $(this.canvas).css('background-color'));
        this.$compilerRegistry.loadLibraries(this.block.domLibs, function () {
          _this2.obj.resetResources();
          _this2.obj.resetBlockData(_this2.block.appSettings.blocks);
          _this2.obj.rebuild(); //we need to rebuild the script to make sure its context is the current state of the DOM
          _this2.obj.setupDOM($(_this2.canvas), _this2.block.scope);
          _this2.$nextTick(function () {
            _this2.$nextTick(function () {
              _this2.obj.init($(_this2.canvas), _this2.block.scope, _this2.runner);
              _this2.$emit('did-init', _this2.canvas);
            });
          });
        });
      }
    }
  }, {
    key: "mounted",
    value: function mounted() {
      if (this.eventHub) {
        this.eventHub.$on('all-mounted', this.whenMounted);
      } else {
        this.whenMounted();
      }
      this.$emit('canvas-change', this.canvas);
    }
  }, {
    key: "beforeDestroy",
    value: function beforeDestroy() {
      if (this.eventHub) {
        this.eventHub.$off('all-mounted');
      }
    }
  }]);
  return PlaygroundCanvas;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])()], PlaygroundCanvasvue_type_script_lang_ts_PlaygroundCanvas.prototype, "output", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], PlaygroundCanvasvue_type_script_lang_ts_PlaygroundCanvas.prototype, "obj", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], PlaygroundCanvasvue_type_script_lang_ts_PlaygroundCanvas.prototype, "block", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], PlaygroundCanvasvue_type_script_lang_ts_PlaygroundCanvas.prototype, "eventHub", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: function _default() {}
})], PlaygroundCanvasvue_type_script_lang_ts_PlaygroundCanvas.prototype, "runner", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])()], PlaygroundCanvasvue_type_script_lang_ts_PlaygroundCanvas.prototype, "tagSet", void 0);
PlaygroundCanvasvue_type_script_lang_ts_PlaygroundCanvas = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], PlaygroundCanvasvue_type_script_lang_ts_PlaygroundCanvas);
/* harmony default export */ var PlaygroundCanvasvue_type_script_lang_ts_ = (PlaygroundCanvasvue_type_script_lang_ts_PlaygroundCanvas);
// CONCATENATED MODULE: ./src/components/PlaygroundCanvas.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_PlaygroundCanvasvue_type_script_lang_ts_ = (PlaygroundCanvasvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/PlaygroundCanvas.vue?vue&type=style&index=0&id=09d07b72&prod&lang=sass&scoped=true&
var PlaygroundCanvasvue_type_style_index_0_id_09d07b72_prod_lang_sass_scoped_true_ = __webpack_require__("775d");

// CONCATENATED MODULE: ./src/components/PlaygroundCanvas.vue






/* normalize component */

var PlaygroundCanvas_component = Object(componentNormalizer["a" /* default */])(
  components_PlaygroundCanvasvue_type_script_lang_ts_,
  PlaygroundCanvasvue_type_template_id_09d07b72_scoped_true_render,
  PlaygroundCanvasvue_type_template_id_09d07b72_scoped_true_staticRenderFns,
  false,
  null,
  "09d07b72",
  null
  
)

/* harmony default export */ var components_PlaygroundCanvas = (PlaygroundCanvas_component.exports);
// EXTERNAL MODULE: ./src/components/BaseBlock.vue + 2 modules
var BaseBlock = __webpack_require__("879e");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodePlayground.vue?vue&type=script&lang=ts&













//helper to reset the canvas area if needed



var PlaygroundCanvasCtor = lib["c" /* Vue */].extend(components_PlaygroundCanvas);


var CodePlaygroundvue_type_script_lang_ts_CodePlayground = /*#__PURE__*/function (_BaseBlock) {
  Object(inherits["a" /* default */])(CodePlayground, _BaseBlock);
  var _super = Object(createSuper["a" /* default */])(CodePlayground);
  function CodePlayground() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, CodePlayground);
    _this = _super.apply(this, arguments);
    _this.isPreparingRun = false;
    _this.lastRun = new Date();
    _this.runCount = 0;
    _this.canvas = undefined;
    _this.needsCodeRebuild = false;
    _this.initAndRebuildErrors = [];
    return _this;
  }
  Object(createClass["a" /* default */])(CodePlayground, [{
    key: "originalMode",
    get: function get() {
      if (this.block.obj === null) {
        return false;
      }
      return this.block.obj.requestsOriginalVersion();
    }
  }, {
    key: "options",
    get: function get() {
      return {
        // codemirror options
        mode: this.$CodeBlock.mimeType('javascript'),
        theme: this.theme,
        lineNumbers: true,
        line: true,
        tabSize: 4,
        indentUnit: 4,
        autoCloseBrackets: true,
        readOnly: !this.editMode,
        firstLineNumber: 1,
        gutters: ['diagnostics', 'CodeMirror-linenumbers']
      };
    }
  }, {
    key: "visibleLinesNow",
    get: function get() {
      if (this.block.codeExpanded == ICodeBlocks["a" /* CodeExpansionType */].TINY) {
        return '2.4';
      } else if (this.block.codeExpanded == ICodeBlocks["a" /* CodeExpansionType */].LARGE) {
        return '33.4';
      }
      return 'auto';
    }
  }, {
    key: "created",
    value: function created() {
      this.eventHub.$on('before-run', this.resetBeforeRun);
      this.eventHub.$on('render-diagnostics', this.updateErrors);
    }
  }, {
    key: "mounted",
    value: function mounted() {
      var hasErrors = this.block && this.block.obj && this.block.obj.err.length > 0;
      if (hasErrors) {
        this.updateErrors();
      }
      this.eventHub.$on('output-updated', this.onFinalOutputObject);
    }
  }, {
    key: "beforeDestroy",
    value: function beforeDestroy() {
      this.eventHub.$off('before-run', this.resetBeforeRun);
      this.eventHub.$off('render-diagnostics', this.updateErrors);
      this.eventHub.$off('output-updated', this.onFinalOutputObject);
    }
  }, {
    key: "isExpandedLarge",
    get: function get() {
      return this.block.codeExpanded == ICodeBlocks["a" /* CodeExpansionType */].LARGE;
    }
  }, {
    key: "isExpandedTiny",
    get: function get() {
      return this.block.codeExpanded == ICodeBlocks["a" /* CodeExpansionType */].TINY;
    }
  }, {
    key: "isExpandedAuto",
    get: function get() {
      return this.block.codeExpanded == ICodeBlocks["a" /* CodeExpansionType */].AUTO;
    }
  }, {
    key: "setExpandedLarge",
    value: function setExpandedLarge() {
      this.setExpanded(ICodeBlocks["a" /* CodeExpansionType */].LARGE);
    }
  }, {
    key: "setExpandedTiny",
    value: function setExpandedTiny() {
      this.setExpanded(ICodeBlocks["a" /* CodeExpansionType */].TINY);
    }
  }, {
    key: "setExpandedAuto",
    value: function setExpandedAuto() {
      this.setExpanded(ICodeBlocks["a" /* CodeExpansionType */].AUTO);
    }
  }, {
    key: "setExpanded",
    value: function setExpanded(val) {
      this.block.codeExpanded = val;
      if (this.block.codeExpanded != ICodeBlocks["a" /* CodeExpansionType */].TINY) {
        this.$CodeBlock.refreshAllCodeMirrors();
      }
    }
  }, {
    key: "updateErrors",
    value: function updateErrors() {
      var _this2 = this;
      this.block.errors = [];
      if (this.block.obj === null) {
        return false;
      }
      this.block.obj.err = this.block.obj.err.concat(this.initAndRebuildErrors);
      this.block.obj.err.forEach(function (e) {
        var err = {
          start: {
            line: e.line,
            column: e.column
          },
          end: {
            line: e.line,
            column: e.column + 1
          },
          message: e.msg,
          severity: lib["c" /* Vue */].$SEVERITY_ERROR
        };
        if (e.line === undefined) {
          err.start = {
            line: 1,
            column: -1
          };
          err.end = {
            line: 1,
            column: -1
          };
        } else if (e.column === undefined) {
          err.start = {
            line: e.line,
            column: -1
          };
          err.end = {
            line: e.line,
            column: -1
          };
        }
        _this2.block.errors.push(err);
      });
      if (this.block.obj.err.length > 0 && this.editMode) {
        this.needsCodeRebuild = true;
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "resetBeforeRun",
    value: function resetBeforeRun() {
      var _this3 = this;
      var rebuildCode = this.editMode && (this.needsCodeRebuild || this.tagSet !== undefined);
      var reInitCode = rebuildCode;
      var onNextTick = false;
      if (this.block && this.block.obj) {
        if (this.block.shouldAutoreset || rebuildCode) {
          if (this.canvas !== undefined) {
            console.log('Will Re-Initialize', this.canvas, $(this.canvas).css('background-color'));
          } else {
            console.log('Will Re-Initialize', 'Without Canvas');
          }
          this.lastRun = new Date();
          this.runCount++;
          reInitCode = true;
          onNextTick = true;
        } else {
          var self = this;
          this.$nextTick(function () {
            //console.log("Will Reset", this.canvas, $(this.canvas).css('background-color'));
            if (self.block.obj !== null && self.canvas !== undefined) {
              self.block.obj.reset($(self.canvas));
            }
            self.updateErrors();
          });
        }
      }
      if (rebuildCode) {
        this.initAndRebuildErrors = [];
        if (this.block.obj != null) {
          this.block.obj.rebuild(this.block.actualContent());
          if (this.updateErrors()) {
            this.initAndRebuildErrors = this.block.obj.err;
            this.block.obj.invalidate();
            return;
          }
        }
        reInitCode = true;
      }
      if (reInitCode) {
        this.initAndRebuildErrors = [];
        var doInit = function doInit() {
          console.i('!!! DO INIT !!!');
          if (_this3.block.obj !== null) {
            var canvas = $(_this3.canvas);
            var scope = _this3.block.scope;
            if (_this3.block.shouldReloadResources) {
              _this3.block.obj.resetResources();
            }
            _this3.block.obj.resetBlockData(_this3.block.appSettings.blocks);
            _this3.block.obj.setupDOM(canvas, scope);
            _this3.block.obj.init(canvas, scope, _this3.emitRun);
            if (_this3.updateErrors()) {
              _this3.initAndRebuildErrors = _this3.block.obj.err;
              _this3.block.obj.invalidate();
              return false;
            }
            return true;
          } else {
            return false;
          }
        };
        if (onNextTick) {
          this.$nextTick(doInit);
        } else {
          if (!doInit()) {
            return;
          }
        }
      }
    }
  }, {
    key: "emitRun",
    value: function emitRun() {
      this.$emit('run', this.block);
    }
  }, {
    key: "onCanvasChange",
    value: function onCanvasChange(can) {
      this.canvas = can;
      if (this.editMode) {
        this.updateErrors();
      }
      //console.log("Changed Canvas", can, $(can).css('background-color'));
    }
  }, {
    key: "onCodeChange",
    value: function onCodeChange(newCode) {
      if (this.editMode) {
        this.needsCodeRebuild = true;
      }
    }
  }, {
    key: "onDidInit",
    value: function onDidInit() {
      this.updateErrors();
    }
    //we emit an event to the global event hub
    //@Watch('finalOutputObject')
  }, {
    key: "onFinalOutputObject",
    value: function onFinalOutputObject(val) {
      var initialOutput = val.output;
      console.d('onFinalOutputObject', val, this.block.obj);
      if (this.block.obj !== null) {
        this.block.obj.err = [];
        try {
          if (val.parseError != null) {
            if (!this.block.obj.onParseError(initialOutput, val.parseError) && this.editMode) {
              var jStr = initialOutput;
              if (val.parseError.parsedString !== undefined) {
                jStr = val.parseError.parsedString;
              }
              jStr = jStr.replace(/</g, '&lt;');
              this.$q.dialog({
                title: this.$l('CodePlayground.InvalidJson'),
                message: '<span class="text-caption jsonErrTitle">' + this.$t('CodePlayground.Output') + '</span><div class="jsonErrObj">' + jStr + '</div>\n<span class="text-caption jsonErrTitle">' + this.$t('CodePlayground.Message') + '</span><div class="jsonErr">' + val.parseError + '</div>',
                html: true
              }).onOk(function () {
                // console.log('OK')
              }).onCancel(function () {
                // console.log('Cancel')
              }).onDismiss(function () {
                // console.log('I am triggered on both OK and Cancel')
              });
            }
            if (this.updateErrors()) {
              return;
            }
          }
          var self = this;
          this.$nextTick(function () {
            console.d('Ticked', self.block.obj, self.canvas);
            if (self.block.obj !== null && self.canvas !== undefined) {
              var result = self.block.obj.update(val, $(self.canvas));
              if (self.updateErrors()) {
                return;
              }
              //construct a split output object
              if (result === undefined && val.processedOutput.type != 'text') {
                if (!self.originalMode) {
                  result = val.processedOutput.text;
                }
              }
              if (self.originalMode) {
                if (typeof result !== 'string') {
                  result = '';
                }
              }
              if (result !== undefined) {
                self.$emit('changeOutput', result);
              }
            }
          });
        } catch (e) {
          console.error(e);
        }
        if (this.block.obj.err.length > 0) {
          if (this.editMode) {
            this.updateErrors();
          } else {
            console.error(this.block.obj.err);
          }
        }
      }
    }
  }]);
  return CodePlayground;
}(BaseBlock["a" /* default */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodePlaygroundvue_type_script_lang_ts_CodePlayground.prototype, "finalOutputObject", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true,
  validator: function validator(b) {
    if (!b.obj) {
      return false;
    }
    return true;
  }
})], CodePlaygroundvue_type_script_lang_ts_CodePlayground.prototype, "block", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], CodePlaygroundvue_type_script_lang_ts_CodePlayground.prototype, "editMode", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: 'auto'
})], CodePlaygroundvue_type_script_lang_ts_CodePlayground.prototype, "visibleLines", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: 'base16-dark'
})], CodePlaygroundvue_type_script_lang_ts_CodePlayground.prototype, "theme", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodePlaygroundvue_type_script_lang_ts_CodePlayground.prototype, "eventHub", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])()], CodePlaygroundvue_type_script_lang_ts_CodePlayground.prototype, "tagSet", void 0);
CodePlaygroundvue_type_script_lang_ts_CodePlayground = Object(tslib_es6["b" /* __decorate */])([Object(lib["a" /* Component */])({
  components: {
    PlaygroundCanvas: components_PlaygroundCanvas,
    CodeBlock: CodeBlock["a" /* default */]
  }
})], CodePlaygroundvue_type_script_lang_ts_CodePlayground);
/* harmony default export */ var CodePlaygroundvue_type_script_lang_ts_ = (CodePlaygroundvue_type_script_lang_ts_CodePlayground);
// CONCATENATED MODULE: ./src/components/CodePlayground.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_CodePlaygroundvue_type_script_lang_ts_ = (CodePlaygroundvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/CodePlayground.vue?vue&type=style&index=0&id=0fa31c20&prod&lang=sass&scoped=true&
var CodePlaygroundvue_type_style_index_0_id_0fa31c20_prod_lang_sass_scoped_true_ = __webpack_require__("5531");

// EXTERNAL MODULE: ./src/components/CodePlayground.vue?vue&type=style&index=1&id=0fa31c20&prod&lang=stylus&
var CodePlaygroundvue_type_style_index_1_id_0fa31c20_prod_lang_stylus_ = __webpack_require__("a7ae");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/btn-group/QBtnGroup.js








/* harmony default export */ var QBtnGroup = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QBtnGroup',
  mixin: [listeners["a" /* default */]],
  props: {
    unelevated: Boolean,
    outline: Boolean,
    flat: Boolean,
    rounded: Boolean,
    square: Boolean,
    push: Boolean,
    stretch: Boolean,
    glossy: Boolean,
    spread: Boolean
  },
  computed: {
    classes: function classes() {
      var _this = this;
      return ['unelevated', 'outline', 'flat', 'rounded', 'square', 'push', 'stretch', 'glossy'].filter(function (t) {
        return _this[t] === true;
      }).map(function (t) {
        return "q-btn-group--".concat(t);
      }).join(' ');
    }
  },
  render: function render(h) {
    return h('div', {
      staticClass: 'q-btn-group row no-wrap ' + (this.spread === true ? 'q-btn-group--spread' : 'inline'),
      class: this.classes,
      on: Object(objectSpread2["a" /* default */])({}, this.qListeners)
    }, Object(slot["c" /* slot */])(this, 'default'));
  }
}));
// CONCATENATED MODULE: ./src/components/CodePlayground.vue







/* normalize component */

var CodePlayground_component = Object(componentNormalizer["a" /* default */])(
  components_CodePlaygroundvue_type_script_lang_ts_,
  CodePlaygroundvue_type_template_id_0fa31c20_scoped_true_render,
  CodePlaygroundvue_type_template_id_0fa31c20_scoped_true_staticRenderFns,
  false,
  null,
  "0fa31c20",
  null
  
)

/* harmony default export */ var components_CodePlayground = (CodePlayground_component.exports);




runtime_auto_import_default()(CodePlayground_component, 'components', {QBtnGroup: QBtnGroup,QBtn: QBtn["a" /* default */],QSlideTransition: QSlideTransition["a" /* default */]});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeREPL.vue?vue&type=template&id=a208ad54&
var CodeREPLvue_type_template_id_a208ad54_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', {
    class: "codeblock block-".concat(_vm.typeName)
  }, [_vm.allowsREPL && _vm.canStartREPL ? _c('div', {
    staticClass: "row runnerState",
    attrs: {
      "id": "stateBox",
      "data-question": _vm.blockInfo.id
    }
  }, [_c('q-btn', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: !_vm.isRunning,
      expression: "!isRunning"
    }],
    staticClass: "white--text q-pr-sm",
    staticStyle: {
      "border-radius": "0px"
    },
    attrs: {
      "id": "allow_run_button",
      "loading": !_vm.isReady,
      "disabled": !_vm.isReady,
      "color": "primary",
      "ripple": {
        center: true
      },
      "data-question": _vm.blockInfo.id
    },
    on: {
      "click": _vm.emitRun
    }
  }, [_vm._v(" " + _vm._s(_vm.$t('CodeBlocks.start')) + " "), _c('q-icon', {
    attrs: {
      "right": "",
      "dark": "",
      "name": "play_arrow"
    }
  })], 1), _c('div', {
    staticClass: "animated fadeIn"
  }), _c('transition', {
    attrs: {
      "appear": "",
      "enter-active-class": "animated fadeIn",
      "leave-active-class": "animated fadeOut"
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.canStop,
      expression: "canStop"
    }],
    staticClass: "q-pl-0"
  }, [_c('q-btn', {
    staticStyle: {
      "border-radius": "0px"
    },
    attrs: {
      "id": "cancel_button",
      "color": "negative",
      "ripple": {
        center: true
      },
      "data-question": _vm.blockInfo.id
    },
    on: {
      "click": _vm.emitStop
    }
  }, [_vm._v(" " + _vm._s(_vm.$t('CodeBlocks.stop')) + " "), _c('q-icon', {
    attrs: {
      "right": "",
      "dark": "",
      "name": "stop"
    }
  })], 1)], 1)]), _c('transition', {
    attrs: {
      "appear": "",
      "enter-active-class": "animated fadeIn",
      "leave-active-class": "animated fadeOut"
    }
  }, [_c('div', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.showGlobalMessages,
      expression: "showGlobalMessages"
    }],
    staticClass: "globalState col-grow",
    staticStyle: {
      "align-self": "center"
    }
  }, [_c('div', {
    attrs: {
      "id": "message"
    },
    domProps: {
      "innerHTML": _vm._s(_vm.globalStateMessage)
    }
  })])])], 1) : _vm._e(), _c('transition', {
    attrs: {
      "appear": "",
      "enter-active-class": "animated fadeInup",
      "leave-active-class": "animated fadeOutDown"
    }
  }, [!_vm.isRunning ? _c('div', {
    staticClass: "q-mt-md"
  }, [_c('q-banner', {
    staticClass: "bg-warning",
    attrs: {
      "inline-actions": ""
    },
    scopedSlots: _vm._u([{
      key: "action",
      fn: function fn() {
        return [_vm.isReady && !_vm.canStop ? _c('q-btn', {
          attrs: {
            "flat": "",
            "color": "white"
          },
          on: {
            "click": _vm.emitRun
          }
        }, [_vm._v(" " + _vm._s(_vm.$t('CodeBlocks.start')) + " "), _c('q-icon', {
          attrs: {
            "right": "",
            "dark": "",
            "name": "play_arrow"
          }
        })], 1) : _vm._e()];
      },
      proxy: true
    }], null, false, 3640785926)
  }, [_vm._v(" Interpreter is not yet Ready. You may need to start it first. ")])], 1) : _vm._e()]), _c('Terminal', {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: _vm.allowsREPL && _vm.canStartREPL,
      expression: "allowsREPL && canStartREPL"
    }],
    attrs: {
      "console-sign": "$",
      "allow-arbitrary": "",
      "height": "500px",
      "blockInfo": _vm.blockInfo,
      "eventHub": _vm.eventHub
    },
    on: {
      "run": _vm.emitRun,
      "stop": _vm.emitStop
    }
  }), !_vm.allowsREPL ? _c('div', {
    staticClass: "q-mt-md"
  }, [_vm._v(" The current language does not support a REPL-Element ")]) : _vm._e(), !_vm.canStartREPL ? _c('div', {
    staticClass: "q-mt-md"
  }, [_vm._v(" Unable to start REPL-Environment. (Code execution, message passing and keep-alive need to be enabled) ")]) : _vm._e()], 1);
};
var CodeREPLvue_type_template_id_a208ad54_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/CodeREPL.vue?vue&type=template&id=a208ad54&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Terminal.vue?vue&type=template&id=2ec5dfe0&
var Terminalvue_type_template_id_2ec5dfe0_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _vm._m(0);
};
var Terminalvue_type_template_id_2ec5dfe0_staticRenderFns = [function () {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', {
    staticClass: "vue-terminal-wrapper"
  }, [_c('div', {
    staticClass: "basicterm",
    attrs: {
      "id": "terminal"
    }
  })]);
}];

// CONCATENATED MODULE: ./src/components/Terminal.vue?vue&type=template&id=2ec5dfe0&

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
var unsupportedIterableToArray = __webpack_require__("06c5");

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js









function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = Object(unsupportedIterableToArray["a" /* default */])(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
// EXTERNAL MODULE: ./src/lib/jquery.terminal.js
var jquery_terminal = __webpack_require__("d9d0");

// EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js
var jquery = __webpack_require__("1157");
var jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/Terminal.vue?vue&type=script&lang=ts&













function sleep(s) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, s);
  });
}
var Terminalvue_type_script_lang_ts_Terminal = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(Terminal, _Vue);
  var _super = Object(createSuper["a" /* default */])(Terminal);
  function Terminal() {
    Object(classCallCheck["a" /* default */])(this, Terminal);
    return _super.apply(this, arguments);
  }
  Object(createClass["a" /* default */])(Terminal, [{
    key: "compiler",
    get: function get() {
      return this.blockInfo.compiler;
    }
  }, {
    key: "welcomeMessage",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      var language = '';
      if (cmp !== undefined) {
        language = cmp.language;
      }
      return "{*_*} Interactive ".concat(language, " Shell\n------------------------------");
    }
  }, {
    key: "emitRun",
    value: function emitRun() {
      if (this.term !== undefined) {
        this.clear();
      }
      this.$emit('run');
    }
  }, {
    key: "emitStop",
    value: function emitStop() {
      this.$emit('stop');
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.term !== undefined) {
        this.term.clear();
        this.term.echo(this.welcomeMessage);
      }
    }
  }, {
    key: "mounted",
    value: function mounted() {
      var self = this;
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      var ps1 = cmp.language === 'python' ? 'py> ' : '>>> ',
        ps2 = '... ';
      function lock() {
        return Object(tslib_es6["a" /* __awaiter */])(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var resolve, ready;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                ready = self.term.ready;
                self.term.ready = new Promise(function (res) {
                  return resolve = res;
                });
                _context.next = 4;
                return ready;
              case 4:
                return _context.abrupt("return", resolve);
              case 5:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
      }
      function interpreter(command) {
        return Object(tslib_es6["a" /* __awaiter */])(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var unlock, _iterator, _step, c;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return lock();
              case 2:
                unlock = _context2.sent;
                _context2.prev = 3;
                self.term.pause();
                _iterator = _createForOfIteratorHelper(command.split('\n'));
                _context2.prev = 6;
                _iterator.s();
              case 8:
                if ((_step = _iterator.n()).done) {
                  _context2.next = 34;
                  break;
                }
                c = _step.value;
                _context2.prev = 10;
                if (!(c === '.stop')) {
                  _context2.next = 14;
                  break;
                }
                self.emitStop();
                return _context2.abrupt("return");
              case 14:
                if (!(c === '.restart')) {
                  _context2.next = 21;
                  break;
                }
                self.emitStop();
                self.clear();
                _context2.next = 19;
                return sleep(1000);
              case 19:
                self.emitRun();
                return _context2.abrupt("return");
              case 21:
                if (!(c === '.clear')) {
                  _context2.next = 24;
                  break;
                }
                self.term.clear();
                return _context2.abrupt("return");
              case 24:
                self.term.set_prompt(ps2);
                _context2.next = 27;
                return cmp.interpreter(c, function (incomplete) {
                  self.term.set_prompt(incomplete ? ps2 : ps1);
                }, function (msg) {
                  self.term.echo(msg, {
                    newline: false
                  });
                }, function (err) {
                  self.term.error(err);
                });
              case 27:
                _context2.next = 32;
                break;
              case 29:
                _context2.prev = 29;
                _context2.t0 = _context2["catch"](10);
                self.term.error(_context2.t0);
              case 32:
                _context2.next = 8;
                break;
              case 34:
                _context2.next = 39;
                break;
              case 36:
                _context2.prev = 36;
                _context2.t1 = _context2["catch"](6);
                _iterator.e(_context2.t1);
              case 39:
                _context2.prev = 39;
                _iterator.f();
                return _context2.finish(39);
              case 42:
                _context2.prev = 42;
                self.term.resume();
                _context2.next = 46;
                return sleep(10);
              case 46:
                unlock();
                return _context2.finish(42);
              case 48:
              case "end":
                return _context2.stop();
            }
          }, _callee2, null, [[3,, 42, 48], [6, 36, 39, 42], [10, 29]]);
        }));
      }
      var el = jquery_default()('#terminal', '.vue-terminal-wrapper');
      self.term = el.terminal(interpreter, {
        greetings: self.welcomeMessage,
        name: 'codeblocks_repl',
        height: this.height,
        prompt: ps1
      });
      self.term.ready = Promise.resolve();
      if (this.eventHub) {
        this.eventHub.$on('console-log', function (msg) {
          return self.term.echo(msg);
        });
        this.eventHub.$on('console-err', function (msg) {
          return self.term.error(msg);
        });
        this.eventHub.$on('clicked-run', function () {
          return self.clear();
        });
      }
    }
  }, {
    key: "beforeDestroy",
    value: function beforeDestroy() {
      if (this.eventHub) {
        this.eventHub.$off('console-log');
        this.eventHub.$off('console-err');
        this.eventHub.$off('clicked-run');
      }
    }
  }]);
  return Terminal;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: '250px'
})], Terminalvue_type_script_lang_ts_Terminal.prototype, "height", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], Terminalvue_type_script_lang_ts_Terminal.prototype, "blockInfo", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], Terminalvue_type_script_lang_ts_Terminal.prototype, "eventHub", void 0);
Terminalvue_type_script_lang_ts_Terminal = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], Terminalvue_type_script_lang_ts_Terminal);
/* harmony default export */ var Terminalvue_type_script_lang_ts_ = (Terminalvue_type_script_lang_ts_Terminal);
// CONCATENATED MODULE: ./src/components/Terminal.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_Terminalvue_type_script_lang_ts_ = (Terminalvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/Terminal.vue?vue&type=style&index=0&id=2ec5dfe0&prod&lang=css&
var Terminalvue_type_style_index_0_id_2ec5dfe0_prod_lang_css_ = __webpack_require__("08a0");

// CONCATENATED MODULE: ./src/components/Terminal.vue






/* normalize component */

var Terminal_component = Object(componentNormalizer["a" /* default */])(
  components_Terminalvue_type_script_lang_ts_,
  Terminalvue_type_template_id_2ec5dfe0_render,
  Terminalvue_type_template_id_2ec5dfe0_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var components_Terminal = (Terminal_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeREPL.vue?vue&type=script&lang=ts&






//helper to reset the canvas area if needed



var CodeREPLvue_type_script_lang_ts_CodeREPL = /*#__PURE__*/function (_BaseBlock) {
  Object(inherits["a" /* default */])(CodeREPL, _BaseBlock);
  var _super = Object(createSuper["a" /* default */])(CodeREPL);
  function CodeREPL() {
    Object(classCallCheck["a" /* default */])(this, CodeREPL);
    return _super.apply(this, arguments);
  }
  Object(createClass["a" /* default */])(CodeREPL, [{
    key: "hasContent",
    get: function get() {
      return false;
    }
  }, {
    key: "isRunning",
    get: function get() {
      return this.canStop;
    }
  }, {
    key: "canStartREPL",
    get: function get() {
      return this.blockInfo.runCode && this.blockInfo.messagePassing && this.blockInfo.keepAlive;
    }
  }, {
    key: "allowsREPL",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp === undefined) {
        return false;
      }
      return cmp.allowsREPL;
    }
  }, {
    key: "compiler",
    get: function get() {
      return this.blockInfo.compiler;
    }
  }, {
    key: "typeName",
    get: function get() {
      var s = this.block.type.toLowerCase();
      if (this.block.hidden) {
        s += '-hidden';
      }
      if (this.block.static) {
        s += '-static';
      }
      return s;
    }
  }, {
    key: "readyWhenMounted",
    get: function get() {
      return false;
    }
  }, {
    key: "terminal",
    get: function get() {
      return this.$refs.terminal;
    }
  }, {
    key: "emitRun",
    value: function emitRun() {
      this.$emit('run', this.block);
    }
  }, {
    key: "emitStop",
    value: function emitStop() {
      this.$emit('stop', this.block);
    }
  }, {
    key: "mounted",
    value: function mounted() {
      if (this.eventHub) {
        this.eventHub.$on('all-mounted', this.whenMounted);
      } else {
        this.whenMounted();
      }
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      this.waitReady(cmp);
    }
  }, {
    key: "beforeDestroy",
    value: function beforeDestroy() {
      if (this.eventHub) {
        this.eventHub.$off('all-mounted');
      }
      this.whenBlockIsDestroyed();
    }
  }, {
    key: "waitReady",
    value: function waitReady(cmp) {
      if (cmp === undefined || cmp.isReady) {
        this.whenBlockIsReady();
      } else {
        setTimeout(this.waitReady.bind(this, cmp), 500);
      }
    }
  }, {
    key: "whenMounted",
    value: function whenMounted() {
      this.emitRun();
    }
  }]);
  return CodeREPL;
}(BaseBlock["a" /* default */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodeREPLvue_type_script_lang_ts_CodeREPL.prototype, "eventHub", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodeREPLvue_type_script_lang_ts_CodeREPL.prototype, "blockInfo", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodeREPLvue_type_script_lang_ts_CodeREPL.prototype, "isReady", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodeREPLvue_type_script_lang_ts_CodeREPL.prototype, "canStop", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodeREPLvue_type_script_lang_ts_CodeREPL.prototype, "showGlobalMessages", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodeREPLvue_type_script_lang_ts_CodeREPL.prototype, "globalStateMessage", void 0);
CodeREPLvue_type_script_lang_ts_CodeREPL = Object(tslib_es6["b" /* __decorate */])([Object(lib["a" /* Component */])({
  components: {
    Terminal: components_Terminal
  }
})], CodeREPLvue_type_script_lang_ts_CodeREPL);
/* harmony default export */ var CodeREPLvue_type_script_lang_ts_ = (CodeREPLvue_type_script_lang_ts_CodeREPL);
// CONCATENATED MODULE: ./src/components/CodeREPL.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_CodeREPLvue_type_script_lang_ts_ = (CodeREPLvue_type_script_lang_ts_); 
// CONCATENATED MODULE: ./src/components/CodeREPL.vue





/* normalize component */

var CodeREPL_component = Object(componentNormalizer["a" /* default */])(
  components_CodeREPLvue_type_script_lang_ts_,
  CodeREPLvue_type_template_id_a208ad54_render,
  CodeREPLvue_type_template_id_a208ad54_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var components_CodeREPL = (CodeREPL_component.exports);




runtime_auto_import_default()(CodeREPL_component, 'components', {QBtn: QBtn["a" /* default */],QIcon: QIcon["a" /* default */],QBanner: QBanner["a" /* default */]});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/SimpleText.vue?vue&type=template&id=fead5814&scoped=true&

var SimpleTextvue_type_template_id_fead5814_scoped_true_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', [!_vm.editMode ? _c('div', {
    directives: [{
      name: "highlight",
      rawName: "v-highlight",
      value: _vm.language,
      expression: "language"
    }],
    domProps: {
      "innerHTML": _vm._s(_vm.previewValue)
    }
  }) : _c('TipTap', {
    staticClass: "editor q-my-3",
    attrs: {
      "value": _vm.value,
      "name": _vm.name,
      "language": _vm.language,
      "scopUUID": _vm.scopeUUID,
      "editMode": _vm.editMode
    },
    on: {
      "input": _vm.updatedContentDefered
    }
  })], 1);
};
var SimpleTextvue_type_template_id_fead5814_scoped_true_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/SimpleText.vue?vue&type=template&id=fead5814&scoped=true&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/TipTap.vue?vue&type=template&id=5a368702&scoped=true&

var TipTapvue_type_template_id_5a368702_scoped_true_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _c('div', {
    staticClass: "row q-ma-0 q-pa-0"
  }, [_c('div', {
    staticClass: "col-xs-12 col-md-6 q-px-sm"
  }, [_c('q-input', {
    ref: "editBox",
    staticClass: "plain accqstXmlInput noRTEditor",
    attrs: {
      "type": "textarea",
      "autogrow": "",
      "filled": "",
      "name": _vm.name,
      "label": "HTML Source",
      "background-color": "blue-grey darken-3"
    },
    model: {
      value: _vm.text,
      callback: function callback($$v) {
        _vm.text = $$v;
      },
      expression: "text"
    }
  })], 1), _c('div', {
    staticClass: "col-xs-12 col-md-6 q-px-sm"
  }, [_c('div', {
    staticClass: "q-field__label no-pointer-events ellipsis text-caption wysiwyg"
  }, [_vm._v(" Preview ")]), _c('div', {
    directives: [{
      name: "highlight",
      rawName: "v-highlight",
      value: _vm.language,
      expression: "language"
    }, {
      name: "tagged",
      rawName: "v-tagged",
      value: _vm.scopeUUID,
      expression: "scopeUUID"
    }],
    domProps: {
      "innerHTML": _vm._s(_vm.text)
    }
  })])]);
};
var TipTapvue_type_template_id_5a368702_scoped_true_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/TipTap.vue?vue&type=template&id=5a368702&scoped=true&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/TipTap.vue?vue&type=script&lang=ts&











var TipTapvue_type_script_lang_ts_TipTap = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(TipTap, _Vue);
  var _super = Object(createSuper["a" /* default */])(TipTap);
  function TipTap() {
    Object(classCallCheck["a" /* default */])(this, TipTap);
    return _super.apply(this, arguments);
  }
  Object(createClass["a" /* default */])(TipTap, [{
    key: "text",
    get: function get() {
      return this.value;
    },
    set: function set(v) {
      this.updatedContent(v);
    }
  }, {
    key: "updatedContent",
    value: function updatedContent(v) {
      this.$emit('input', v);
    }
  }, {
    key: "replaceTemplateTags",
    value: function replaceTemplateTags(o) {
      if (!this.editMode) {
        return;
      }
      if (o.scopeUUID != this.scopeUUID) {
        return;
      }
      this.updatedContent(lib["c" /* Vue */].$tagger.replaceTemplateTagInString(this.text, o.name, o.newValue));
    }
  }, {
    key: "mounted",
    value: function mounted() {
      var eb = this.$refs.editBox;
      //we need this for StudON to make sure tinyMCE is not taking over :D
      eb.$el.querySelectorAll('textarea[name]').forEach(function (el) {
        el.className = (el.className + ' accqstXmlInput noRTEditor').trim();
      });
      lib["c" /* Vue */].$tagger.$on('replace-template-tag', this.replaceTemplateTags);
    }
  }, {
    key: "beforeDestroy",
    value: function beforeDestroy() {
      lib["c" /* Vue */].$tagger.$off('replace-template-tag', this.replaceTemplateTags);
    }
  }]);
  return TipTap;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: ''
})], TipTapvue_type_script_lang_ts_TipTap.prototype, "value", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: ''
})], TipTapvue_type_script_lang_ts_TipTap.prototype, "name", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: ''
})], TipTapvue_type_script_lang_ts_TipTap.prototype, "scopeUUID", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], TipTapvue_type_script_lang_ts_TipTap.prototype, "editMode", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: 'javascript'
})], TipTapvue_type_script_lang_ts_TipTap.prototype, "language", void 0);
TipTapvue_type_script_lang_ts_TipTap = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], TipTapvue_type_script_lang_ts_TipTap);
/* harmony default export */ var TipTapvue_type_script_lang_ts_ = (TipTapvue_type_script_lang_ts_TipTap);
// CONCATENATED MODULE: ./src/components/TipTap.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_TipTapvue_type_script_lang_ts_ = (TipTapvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/TipTap.vue?vue&type=style&index=0&id=5a368702&prod&lang=stylus&scoped=true&
var TipTapvue_type_style_index_0_id_5a368702_prod_lang_stylus_scoped_true_ = __webpack_require__("6e02");

// EXTERNAL MODULE: ./node_modules/quasar/src/components/field/QField.js + 2 modules
var QField = __webpack_require__("8572");

// CONCATENATED MODULE: ./src/components/TipTap.vue






/* normalize component */

var TipTap_component = Object(componentNormalizer["a" /* default */])(
  components_TipTapvue_type_script_lang_ts_,
  TipTapvue_type_template_id_5a368702_scoped_true_render,
  TipTapvue_type_template_id_5a368702_scoped_true_staticRenderFns,
  false,
  null,
  "5a368702",
  null
  
)

/* harmony default export */ var components_TipTap = (TipTap_component.exports);



runtime_auto_import_default()(TipTap_component, 'components', {QInput: QInput["a" /* default */],QField: QField["a" /* default */]});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/SimpleText.vue?vue&type=script&lang=ts&









var SimpleTextvue_type_script_lang_ts_SimpleText = /*#__PURE__*/function (_BaseBlock) {
  Object(inherits["a" /* default */])(SimpleText, _BaseBlock);
  var _super = Object(createSuper["a" /* default */])(SimpleText);
  function SimpleText() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, SimpleText);
    _this = _super.apply(this, arguments);
    _this.textUpdateTimer = null;
    _this.textUpdateStartTime = 0;
    return _this;
  }
  Object(createClass["a" /* default */])(SimpleText, [{
    key: "updatedContentDefered",
    value: function updatedContentDefered(newVal) {
      var _this2 = this;
      if (!this.editMode) {
        this.updatedContent(newVal);
        return;
      }
      var now = new Date().getTime();
      //clear an existing update timeout
      if (this.textUpdateTimer !== null) {
        clearTimeout(this.textUpdateTimer);
        this.textUpdateTimer = null;
      } else {
        this.textUpdateStartTime = now;
      }
      var doIt = function doIt() {
        _this2.textUpdateTimer = null;
        _this2.updatedContent(newVal);
      };
      //did we wait for a maximum time? run
      if (now - this.textUpdateStartTime > "800") {
        doIt();
        return;
      }
      this.textUpdateTimer = setTimeout(function () {
        doIt();
      }, "150");
    }
  }, {
    key: "updatedContent",
    value: function updatedContent(v) {
      //console.log('Updating')
      //this.value = v
      this.$emit('input', v);
    }
  }]);
  return SimpleText;
}(BaseBlock["a" /* default */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])()], SimpleTextvue_type_script_lang_ts_SimpleText.prototype, "language", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: ''
})], SimpleTextvue_type_script_lang_ts_SimpleText.prototype, "value", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: ''
})], SimpleTextvue_type_script_lang_ts_SimpleText.prototype, "name", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: ''
})], SimpleTextvue_type_script_lang_ts_SimpleText.prototype, "scopeUUID", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], SimpleTextvue_type_script_lang_ts_SimpleText.prototype, "editMode", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: ''
})], SimpleTextvue_type_script_lang_ts_SimpleText.prototype, "previewValue", void 0);
SimpleTextvue_type_script_lang_ts_SimpleText = Object(tslib_es6["b" /* __decorate */])([Object(lib["a" /* Component */])({
  components: {
    TipTap: components_TipTap
  }
})], SimpleTextvue_type_script_lang_ts_SimpleText);
/* harmony default export */ var SimpleTextvue_type_script_lang_ts_ = (SimpleTextvue_type_script_lang_ts_SimpleText);
// CONCATENATED MODULE: ./src/components/SimpleText.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_SimpleTextvue_type_script_lang_ts_ = (SimpleTextvue_type_script_lang_ts_); 
// CONCATENATED MODULE: ./src/components/SimpleText.vue





/* normalize component */

var SimpleText_component = Object(componentNormalizer["a" /* default */])(
  components_SimpleTextvue_type_script_lang_ts_,
  SimpleTextvue_type_template_id_fead5814_scoped_true_render,
  SimpleTextvue_type_template_id_fead5814_scoped_true_staticRenderFns,
  false,
  null,
  "fead5814",
  null
  
)

/* harmony default export */ var components_SimpleText = (SimpleText_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/DataBlock.vue?vue&type=template&id=0deb24d0&scoped=true&


var DataBlockvue_type_template_id_0deb24d0_scoped_true_render = function render() {
  var _vm = this,
    _c = _vm._self._c,
    _setup = _vm._self._setupProxy;
  return _vm.editMode ? _c('div', [_c('transition', {
    attrs: {
      "enter-active-class": "animated fadeIn",
      "leave-active-class": "animated fadeOut"
    }
  }, [_vm.hasError ? _c('q-banner', {
    staticClass: "text-white bg-red q-mb-md",
    attrs: {
      "inline-actions": ""
    },
    scopedSlots: _vm._u([{
      key: "action",
      fn: function fn() {
        return [_c('q-btn', {
          attrs: {
            "flat": "",
            "color": "white",
            "label": "OK"
          },
          on: {
            "click": function click($event) {
              _vm.error = '';
            }
          }
        })];
      },
      proxy: true
    }], null, false, 1144489300)
  }, [_vm._v(" " + _vm._s(_vm.error) + " ")]) : _vm._e()], 1), _vm.editMode ? _c('div', {
    staticClass: "row justify-between controlContainer"
  }, [_c('div', {
    staticClass: "multiDiv"
  }, [_c('div', {
    staticClass: "inlined-input q-mr-sm"
  }, [_c('q-btn', {
    attrs: {
      "flat": "",
      "round": "",
      "color": "primary",
      "icon": "info",
      "size": "xs"
    },
    on: {
      "click": _vm.showInfoDialog
    }
  })], 1), _c('div', {
    staticClass: "q-mr-lg inlined-input noMoreBottomMargin"
  }, [_c('q-input', {
    staticClass: "noMoreBottomMargin",
    attrs: {
      "label": "Name",
      "rounded": "",
      "filled": ""
    },
    model: {
      value: _vm.name,
      callback: function callback($$v) {
        _vm.name = $$v;
      },
      expression: "name"
    }
  })], 1), _c('div', {
    staticClass: "inlined-input q-mr-md"
  }, [_c('input', {
    ref: "jsonFileUploader",
    staticClass: "jsonFileUploader",
    attrs: {
      "type": "file"
    },
    on: {
      "change": function change($event) {
        return _vm.onUploadJson($event);
      }
    }
  }), _c('q-btn', {
    attrs: {
      "color": "teal-9",
      "filled": "",
      "label": "Load JSON",
      "icon": "cloud_upload"
    },
    on: {
      "click": _vm.openJson
    }
  })], 1), _c('div', {
    staticClass: "inlined-input q-mr-md"
  }, [_c('input', {
    ref: "plainFileUploader",
    staticClass: "plainFileUploader",
    attrs: {
      "type": "file"
    },
    on: {
      "change": function change($event) {
        return _vm.onUploadPlain($event);
      }
    }
  }), _c('q-btn', {
    attrs: {
      "color": "teal-8",
      "filled": "",
      "label": "Add Text Data",
      "icon": "post_add"
    },
    on: {
      "click": _vm.openPlain
    }
  })], 1), _c('div', {
    staticClass: "inlined-input"
  }, [_c('input', {
    ref: "imageFileUploader",
    staticClass: "imageFileUploader",
    attrs: {
      "type": "file"
    },
    on: {
      "change": function change($event) {
        return _vm.onUploadImage($event);
      }
    }
  }), _c('q-btn', {
    attrs: {
      "color": "teal",
      "filled": "",
      "label": "Add Image Data",
      "icon": "add_photo_alternate"
    },
    on: {
      "click": _vm.openImage
    }
  })], 1)]), _c('div', {
    staticClass: "col-grow"
  }), _c('div', [_vm.editMode ? _c('q-btn-group', {
    staticClass: "q-mb-sm",
    attrs: {
      "rounded": ""
    }
  }, [_c('q-btn', {
    attrs: {
      "color": _vm.isExpandedAuto ? 'primary' : 'blue-grey-4',
      "small": "",
      "label": "Auto",
      "icon": "video_label"
    },
    on: {
      "click": _vm.setExpandedAuto
    }
  }), _c('q-btn', {
    attrs: {
      "color": _vm.isExpandedLarge ? 'primary' : 'blue-grey-4',
      "small": "",
      "label": "Large",
      "icon": "call_to_action"
    },
    on: {
      "click": _vm.setExpandedLarge
    }
  }), _c('q-btn', {
    attrs: {
      "color": _vm.isExpandedTiny ? 'primary' : 'blue-grey-4',
      "small": "",
      "label": "Small",
      "icon": "visibility_off"
    },
    on: {
      "click": _vm.setExpandedTiny
    }
  })], 1) : _vm._e()], 1)]) : _vm._e(), _c('q-slide-transition', [_c('codemirror', {
    ref: "codeBox",
    class: "accqstXmlInput noRTEditor codebox",
    attrs: {
      "value": _vm.code,
      "options": _vm.options,
      "name": "".concat(_vm.namePrefix, "block[").concat(_vm.block.parentID, "][").concat(_vm.block.id, "]"),
      "id": "teQ".concat(_vm.block.parentID, "B").concat(_vm.block.id),
      "data-question": _vm.block.parentID
    },
    on: {
      "ready": _vm.onCodeReady,
      "focus": _vm.onCodeFocus,
      "input": _vm.onCodeChange
    }
  })], 1)], 1) : _vm._e();
};
var DataBlockvue_type_template_id_0deb24d0_scoped_true_staticRenderFns = [];

// CONCATENATED MODULE: ./src/components/DataBlock.vue?vue&type=template&id=0deb24d0&scoped=true&

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.starts-with.js
var es_string_starts_with = __webpack_require__("2ca0");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/solarized.css
var solarized = __webpack_require__("8c06");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/base16-dark.css
var base16_dark = __webpack_require__("8c2e");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/base16-light.css
var base16_light = __webpack_require__("cc10");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/duotone-dark.css
var duotone_dark = __webpack_require__("e8b0");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/duotone-light.css
var duotone_light = __webpack_require__("b6fc");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/xq-dark.css
var xq_dark = __webpack_require__("bd58");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/xq-light.css
var xq_light = __webpack_require__("8d7e");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/blackboard.css
var blackboard = __webpack_require__("7393");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/midnight.css
var midnight = __webpack_require__("1ad7");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/neo.css
var neo = __webpack_require__("d5db");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/mbo.css
var mbo = __webpack_require__("9603");

// EXTERNAL MODULE: ./node_modules/codemirror/theme/mdn-like.css
var mdn_like = __webpack_require__("eb8f");

// EXTERNAL MODULE: ./node_modules/codemirror/mode/javascript/javascript.js
var javascript = __webpack_require__("f9d4");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/DataBlock.vue?vue&type=script&lang=ts&
















//helper to reset the canvas area if needed




//themes












//languages

var DataBlockvue_type_script_lang_ts_DataBlock = /*#__PURE__*/function (_BaseBlock) {
  Object(inherits["a" /* default */])(DataBlock, _BaseBlock);
  var _super = Object(createSuper["a" /* default */])(DataBlock);
  function DataBlock() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, DataBlock);
    _this = _super.apply(this, arguments);
    _this.needsCodeRebuild = false;
    _this.error = '';
    return _this;
  }
  Object(createClass["a" /* default */])(DataBlock, [{
    key: "codeBox",
    get: function get() {
      return this.$refs.codeBox;
    }
  }, {
    key: "codemirror",
    get: function get() {
      if (this.codeBox === undefined || this.codeBox === null) {
        return undefined;
      }
      return this.codeBox.codemirror;
    }
  }, {
    key: "originalMode",
    get: function get() {
      if (this.block.obj === null) {
        return false;
      }
      return this.block.obj.requestsOriginalVersion();
    }
  }, {
    key: "options",
    get: function get() {
      return {
        // codemirror options
        mode: this.$CodeBlock.mimeType('javascript'),
        theme: this.theme,
        lineNumbers: true,
        line: true,
        tabSize: 4,
        indentUnit: 4,
        autoCloseBrackets: true,
        readOnly: !this.editMode,
        firstLineNumber: 1,
        gutters: ['diagnostics', 'CodeMirror-linenumbers']
      };
    }
  }, {
    key: "code",
    get: function get() {
      if (!this.editMode) {
        return this.block.actualContent();
      }
      return this.block.content;
    }
  }, {
    key: "name",
    get: function get() {
      return this.block.name;
    },
    set: function set(newName) {
      this.block.name = newName;
    }
  }, {
    key: "visibleLines",
    get: function get() {
      if (this.block.codeExpanded == ICodeBlocks["a" /* CodeExpansionType */].TINY) {
        return '2.4';
      } else if (this.block.codeExpanded == ICodeBlocks["a" /* CodeExpansionType */].LARGE) {
        return '33.4';
      }
      return 'auto';
    }
  }, {
    key: "created",
    value: function created() {
      this.eventHub.$on('before-run', this.resetBeforeRun);
      this.eventHub.$on('render-diagnostics', this.updateErrors);
    }
  }, {
    key: "mounted",
    value: function mounted() {
      var hasErrors = this.block && this.block.obj && this.block.obj.err.length > 0;
      if (hasErrors) {
        this.updateErrors();
      }
      this.updateHeight();
    }
  }, {
    key: "beforeDestroy",
    value: function beforeDestroy() {
      this.eventHub.$off('before-run', this.resetBeforeRun);
      this.eventHub.$off('render-diagnostics', this.updateErrors);
    }
  }, {
    key: "isExpandedLarge",
    get: function get() {
      return this.block.codeExpanded == ICodeBlocks["a" /* CodeExpansionType */].LARGE;
    }
  }, {
    key: "isExpandedTiny",
    get: function get() {
      return this.block.codeExpanded == ICodeBlocks["a" /* CodeExpansionType */].TINY;
    }
  }, {
    key: "isExpandedAuto",
    get: function get() {
      return this.block.codeExpanded == ICodeBlocks["a" /* CodeExpansionType */].AUTO;
    }
  }, {
    key: "setExpandedLarge",
    value: function setExpandedLarge() {
      this.setExpanded(ICodeBlocks["a" /* CodeExpansionType */].LARGE);
    }
  }, {
    key: "setExpandedTiny",
    value: function setExpandedTiny() {
      this.setExpanded(ICodeBlocks["a" /* CodeExpansionType */].TINY);
    }
  }, {
    key: "setExpandedAuto",
    value: function setExpandedAuto() {
      this.setExpanded(ICodeBlocks["a" /* CodeExpansionType */].AUTO);
    }
  }, {
    key: "setExpanded",
    value: function setExpanded(val) {
      this.block.codeExpanded = val;
      if (this.block.codeExpanded != ICodeBlocks["a" /* CodeExpansionType */].TINY) {
        this.$CodeBlock.refreshAllCodeMirrors();
      }
      this.updateHeight();
    }
  }, {
    key: "updateErrors",
    value: function updateErrors() {
      return false;
    }
  }, {
    key: "resetBeforeRun",
    value: function resetBeforeRun() {}
  }, {
    key: "onCodeChange",
    value: function onCodeChange(newCode) {
      //copy the content to the actual textbox processed by StudON
      var tb = this.codeBox.$el.querySelector('textarea[name]');
      tb.value = newCode;
      //copy code to the block structure
      this.block.content = newCode;
      if (this.editMode) {
        this.needsCodeRebuild = true;
      }
    }
  }, {
    key: "onCodeFocus",
    value: function onCodeFocus(editor) {}
  }, {
    key: "onDidInit",
    value: function onDidInit() {
      this.updateErrors();
    }
  }, {
    key: "onCodeReady",
    value: function onCodeReady(editor) {
      var _this2 = this;
      //we need this for StudON to make sure tinyMCE is not taking over :D
      if (this.codemirror && this.codemirror.display && this.codemirror.display.input && this.codemirror.display.input.textarea) {
        this.codemirror.display.input.textarea.className = 'noRTEditor';
      }
      this.codeBox.$el.querySelectorAll('textarea[name]').forEach(function (el) {
        el.className = (el.className + ' accqstXmlInput noRTEditor').trim();
        el.id = _this2.codeBox.$el.id;
        $(el).text(_this2.block.content);
        el.setAttribute('data-question', "".concat(_this2.block.parentID));
        if (_this2.editMode) {
          el.setAttribute('is-editmode', "".concat(_this2.editMode));
        }
      });
      this.onCodeChange(this.block.content);
      this.whenBlockIsReady();
    }
  }, {
    key: "updateHeight",
    value: function updateHeight() {
      if (this.visibleLines === 'auto') {
        if (this.codemirror) {
          this.codemirror.setSize('height', 'auto');
        }
      } else {
        if (this.codemirror) {
          this.codemirror.setSize(null, Math.round(20 * Math.max(1, +this.visibleLines)) + 9);
        }
      }
    }
  }, {
    key: "showInfoDialog",
    value: function showInfoDialog() {
      this.$q.dialog({
        title: this.$l('DataBlock.InfoCaption'),
        message: this.$l('DataBlock.Info').replace('{NAME}', this.name),
        html: true,
        style: 'width:75%'
      }).onOk(function () {
        // console.log('OK')
      }).onCancel(function () {
        // console.log('Cancel')
      }).onDismiss(function () {
        // console.log('I am triggered on both OK and Cancel')
      });
    }
  }, {
    key: "hasError",
    get: function get() {
      return this.error !== '';
    }
  }, {
    key: "onUpload",
    value: function onUpload(uploader, validateFileType, processor, action) {
      var _this3 = this;
      if (uploader.files === undefined || uploader.files.length < 1) {
        return;
      }
      var files = uploader.files;
      var _loop = function _loop() {
        var fl = files[i];
        var type = fl.type;
        if (fl.type == '') {
          var ext = fl.name.split('.').pop();
          var knownTextExtensions = ['obj', 'mat', 'vsh', 'fsh', 'ply'];
          if (knownTextExtensions.indexOf(ext) === 0) {
            type = 'text/' + ext;
          }
          console.log(ext, type);
        }
        //console.log(fl)
        if (!validateFileType(type)) {
          _this3.error = "Uploads of type '".concat(type, "' are not allowed.");
          console.error(_this3.error);
          return "break";
        }
        if (fl.size > 500 * 1025) {
          _this3.error = "Maximum allowed upload size are 500kB.";
          console.error(_this3.error);
          return "break";
        }
        var fr = new FileReader();
        fr.onload = function () {
          action(fl.name, fr.result);
        };
        fr.onerror = function (e) {
          console.error(fr.error);
          _this3.error = fr.error === undefined || fr.error === null ? '' : fr.error.message;
        };
        processor(fl, fr);
      };
      for (var i = 0; i < files.length; i++) {
        var _ret = _loop();
        if (_ret === "break") break;
      }
      uploader.value = '';
    }
  }, {
    key: "openImage",
    value: function openImage() {
      var uploader = this.$refs['imageFileUploader'];
      uploader.click();
    }
  }, {
    key: "openPlain",
    value: function openPlain() {
      var uploader = this.$refs['plainFileUploader'];
      uploader.click();
    }
  }, {
    key: "openJson",
    value: function openJson() {
      var uploader = this.$refs['jsonFileUploader'];
      uploader.click();
    }
  }, {
    key: "onUploadImage",
    value: function onUploadImage(event) {
      var _this4 = this;
      var uploader = this.$refs['imageFileUploader'];
      this.onUpload(uploader, function (type) {
        return type.startsWith('image/');
      }, function (fl, fr) {
        return fr.readAsDataURL(fl);
      }, function (fileName, content) {
        return _this4.addImageURL(fileName, content);
      });
    }
  }, {
    key: "onUploadPlain",
    value: function onUploadPlain(event) {
      var _this5 = this;
      var uploader = this.$refs['plainFileUploader'];
      this.onUpload(uploader, function (type) {
        return type.startsWith('text/');
      }, function (fl, fr) {
        return fr.readAsText(fl);
      }, function (fileName, content) {
        return _this5.loadPlain(fileName, content);
      });
    }
  }, {
    key: "onUploadJson",
    value: function onUploadJson(event) {
      var _this6 = this;
      var uploader = this.$refs['jsonFileUploader'];
      this.onUpload(uploader, function (type) {
        return type.trim() === 'application/json' || type.trim() === 'text/json';
      }, function (fl, fr) {
        return fr.readAsText(fl);
      }, function (fileName, content) {
        return _this6.loadJson(fileName, content);
      });
    }
  }, {
    key: "loadJson",
    value: function loadJson(fileName, txt) {
      this.block.content = txt;
    }
  }, {
    key: "loadPlain",
    value: function loadPlain(fileName, txt) {
      this.addToContent(fileName, txt);
    }
  }, {
    key: "addImageURL",
    value: function addImageURL(fileName, img) {
      this.addToContent(fileName, img);
    }
  }, {
    key: "addToContent",
    value: function addToContent(fileName, data) {
      var json = {};
      try {
        json = JSON.parse(this.block.content);
      } catch (e) {
        console.error(e);
      }
      var i = -1;
      var name;
      do {
        i++;
        if (i == 0) {
          name = fileName;
        } else {
          name = "".concat(fileName, "_").concat(i);
        }
      } while (json[name] !== undefined);
      json[name] = data;
      this.block.content = JSON.stringify(json, undefined, 2);
    }
  }, {
    key: "images",
    get: function get() {
      return [];
    },
    set: function set(val) {
      console.log('IMAGES:' + val);
    }
  }]);
  return DataBlock;
}(BaseBlock["a" /* default */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: ''
})], DataBlockvue_type_script_lang_ts_DataBlock.prototype, "namePrefix", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], DataBlockvue_type_script_lang_ts_DataBlock.prototype, "finalOutputObject", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], DataBlockvue_type_script_lang_ts_DataBlock.prototype, "block", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: false
})], DataBlockvue_type_script_lang_ts_DataBlock.prototype, "editMode", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  default: 'base16-dark'
})], DataBlockvue_type_script_lang_ts_DataBlock.prototype, "theme", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], DataBlockvue_type_script_lang_ts_DataBlock.prototype, "eventHub", void 0);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])()], DataBlockvue_type_script_lang_ts_DataBlock.prototype, "tagSet", void 0);
DataBlockvue_type_script_lang_ts_DataBlock = Object(tslib_es6["b" /* __decorate */])([Object(lib["a" /* Component */])({
  components: {}
})], DataBlockvue_type_script_lang_ts_DataBlock);
/* harmony default export */ var DataBlockvue_type_script_lang_ts_ = (DataBlockvue_type_script_lang_ts_DataBlock);
// CONCATENATED MODULE: ./src/components/DataBlock.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_DataBlockvue_type_script_lang_ts_ = (DataBlockvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/DataBlock.vue?vue&type=style&index=0&id=0deb24d0&prod&lang=sass&scoped=true&
var DataBlockvue_type_style_index_0_id_0deb24d0_prod_lang_sass_scoped_true_ = __webpack_require__("be02");

// EXTERNAL MODULE: ./src/components/DataBlock.vue?vue&type=style&index=1&id=0deb24d0&prod&lang=stylus&
var DataBlockvue_type_style_index_1_id_0deb24d0_prod_lang_stylus_ = __webpack_require__("8233");

// CONCATENATED MODULE: ./src/components/DataBlock.vue







/* normalize component */

var DataBlock_component = Object(componentNormalizer["a" /* default */])(
  components_DataBlockvue_type_script_lang_ts_,
  DataBlockvue_type_template_id_0deb24d0_scoped_true_render,
  DataBlockvue_type_template_id_0deb24d0_scoped_true_staticRenderFns,
  false,
  null,
  "0deb24d0",
  null
  
)

/* harmony default export */ var components_DataBlock = (DataBlock_component.exports);






runtime_auto_import_default()(DataBlock_component, 'components', {QBanner: QBanner["a" /* default */],QBtn: QBtn["a" /* default */],QInput: QInput["a" /* default */],QBtnGroup: QBtnGroup,QSlideTransition: QSlideTransition["a" /* default */]});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlocks.vue?vue&type=script&lang=ts&

























//import Blockly from '@/components/Blockly/Blockly.vue'





function formatOutput(result) {
  var regex = /^@(bold|italic|em)?(red|green|blue|cyan|magenta|yellow|orange|gray|#[\da-f]{6}|#[\da-f]{8}):(.*)/gim;
  return result.split('\n').map(function (line, nr) {
    var m;
    if ((m = regex.exec(result)) !== null) {
      var style = '';
      if (m[2] === 'gray') {
        style = 'style="color:silver"';
      } else if (m[2] !== undefined) {
        style = "style=\"color:".concat(m[2], "\"");
      }
      if (m[1] === 'bold') {
        line = "<b ".concat(style, ">").concat(m[3], "</b>");
      } else if (m[1] === 'italic' || m[1] === 'em') {
        line = "<em ".concat(style, ">").concat(m[3], "</em>");
      } else {
        line = "<span ".concat(style, ">").concat(m[3], "</span>");
      }
    }
    return line;
  }).join('\n');
}
var Blockly = function Blockly() {
  return __webpack_require__.e(/* import() */ 1).then(__webpack_require__.bind(null, "c3c6"));
};
var CodeBlocksvue_type_script_lang_ts_CodeBlocks = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(CodeBlocks, _Vue);
  var _super = Object(createSuper["a" /* default */])(CodeBlocks);
  function CodeBlocks() {
    var _this;
    Object(classCallCheck["a" /* default */])(this, CodeBlocks);
    _this = _super.apply(this, arguments);
    _this.didInitialize = false;
    _this.outputHTML = '';
    _this.output = '';
    _this.sansoutput = '';
    _this.didClip = false;
    _this._finalOutputObject = null;
    _this.eventHub = new lib["c" /* Vue */]();
    _this.didRunOnce = false;
    _this.bookmarkedBlock = null;
    _this.triggerRecompileWhenFinished = false;
    _this.continuousCodeUpdateTimer = null;
    return _this;
  }
  Object(createClass["a" /* default */])(CodeBlocks, [{
    key: "continuousCompile",
    get: function get() {
      if (this.editMode) {
        return false;
      }
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp) {
        return cmp.allowsContinousCompilation;
      }
      return false;
    }
  }, {
    key: "finalOutputObject",
    get: function get() {
      if (this._finalOutputObject === null || this._finalOutputObject === undefined) {
        return {
          initialOutput: '',
          output: '',
          processedOutput: {
            type: 'text',
            text: '',
            json: undefined
          },
          sansoutput: '',
          outputElement: $(this.outputElement)
        };
      }
      return this._finalOutputObject;
    }
  }, {
    key: "options",
    get: function get() {
      return {
        language: this.language,
        compiler: this.compiler,
        executionTimeout: this.executionTimeout,
        maxCharacters: this.maxCharacters,
        runCode: this.runCode,
        domLibs: this.domLibraries,
        workerLibs: this.workerLibraries,
        id: this.blockInfo.id,
        codeTheme: this.codeTheme,
        solutionTheme: this.solutionTheme,
        outputParser: this.outputParser,
        randomizer: this.blockInfo.randomizer,
        continuousCompilation: this.blockInfo.continuousCompilation,
        persistentArguments: this.blockInfo.persistentArguments,
        messagePassing: this.blockInfo.messagePassing,
        keepAlive: this.blockInfo.keepAlive
      };
    }
  }, {
    key: "blocks",
    get: function get() {
      return this.blockInfo.blocks;
    }
  }, {
    key: "language",
    get: function get() {
      return this.blockInfo.language;
    }
  }, {
    key: "blockid",
    get: function get() {
      return this.blockInfo.id;
    }
  }, {
    key: "executionTimeout",
    get: function get() {
      return this.blockInfo.executionTimeout;
    }
  }, {
    key: "maxCharacters",
    get: function get() {
      return this.blockInfo.maxCharacters;
    }
  }, {
    key: "compiler",
    get: function get() {
      return this.blockInfo.compiler;
    }
  }, {
    key: "runCode",
    get: function get() {
      return this.blockInfo.runCode;
    }
  }, {
    key: "domLibraries",
    get: function get() {
      return this.blockInfo.domLibs;
    }
  }, {
    key: "workerLibraries",
    get: function get() {
      return this.blockInfo.workerLibs;
    }
  }, {
    key: "solutionTheme",
    get: function get() {
      return this.blockInfo.solutionTheme;
    }
  }, {
    key: "codeTheme",
    get: function get() {
      return this.blockInfo.codeTheme;
    }
  }, {
    key: "readonly",
    get: function get() {
      return this.blockInfo.readonly;
    }
  }, {
    key: "outputParser",
    get: function get() {
      return this.blockInfo.outputParser;
    }
  }, {
    key: "editMode",
    get: function get() {
      return false;
    }
  }, {
    key: "hasOutput",
    get: function get() {
      return this.outputHTML !== undefined && this.outputHTML != '';
    }
  }, {
    key: "mimeType",
    get: function get() {
      return this.$CodeBlock.mimeType(this.language);
    }
  }, {
    key: "isReady",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (!cmp) {
        return false;
      }
      return this.didInitialize && cmp.isReady && !cmp.isRunning && !this.$compilerState.runButtonForceHide;
    }
  }, {
    key: "canRun",
    get: function get() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (!cmp) {
        return false;
      }
      return cmp.canRun && this.runCode;
    }
  }, {
    key: "randomizerActive",
    get: function get() {
      return this.blockInfo.randomizer.active;
    }
  }, {
    key: "activeTagSet",
    get: function get() {
      if (!this.randomizerActive) {
        return undefined;
      }
      return this.tagSet(this.blockInfo.randomizer.previewIndex);
    }
  }, {
    key: "completeSource",
    get: function get() {
      return this.blocks.filter(function (b) {
        return b.hasCode;
      }).map(function (b) {
        return b.actualContent();
      }).reduce(function (p, c) {
        return p + '\n' + c;
      }, '');
    }
  }, {
    key: "showGlobalMessages",
    get: function get() {
      return !this.$compilerState.globalStateHidden;
    }
  }, {
    key: "playgrounds",
    get: function get() {
      return this.blocks.filter(function (b) {
        return b.type == 'PLAYGROUND';
      });
    }
  }, {
    key: "dataBlocks",
    get: function get() {
      return this.blocks.filter(function (b) {
        return b.type == 'DATA';
      });
    }
  }, {
    key: "outputElement",
    get: function get() {
      return this.$refs.output;
    }
  }, {
    key: "addonClass",
    get: function get() {
      var cl = '';
      if (this.editMode) {
        cl += 'editmode ';
      }
      if (this.readonly) {
        cl += 'block-readonly ';
      }
      return cl;
    }
  }, {
    key: "backgroundColorClass",
    get: function get() {
      return this.editMode ? 'blue-grey darken-4' : '';
    }
  }, {
    key: "blockBecameReady",
    value: function blockBecameReady() {
      var _this2 = this;
      var readyCount = this.blockInfo.blocks.map(function (b) {
        return b.readyCount;
      }).reduce(function (p, c) {
        return p + c;
      }, 0);
      if (readyCount == this.blockInfo.blocks.length) {
        this.$nextTick(function () {
          _this2.eventHub.$emit('all-mounted', {});
        });
      }
      console.d('Ready', readyCount, this.blockInfo.blocks.length);
    }
  }, {
    key: "tagSet",
    value: function tagSet(nr) {
      return this.blockInfo.randomizer.sets[nr];
    }
  }, {
    key: "themeForBlock",
    value: function themeForBlock(bl) {
      return bl.themeForCodeBlock;
    }
  }, {
    key: "blockById",
    value: function blockById(id) {
      return this.blocks.find(function (block) {
        return block.id == id;
      });
    }
  }, {
    key: "onTypeChange",
    value: function onTypeChange(nfo) {}
  }, {
    key: "onVisibleLinesChange",
    value: function onVisibleLinesChange(nfo) {}
  }, {
    key: "onPlacementChange",
    value: function onPlacementChange(nfo) {}
  }, {
    key: "onScriptVersionChange",
    value: function onScriptVersionChange(nfo) {}
  }, {
    key: "onSetAutoReset",
    value: function onSetAutoReset(nfo) {}
  }, {
    key: "onReloadResources",
    value: function onReloadResources(nfo) {}
  }, {
    key: "onSetGenerateTemplate",
    value: function onSetGenerateTemplate(nfo) {}
  }, {
    key: "onCompilerChange",
    value: function onCompilerChange(v) {}
  }, {
    key: "onCompilerVersionChange",
    value: function onCompilerVersionChange(v) {}
  }, {
    key: "onRunStateChange",
    value: function onRunStateChange(v) {}
  }, {
    key: "onContinousCompileStateChange",
    value: function onContinousCompileStateChange(v) {}
  }, {
    key: "onMessagePassingChange",
    value: function onMessagePassingChange(v) {}
  }, {
    key: "onKeepAliveChange",
    value: function onKeepAliveChange(v) {}
  }, {
    key: "onPersistentArgumentsChange",
    value: function onPersistentArgumentsChange(v) {}
  }, {
    key: "onLanguageChange",
    value: function onLanguageChange(v) {}
  }, {
    key: "onCharacterLimitChange",
    value: function onCharacterLimitChange(v) {}
  }, {
    key: "onTimeoutChange",
    value: function onTimeoutChange(v) {}
  }, {
    key: "onWorkerLibChange",
    value: function onWorkerLibChange(v) {}
  }, {
    key: "onDomLibChange",
    value: function onDomLibChange(v) {}
  }, {
    key: "onThemeChange",
    value: function onThemeChange(nfo) {}
  }, {
    key: "onOutputParserChange",
    value: function onOutputParserChange(v) {}
  }, {
    key: "moveUp",
    value: function moveUp(idx) {}
  }, {
    key: "moveDown",
    value: function moveDown(idx) {}
  }, {
    key: "onChangeOrder",
    value: function onChangeOrder(nfo) {}
  }, {
    key: "removeBlock",
    value: function removeBlock(idx) {}
  }, {
    key: "addNewBlock",
    value: function addNewBlock() {}
  }, {
    key: "onPlaygroundChangedOutput",
    value: function onPlaygroundChangedOutput(newOutput) {
      if (newOutput === undefined) {
        return;
      }
      if (this.output != newOutput) {
        this.output = newOutput.replaceAllPoly('<', '&lt;').replaceAllPoly('>', '&gt;');
        if (this.maxCharacters > 0 && this.output.length > this.maxCharacters) {
          this.outputHTML = formatOutput(this.output.substr(0, this.maxCharacters));
          this.outputHTML += this.$CodeBlock.format_info('Info: Output too long. Removed all following Characters. \n<b>...</b>\n\n');
        } else {
          this.outputHTML = formatOutput(this.output);
        }
        this.outputHTML += this.sansoutput;
      }
    }
  }, {
    key: "resetOutput",
    value: function resetOutput() {
      this.output = '';
      this.sansoutput = '';
      this.didClip = false;
      this.outputHTML = '';
    }
  }, {
    key: "log",
    value: function log(text) {
      //console.log("log", text);
      this.output += text;
      text = text.replaceAllPoly('<', '&lt;').replaceAllPoly('>', '&gt;');
      if (!this.didClip) {
        var formatedText;
        if (this.maxCharacters > 0 && this.output.length > this.maxCharacters) {
          formatedText = this.$CodeBlock.format_info('Info: Output too long. Removed all following Characters. \n<b>...</b>\n\n');
          this.didClip = true;
        } else {
          formatedText = formatOutput(text);
        }
        this.outputHTML += formatedText;
        this.eventHub.$emit('console-log', formatedText);
      }
    }
  }, {
    key: "logError",
    value: function logError(text) {
      text = text.replaceAllPoly('<', '&lt;').replaceAllPoly('>', '&gt;');
      this.eventHub.$emit('console-err', text);
      text = this.$CodeBlock.format_error(text);
      //console.log("err", text);
      this.sansoutput += text;
      this.outputHTML += text;
    }
  }, {
    key: "logInfo",
    value: function logInfo(text) {
      text = text.replaceAllPoly('<', '&lt;').replaceAllPoly('>', '&gt;');
      this.eventHub.$emit('console-nfo', text);
      text = this.$CodeBlock.format_info(text);
      //console.log("nfo", text);
      this.sansoutput += text;
      this.outputHTML += text;
    }
  }, {
    key: "processDiagnostics",
    value: function processDiagnostics(error) {
      var line = error.start.line;
      this.blocks.forEach(function (block) {
        if (!block.hasCode) {
          return;
        }
        var first = block.firstLine;
        var last = block.nextLine - 1;
        if (error.start.line >= first && error.start.line <= last) {
          block.errors.push(error);
        }
      });
    }
  }, {
    key: "clearDiagnostics",
    value: function clearDiagnostics() {
      this.blocks.forEach(function (block) {
        return block.errors = [];
      });
      this.eventHub.$emit('render-diagnostics', {});
    }
  }, {
    key: "loadLibraries",
    value: function loadLibraries(whenLoaded) {
      this.$compilerRegistry.loadLibraries(this.domLibraries, whenLoaded);
    }
    /**
     * Call when the program finished executing and pass the output string. We will send the output to all embeded canvas elements
     * @param {*} output
     * @param {*} infoErrorOutput output generated by info or error messages
     */
  }, {
    key: "finishedExecution",
    value: function finishedExecution(output, infoErrorOutput, resultData) {
      var parseError = undefined;
      var processed = {
        type: 'text',
        json: undefined,
        text: output
      };
      if (output !== undefined && this.playgrounds.length > 0) {
        try {
          processed = this.$CodeBlock.processMixedOutput(output, this.outputParser, undefined, resultData);
        } catch (e) {
          parseError = e;
        }
      }
      this._finalOutputObject = {
        initialOutput: output,
        output: output,
        processedOutput: processed,
        sansoutput: this.sansoutput,
        parseError: parseError,
        //outputElement: $(this.outputElement) as JQuery<HTMLElement> //This line soes not work here, looks like the update did not yet happen?
        outputElement: $(this.$refs.output)
      };
      this.eventHub.$emit('output-updated', this._finalOutputObject);
      this.onRunFinished();
    }
  }, {
    key: "hasREPL",
    get: function get() {
      return this.blocks.filter(function (bl) {
        return bl.type === ICodeBlocks["c" /* KnownBlockTypes */].REPL;
      }).length > 0;
    }
  }, {
    key: "canStop",
    get: function get() {
      return !this.isReady && this.didRunOnce;
    }
  }, {
    key: "stop",
    value: function stop() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp === undefined || cmp.stop === undefined) {
        return;
      }
      cmp.stop();
    }
  }, {
    key: "run",
    value: function run() {
      var _this3 = this;
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp === undefined) {
        return false;
      }
      this.$compilerState.setAllRunButtons(false);
      this.resetOutput();
      this.eventHub.$emit('clicked-run');
      this.clearDiagnostics();
      var self = this;
      this.loadLibraries(function () {
        self.eventHub.$emit('before-run', {});
        console.d('compileAndRun');
        self.didRunOnce = true;
        self.$nextTick(function () {
          self.$nextTick(function () {
            var _args = {};
            if (cmp.acceptsJSONArgument) {
              _args = _this3.blockInfo.initArgsForLanguage();
              _this3.blocks.forEach(function (bl) {
                if (bl.obj) {
                  console.i('!!! ADD ARGUMENTS TO !!!');
                  bl.obj.addArgumentsTo(_args);
                }
              });
            }
            var runOptions = {
              max_ms: self.executionTimeout,
              log_callback: self.log.bind(_this3),
              info_callback: self.logInfo.bind(_this3),
              err_callback: self.logError.bind(_this3),
              compileFailedCallback: self.processDiagnostics.bind(_this3),
              finishedExecutionCB: function finishedExecutionCB() {
                var success = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                var overrideOutput = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
                var returnState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
                console.i('returnState:', returnState, _args);
                if (!success) {
                  self.$compilerState.hideGlobalState();
                  self.$compilerState.setAllRunButtons(true);
                  return undefined;
                }
                var res = self.finishedExecution(overrideOutput ? overrideOutput : self.output, self.sansoutput, runOptions.resultData);
                if (returnState !== undefined) {
                  if (_this3.blockInfo.persistentArguments) {
                    console.i('Store Default State', returnState);
                    _this3.blockInfo.storeDefaultArgs(returnState);
                  } else {
                    _this3.blockInfo.clearDefaultArgs();
                  }
                }
                self.$compilerState.hideGlobalState();
                self.$compilerState.setAllRunButtons(true);
                return res;
              },
              args: _args,
              didReceiveMessage: function didReceiveMessage(cmd, data) {
                console.i('MESSAGE - Received', cmd);
                _this3.blocks.forEach(function (bl) {
                  if (bl.obj) {
                    bl.obj.didReceiveMessage(cmd, data);
                  }
                });
              },
              postMessageFunction: null,
              dequeuePostponedMessages: function dequeuePostponedMessages() {},
              allowMessagePassing: cmp.allowsMessagePassing && self.options.messagePassing,
              keepAlive: cmp.allowsMessagePassing && self.options.messagePassing && self.options.keepAlive,
              withREPL: cmp.allowsMessagePassing && self.options.messagePassing && self.options.keepAlive && _this3.hasREPL,
              beforeStartHandler: function beforeStartHandler() {
                _this3.blocks.forEach(function (bl) {
                  console.d('MESSAGE - Before Start');
                  if (bl.obj) {
                    bl.obj.beforeStart();
                  }
                });
              },
              whenFinishedHandler: function whenFinishedHandler(args) {
                _this3.blocks.forEach(function (bl) {
                  console.d('MESSAGE - When Finished');
                  if (bl.obj) {
                    bl.obj.whenFinished(args, runOptions.resultData);
                  }
                });
              },
              resultData: undefined
            };
            if (runOptions.keepAlive) {
              _this3.blocks.forEach(function (bl) {
                if (bl.obj) {
                  bl.obj.runConfig = runOptions;
                }
              });
            }
            cmp.compileAndRun('' + self.blockid, self.completeSource, self, runOptions);
          });
        });
      });
      return true;
    }
  }, {
    key: "onkey",
    value: function onkey(event) {
      if (this.editMode && (event.ctrlKey || event.metaKey) && (event.key === 'w' || event.key === 'j')) {
        this.run();
        event.preventDefault();
        return false;
      }
    }
  }, {
    key: "mounted",
    value: function mounted() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp) {
        cmp.preload();
      }
      var self = this;
      this.loadLibraries(function () {
        self.eventHub.$emit('initialized-libraries', {});
      });
      this.didInitialize = true;
      if (this.editMode) {
        window.addEventListener('keydown', this.onkey, false);
      }
      lib["c" /* Vue */].$GlobalEventHub.$on('bookmark-block', this.onBookmarkBlock);
    }
  }, {
    key: "beforeDestroy",
    value: function beforeDestroy() {
      window.removeEventListener('keydown', this.onkey);
      lib["c" /* Vue */].$GlobalEventHub.$off('bookmark-block');
    }
  }, {
    key: "hasBookmark",
    get: function get() {
      return this.bookmarkedBlock !== null && this.editMode;
    }
  }, {
    key: "panelBlock",
    get: function get() {
      return this.bookmarkedBlock;
    }
  }, {
    key: "onBookmarkBlock",
    value: function onBookmarkBlock(data) {
      console.i('Bookmark', data);
      if (this.blockInfo.uuid == data.uuid) {
        this.bookmarkedBlock = data.block;
      }
    }
  }, {
    key: "onViewCodeChange",
    value: function onViewCodeChange() {
      var _this4 = this;
      var forceRun = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!forceRun && !this.blockInfo.continuousCompilation) {
        return;
      }
      if (this.continuousCodeUpdateTimer !== null) {
        clearTimeout(this.continuousCodeUpdateTimer);
        this.continuousCodeUpdateTimer = null;
      }
      this.continuousCodeUpdateTimer = setTimeout(function () {
        var cmp = _this4.$compilerRegistry.getCompiler(_this4.compiler);
        console.d('Continuous Compile - ', cmp);
        if (cmp && cmp.allowsContinousCompilation) {
          if (!cmp.isRunning && cmp.isReady) {
            console.d('Continuous Compile - ', 'RUN');
            _this4.run();
          } else {
            console.d('Continuous Compile - ', 'DEFER');
            _this4.triggerRecompileWhenFinished = true;
          }
        }
      }, "800");
    }
  }, {
    key: "onRunFinished",
    value: function onRunFinished() {
      this.didRunOnce = false;
      if (this.triggerRecompileWhenFinished) {
        console.d('Continuous Compile - ', 'RE-RUN');
        this.triggerRecompileWhenFinished = false;
        this.onViewCodeChange();
      }
    }
  }, {
    key: "onRunFromPlayground",
    value: function onRunFromPlayground() {
      var cmp = this.$compilerRegistry.getCompiler(this.compiler);
      if (cmp && cmp.canRun && !this.editMode && cmp.allowsContinousCompilation // &&
      // this.blockInfo.continuousCompilation
      ) {
        this.onViewCodeChange(true);
      }
    }
  }]);
  return CodeBlocks;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["b" /* Prop */])({
  required: true
})], CodeBlocksvue_type_script_lang_ts_CodeBlocks.prototype, "blockInfo", void 0);
CodeBlocksvue_type_script_lang_ts_CodeBlocks = Object(tslib_es6["b" /* __decorate */])([Object(lib["a" /* Component */])({
  components: {
    CodeBlockContainer: CodeBlockContainer,
    CodeBlocksSettings: components_CodeBlocksSettings,
    CodeBlock: CodeBlock["a" /* default */],
    CodePlayground: components_CodePlayground,
    SimpleText: components_SimpleText,
    Blockly: Blockly,
    CodePanel: components_CodePanel,
    CodeREPL: components_CodeREPL,
    DataBlock: components_DataBlock
  }
})], CodeBlocksvue_type_script_lang_ts_CodeBlocks);
/* harmony default export */ var CodeBlocksvue_type_script_lang_ts_ = (CodeBlocksvue_type_script_lang_ts_CodeBlocks);
// CONCATENATED MODULE: ./src/components/CodeBlocks.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_CodeBlocksvue_type_script_lang_ts_ = (CodeBlocksvue_type_script_lang_ts_); 
// EXTERNAL MODULE: ./src/components/CodeBlocks.vue?vue&type=style&index=0&id=7e42fd95&prod&lang=sass&
var CodeBlocksvue_type_style_index_0_id_7e42fd95_prod_lang_sass_ = __webpack_require__("00b1");

// CONCATENATED MODULE: ./src/components/CodeBlocks.vue






/* normalize component */

var CodeBlocks_component = Object(componentNormalizer["a" /* default */])(
  components_CodeBlocksvue_type_script_lang_ts_,
  CodeBlocksvue_type_template_id_7e42fd95_render,
  CodeBlocksvue_type_template_id_7e42fd95_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var components_CodeBlocks = (CodeBlocks_component.exports);





runtime_auto_import_default()(CodeBlocks_component, 'components', {QBtn: QBtn["a" /* default */],QIcon: QIcon["a" /* default */],QTooltip: QTooltip["a" /* default */],QSlideTransition: QSlideTransition["a" /* default */]});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=script&lang=js&


/* harmony default export */ var Appvue_type_script_lang_js_ = ({
  name: 'App',
  props: ['blocks'],
  components: {
    CodeBlocks: components_CodeBlocks
  },
  data: function data() {
    return {};
  },
  computed: {}
});
// CONCATENATED MODULE: ./src/App.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_Appvue_type_script_lang_js_ = (Appvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/App.vue?vue&type=style&index=0&id=eaf51832&prod&lang=sass&
var Appvue_type_style_index_0_id_eaf51832_prod_lang_sass_ = __webpack_require__("ba2b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.test.js
var es_regexp_test = __webpack_require__("00b4");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js + 3 modules
var slicedToArray = __webpack_require__("3835");

// EXTERNAL MODULE: ./node_modules/quasar/src/utils/scroll.js
var utils_scroll = __webpack_require__("0831");

// CONCATENATED MODULE: ./node_modules/quasar/src/components/scroll-observer/QScrollObserver.js





var passive = utils_event["e" /* listenOpts */].passive;
/* harmony default export */ var QScrollObserver = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QScrollObserver',
  props: {
    debounce: [String, Number],
    horizontal: Boolean,
    scrollTarget: {
      default: void 0
    }
  },
  render: utils_event["f" /* noop */],
  // eslint-disable-line
  data: function data() {
    return {
      pos: 0,
      dir: this.horizontal === true ? 'right' : 'down',
      dirChanged: false,
      dirChangePos: 0
    };
  },
  watch: {
    scrollTarget: function scrollTarget() {
      this.__unconfigureScrollTarget();
      this.__configureScrollTarget();
    },
    '$q.lang.rtl': function $qLangRtl() {
      this.__emit();
    }
  },
  methods: {
    getPosition: function getPosition() {
      return {
        position: this.pos,
        direction: this.dir,
        directionChanged: this.dirChanged,
        inflexionPosition: this.dirChangePos
      };
    },
    trigger: function trigger(immediately) {
      var _this = this;
      if (immediately === true || this.debounce === 0 || this.debounce === '0') {
        this.__emit();
      } else if (this.clearTimer === void 0) {
        var _ref = this.debounce ? [setTimeout(this.__emit, this.debounce), clearTimeout] : [requestAnimationFrame(this.__emit), cancelAnimationFrame],
          _ref2 = Object(slicedToArray["a" /* default */])(_ref, 2),
          timer = _ref2[0],
          fn = _ref2[1];
        this.clearTimer = function () {
          fn(timer);
          _this.clearTimer = void 0;
        };
      }
    },
    __emit: function __emit() {
      this.clearTimer !== void 0 && this.clearTimer();
      var fn = this.horizontal === true ? utils_scroll["a" /* getHorizontalScrollPosition */] : utils_scroll["b" /* getScrollPosition */];
      var pos = Math.max(0, fn(this.__scrollTarget)),
        delta = pos - this.pos,
        dir = this.horizontal === true ? delta < 0 ? 'left' : 'right' : delta < 0 ? 'up' : 'down';
      this.dirChanged = this.dir !== dir;
      if (this.dirChanged) {
        this.dir = dir;
        this.dirChangePos = this.pos;
      }
      this.pos = pos;
      this.$emit('scroll', this.getPosition());
    },
    __configureScrollTarget: function __configureScrollTarget() {
      this.__scrollTarget = Object(utils_scroll["c" /* getScrollTarget */])(this.$el.parentNode, this.scrollTarget);
      this.__scrollTarget.addEventListener('scroll', this.trigger, passive);
      this.trigger(true);
    },
    __unconfigureScrollTarget: function __unconfigureScrollTarget() {
      if (this.__scrollTarget !== void 0) {
        this.__scrollTarget.removeEventListener('scroll', this.trigger, passive);
        this.__scrollTarget = void 0;
      }
    }
  },
  mounted: function mounted() {
    this.__configureScrollTarget();
  },
  beforeDestroy: function beforeDestroy() {
    this.clearTimer !== void 0 && this.clearTimer();
    this.__unconfigureScrollTarget();
  }
}));
// CONCATENATED MODULE: ./node_modules/quasar/src/mixins/can-render.js
// using it to manage SSR rendering with best performance

/* harmony default export */ var can_render = ({
  data: function data() {
    return {
      canRender: !Platform["f" /* onSSR */]
    };
  },
  mounted: function mounted() {
    this.canRender === false && (this.canRender = true);
  }
});
// CONCATENATED MODULE: ./node_modules/quasar/src/components/resize-observer/QResizeObserver.js






/* harmony default export */ var QResizeObserver = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QResizeObserver',
  mixins: [can_render],
  props: {
    debounce: {
      type: [String, Number],
      default: 100
    }
  },
  data: function data() {
    return this.hasObserver === true ? {} : {
      url: this.$q.platform.is.ie === true ? null : 'about:blank'
    };
  },
  methods: {
    trigger: function trigger(immediately) {
      if (immediately === true || this.debounce === 0 || this.debounce === '0') {
        this.__emit();
      } else if (this.timer === null) {
        this.timer = setTimeout(this.__emit, this.debounce);
      }
    },
    __emit: function __emit() {
      if (this.timer !== null) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      if (!this.$el || !this.$el.parentNode) {
        return;
      }
      var parent = this.$el.parentNode,
        size = {
          width: parent.offsetWidth,
          height: parent.offsetHeight
        };
      if (size.width === this.size.width && size.height === this.size.height) {
        return;
      }
      this.size = size;
      this.$emit('resize', this.size);
    },
    __cleanup: function __cleanup() {
      if (this.curDocView !== void 0) {
        // iOS is fuzzy, need to check it first
        if (this.curDocView.removeEventListener !== void 0) {
          this.curDocView.removeEventListener('resize', this.trigger, utils_event["e" /* listenOpts */].passive);
        }
        this.curDocView = void 0;
      }
    },
    __onObjLoad: function __onObjLoad() {
      this.__cleanup();
      if (this.$el.contentDocument) {
        this.curDocView = this.$el.contentDocument.defaultView;
        this.curDocView.addEventListener('resize', this.trigger, utils_event["e" /* listenOpts */].passive);
      }
      this.__emit();
    }
  },
  render: function render(h) {
    if (this.canRender === false || this.hasObserver === true) {
      return;
    }
    return h('object', {
      style: this.style,
      attrs: {
        tabindex: -1,
        // fix for Firefox
        type: 'text/html',
        data: this.url,
        'aria-hidden': 'true'
      },
      on: Object(cache["a" /* default */])(this, 'load', {
        load: this.__onObjLoad
      })
    });
  },
  beforeCreate: function beforeCreate() {
    this.size = {
      width: -1,
      height: -1
    };
    if (Platform["e" /* isSSR */] === true) {
      return;
    }
    this.hasObserver = typeof ResizeObserver !== 'undefined';
    if (this.hasObserver !== true) {
      this.style = "".concat(this.$q.platform.is.ie ? 'visibility:hidden;' : '', "display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;");
    }
  },
  mounted: function mounted() {
    this.timer = null;
    if (this.hasObserver === true) {
      this.observer = new ResizeObserver(this.trigger);
      this.observer.observe(this.$el.parentNode);
      this.__emit();
      return;
    }
    if (this.$q.platform.is.ie === true) {
      this.url = 'about:blank';
      this.__emit();
    } else {
      this.__onObjLoad();
    }
  },
  beforeDestroy: function beforeDestroy() {
    clearTimeout(this.timer);
    if (this.hasObserver === true) {
      if (this.observer !== void 0 && this.$el.parentNode) {
        this.observer.unobserve(this.$el.parentNode);
      }
      return;
    }
    this.__cleanup();
  }
}));
// CONCATENATED MODULE: ./node_modules/quasar/src/components/layout/QLayout.js












/* harmony default export */ var QLayout = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QLayout',
  mixins: [listeners["a" /* default */]],
  provide: function provide() {
    return {
      layout: this
    };
  },
  props: {
    container: Boolean,
    view: {
      type: String,
      default: 'hhh lpr fff',
      validator: function validator(v) {
        return /^(h|l)h(h|r) lpr (f|l)f(f|r)$/.test(v.toLowerCase());
      }
    }
  },
  data: function data() {
    return {
      // page related
      height: this.$q.screen.height,
      width: this.container === true ? 0 : this.$q.screen.width,
      // container only prop
      containerHeight: 0,
      scrollbarWidth: Platform["f" /* onSSR */] === true ? 0 : Object(utils_scroll["d" /* getScrollbarWidth */])(),
      header: {
        size: 0,
        offset: 0,
        space: false
      },
      right: {
        size: 300,
        offset: 0,
        space: false
      },
      footer: {
        size: 0,
        offset: 0,
        space: false
      },
      left: {
        size: 300,
        offset: 0,
        space: false
      },
      scroll: {
        position: 0,
        direction: 'down'
      }
    };
  },
  computed: {
    rows: function rows() {
      var rows = this.view.toLowerCase().split(' ');
      return {
        top: rows[0].split(''),
        middle: rows[1].split(''),
        bottom: rows[2].split('')
      };
    },
    style: function style() {
      return this.container === true ? null : {
        minHeight: this.$q.screen.height + 'px'
      };
    },
    // used by container only
    targetStyle: function targetStyle() {
      if (this.scrollbarWidth !== 0) {
        return Object(esm_defineProperty["a" /* default */])({}, this.$q.lang.rtl === true ? 'left' : 'right', "".concat(this.scrollbarWidth, "px"));
      }
    },
    targetChildStyle: function targetChildStyle() {
      if (this.scrollbarWidth !== 0) {
        var _ref2;
        return _ref2 = {}, Object(esm_defineProperty["a" /* default */])(_ref2, this.$q.lang.rtl === true ? 'right' : 'left', 0), Object(esm_defineProperty["a" /* default */])(_ref2, this.$q.lang.rtl === true ? 'left' : 'right', "-".concat(this.scrollbarWidth, "px")), Object(esm_defineProperty["a" /* default */])(_ref2, "width", "calc(100% + ".concat(this.scrollbarWidth, "px)")), _ref2;
      }
    },
    totalWidth: function totalWidth() {
      return this.width + this.scrollbarWidth;
    },
    classes: function classes() {
      return 'q-layout q-layout--' + (this.container === true ? 'containerized' : 'standard');
    },
    scrollbarEvtAction: function scrollbarEvtAction() {
      return this.container !== true && this.scrollbarWidth > 0 ? 'add' : 'remove';
    }
  },
  watch: {
    scrollbarEvtAction: '__updateScrollEvent'
  },
  created: function created() {
    this.instances = {};
  },
  mounted: function mounted() {
    this.scrollbarEvtAction === 'add' && this.__updateScrollEvent('add');
  },
  beforeDestroy: function beforeDestroy() {
    this.scrollbarEvtAction === 'add' && this.__updateScrollEvent('remove');
  },
  render: function render(h) {
    var layout = h('div', {
      class: this.classes,
      style: this.style,
      attrs: {
        tabindex: -1
      },
      on: Object(objectSpread2["a" /* default */])({}, this.qListeners)
    }, Object(slot["a" /* mergeSlot */])([h(QScrollObserver, {
      on: Object(cache["a" /* default */])(this, 'scroll', {
        scroll: this.__onPageScroll
      })
    }), h(QResizeObserver, {
      on: Object(cache["a" /* default */])(this, 'resizeOut', {
        resize: this.__onPageResize
      })
    })], this, 'default'));
    return this.container === true ? h('div', {
      staticClass: 'q-layout-container overflow-hidden'
    }, [h(QResizeObserver, {
      on: Object(cache["a" /* default */])(this, 'resizeIn', {
        resize: this.__onContainerResize
      })
    }), h('div', {
      staticClass: 'absolute-full',
      style: this.targetStyle
    }, [h('div', {
      staticClass: 'scroll',
      style: this.targetChildStyle
    }, [layout])])]) : layout;
  },
  methods: {
    __animate: function __animate() {
      var _this = this;
      if (this.timer !== void 0) {
        clearTimeout(this.timer);
      } else {
        document.body.classList.add('q-body--layout-animate');
      }
      this.timer = setTimeout(function () {
        document.body.classList.remove('q-body--layout-animate');
        _this.timer = void 0;
      }, 150);
    },
    __onPageScroll: function __onPageScroll(data) {
      if (this.container === true || document.qScrollPrevented !== true) {
        this.scroll = data;
      }
      this.qListeners.scroll !== void 0 && this.$emit('scroll', data);
    },
    __onPageResize: function __onPageResize(_ref3) {
      var height = _ref3.height,
        width = _ref3.width;
      var resized = false;
      if (this.height !== height) {
        resized = true;
        this.height = height;
        if (this.qListeners['scroll-height'] !== void 0) {
          this.$emit('scroll-height', height);
        }
        this.__updateScrollbarWidth();
      }
      if (this.width !== width) {
        resized = true;
        this.width = width;
      }
      if (resized === true && this.qListeners.resize !== void 0) {
        this.$emit('resize', {
          height: height,
          width: width
        });
      }
    },
    __onContainerResize: function __onContainerResize(_ref4) {
      var height = _ref4.height;
      if (this.containerHeight !== height) {
        this.containerHeight = height;
        this.__updateScrollbarWidth();
      }
    },
    __updateScrollbarWidth: function __updateScrollbarWidth() {
      if (this.container === true) {
        var width = this.height > this.containerHeight ? Object(utils_scroll["d" /* getScrollbarWidth */])() : 0;
        if (this.scrollbarWidth !== width) {
          this.scrollbarWidth = width;
        }
      }
    },
    __updateScrollEvent: function __updateScrollEvent(action) {
      if (this.timerScrollbar !== void 0 && action === 'remove') {
        clearTimeout(this.timerScrollbar);
        this.__restoreScrollbar();
      }
      window["".concat(action, "EventListener")]('resize', this.__hideScrollbar);
    },
    __hideScrollbar: function __hideScrollbar() {
      if (this.timerScrollbar === void 0) {
        var el = document.body;

        // if it has no scrollbar then there's nothing to do
        if (el.scrollHeight > this.$q.screen.height) {
          return;
        }
        el.classList.add('hide-scrollbar');
      } else {
        clearTimeout(this.timerScrollbar);
      }
      this.timerScrollbar = setTimeout(this.__restoreScrollbar, 200);
    },
    __restoreScrollbar: function __restoreScrollbar() {
      this.timerScrollbar = void 0;
      document.body.classList.remove('hide-scrollbar');
    }
  }
}));
// CONCATENATED MODULE: ./node_modules/quasar/src/components/page/QPageContainer.js




/* harmony default export */ var QPageContainer = (external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend({
  name: 'QPageContainer',
  mixins: [listeners["a" /* default */]],
  inject: {
    layout: {
      default: function _default() {
        console.error('QPageContainer needs to be child of QLayout');
      }
    }
  },
  provide: {
    pageContainer: true
  },
  computed: {
    style: function style() {
      var css = {};
      if (this.layout.header.space === true) {
        css.paddingTop = "".concat(this.layout.header.size, "px");
      }
      if (this.layout.right.space === true) {
        css["padding".concat(this.$q.lang.rtl === true ? 'Left' : 'Right')] = "".concat(this.layout.right.size, "px");
      }
      if (this.layout.footer.space === true) {
        css.paddingBottom = "".concat(this.layout.footer.size, "px");
      }
      if (this.layout.left.space === true) {
        css["padding".concat(this.$q.lang.rtl === true ? 'Right' : 'Left')] = "".concat(this.layout.left.size, "px");
      }
      return css;
    }
  },
  render: function render(h) {
    return h('div', {
      staticClass: 'q-page-container',
      style: this.style,
      on: Object(objectSpread2["a" /* default */])({}, this.qListeners)
    }, Object(slot["c" /* slot */])(this, 'default'));
  }
}));
// CONCATENATED MODULE: ./src/App.vue






/* normalize component */

var App_component = Object(componentNormalizer["a" /* default */])(
  src_Appvue_type_script_lang_js_,
  Appvue_type_template_id_eaf51832_render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var App = (App_component.exports);



runtime_auto_import_default()(App_component, 'components', {QLayout: QLayout,QPageContainer: QPageContainer});

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"58e6adbb-vue-loader-template"}!./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-loader/lib/loaders/templateLoader.js??ref--7!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/AppEditor.vue?vue&type=template&id=0797aa13&
var AppEditorvue_type_template_id_0797aa13_render = function render() {
  var _vm = this,
    _c = _vm._self._c;
  return _c('q-layout', {
    staticStyle: {
      "min-height": "0"
    },
    attrs: {
      "view": "hHh lpR fFf"
    }
  }, [_c('q-page-container', [_c('CodeBlocksEditor', {
    attrs: {
      "blockInfo": _vm.blocks
    }
  })], 1)], 1);
};
var AppEditorvue_type_template_id_0797aa13_staticRenderFns = [];

// CONCATENATED MODULE: ./src/AppEditor.vue?vue&type=template&id=0797aa13&

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/components/CodeBlocksEditor.vue?vue&type=script&lang=ts&








var CodeBlocksEditorvue_type_script_lang_ts_mixin = {
  created: function created() {
    console.log(1);
  }
};
var CodeBlocksEditorvue_type_script_lang_ts_CodeBlocksEditor = /*#__PURE__*/function (_CodeBlocks) {
  Object(inherits["a" /* default */])(CodeBlocksEditor, _CodeBlocks);
  var _super = Object(createSuper["a" /* default */])(CodeBlocksEditor);
  function CodeBlocksEditor() {
    Object(classCallCheck["a" /* default */])(this, CodeBlocksEditor);
    return _super.apply(this, arguments);
  }
  Object(createClass["a" /* default */])(CodeBlocksEditor, [{
    key: "editMode",
    get: function get() {
      return true;
    }
  }, {
    key: "onTypeChange",
    value: function onTypeChange(nfo) {
      var bl = this.blockById(nfo.id);
      if (bl === undefined) {
        return;
      }
      bl.type = nfo.type;
      bl.hidden = nfo.hidden;
      bl.static = nfo.static;
      bl.hasCode = nfo.hasCode;
    }
  }, {
    key: "onVisibleLinesChange",
    value: function onVisibleLinesChange(nfo) {
      var bl = this.blockById(nfo.id);
      if (bl === undefined) {
        return;
      }
      if (nfo.visibleLines != 'auto' && isNaN(nfo.visibleLines)) {
        bl.visibleLines = 'auto';
      } else {
        bl.visibleLines = nfo.visibleLines;
      }
    }
  }, {
    key: "onPlacementChange",
    value: function onPlacementChange(nfo) {
      var bl = this.blockById(nfo.id);
      if (bl === undefined) {
        return;
      }
      bl.width = nfo.width;
      bl.height = nfo.height;
      bl.align = nfo.align;
    }
  }, {
    key: "onCompilerChange",
    value: function onCompilerChange(v) {
      var c = this.$compilerRegistry.getCompiler({
        languageType: v
      });
      if (c !== undefined) {
        console.log('Selected Compiler', c, v, this.blockInfo.compiler);
        this.blockInfo.compiler.languageType = v;
        this.blockInfo.compiler.version = c.version;
        this.blockInfo.language = c.language;
        console.log('PRELOADING');
        c.preload();
      }
    }
  }, {
    key: "onCompilerVersionChange",
    value: function onCompilerVersionChange(v) {
      console.log('Selected Version', v, this.blockInfo.compiler.languageType);
      var c = this.$compilerRegistry.getCompiler({
        languageType: this.blockInfo.compiler.languageType,
        version: v
      });
      this.blockInfo.compiler.version = v;
      if (c !== undefined) {
        this.blockInfo.language = c.language;
        console.log('PRELOADING');
        c.preload();
      }
    }
  }, {
    key: "onRunStateChange",
    value: function onRunStateChange(v) {
      this.blockInfo.runCode = v;
    }
  }, {
    key: "onContinousCompileStateChange",
    value: function onContinousCompileStateChange(v) {
      this.blockInfo.continuousCompilation = v;
    }
  }, {
    key: "onMessagePassingChange",
    value: function onMessagePassingChange(v) {
      this.blockInfo.messagePassing = v;
    }
  }, {
    key: "onKeepAliveChange",
    value: function onKeepAliveChange(v) {
      this.blockInfo.keepAlive = v;
    }
  }, {
    key: "onPersistentArgumentsChange",
    value: function onPersistentArgumentsChange(v) {
      if (v === false) {
        this.blockInfo.clearDefaultArgs();
      }
      this.blockInfo.persistentArguments = v;
    }
  }, {
    key: "onLanguageChange",
    value: function onLanguageChange(v) {
      this.blockInfo.language = v;
    }
  }, {
    key: "onCharacterLimitChange",
    value: function onCharacterLimitChange(v) {
      this.blockInfo.maxCharacters = v;
    }
  }, {
    key: "onTimeoutChange",
    value: function onTimeoutChange(v) {
      this.blockInfo.executionTimeout = v;
    }
  }, {
    key: "onWorkerLibChange",
    value: function onWorkerLibChange(v) {
      this.blockInfo.workerLibs = v;
    }
  }, {
    key: "onDomLibChange",
    value: function onDomLibChange(v) {
      this.blockInfo.domLibs = v;
    }
  }, {
    key: "onScriptVersionChange",
    value: function onScriptVersionChange(nfo) {
      var bl = this.blockById(nfo.id);
      if (bl === undefined) {
        return;
      }
      bl.version = nfo.version;
      if (bl.obj) {
        bl.obj.version = nfo.version;
      }
    }
  }, {
    key: "onSetAutoReset",
    value: function onSetAutoReset(nfo) {
      var bl = this.blockById(nfo.id);
      if (bl === undefined) {
        return;
      }
      bl.shouldAutoreset = nfo.shouldAutoreset;
    }
  }, {
    key: "onReloadResources",
    value: function onReloadResources(nfo) {
      var bl = this.blockById(nfo.id);
      if (bl === undefined) {
        return;
      }
      bl.shouldReloadResources = nfo.shouldReloadResources;
    }
  }, {
    key: "onSetGenerateTemplate",
    value: function onSetGenerateTemplate(nfo) {
      var bl = this.blockById(nfo.id);
      if (bl === undefined) {
        return;
      }
      bl.generateTemplate = nfo.generateTemplate;
    }
  }, {
    key: "onThemeChange",
    value: function onThemeChange(nfo) {
      this.blockInfo.solutionTheme = nfo.solution;
      this.blockInfo.codeTheme = nfo.code;
    }
  }, {
    key: "moveUp",
    value: function moveUp(idx) {
      this.blockInfo.moveUp(idx);
    }
  }, {
    key: "moveDown",
    value: function moveDown(idx) {
      this.blockInfo.moveDown(idx);
    }
  }, {
    key: "onChangeOrder",
    value: function onChangeOrder(nfo) {
      var bl = this.blockById(nfo.id);
      if (bl === undefined) {
        return;
      }
      this.blockInfo.changeOrder(nfo.id, nfo.newID);
    }
  }, {
    key: "addNewBlock",
    value: function addNewBlock() {
      this.blockInfo.addNewBlock();
    }
  }, {
    key: "removeBlock",
    value: function removeBlock(idx) {
      this.blockInfo.removeBlock(idx);
    }
  }, {
    key: "onOutputParserChange",
    value: function onOutputParserChange(v) {
      this.blockInfo.outputParser = v;
    }
  }]);
  return CodeBlocksEditor;
}(components_CodeBlocks);
CodeBlocksEditorvue_type_script_lang_ts_CodeBlocksEditor = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], CodeBlocksEditorvue_type_script_lang_ts_CodeBlocksEditor);
/* harmony default export */ var CodeBlocksEditorvue_type_script_lang_ts_ = (CodeBlocksEditorvue_type_script_lang_ts_CodeBlocksEditor);
// CONCATENATED MODULE: ./src/components/CodeBlocksEditor.vue?vue&type=script&lang=ts&
 /* harmony default export */ var components_CodeBlocksEditorvue_type_script_lang_ts_ = (CodeBlocksEditorvue_type_script_lang_ts_); 
// CONCATENATED MODULE: ./src/components/CodeBlocksEditor.vue
var CodeBlocksEditor_render, CodeBlocksEditor_staticRenderFns




/* normalize component */

var CodeBlocksEditor_component = Object(componentNormalizer["a" /* default */])(
  components_CodeBlocksEditorvue_type_script_lang_ts_,
  CodeBlocksEditor_render,
  CodeBlocksEditor_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var components_CodeBlocksEditor = (CodeBlocksEditor_component.exports);
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--13-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/vue-cli-plugin-quasar/lib/loader.transform-quasar-imports.js!./node_modules/vue-cli-plugin-quasar/lib/loader.auto-import.js?kebab!./node_modules/cache-loader/dist/cjs.js??ref--1-1!./node_modules/vue-loader/lib??vue-loader-options!./src/AppEditor.vue?vue&type=script&lang=js&


/* harmony default export */ var AppEditorvue_type_script_lang_js_ = ({
  name: 'AppEditor',
  props: ['blocks'],
  components: {
    CodeBlocksEditor: components_CodeBlocksEditor
  },
  data: function data() {
    return {};
  },
  computed: {}
});
// CONCATENATED MODULE: ./src/AppEditor.vue?vue&type=script&lang=js&
 /* harmony default export */ var src_AppEditorvue_type_script_lang_js_ = (AppEditorvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./src/AppEditor.vue?vue&type=style&index=0&id=0797aa13&prod&lang=sass&
var AppEditorvue_type_style_index_0_id_0797aa13_prod_lang_sass_ = __webpack_require__("17bf");

// CONCATENATED MODULE: ./src/AppEditor.vue






/* normalize component */

var AppEditor_component = Object(componentNormalizer["a" /* default */])(
  src_AppEditorvue_type_script_lang_js_,
  AppEditorvue_type_template_id_0797aa13_render,
  AppEditorvue_type_template_id_0797aa13_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var AppEditor = (AppEditor_component.exports);



runtime_auto_import_default()(AppEditor_component, 'components', {QLayout: QLayout,QPageContainer: QPageContainer});

// CONCATENATED MODULE: ./src/lib/BlockloadManagers/BlockManager.ts


var BlockManager_BlockLoadManager = /*#__PURE__*/function () {
  function BlockLoadManager() {
    Object(classCallCheck["a" /* default */])(this, BlockLoadManager);
  }
  Object(createClass["a" /* default */])(BlockLoadManager, [{
    key: "blockTag",
    get: function get() {
      return 'BLOCK';
    }
  }, {
    key: "loadFromDatablock",
    value: function loadFromDatablock(bl, inBlock, block, editMode) {
      var alts = bl.getElementsByTagName('ALTERNATIVE');
      var codes = bl.getElementsByTagName('CODE');
      if (codes.length > 0) {
        block.content = codes[0].textContent ? codes[0].textContent : '';
      }
      if (alts.length > 0) {
        block.hasAlternativeContent = true;
        block.alternativeContent = alts[0].textContent;
        if (!editMode && block.noContent) {
          block.content = block.alternativeContent ? block.alternativeContent : '';
        }
      }
      block.hasCode = true;
    }
  }]);
  return BlockLoadManager;
}();
var blockLoader = new BlockManager_BlockLoadManager();
/* harmony default export */ var BlockManager = (function (loaders) {
  loaders[blockLoader.blockTag] = blockLoader;
});
// CONCATENATED MODULE: ./src/lib/BlockloadManagers/PlaygroundManager.ts



var PlaygroundManager_PlaygroundLoadManager = /*#__PURE__*/function () {
  function PlaygroundLoadManager() {
    Object(classCallCheck["a" /* default */])(this, PlaygroundLoadManager);
  }
  Object(createClass["a" /* default */])(PlaygroundLoadManager, [{
    key: "blockTag",
    get: function get() {
      return 'PLAYGROUND';
    }
  }, {
    key: "loadFromDatablock",
    value: function loadFromDatablock(bl, inBlock, block, editMode) {
      block.obj = null;
      positioninLoadManager.loadFromDatablock(bl, inBlock, block);
      block.version = bl.getAttribute('data-version') ? bl.getAttribute('data-version') : block.version;
    }
  }]);
  return PlaygroundLoadManager;
}();
var playgroundLoader = new PlaygroundManager_PlaygroundLoadManager();
/* harmony default export */ var PlaygroundManager = (function (loaders) {
  loaders[playgroundLoader.blockTag] = playgroundLoader;
});
// CONCATENATED MODULE: ./src/lib/BlockloadManagers/DataManager.ts



var DataManager_DataLoadManager = /*#__PURE__*/function () {
  function DataLoadManager() {
    Object(classCallCheck["a" /* default */])(this, DataLoadManager);
  }
  Object(createClass["a" /* default */])(DataLoadManager, [{
    key: "blockTag",
    get: function get() {
      return 'DATA';
    }
  }, {
    key: "loadFromDatablock",
    value: function loadFromDatablock(bl, inBlock, block, editMode) {
      block.obj = null;
      block.version = bl.getAttribute('data-version') ? bl.getAttribute('data-version') : block.version;
      block.name = inBlock.name !== undefined ? inBlock.name : "v".concat(block.id);
    }
  }]);
  return DataLoadManager;
}();
var dataLoader = new DataManager_DataLoadManager();
/* harmony default export */ var DataManager = (function (loaders) {
  loaders[dataLoader.blockTag] = dataLoader;
});
// CONCATENATED MODULE: ./src/lib/BlockloadManagers/REPLManager.ts


var REPLManager_REPLLoadManager = /*#__PURE__*/function () {
  function REPLLoadManager() {
    Object(classCallCheck["a" /* default */])(this, REPLLoadManager);
  }
  Object(createClass["a" /* default */])(REPLLoadManager, [{
    key: "blockTag",
    get: function get() {
      return 'REPL';
    }
  }, {
    key: "loadFromDatablock",
    value: function loadFromDatablock(bl, inBlock, block, editMode) {}
  }]);
  return REPLLoadManager;
}();
var REPLLoader = new REPLManager_REPLLoadManager();
/* harmony default export */ var REPLManager = (function (loaders) {
  loaders[REPLLoader.blockTag] = REPLLoader;
});
// CONCATENATED MODULE: ./src/lib/codeBlocksManager.ts




























//get loaders





var loaders = {};
BlockManager(loaders);
BlocklyManager(loaders);
PlaygroundManager(loaders);
REPLManager(loaders);
DataManager(loaders);
lib["c" /* Vue */].prototype.$compilerRegistry = CompilerRegistry_compilerRegistry;
var codeBlocksManager_BlockData = /*#__PURE__*/function (_Vue) {
  Object(inherits["a" /* default */])(BlockData, _Vue);
  var _super = Object(createSuper["a" /* default */])(BlockData);
  function BlockData() {
    Object(classCallCheck["a" /* default */])(this, BlockData);
    return _super.apply(this, arguments);
  }
  Object(createClass["a" /* default */])(BlockData, [{
    key: "actualContent",
    value: function actualContent() {
      if (this.appSettings.randomizer.active) {
        return lib["c" /* Vue */].$tagger.replaceRandomTagsInString(this.content, this.appSettings.randomizer.sets[this.appSettings.randomizer.previewIndex]);
      }
      return this.content;
    }
  }, {
    key: "recreateScriptObject",
    value: function recreateScriptObject() {
      if (this.type === ICodeBlocks["c" /* KnownBlockTypes */].PLAYGROUND) {
        console.i('recreateScriptObject - Playground');
        var so = new scriptBlock_ScriptBlock(this.actualContent(), this.version);
        this.obj = so;
        console.i('Block Rebuild', this.obj, this.uuid);
      } else if (this.type === ICodeBlocks["c" /* KnownBlockTypes */].DATA) {
        console.i('recreateScriptObject - Data');
        this.dataObj = {
          name: '',
          content: ''
        };
        console.i('Block Rebuild', this.obj, this.uuid);
      }
    }
  }, {
    key: "created",
    value: function created() {
      this.recreateScriptObject();
    }
  }, {
    key: "getThemeForBlock",
    value: function getThemeForBlock(bl) {
      if (bl.static || bl.readonly || bl.hidden || this.type === ICodeBlocks["c" /* KnownBlockTypes */].DATA) {
        return this.appSettings.codeTheme;
      }
      return this.appSettings.solutionTheme;
    }
  }, {
    key: "themeForCodeBlock",
    get: function get() {
      if (this.static || this.readonly || this.hidden || this.type === ICodeBlocks["c" /* KnownBlockTypes */].DATA) {
        return this.appSettings.codeTheme;
      }
      return this.appSettings.solutionTheme;
    }
  }, {
    key: "isLast",
    get: function get() {
      return this.id == this.appSettings.blocks.length - 1;
    }
  }, {
    key: "firstLine",
    get: function get() {
      if (this.id === 0) {
        return 1;
      }
      return this.appSettings.blocks[this.id - 1].nextLine;
    }
  }, {
    key: "lineCount",
    get: function get() {
      if (!this.hasCode) {
        return 0;
      }
      if (this.lineCountHint >= 0) {
        return this.lineCountHint;
      }
      var ct = 0;
      this.content.replace(/\n/, function (m) {
        ct++;
        return m;
      });
      return ct;
    }
  }, {
    key: "nextLine",
    get: function get() {
      if (!this.hasCode) {
        return this.firstLine;
      }
      return this.firstLine + this.lineCount;
    }
  }, {
    key: "domLibs",
    get: function get() {
      return this.appSettings.domLibs;
    }
    //is this right. Happend when converting from JS
  }, {
    key: "scriptVersion",
    get: function get() {
      return this.version;
    }
  }, {
    key: "onTypeChanged",
    value: function onTypeChanged(newType, oldType) {
      if (newType != oldType) {
        this.recreateScriptObject();
      }
    }
  }, {
    key: "scope",
    get: function get() {
      return this.scopeSelector ? $(this.scopeSelector) : $(".codeblocks[uuid=\"".concat(this.appSettings.uuid, "\"]"));
    }
  }]);
  return BlockData;
}(lib["c" /* Vue */]);
Object(tslib_es6["b" /* __decorate */])([Object(lib["d" /* Watch */])('type')], codeBlocksManager_BlockData.prototype, "onTypeChanged", null);
codeBlocksManager_BlockData = Object(tslib_es6["b" /* __decorate */])([lib["a" /* Component */]], codeBlocksManager_BlockData);

function isTrue(val) {
  //return val !== undefined || val == 'true' || val == '1'
  return val !== undefined && val != 'false' && val != '0';
}
var useShadowDOM = false;
//this will handle the vue mounting on the dom
var codeBlocksManager_InternalCodeBlocksManager = /*#__PURE__*/function () {
  function InternalCodeBlocksManager(el) {
    var _this = this;
    Object(classCallCheck["a" /* default */])(this, InternalCodeBlocksManager);
    this.shadowRoot = undefined;
    if (useShadowDOM) {
      var content = el.outerHTML;
      //replace original element with empty div that will store the shadowDOM
      var parent = el.parentElement;
      var rewrap = document.createElement('DIV');
      parent.replaceChild(rewrap, el);
      //add shadowDOM and clear content
      var shadow = rewrap.attachShadow({
        mode: 'open'
      });
      this.shadowRoot = shadow;
      shadow.innerHTML = '';
      //copy root-level styles into the shadowDOM
      $('style').each(function (idx, style) {
        var st = document.createElement('STYLE');
        st.innerHTML = style.innerHTML;
        shadow.appendChild(st);
      });
      $('link[shadow]').each(function (idx, link) {
        shadow.appendChild(link.cloneNode());
      });
      // //add new root and append original Element
      // const root = document.createElement('DIV')
      // root.id = 'root'
      // //root.innerHTML = noContent
      // root.appendChild(el)
      // shadow.appendChild(root)
      // console.log($('style').length)
      // this.element = root
      //append original element to shadowDOM
      shadow.appendChild(el);
      this.element = el;
    } else {
      this.shadowRoot = undefined;
      this.element = el;
    }
    //console.log(this.element)
    var inData = el.dataset;
    var data = {
      id: -1,
      editMode: el.tagName == 'CODEBLOCKSEDITOR' || el.hasAttribute('codeblockseditor'),
      runCode: false,
      language: 'javascript',
      compiler: {
        languageType: 'javascript',
        version: '101'
      },
      randomizer: {
        active: false,
        previewIndex: 0,
        knownTags: [],
        sets: []
      },
      domLibs: [],
      workerLibs: [],
      blocks: [],
      outputParser: ICodeBlocks["b" /* CodeOutputTypes */].AUTO,
      readonly: false,
      solutionTheme: 'solarized light',
      codeTheme: 'xq-light',
      uuid: 'is-set-below',
      executionTimeout: 5000,
      maxCharacters: 1000,
      continuousCompilation: isTrue(inData.continuousCompilation),
      messagePassing: isTrue(inData.messagePassing),
      keepAlive: isTrue(inData.keepAlive),
      persistentArguments: isTrue(inData.persistentArguments),
      shadowRoot: this.shadowRoot
    };
    if (inData.randomizerActive !== undefined) {
      data.randomizer.active = isTrue(inData.randomizerActive);
    }
    if (inData.randomizerPreviewIndex !== undefined) {
      data.randomizer.previewIndex = Number(inData.randomizerPreviewIndex);
    }
    if (inData.randomizerKnownTags !== undefined) {
      data.randomizer.knownTags = JSON.parse(inData.randomizerKnownTags);
    }
    if (inData.randomizerSets !== undefined) {
      data.randomizer.sets = JSON.parse(inData.randomizerSets).map(function (o, i) {
        var ret = {
          uuid: index_esm["b" /* uuid */].v4(),
          values: []
        };
        Object.keys(o).forEach(function (tag) {
          var item = {
            tag: tag,
            value: o[tag]
          };
          ret.values.push(item);
        });
        return ret;
      });
    }
    if (inData.question !== undefined) {
      data.id = Number(inData.question);
    }
    if (inData.compiler !== undefined) {
      var cInfo = {
        languageType: inData.compiler,
        version: inData.compilerVersion
      };
      data.compiler = cInfo;
      var c = CompilerRegistry_compilerRegistry.getCompiler(data.compiler);
      if (c === undefined) {
        data.runCode = false;
        data.language = data.compiler.languageType;
      } else {
        data.runCode = isTrue(inData.runCode);
        data.language = c.language;
        data.compiler.version = c.version;
      }
    }
    if (inData.domLibs !== undefined) {
      data.domLibs = JSON.parse(inData.domLibs).map(function (l) {
        return lib_CompilerRegistry.mapLibrary(l);
      });
    }
    if (inData.readonly !== undefined) {
      if (data.editMode) {
        data.readonly = false;
      } else {
        data.readonly = isTrue(inData.readonly);
      }
    }
    if (inData.workerLibs !== undefined) {
      data.workerLibs = JSON.parse(inData.workerLibs);
    }
    if (el.hasAttribute('uuid')) {
      data.uuid = el.getAttribute('uuid');
    } else {
      data.uuid = index_esm["b" /* uuid */].v4();
      el.setAttribute('uuid', data.uuid);
    }
    //data.id = Number(data.id)
    if (inData.executionTimeout !== undefined) {
      data.executionTimeout = Number(inData.executionTimeout);
    }
    if (inData.maxCharacters !== undefined) {
      data.maxCharacters = Number(inData.maxCharacters);
    }
    if (inData.scopeUUID !== undefined) {
      data.scopeUUID = inData.scopeUUID;
    }
    if (inData.scopeSelector !== undefined) {
      data.scopeSelector = inData.scopeSelector;
    }
    if (inData.outputParser !== undefined) {
      data.outputParser = inData.outputParser;
    }
    if (inData.solutionTheme !== undefined) {
      data.solutionTheme = inData.solutionTheme;
    }
    if (inData.codeTheme !== undefined) {
      data.codeTheme = inData.codeTheme;
    }
    el.querySelectorAll('*').forEach(function (blIn) {
      var _a;
      var bl = blIn;
      //only first level children
      if (bl.parentElement != el) {
        return;
      }
      var inBlock = bl.dataset;
      var as = bl.getAttribute('as');
      if (as !== null) {
        inBlock.as = as.trim().toUpperCase();
      }
      var block = {
        as: inBlock.as ? ICodeBlocks["c" /* KnownBlockTypes */][inBlock.as] : undefined,
        hasCode: false,
        version: '101',
        type: bl.tagName,
        content: bl.textContent ? bl.textContent : '',
        alternativeContent: null,
        hasAlternativeContent: false,
        id: data.blocks.length,
        uuid: index_esm["b" /* uuid */].v4(),
        parentID: data.id,
        width: '100%',
        height: '200px',
        align: 'center',
        readyCount: 0,
        obj: null,
        name: "v".concat(data.blocks.length),
        lineCountHint: -1,
        blockly: {
          showControls: false,
          useOverride: false,
          toolbox: {
            categories: []
          },
          toolboxOverride: '',
          blocks: [],
          _blockErrors: []
        },
        errors: [],
        readonly: isTrue(inBlock.readonly),
        static: isTrue(inBlock.static),
        hidden: isTrue(inBlock.hidden),
        visibleLines: inBlock.visibleLines === undefined || ((_a = inBlock.visibleLines) === null || _a === void 0 ? void 0 : _a.trim().toLowerCase()) == 'auto' ? 'auto' : Number(inBlock.visibleLines),
        shouldAutoreset: isTrue(inBlock.shouldAutoreset),
        shouldReloadResources: isTrue(inBlock.shouldReloadResources),
        generateTemplate: undefined || inBlock.generateTemplate != 'false' && inBlock.generateTemplate != '0',
        expanded: inBlock.expanded === undefined || inBlock.expanded != 'false' && inBlock.expanded != '0',
        codeExpanded: ICodeBlocks["a" /* CodeExpansionType */].AUTO,
        noContent: isTrue(inBlock.noContent),
        scopeUUID: inBlock.scopeUUID,
        scopeSelector: inBlock.scopeSelector
      };
      if (inBlock.codeExpanded !== undefined) {
        if (inBlock.codeExpanded.toUpperCase() == 'TINY' || inBlock.codeExpanded == 'false' || inBlock.codeExpanded == '0') {
          block.codeExpanded = ICodeBlocks["a" /* CodeExpansionType */].TINY;
        } else if (inBlock.codeExpanded.toUpperCase() == 'LARGE' || inBlock.codeExpanded == '2') {
          block.codeExpanded = ICodeBlocks["a" /* CodeExpansionType */].LARGE;
        }
      }
      if (!data.editMode && block.noContent) {
        block.content = '';
      }
      if (inBlock.alternativeContent !== undefined && !block.static && !block.hidden) {
        block.alternativeContent = inBlock.alternativeContent;
        block.hasAlternativeContent = true;
        if (!data.editMode && block.noContent) {
          block.content = block.alternativeContent;
        }
      } else {
        block.hasAlternativeContent = false;
      }
      if (block.type != 'TEXT') {
        console.log('BL', block.type, block.as);
        if (block.as) {
          block.type = block.as;
        }
        var loader = loaders[block.type];
        console.d('LOADER', loader, loaders, block.type, block.as);
        if (loader === undefined) {
          console.i('Skipping', block.type, block.as);
          return;
        } else {
          loader.loadFromDatablock(bl, inBlock, block, data.editMode);
        }
      }
      data.blocks.push(_this.constructBlock(data, block));
    });
    this.data = data;
    console.d('DATA', data);
  }
  Object(createClass["a" /* default */])(InternalCodeBlocksManager, [{
    key: "constructBlock",
    value: function constructBlock(_data, bl) {
      if (bl.type === ICodeBlocks["c" /* KnownBlockTypes */].PLAYGROUND || bl.type === ICodeBlocks["c" /* KnownBlockTypes */].DATA) {
        if (bl.content == '' || bl.content === undefined || bl.content === null) {
          bl.content = '{}';
        }
      }
      return new codeBlocksManager_BlockData({
        data: function data() {
          return Object.assign(Object.assign({}, bl), {
            appSettings: _data
          });
        }
      });
    }
  }, {
    key: "instantiateVue",
    value: function instantiateVue() {
      var _data2 = this.data;
      var self = this;
      new lib["c" /* Vue */]({
        i18n: i18n["a" /* default */],
        render: function render(h) {
          var MainBlock = /*#__PURE__*/function (_Vue2) {
            Object(inherits["a" /* default */])(MainBlock, _Vue2);
            var _super2 = Object(createSuper["a" /* default */])(MainBlock);
            function MainBlock() {
              Object(classCallCheck["a" /* default */])(this, MainBlock);
              return _super2.apply(this, arguments);
            }
            Object(createClass["a" /* default */])(MainBlock, [{
              key: "initArgsForLanguage",
              value: function initArgsForLanguage() {
                console.d('Constructing args for', this.language, this.defaultArgs);
                if (this.defaultArgs === undefined) {
                  if (this.language === 'java') {
                    return [];
                  } else {
                    return {};
                  }
                } else {
                  return this.defaultArgs;
                }
              }
            }, {
              key: "storeDefaultArgs",
              value: function storeDefaultArgs(args) {
                this.defaultArgs = args;
              }
            }, {
              key: "clearDefaultArgs",
              value: function clearDefaultArgs() {
                this.defaultArgs = undefined;
              }
            }, {
              key: "swap",
              value: function swap(id1, id2) {
                var a = this.blocks[id1];
                this.blocks[id1] = this.blocks[id2];
                this.blocks[id2] = a;
                this.blocks[id1].id = id1;
                this.blocks[id2].id = id2;
              }
            }, {
              key: "moveUp",
              value: function moveUp(id) {
                if (id <= 0) {
                  return;
                }
                this.swap(id - 1, id);
              }
            }, {
              key: "moveDown",
              value: function moveDown(id) {
                if (id >= this.blocks.length - 1) {
                  return;
                }
                this.swap(id, id + 1);
              }
            }, {
              key: "changeOrder",
              value: function changeOrder(id, newID) {
                //this.swap(id, newID)
                var a = this.blocks[id];
                this.blocks.splice(id, 1);
                this.blocks.splice(newID, 0, a);
                this.blocks.forEach(function (v, i) {
                  return v.id = i;
                });
              }
            }, {
              key: "removeBlock",
              value: function removeBlock(idx) {
                _data2.blocks.splice(idx, 1);
                for (var i = idx; i < _data2.blocks.length; i++) {
                  _data2.blocks[i].id = i;
                }
              }
            }, {
              key: "addNewBlock",
              value: function addNewBlock() {
                var block = {
                  noContent: false,
                  alternativeContent: null,
                  hasCode: true,
                  type: ICodeBlocks["c" /* KnownBlockTypes */].BLOCK,
                  content: '',
                  id: _data2.blocks.length,
                  uuid: index_esm["b" /* uuid */].v4(),
                  name: "v".concat(_data2.blocks.length),
                  parentID: _data2.id,
                  expanded: true,
                  codeExpanded: ICodeBlocks["a" /* CodeExpansionType */].AUTO,
                  width: '100%',
                  height: '200px',
                  align: 'center',
                  obj: null,
                  readonly: false,
                  static: true,
                  hidden: false,
                  version: '101',
                  readyCount: 0,
                  errors: [],
                  scopeUUID: _data2.scopeUUID,
                  scopeSelector: _data2.scopeSelector,
                  visibleLines: 10,
                  hasAlternativeContent: false,
                  shouldAutoreset: false,
                  shouldReloadResources: false,
                  generateTemplate: true,
                  blockly: {
                    showControls: false,
                    useOverride: false,
                    toolboxOverride: '',
                    toolbox: {
                      categories: []
                    },
                    blocks: [],
                    _blockErrors: []
                  },
                  lineCountHint: -1
                };
                _data2.blocks.push(self.constructBlock(_data2, block));
              }
            }]);
            return MainBlock;
          }(lib["c" /* Vue */]);
          MainBlock = Object(tslib_es6["b" /* __decorate */])([Object(lib["a" /* Component */])({
            data: function data() {
              return _data2;
            }
          })], MainBlock);
          var context = {
            props: {
              language: _data2.language,
              id: _data2.id,
              blocks: new MainBlock()
            }
          };
          return h(_data2.editMode ? AppEditor : App, context);
        }
      }).$mount(this.element);
    }
  }]);
  return InternalCodeBlocksManager;
}();
var codeBlocksManager_MountableArray = /*#__PURE__*/function (_Array) {
  Object(inherits["a" /* default */])(MountableArray, _Array);
  var _super3 = Object(createSuper["a" /* default */])(MountableArray);
  function MountableArray() {
    Object(classCallCheck["a" /* default */])(this, MountableArray);
    return _super3.apply(this, arguments);
  }
  Object(createClass["a" /* default */])(MountableArray, [{
    key: "mount",
    value: function mount() {
      this.forEach(function (el) {
        return el.instantiateVue();
      });
    }
  }]);
  return MountableArray;
}( /*#__PURE__*/wrapNativeSuper_wrapNativeSuper(Array));
var CodeBlocksManager = {
  find: function find(scope) {
    if (scope === undefined) {
      scope = document;
    }
    var allCodeBlockParents = scope.querySelectorAll('codeblocks, codeblockseditor, div[codeblocks], div[codeblockseditor]');
    var result = new codeBlocksManager_MountableArray();
    allCodeBlockParents.forEach(function (el) {
      var cbm = new codeBlocksManager_InternalCodeBlocksManager(el);
      var scope = cbm.data.scopeSelector ? document.querySelector(cbm.data.scopeSelector) : undefined;
      if (scope === undefined || scope === null) {
        scope = el;
      }
      lib["c" /* Vue */].$hljs.$vue.processElements(scope);
      if (cbm.data.editMode) {
        lib["c" /* Vue */].$tagger.processElements(scope);
        cbm.data.scopeSelector = "[uuid=".concat(scope.getAttribute('uuid'), "]");
        cbm.data.scopeUUID = scope.getAttribute('uuid') ? scope.getAttribute('uuid') : undefined;
        cbm.data.blocks.forEach(function (b) {
          b.scopeUUID = cbm.data.scopeUUID;
          b.scopeSelector = cbm.data.scopeSelector ? cbm.data.scopeSelector : "[uuid=".concat(b.scopeUUID, "]");
        });
      }
      result.push(cbm);
    });
    return result;
  }
};
// CONCATENATED MODULE: ./src/main.ts









String.prototype.replaceAllPoly = function (search, replacement) {
  var target = this;
  return target.replace(new RegExp(search, 'g'), replacement);
};
String.prototype.replaceRec = function (pattern, replacement) {
  var newstr = this.replace(pattern, replacement);
  if (newstr == this) {
    return newstr;
  }
  return newstr.replaceRec(pattern, replacement);
};
console.d = function () {
  if (false) { var _len, lines, _key, _console; }
};
console.i = function () {
  if (false) { var _len2, lines, _key2, _console2; }
};










//import './plugins/blocklyEnv'
//remove "noImplicitAny": false from tsconfig when this file goes ts

external_commonjs_vue_commonjs2_vue_root_Vue_default.a.config.productionTip = false;
CodeBlocksManager.find(document).mount();
window.mountInElement = function (element) {
  external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$hljs.$vue.processElements(element);
  external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$tagger.processElements(element);
  CodeBlocksManager.find(element).mount();
};
window.mountCodeBlocks = function (scope) {
  return CodeBlocksManager.find(scope).mount();
};
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib-no-default.js




/***/ }),

/***/ "fb6a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var isArray = __webpack_require__("e8b5");
var isConstructor = __webpack_require__("68ee");
var isObject = __webpack_require__("861d");
var toAbsoluteIndex = __webpack_require__("23cb");
var lengthOfArrayLike = __webpack_require__("07fa");
var toIndexedObject = __webpack_require__("fc6a");
var createProperty = __webpack_require__("8418");
var wellKnownSymbol = __webpack_require__("b622");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var nativeSlice = __webpack_require__("f36a");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

var SPECIES = wellKnownSymbol('species');
var $Array = Array;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = lengthOfArrayLike(O);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (isConstructor(Constructor) && (Constructor === $Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === $Array || Constructor === undefined) {
        return nativeSlice(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? $Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "fc0f":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlockContainer_vue_vue_type_style_index_0_id_6bc47167_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("edda");
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlockContainer_vue_vue_type_style_index_0_id_6bc47167_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_vue_cli_plugin_quasar_lib_loader_auto_import_js_kebab_node_modules_cache_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_index_js_vue_loader_options_CodeBlockContainer_vue_vue_type_style_index_0_id_6bc47167_prod_lang_sass___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "fc6a":
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__("44ad");
var requireObjectCoercible = __webpack_require__("1d80");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "fce3":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError
var $RegExp = global.RegExp;

module.exports = fails(function () {
  var re = $RegExp('.', 's');
  return !(re.dotAll && re.exec('\n') && re.flags === 's');
});


/***/ }),

/***/ "fdbc":
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "fdbf":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__("04f8");

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "fe0b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: I18n, i18n

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__("bee2");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__("d4ec");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js
var inherits = __webpack_require__("262e");

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js + 2 modules
var createSuper = __webpack_require__("2caf");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__("e260");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
var es_string_match = __webpack_require__("466d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__("25f0");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default = /*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// CONCATENATED MODULE: ./node_modules/vue-i18n/dist/vue-i18n.esm.js
/*!
 * vue-i18n v8.28.2 
 * (c) 2022 kazuya kawaguchi
 * Released under the MIT License.
 */
/*  */

/**
 * constants
 */

var numberFormatKeys = [
  'compactDisplay',
  'currency',
  'currencyDisplay',
  'currencySign',
  'localeMatcher',
  'notation',
  'numberingSystem',
  'signDisplay',
  'style',
  'unit',
  'unitDisplay',
  'useGrouping',
  'minimumIntegerDigits',
  'minimumFractionDigits',
  'maximumFractionDigits',
  'minimumSignificantDigits',
  'maximumSignificantDigits'
];

var dateTimeFormatKeys = [
  'dateStyle',
  'timeStyle',
  'calendar',
  'localeMatcher',
  "hour12",
  "hourCycle",
  "timeZone",
  "formatMatcher",
  'weekday',
  'era',
  'year',
  'month',
  'day',
  'hour',
  'minute',
  'second',
  'timeZoneName' ];

/**
 * utilities
 */

function warn (msg, err) {
  if (typeof console !== 'undefined') {
    console.warn('[vue-i18n] ' + msg);
    /* istanbul ignore if */
    if (err) {
      console.warn(err.stack);
    }
  }
}

function error (msg, err) {
  if (typeof console !== 'undefined') {
    console.error('[vue-i18n] ' + msg);
    /* istanbul ignore if */
    if (err) {
      console.error(err.stack);
    }
  }
}

var isArray = Array.isArray;

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isBoolean (val) {
  return typeof val === 'boolean'
}

function isString (val) {
  return typeof val === 'string'
}

var vue_i18n_esm_toString = Object.prototype.toString;
var OBJECT_STRING = '[object Object]';
function isPlainObject (obj) {
  return vue_i18n_esm_toString.call(obj) === OBJECT_STRING
}

function isNull (val) {
  return val === null || val === undefined
}

function isFunction (val) {
  return typeof val === 'function'
}

function parseArgs () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  var locale = null;
  var params = null;
  if (args.length === 1) {
    if (isObject(args[0]) || isArray(args[0])) {
      params = args[0];
    } else if (typeof args[0] === 'string') {
      locale = args[0];
    }
  } else if (args.length === 2) {
    if (typeof args[0] === 'string') {
      locale = args[0];
    }
    /* istanbul ignore if */
    if (isObject(args[1]) || isArray(args[1])) {
      params = args[1];
    }
  }

  return { locale: locale, params: params }
}

function looseClone (obj) {
  return JSON.parse(JSON.stringify(obj))
}

function remove (arr, item) {
  if (arr.delete(item)) {
    return arr
  }
}

function arrayFrom (arr) {
  var ret = [];
  arr.forEach(function (a) { return ret.push(a); });
  return ret
}

function includes (arr, item) {
  return !!~arr.indexOf(item)
}

var vue_i18n_esm_hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return vue_i18n_esm_hasOwnProperty.call(obj, key)
}

function merge (target) {
  var arguments$1 = arguments;

  var output = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments$1[i];
    if (source !== undefined && source !== null) {
      var key = (void 0);
      for (key in source) {
        if (hasOwn(source, key)) {
          if (isObject(source[key])) {
            output[key] = merge(output[key], source[key]);
          } else {
            output[key] = source[key];
          }
        }
      }
    }
  }
  return output
}

function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = isArray(a);
      var isArrayB = isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Sanitizes html special characters from input strings. For mitigating risk of XSS attacks.
 * @param rawText The raw input from the user that should be escaped.
 */
function escapeHtml(rawText) {
  return rawText
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;')
}

/**
 * Escapes html tags and special symbols from all provided params which were returned from parseArgs().params.
 * This method performs an in-place operation on the params object.
 *
 * @param {any} params Parameters as provided from `parseArgs().params`.
 *                     May be either an array of strings or a string->any map.
 *
 * @returns The manipulated `params` object.
 */
function escapeParams(params) {
  if(params != null) {
    Object.keys(params).forEach(function (key) {
      if(typeof(params[key]) == 'string') {
        params[key] = escapeHtml(params[key]);
      }
    });
  }
  return params
}

/*  */

function extend (Vue) {
  if (!Vue.prototype.hasOwnProperty('$i18n')) {
    // $FlowFixMe
    Object.defineProperty(Vue.prototype, '$i18n', {
      get: function get () { return this._i18n }
    });
  }

  Vue.prototype.$t = function (key) {
    var values = [], len = arguments.length - 1;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];

    var i18n = this.$i18n;
    return i18n._t.apply(i18n, [ key, i18n.locale, i18n._getMessages(), this ].concat( values ))
  };

  Vue.prototype.$tc = function (key, choice) {
    var values = [], len = arguments.length - 2;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];

    var i18n = this.$i18n;
    return i18n._tc.apply(i18n, [ key, i18n.locale, i18n._getMessages(), this, choice ].concat( values ))
  };

  Vue.prototype.$te = function (key, locale) {
    var i18n = this.$i18n;
    return i18n._te(key, i18n.locale, i18n._getMessages(), locale)
  };

  Vue.prototype.$d = function (value) {
    var ref;

    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
    return (ref = this.$i18n).d.apply(ref, [ value ].concat( args ))
  };

  Vue.prototype.$n = function (value) {
    var ref;

    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];
    return (ref = this.$i18n).n.apply(ref, [ value ].concat( args ))
  };
}

/*  */

/**
 * Mixin
 * 
 * If `bridge` mode, empty mixin is returned,
 * else regulary mixin implementation is returned.
 */
function defineMixin (bridge) {
  if ( bridge === void 0 ) bridge = false;

  function mounted () {
    if (this !== this.$root && this.$options.__INTLIFY_META__ && this.$el) {
      this.$el.setAttribute('data-intlify', this.$options.__INTLIFY_META__);
    }
  }

  return bridge
    ? { mounted: mounted } // delegate `vue-i18n-bridge` mixin implementation
    : { // regulary 
    beforeCreate: function beforeCreate () {
      var options = this.$options;
      options.i18n = options.i18n || ((options.__i18nBridge || options.__i18n) ? {} : null);

      if (options.i18n) {
        if (options.i18n instanceof VueI18n) {
          // init locale messages via custom blocks
          if ((options.__i18nBridge || options.__i18n)) {
            try {
              var localeMessages = options.i18n && options.i18n.messages ? options.i18n.messages : {};
              var _i18n = options.__i18nBridge || options.__i18n;
              _i18n.forEach(function (resource) {
                localeMessages = merge(localeMessages, JSON.parse(resource));
              });
              Object.keys(localeMessages).forEach(function (locale) {
                options.i18n.mergeLocaleMessage(locale, localeMessages[locale]);
              });
            } catch (e) {
              if (false) {}
            }
          }
          this._i18n = options.i18n;
          this._i18nWatcher = this._i18n.watchI18nData();
        } else if (isPlainObject(options.i18n)) {
          var rootI18n = this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n
            ? this.$root.$i18n
            : null;
          // component local i18n
          if (rootI18n) {
            options.i18n.root = this.$root;
            options.i18n.formatter = rootI18n.formatter;
            options.i18n.fallbackLocale = rootI18n.fallbackLocale;
            options.i18n.formatFallbackMessages = rootI18n.formatFallbackMessages;
            options.i18n.silentTranslationWarn = rootI18n.silentTranslationWarn;
            options.i18n.silentFallbackWarn = rootI18n.silentFallbackWarn;
            options.i18n.pluralizationRules = rootI18n.pluralizationRules;
            options.i18n.preserveDirectiveContent = rootI18n.preserveDirectiveContent;
          }

          // init locale messages via custom blocks
          if ((options.__i18nBridge || options.__i18n)) {
            try {
              var localeMessages$1 = options.i18n && options.i18n.messages ? options.i18n.messages : {};
              var _i18n$1 = options.__i18nBridge || options.__i18n;
              _i18n$1.forEach(function (resource) {
                localeMessages$1 = merge(localeMessages$1, JSON.parse(resource));
              });
              options.i18n.messages = localeMessages$1;
            } catch (e) {
              if (false) {}
            }
          }

          var ref = options.i18n;
          var sharedMessages = ref.sharedMessages;
          if (sharedMessages && isPlainObject(sharedMessages)) {
            options.i18n.messages = merge(options.i18n.messages, sharedMessages);
          }

          this._i18n = new VueI18n(options.i18n);
          this._i18nWatcher = this._i18n.watchI18nData();

          if (options.i18n.sync === undefined || !!options.i18n.sync) {
            this._localeWatcher = this.$i18n.watchLocale();
          }

          if (rootI18n) {
            rootI18n.onComponentInstanceCreated(this._i18n);
          }
        } else {
          if (false) {}
        }
      } else if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n) {
        // root i18n
        this._i18n = this.$root.$i18n;
      } else if (options.parent && options.parent.$i18n && options.parent.$i18n instanceof VueI18n) {
        // parent i18n
        this._i18n = options.parent.$i18n;
      }
    },

    beforeMount: function beforeMount () {
      var options = this.$options;
      options.i18n = options.i18n || ((options.__i18nBridge || options.__i18n) ? {} : null);

      if (options.i18n) {
        if (options.i18n instanceof VueI18n) {
          // init locale messages via custom blocks
          this._i18n.subscribeDataChanging(this);
          this._subscribing = true;
        } else if (isPlainObject(options.i18n)) {
          this._i18n.subscribeDataChanging(this);
          this._subscribing = true;
        } else {
          if (false) {}
        }
      } else if (this.$root && this.$root.$i18n && this.$root.$i18n instanceof VueI18n) {
        this._i18n.subscribeDataChanging(this);
        this._subscribing = true;
      } else if (options.parent && options.parent.$i18n && options.parent.$i18n instanceof VueI18n) {
        this._i18n.subscribeDataChanging(this);
        this._subscribing = true;
      }
    },

    mounted: mounted,

    beforeDestroy: function beforeDestroy () {
      if (!this._i18n) { return }

      var self = this;
      this.$nextTick(function () {
        if (self._subscribing) {
          self._i18n.unsubscribeDataChanging(self);
          delete self._subscribing;
        }

        if (self._i18nWatcher) {
          self._i18nWatcher();
          self._i18n.destroyVM();
          delete self._i18nWatcher;
        }

        if (self._localeWatcher) {
          self._localeWatcher();
          delete self._localeWatcher;
        }
      });
    }
  }
}

/*  */

var interpolationComponent = {
  name: 'i18n',
  functional: true,
  props: {
    tag: {
      type: [String, Boolean, Object],
      default: 'span'
    },
    path: {
      type: String,
      required: true
    },
    locale: {
      type: String
    },
    places: {
      type: [Array, Object]
    }
  },
  render: function render (h, ref) {
    var data = ref.data;
    var parent = ref.parent;
    var props = ref.props;
    var slots = ref.slots;

    var $i18n = parent.$i18n;
    if (!$i18n) {
      if (false) {}
      return
    }

    var path = props.path;
    var locale = props.locale;
    var places = props.places;
    var params = slots();
    var children = $i18n.i(
      path,
      locale,
      onlyHasDefaultPlace(params) || places
        ? useLegacyPlaces(params.default, places)
        : params
    );

    var tag = (!!props.tag && props.tag !== true) || props.tag === false ? props.tag : 'span';
    return tag ? h(tag, data, children) : children
  }
};

function onlyHasDefaultPlace (params) {
  var prop;
  for (prop in params) {
    if (prop !== 'default') { return false }
  }
  return Boolean(prop)
}

function useLegacyPlaces (children, places) {
  var params = places ? createParamsFromPlaces(places) : {};

  if (!children) { return params }

  // Filter empty text nodes
  children = children.filter(function (child) {
    return child.tag || child.text.trim() !== ''
  });

  var everyPlace = children.every(vnodeHasPlaceAttribute);
  if (false) {}

  return children.reduce(
    everyPlace ? assignChildPlace : assignChildIndex,
    params
  )
}

function createParamsFromPlaces (places) {
  if (false) {}

  return Array.isArray(places)
    ? places.reduce(assignChildIndex, {})
    : Object.assign({}, places)
}

function assignChildPlace (params, child) {
  if (child.data && child.data.attrs && child.data.attrs.place) {
    params[child.data.attrs.place] = child;
  }
  return params
}

function assignChildIndex (params, child, index) {
  params[index] = child;
  return params
}

function vnodeHasPlaceAttribute (vnode) {
  return Boolean(vnode.data && vnode.data.attrs && vnode.data.attrs.place)
}

/*  */

var numberComponent = {
  name: 'i18n-n',
  functional: true,
  props: {
    tag: {
      type: [String, Boolean, Object],
      default: 'span'
    },
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    },
    locale: {
      type: String
    }
  },
  render: function render (h, ref) {
    var props = ref.props;
    var parent = ref.parent;
    var data = ref.data;

    var i18n = parent.$i18n;

    if (!i18n) {
      if (false) {}
      return null
    }

    var key = null;
    var options = null;

    if (isString(props.format)) {
      key = props.format;
    } else if (isObject(props.format)) {
      if (props.format.key) {
        key = props.format.key;
      }

      // Filter out number format options only
      options = Object.keys(props.format).reduce(function (acc, prop) {
        var obj;

        if (includes(numberFormatKeys, prop)) {
          return Object.assign({}, acc, ( obj = {}, obj[prop] = props.format[prop], obj ))
        }
        return acc
      }, null);
    }

    var locale = props.locale || i18n.locale;
    var parts = i18n._ntp(props.value, locale, key, options);

    var values = parts.map(function (part, index) {
      var obj;

      var slot = data.scopedSlots && data.scopedSlots[part.type];
      return slot ? slot(( obj = {}, obj[part.type] = part.value, obj.index = index, obj.parts = parts, obj )) : part.value
    });

    var tag = (!!props.tag && props.tag !== true) || props.tag === false ? props.tag : 'span';
    return tag
      ? h(tag, {
        attrs: data.attrs,
        'class': data['class'],
        staticClass: data.staticClass
      }, values)
      : values
  }
};

/*  */

function bind (el, binding, vnode) {
  if (!assert(el, vnode)) { return }

  t(el, binding, vnode);
}

function update (el, binding, vnode, oldVNode) {
  if (!assert(el, vnode)) { return }

  var i18n = vnode.context.$i18n;
  if (localeEqual(el, vnode) &&
    (looseEqual(binding.value, binding.oldValue) &&
     looseEqual(el._localeMessage, i18n.getLocaleMessage(i18n.locale)))) { return }

  t(el, binding, vnode);
}

function unbind (el, binding, vnode, oldVNode) {
  var vm = vnode.context;
  if (!vm) {
    warn('Vue instance does not exists in VNode context');
    return
  }

  var i18n = vnode.context.$i18n || {};
  if (!binding.modifiers.preserve && !i18n.preserveDirectiveContent) {
    el.textContent = '';
  }
  el._vt = undefined;
  delete el['_vt'];
  el._locale = undefined;
  delete el['_locale'];
  el._localeMessage = undefined;
  delete el['_localeMessage'];
}

function assert (el, vnode) {
  var vm = vnode.context;
  if (!vm) {
    warn('Vue instance does not exists in VNode context');
    return false
  }

  if (!vm.$i18n) {
    warn('VueI18n instance does not exists in Vue instance');
    return false
  }

  return true
}

function localeEqual (el, vnode) {
  var vm = vnode.context;
  return el._locale === vm.$i18n.locale
}

function t (el, binding, vnode) {
  var ref$1, ref$2;

  var value = binding.value;

  var ref = parseValue(value);
  var path = ref.path;
  var locale = ref.locale;
  var args = ref.args;
  var choice = ref.choice;
  if (!path && !locale && !args) {
    warn('value type not supported');
    return
  }

  if (!path) {
    warn('`path` is required in v-t directive');
    return
  }

  var vm = vnode.context;
  if (choice != null) {
    el._vt = el.textContent = (ref$1 = vm.$i18n).tc.apply(ref$1, [ path, choice ].concat( makeParams(locale, args) ));
  } else {
    el._vt = el.textContent = (ref$2 = vm.$i18n).t.apply(ref$2, [ path ].concat( makeParams(locale, args) ));
  }
  el._locale = vm.$i18n.locale;
  el._localeMessage = vm.$i18n.getLocaleMessage(vm.$i18n.locale);
}

function parseValue (value) {
  var path;
  var locale;
  var args;
  var choice;

  if (isString(value)) {
    path = value;
  } else if (isPlainObject(value)) {
    path = value.path;
    locale = value.locale;
    args = value.args;
    choice = value.choice;
  }

  return { path: path, locale: locale, args: args, choice: choice }
}

function makeParams (locale, args) {
  var params = [];

  locale && params.push(locale);
  if (args && (Array.isArray(args) || isPlainObject(args))) {
    params.push(args);
  }

  return params
}

var Vue;

function install (_Vue, options) {
  if ( options === void 0 ) options = { bridge: false };

  /* istanbul ignore if */
  if (false) {}
  install.installed = true;

  Vue = _Vue;

  var version = (Vue.version && Number(Vue.version.split('.')[0])) || -1;
  /* istanbul ignore if */
  if (false) {}

  extend(Vue);
  Vue.mixin(defineMixin(options.bridge));
  Vue.directive('t', { bind: bind, update: update, unbind: unbind });
  Vue.component(interpolationComponent.name, interpolationComponent);
  Vue.component(numberComponent.name, numberComponent);

  // use simple mergeStrategies to prevent i18n instance lose '__proto__'
  var strats = Vue.config.optionMergeStrategies;
  strats.i18n = function (parentVal, childVal) {
    return childVal === undefined
      ? parentVal
      : childVal
  };
}

/*  */

var BaseFormatter = function BaseFormatter () {
  this._caches = Object.create(null);
};

BaseFormatter.prototype.interpolate = function interpolate (message, values) {
  if (!values) {
    return [message]
  }
  var tokens = this._caches[message];
  if (!tokens) {
    tokens = parse(message);
    this._caches[message] = tokens;
  }
  return compile(tokens, values)
};



var RE_TOKEN_LIST_VALUE = /^(?:\d)+/;
var RE_TOKEN_NAMED_VALUE = /^(?:\w)+/;

function parse (format) {
  var tokens = [];
  var position = 0;

  var text = '';
  while (position < format.length) {
    var char = format[position++];
    if (char === '{') {
      if (text) {
        tokens.push({ type: 'text', value: text });
      }

      text = '';
      var sub = '';
      char = format[position++];
      while (char !== undefined && char !== '}') {
        sub += char;
        char = format[position++];
      }
      var isClosed = char === '}';

      var type = RE_TOKEN_LIST_VALUE.test(sub)
        ? 'list'
        : isClosed && RE_TOKEN_NAMED_VALUE.test(sub)
          ? 'named'
          : 'unknown';
      tokens.push({ value: sub, type: type });
    } else if (char === '%') {
      // when found rails i18n syntax, skip text capture
      if (format[(position)] !== '{') {
        text += char;
      }
    } else {
      text += char;
    }
  }

  text && tokens.push({ type: 'text', value: text });

  return tokens
}

function compile (tokens, values) {
  var compiled = [];
  var index = 0;

  var mode = Array.isArray(values)
    ? 'list'
    : isObject(values)
      ? 'named'
      : 'unknown';
  if (mode === 'unknown') { return compiled }

  while (index < tokens.length) {
    var token = tokens[index];
    switch (token.type) {
      case 'text':
        compiled.push(token.value);
        break
      case 'list':
        compiled.push(values[parseInt(token.value, 10)]);
        break
      case 'named':
        if (mode === 'named') {
          compiled.push((values)[token.value]);
        } else {
          if (false) {}
        }
        break
      case 'unknown':
        if (false) {}
        break
    }
    index++;
  }

  return compiled
}

/*  */

/**
 *  Path parser
 *  - Inspired:
 *    Vue.js Path parser
 */

// actions
var APPEND = 0;
var PUSH = 1;
var INC_SUB_PATH_DEPTH = 2;
var PUSH_SUB_PATH = 3;

// states
var BEFORE_PATH = 0;
var IN_PATH = 1;
var BEFORE_IDENT = 2;
var IN_IDENT = 3;
var IN_SUB_PATH = 4;
var IN_SINGLE_QUOTE = 5;
var IN_DOUBLE_QUOTE = 6;
var AFTER_PATH = 7;
var ERROR = 8;

var pathStateMachine = [];

pathStateMachine[BEFORE_PATH] = {
  'ws': [BEFORE_PATH],
  'ident': [IN_IDENT, APPEND],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[IN_PATH] = {
  'ws': [IN_PATH],
  '.': [BEFORE_IDENT],
  '[': [IN_SUB_PATH],
  'eof': [AFTER_PATH]
};

pathStateMachine[BEFORE_IDENT] = {
  'ws': [BEFORE_IDENT],
  'ident': [IN_IDENT, APPEND],
  '0': [IN_IDENT, APPEND],
  'number': [IN_IDENT, APPEND]
};

pathStateMachine[IN_IDENT] = {
  'ident': [IN_IDENT, APPEND],
  '0': [IN_IDENT, APPEND],
  'number': [IN_IDENT, APPEND],
  'ws': [IN_PATH, PUSH],
  '.': [BEFORE_IDENT, PUSH],
  '[': [IN_SUB_PATH, PUSH],
  'eof': [AFTER_PATH, PUSH]
};

pathStateMachine[IN_SUB_PATH] = {
  "'": [IN_SINGLE_QUOTE, APPEND],
  '"': [IN_DOUBLE_QUOTE, APPEND],
  '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
  ']': [IN_PATH, PUSH_SUB_PATH],
  'eof': ERROR,
  'else': [IN_SUB_PATH, APPEND]
};

pathStateMachine[IN_SINGLE_QUOTE] = {
  "'": [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_SINGLE_QUOTE, APPEND]
};

pathStateMachine[IN_DOUBLE_QUOTE] = {
  '"': [IN_SUB_PATH, APPEND],
  'eof': ERROR,
  'else': [IN_DOUBLE_QUOTE, APPEND]
};

/**
 * Check if an expression is a literal value.
 */

var literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral (exp) {
  return literalValueRE.test(exp)
}

/**
 * Strip quotes from a string
 */

function stripQuotes (str) {
  var a = str.charCodeAt(0);
  var b = str.charCodeAt(str.length - 1);
  return a === b && (a === 0x22 || a === 0x27)
    ? str.slice(1, -1)
    : str
}

/**
 * Determine the type of a character in a keypath.
 */

function getPathCharType (ch) {
  if (ch === undefined || ch === null) { return 'eof' }

  var code = ch.charCodeAt(0);

  switch (code) {
    case 0x5B: // [
    case 0x5D: // ]
    case 0x2E: // .
    case 0x22: // "
    case 0x27: // '
      return ch

    case 0x5F: // _
    case 0x24: // $
    case 0x2D: // -
      return 'ident'

    case 0x09: // Tab
    case 0x0A: // Newline
    case 0x0D: // Return
    case 0xA0:  // No-break space
    case 0xFEFF:  // Byte Order Mark
    case 0x2028:  // Line Separator
    case 0x2029:  // Paragraph Separator
      return 'ws'
  }

  return 'ident'
}

/**
 * Format a subPath, return its plain form if it is
 * a literal string or number. Otherwise prepend the
 * dynamic indicator (*).
 */

function formatSubPath (path) {
  var trimmed = path.trim();
  // invalid leading 0
  if (path.charAt(0) === '0' && isNaN(path)) { return false }

  return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed
}

/**
 * Parse a string path into an array of segments
 */

function parse$1 (path) {
  var keys = [];
  var index = -1;
  var mode = BEFORE_PATH;
  var subPathDepth = 0;
  var c;
  var key;
  var newChar;
  var type;
  var transition;
  var action;
  var typeMap;
  var actions = [];

  actions[PUSH] = function () {
    if (key !== undefined) {
      keys.push(key);
      key = undefined;
    }
  };

  actions[APPEND] = function () {
    if (key === undefined) {
      key = newChar;
    } else {
      key += newChar;
    }
  };

  actions[INC_SUB_PATH_DEPTH] = function () {
    actions[APPEND]();
    subPathDepth++;
  };

  actions[PUSH_SUB_PATH] = function () {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = IN_SUB_PATH;
      actions[APPEND]();
    } else {
      subPathDepth = 0;
      if (key === undefined) { return false }
      key = formatSubPath(key);
      if (key === false) {
        return false
      } else {
        actions[PUSH]();
      }
    }
  };

  function maybeUnescapeQuote () {
    var nextChar = path[index + 1];
    if ((mode === IN_SINGLE_QUOTE && nextChar === "'") ||
      (mode === IN_DOUBLE_QUOTE && nextChar === '"')) {
      index++;
      newChar = '\\' + nextChar;
      actions[APPEND]();
      return true
    }
  }

  while (mode !== null) {
    index++;
    c = path[index];

    if (c === '\\' && maybeUnescapeQuote()) {
      continue
    }

    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap['else'] || ERROR;

    if (transition === ERROR) {
      return // parse error
    }

    mode = transition[0];
    action = actions[transition[1]];
    if (action) {
      newChar = transition[2];
      newChar = newChar === undefined
        ? c
        : newChar;
      if (action() === false) {
        return
      }
    }

    if (mode === AFTER_PATH) {
      return keys
    }
  }
}





var I18nPath = function I18nPath () {
  this._cache = Object.create(null);
};

/**
 * External parse that check for a cache hit first
 */
I18nPath.prototype.parsePath = function parsePath (path) {
  var hit = this._cache[path];
  if (!hit) {
    hit = parse$1(path);
    if (hit) {
      this._cache[path] = hit;
    }
  }
  return hit || []
};

/**
 * Get path value from path string
 */
I18nPath.prototype.getPathValue = function getPathValue (obj, path) {
  if (!isObject(obj)) { return null }

  var paths = this.parsePath(path);
  if (paths.length === 0) {
    return null
  } else {
    var length = paths.length;
    var last = obj;
    var i = 0;
    while (i < length) {
      var value = last[paths[i]];
      if (value === undefined || value === null) {
        return null
      }
      last = value;
      i++;
    }

    return last
  }
};

/*  */



var htmlTagMatcher = /<\/?[\w\s="/.':;#-\/]+>/;
var linkKeyMatcher = /(?:@(?:\.[a-zA-Z]+)?:(?:[\w\-_|./]+|\([\w\-_:|./]+\)))/g;
var linkKeyPrefixMatcher = /^@(?:\.([a-zA-Z]+))?:/;
var bracketsMatcher = /[()]/g;
var defaultModifiers = {
  'upper': function (str) { return str.toLocaleUpperCase(); },
  'lower': function (str) { return str.toLocaleLowerCase(); },
  'capitalize': function (str) { return ("" + (str.charAt(0).toLocaleUpperCase()) + (str.substr(1))); }
};

var defaultFormatter = new BaseFormatter();

var VueI18n = function VueI18n (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #290
  /* istanbul ignore if */
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  var locale = options.locale || 'en-US';
  var fallbackLocale = options.fallbackLocale === false
    ? false
    : options.fallbackLocale || 'en-US';
  var messages = options.messages || {};
  var dateTimeFormats = options.dateTimeFormats || options.datetimeFormats || {};
  var numberFormats = options.numberFormats || {};

  this._vm = null;
  this._formatter = options.formatter || defaultFormatter;
  this._modifiers = options.modifiers || {};
  this._missing = options.missing || null;
  this._root = options.root || null;
  this._sync = options.sync === undefined ? true : !!options.sync;
  this._fallbackRoot = options.fallbackRoot === undefined
    ? true
    : !!options.fallbackRoot;
  this._fallbackRootWithEmptyString = options.fallbackRootWithEmptyString === undefined
    ? true
    : !!options.fallbackRootWithEmptyString;
  this._formatFallbackMessages = options.formatFallbackMessages === undefined
    ? false
    : !!options.formatFallbackMessages;
  this._silentTranslationWarn = options.silentTranslationWarn === undefined
    ? false
    : options.silentTranslationWarn;
  this._silentFallbackWarn = options.silentFallbackWarn === undefined
    ? false
    : !!options.silentFallbackWarn;
  this._dateTimeFormatters = {};
  this._numberFormatters = {};
  this._path = new I18nPath();
  this._dataListeners = new Set();
  this._componentInstanceCreatedListener = options.componentInstanceCreatedListener || null;
  this._preserveDirectiveContent = options.preserveDirectiveContent === undefined
    ? false
    : !!options.preserveDirectiveContent;
  this.pluralizationRules = options.pluralizationRules || {};
  this._warnHtmlInMessage = options.warnHtmlInMessage || 'off';
  this._postTranslation = options.postTranslation || null;
  this._escapeParameterHtml = options.escapeParameterHtml || false;

  if ('__VUE_I18N_BRIDGE__' in options) {
    this.__VUE_I18N_BRIDGE__ = options.__VUE_I18N_BRIDGE__;
  }

  /**
   * @param choice {number} a choice index given by the input to $tc: `$tc('path.to.rule', choiceIndex)`
   * @param choicesLength {number} an overall amount of available choices
   * @returns a final choice index
  */
  this.getChoiceIndex = function (choice, choicesLength) {
    var thisPrototype = Object.getPrototypeOf(this$1);
    if (thisPrototype && thisPrototype.getChoiceIndex) {
      var prototypeGetChoiceIndex = (thisPrototype.getChoiceIndex);
      return (prototypeGetChoiceIndex).call(this$1, choice, choicesLength)
    }

    // Default (old) getChoiceIndex implementation - english-compatible
    var defaultImpl = function (_choice, _choicesLength) {
      _choice = Math.abs(_choice);

      if (_choicesLength === 2) {
        return _choice
          ? _choice > 1
            ? 1
            : 0
          : 1
      }

      return _choice ? Math.min(_choice, 2) : 0
    };

    if (this$1.locale in this$1.pluralizationRules) {
      return this$1.pluralizationRules[this$1.locale].apply(this$1, [choice, choicesLength])
    } else {
      return defaultImpl(choice, choicesLength)
    }
  };


  this._exist = function (message, key) {
    if (!message || !key) { return false }
    if (!isNull(this$1._path.getPathValue(message, key))) { return true }
    // fallback for flat key
    if (message[key]) { return true }
    return false
  };

  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {
    Object.keys(messages).forEach(function (locale) {
      this$1._checkLocaleMessage(locale, this$1._warnHtmlInMessage, messages[locale]);
    });
  }

  this._initVM({
    locale: locale,
    fallbackLocale: fallbackLocale,
    messages: messages,
    dateTimeFormats: dateTimeFormats,
    numberFormats: numberFormats
  });
};

var prototypeAccessors = { vm: { configurable: true },messages: { configurable: true },dateTimeFormats: { configurable: true },numberFormats: { configurable: true },availableLocales: { configurable: true },locale: { configurable: true },fallbackLocale: { configurable: true },formatFallbackMessages: { configurable: true },missing: { configurable: true },formatter: { configurable: true },silentTranslationWarn: { configurable: true },silentFallbackWarn: { configurable: true },preserveDirectiveContent: { configurable: true },warnHtmlInMessage: { configurable: true },postTranslation: { configurable: true },sync: { configurable: true } };

VueI18n.prototype._checkLocaleMessage = function _checkLocaleMessage (locale, level, message) {
  var paths = [];

  var fn = function (level, locale, message, paths) {
    if (isPlainObject(message)) {
      Object.keys(message).forEach(function (key) {
        var val = message[key];
        if (isPlainObject(val)) {
          paths.push(key);
          paths.push('.');
          fn(level, locale, val, paths);
          paths.pop();
          paths.pop();
        } else {
          paths.push(key);
          fn(level, locale, val, paths);
          paths.pop();
        }
      });
    } else if (isArray(message)) {
      message.forEach(function (item, index) {
        if (isPlainObject(item)) {
          paths.push(("[" + index + "]"));
          paths.push('.');
          fn(level, locale, item, paths);
          paths.pop();
          paths.pop();
        } else {
          paths.push(("[" + index + "]"));
          fn(level, locale, item, paths);
          paths.pop();
        }
      });
    } else if (isString(message)) {
      var ret = htmlTagMatcher.test(message);
      if (ret) {
        var msg = "Detected HTML in message '" + message + "' of keypath '" + (paths.join('')) + "' at '" + locale + "'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";
        if (level === 'warn') {
          warn(msg);
        } else if (level === 'error') {
          error(msg);
        }
      }
    }
  };

  fn(level, locale, message, paths);
};

VueI18n.prototype._initVM = function _initVM (data) {
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  this._vm = new Vue({ data: data, __VUE18N__INSTANCE__: true });
  Vue.config.silent = silent;
};

VueI18n.prototype.destroyVM = function destroyVM () {
  this._vm.$destroy();
};

VueI18n.prototype.subscribeDataChanging = function subscribeDataChanging (vm) {
  this._dataListeners.add(vm);
};

VueI18n.prototype.unsubscribeDataChanging = function unsubscribeDataChanging (vm) {
  remove(this._dataListeners, vm);
};

VueI18n.prototype.watchI18nData = function watchI18nData () {
    var this$1 = this;
  return this._vm.$watch('$data', function () {
    var listeners = arrayFrom(this$1._dataListeners);
    var i = listeners.length;
    while(i--) {
      Vue.nextTick(function () {
        listeners[i] && listeners[i].$forceUpdate();
      });
    }
  }, { deep: true })
};

VueI18n.prototype.watchLocale = function watchLocale (composer) {
  if (!composer) {
    /* istanbul ignore if */
    if (!this._sync || !this._root) { return null }
    var target = this._vm;
    return this._root.$i18n.vm.$watch('locale', function (val) {
      target.$set(target, 'locale', val);
      target.$forceUpdate();
    }, { immediate: true })
  } else {
    // deal with vue-i18n-bridge
    if (!this.__VUE_I18N_BRIDGE__) { return null }
    var self = this;
    var target$1 = this._vm;
    return this.vm.$watch('locale', function (val) {
      target$1.$set(target$1, 'locale', val);
      if (self.__VUE_I18N_BRIDGE__ && composer) {
        composer.locale.value = val;
      }
      target$1.$forceUpdate();
    }, { immediate: true })
  }
};

VueI18n.prototype.onComponentInstanceCreated = function onComponentInstanceCreated (newI18n) {
  if (this._componentInstanceCreatedListener) {
    this._componentInstanceCreatedListener(newI18n, this);
  }
};

prototypeAccessors.vm.get = function () { return this._vm };

prototypeAccessors.messages.get = function () { return looseClone(this._getMessages()) };
prototypeAccessors.dateTimeFormats.get = function () { return looseClone(this._getDateTimeFormats()) };
prototypeAccessors.numberFormats.get = function () { return looseClone(this._getNumberFormats()) };
prototypeAccessors.availableLocales.get = function () { return Object.keys(this.messages).sort() };

prototypeAccessors.locale.get = function () { return this._vm.locale };
prototypeAccessors.locale.set = function (locale) {
  this._vm.$set(this._vm, 'locale', locale);
};

prototypeAccessors.fallbackLocale.get = function () { return this._vm.fallbackLocale };
prototypeAccessors.fallbackLocale.set = function (locale) {
  this._localeChainCache = {};
  this._vm.$set(this._vm, 'fallbackLocale', locale);
};

prototypeAccessors.formatFallbackMessages.get = function () { return this._formatFallbackMessages };
prototypeAccessors.formatFallbackMessages.set = function (fallback) { this._formatFallbackMessages = fallback; };

prototypeAccessors.missing.get = function () { return this._missing };
prototypeAccessors.missing.set = function (handler) { this._missing = handler; };

prototypeAccessors.formatter.get = function () { return this._formatter };
prototypeAccessors.formatter.set = function (formatter) { this._formatter = formatter; };

prototypeAccessors.silentTranslationWarn.get = function () { return this._silentTranslationWarn };
prototypeAccessors.silentTranslationWarn.set = function (silent) { this._silentTranslationWarn = silent; };

prototypeAccessors.silentFallbackWarn.get = function () { return this._silentFallbackWarn };
prototypeAccessors.silentFallbackWarn.set = function (silent) { this._silentFallbackWarn = silent; };

prototypeAccessors.preserveDirectiveContent.get = function () { return this._preserveDirectiveContent };
prototypeAccessors.preserveDirectiveContent.set = function (preserve) { this._preserveDirectiveContent = preserve; };

prototypeAccessors.warnHtmlInMessage.get = function () { return this._warnHtmlInMessage };
prototypeAccessors.warnHtmlInMessage.set = function (level) {
    var this$1 = this;

  var orgLevel = this._warnHtmlInMessage;
  this._warnHtmlInMessage = level;
  if (orgLevel !== level && (level === 'warn' || level === 'error')) {
    var messages = this._getMessages();
    Object.keys(messages).forEach(function (locale) {
      this$1._checkLocaleMessage(locale, this$1._warnHtmlInMessage, messages[locale]);
    });
  }
};

prototypeAccessors.postTranslation.get = function () { return this._postTranslation };
prototypeAccessors.postTranslation.set = function (handler) { this._postTranslation = handler; };

prototypeAccessors.sync.get = function () { return this._sync };
prototypeAccessors.sync.set = function (val) { this._sync = val; };

VueI18n.prototype._getMessages = function _getMessages () { return this._vm.messages };
VueI18n.prototype._getDateTimeFormats = function _getDateTimeFormats () { return this._vm.dateTimeFormats };
VueI18n.prototype._getNumberFormats = function _getNumberFormats () { return this._vm.numberFormats };

VueI18n.prototype._warnDefault = function _warnDefault (locale, key, result, vm, values, interpolateMode) {
  if (!isNull(result)) { return result }
  if (this._missing) {
    var missingRet = this._missing.apply(null, [locale, key, vm, values]);
    if (isString(missingRet)) {
      return missingRet
    }
  } else {
    if (false) {}
  }

  if (this._formatFallbackMessages) {
    var parsedArgs = parseArgs.apply(void 0, values);
    return this._render(key, interpolateMode, parsedArgs.params, key)
  } else {
    return key
  }
};

VueI18n.prototype._isFallbackRoot = function _isFallbackRoot (val) {
  return (this._fallbackRootWithEmptyString? !val : isNull(val)) && !isNull(this._root) && this._fallbackRoot
};

VueI18n.prototype._isSilentFallbackWarn = function _isSilentFallbackWarn (key) {
  return this._silentFallbackWarn instanceof RegExp
    ? this._silentFallbackWarn.test(key)
    : this._silentFallbackWarn
};

VueI18n.prototype._isSilentFallback = function _isSilentFallback (locale, key) {
  return this._isSilentFallbackWarn(key) && (this._isFallbackRoot() || locale !== this.fallbackLocale)
};

VueI18n.prototype._isSilentTranslationWarn = function _isSilentTranslationWarn (key) {
  return this._silentTranslationWarn instanceof RegExp
    ? this._silentTranslationWarn.test(key)
    : this._silentTranslationWarn
};

VueI18n.prototype._interpolate = function _interpolate (
  locale,
  message,
  key,
  host,
  interpolateMode,
  values,
  visitedLinkStack
) {
  if (!message) { return null }

  var pathRet = this._path.getPathValue(message, key);
  if (isArray(pathRet) || isPlainObject(pathRet)) { return pathRet }

  var ret;
  if (isNull(pathRet)) {
    /* istanbul ignore else */
    if (isPlainObject(message)) {
      ret = message[key];
      if (!(isString(ret) || isFunction(ret))) {
        if (false) {}
        return null
      }
    } else {
      return null
    }
  } else {
    /* istanbul ignore else */
    if (isString(pathRet) || isFunction(pathRet)) {
      ret = pathRet;
    } else {
      if (false) {}
      return null
    }
  }

  // Check for the existence of links within the translated string
  if (isString(ret) && (ret.indexOf('@:') >= 0 || ret.indexOf('@.') >= 0)) {
    ret = this._link(locale, message, ret, host, 'raw', values, visitedLinkStack);
  }

  return this._render(ret, interpolateMode, values, key)
};

VueI18n.prototype._link = function _link (
  locale,
  message,
  str,
  host,
  interpolateMode,
  values,
  visitedLinkStack
) {
  var ret = str;

  // Match all the links within the local
  // We are going to replace each of
  // them with its translation
  var matches = ret.match(linkKeyMatcher);

  // eslint-disable-next-line no-autofix/prefer-const
  for (var idx in matches) {
    // ie compatible: filter custom array
    // prototype method
    if (!matches.hasOwnProperty(idx)) {
      continue
    }
    var link = matches[idx];
    var linkKeyPrefixMatches = link.match(linkKeyPrefixMatcher);
    var linkPrefix = linkKeyPrefixMatches[0];
      var formatterName = linkKeyPrefixMatches[1];

    // Remove the leading @:, @.case: and the brackets
    var linkPlaceholder = link.replace(linkPrefix, '').replace(bracketsMatcher, '');

    if (includes(visitedLinkStack, linkPlaceholder)) {
      if (false) {}
      return ret
    }
    visitedLinkStack.push(linkPlaceholder);

    // Translate the link
    var translated = this._interpolate(
      locale, message, linkPlaceholder, host,
      interpolateMode === 'raw' ? 'string' : interpolateMode,
      interpolateMode === 'raw' ? undefined : values,
      visitedLinkStack
    );

    if (this._isFallbackRoot(translated)) {
      if (false) {}
      /* istanbul ignore if */
      if (!this._root) { throw Error('unexpected error') }
      var root = this._root.$i18n;
      translated = root._translate(
        root._getMessages(), root.locale, root.fallbackLocale,
        linkPlaceholder, host, interpolateMode, values
      );
    }
    translated = this._warnDefault(
      locale, linkPlaceholder, translated, host,
      isArray(values) ? values : [values],
      interpolateMode
    );

    if (this._modifiers.hasOwnProperty(formatterName)) {
      translated = this._modifiers[formatterName](translated);
    } else if (defaultModifiers.hasOwnProperty(formatterName)) {
      translated = defaultModifiers[formatterName](translated);
    }

    visitedLinkStack.pop();

    // Replace the link with the translated
    ret = !translated ? ret : ret.replace(link, translated);
  }

  return ret
};

VueI18n.prototype._createMessageContext = function _createMessageContext (values, formatter, path, interpolateMode) {
    var this$1 = this;

  var _list = isArray(values) ? values : [];
  var _named = isObject(values) ? values : {};
  var list = function (index) { return _list[index]; };
  var named = function (key) { return _named[key]; };
  var messages = this._getMessages();
  var locale = this.locale;

  return {
    list: list,
    named: named,
    values: values,
    formatter: formatter,
    path: path,
    messages: messages,
    locale: locale,
    linked: function (linkedKey) { return this$1._interpolate(locale, messages[locale] || {}, linkedKey, null, interpolateMode, undefined, [linkedKey]); }
  }
};

VueI18n.prototype._render = function _render (message, interpolateMode, values, path) {
  if (isFunction(message)) {
    return message(
      this._createMessageContext(values, this._formatter || defaultFormatter, path, interpolateMode)
    )
  }

  var ret = this._formatter.interpolate(message, values, path);

  // If the custom formatter refuses to work - apply the default one
  if (!ret) {
    ret = defaultFormatter.interpolate(message, values, path);
  }

  // if interpolateMode is **not** 'string' ('row'),
  // return the compiled data (e.g. ['foo', VNode, 'bar']) with formatter
  return interpolateMode === 'string' && !isString(ret) ? ret.join('') : ret
};

VueI18n.prototype._appendItemToChain = function _appendItemToChain (chain, item, blocks) {
  var follow = false;
  if (!includes(chain, item)) {
    follow = true;
    if (item) {
      follow = item[item.length - 1] !== '!';
      item = item.replace(/!/g, '');
      chain.push(item);
      if (blocks && blocks[item]) {
        follow = blocks[item];
      }
    }
  }
  return follow
};

VueI18n.prototype._appendLocaleToChain = function _appendLocaleToChain (chain, locale, blocks) {
  var follow;
  var tokens = locale.split('-');
  do {
    var item = tokens.join('-');
    follow = this._appendItemToChain(chain, item, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && (follow === true))
  return follow
};

VueI18n.prototype._appendBlockToChain = function _appendBlockToChain (chain, block, blocks) {
  var follow = true;
  for (var i = 0; (i < block.length) && (isBoolean(follow)); i++) {
    var locale = block[i];
    if (isString(locale)) {
      follow = this._appendLocaleToChain(chain, locale, blocks);
    }
  }
  return follow
};

VueI18n.prototype._getLocaleChain = function _getLocaleChain (start, fallbackLocale) {
  if (start === '') { return [] }

  if (!this._localeChainCache) {
    this._localeChainCache = {};
  }

  var chain = this._localeChainCache[start];
  if (!chain) {
    if (!fallbackLocale) {
      fallbackLocale = this.fallbackLocale;
    }
    chain = [];

    // first block defined by start
    var block = [start];

    // while any intervening block found
    while (isArray(block)) {
      block = this._appendBlockToChain(
        chain,
        block,
        fallbackLocale
      );
    }

    // last block defined by default
    var defaults;
    if (isArray(fallbackLocale)) {
      defaults = fallbackLocale;
    } else if (isObject(fallbackLocale)) {
      /* $FlowFixMe */
      if (fallbackLocale['default']) {
        defaults = fallbackLocale['default'];
      } else {
        defaults = null;
      }
    } else {
      defaults = fallbackLocale;
    }

    // convert defaults to array
    if (isString(defaults)) {
      block = [defaults];
    } else {
      block = defaults;
    }
    if (block) {
      this._appendBlockToChain(
        chain,
        block,
        null
      );
    }
    this._localeChainCache[start] = chain;
  }
  return chain
};

VueI18n.prototype._translate = function _translate (
  messages,
  locale,
  fallback,
  key,
  host,
  interpolateMode,
  args
) {
  var chain = this._getLocaleChain(locale, fallback);
  var res;
  for (var i = 0; i < chain.length; i++) {
    var step = chain[i];
    res =
      this._interpolate(step, messages[step], key, host, interpolateMode, args, [key]);
    if (!isNull(res)) {
      if (step !== locale && "production" !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
        warn(("Fall back to translate the keypath '" + key + "' with '" + step + "' locale."));
      }
      return res
    }
  }
  return null
};

VueI18n.prototype._t = function _t (key, _locale, messages, host) {
    var ref;

    var values = [], len = arguments.length - 4;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 4 ];
  if (!key) { return '' }

  var parsedArgs = parseArgs.apply(void 0, values);
  if(this._escapeParameterHtml) {
    parsedArgs.params = escapeParams(parsedArgs.params);
  }

  var locale = parsedArgs.locale || _locale;

  var ret = this._translate(
    messages, locale, this.fallbackLocale, key,
    host, 'string', parsedArgs.params
  );
  if (this._isFallbackRoot(ret)) {
    if (false) {}
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return (ref = this._root).$t.apply(ref, [ key ].concat( values ))
  } else {
    ret = this._warnDefault(locale, key, ret, host, values, 'string');
    if (this._postTranslation && ret !== null && ret !== undefined) {
      ret = this._postTranslation(ret, key);
    }
    return ret
  }
};

VueI18n.prototype.t = function t (key) {
    var ref;

    var values = [], len = arguments.length - 1;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];
  return (ref = this)._t.apply(ref, [ key, this.locale, this._getMessages(), null ].concat( values ))
};

VueI18n.prototype._i = function _i (key, locale, messages, host, values) {
  var ret =
    this._translate(messages, locale, this.fallbackLocale, key, host, 'raw', values);
  if (this._isFallbackRoot(ret)) {
    if (false) {}
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n.i(key, locale, values)
  } else {
    return this._warnDefault(locale, key, ret, host, [values], 'raw')
  }
};

VueI18n.prototype.i = function i (key, locale, values) {
  /* istanbul ignore if */
  if (!key) { return '' }

  if (!isString(locale)) {
    locale = this.locale;
  }

  return this._i(key, locale, this._getMessages(), null, values)
};

VueI18n.prototype._tc = function _tc (
  key,
  _locale,
  messages,
  host,
  choice
) {
    var ref;

    var values = [], len = arguments.length - 5;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 5 ];
  if (!key) { return '' }
  if (choice === undefined) {
    choice = 1;
  }

  var predefined = { 'count': choice, 'n': choice };
  var parsedArgs = parseArgs.apply(void 0, values);
  parsedArgs.params = Object.assign(predefined, parsedArgs.params);
  values = parsedArgs.locale === null ? [parsedArgs.params] : [parsedArgs.locale, parsedArgs.params];
  return this.fetchChoice((ref = this)._t.apply(ref, [ key, _locale, messages, host ].concat( values )), choice)
};

VueI18n.prototype.fetchChoice = function fetchChoice (message, choice) {
  /* istanbul ignore if */
  if (!message || !isString(message)) { return null }
  var choices = message.split('|');

  choice = this.getChoiceIndex(choice, choices.length);
  if (!choices[choice]) { return message }
  return choices[choice].trim()
};

VueI18n.prototype.tc = function tc (key, choice) {
    var ref;

    var values = [], len = arguments.length - 2;
    while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];
  return (ref = this)._tc.apply(ref, [ key, this.locale, this._getMessages(), null, choice ].concat( values ))
};

VueI18n.prototype._te = function _te (key, locale, messages) {
    var args = [], len = arguments.length - 3;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 3 ];

  var _locale = parseArgs.apply(void 0, args).locale || locale;
  return this._exist(messages[_locale], key)
};

VueI18n.prototype.te = function te (key, locale) {
  return this._te(key, this.locale, this._getMessages(), locale)
};

VueI18n.prototype.getLocaleMessage = function getLocaleMessage (locale) {
  return looseClone(this._vm.messages[locale] || {})
};

VueI18n.prototype.setLocaleMessage = function setLocaleMessage (locale, message) {
  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {
    this._checkLocaleMessage(locale, this._warnHtmlInMessage, message);
  }
  this._vm.$set(this._vm.messages, locale, message);
};

VueI18n.prototype.mergeLocaleMessage = function mergeLocaleMessage (locale, message) {
  if (this._warnHtmlInMessage === 'warn' || this._warnHtmlInMessage === 'error') {
    this._checkLocaleMessage(locale, this._warnHtmlInMessage, message);
  }
  this._vm.$set(this._vm.messages, locale, merge(
    typeof this._vm.messages[locale] !== 'undefined' && Object.keys(this._vm.messages[locale]).length
      ? Object.assign({}, this._vm.messages[locale])
      : {},
    message
  ));
};

VueI18n.prototype.getDateTimeFormat = function getDateTimeFormat (locale) {
  return looseClone(this._vm.dateTimeFormats[locale] || {})
};

VueI18n.prototype.setDateTimeFormat = function setDateTimeFormat (locale, format) {
  this._vm.$set(this._vm.dateTimeFormats, locale, format);
  this._clearDateTimeFormat(locale, format);
};

VueI18n.prototype.mergeDateTimeFormat = function mergeDateTimeFormat (locale, format) {
  this._vm.$set(this._vm.dateTimeFormats, locale, merge(this._vm.dateTimeFormats[locale] || {}, format));
  this._clearDateTimeFormat(locale, format);
};

VueI18n.prototype._clearDateTimeFormat = function _clearDateTimeFormat (locale, format) {
  // eslint-disable-next-line no-autofix/prefer-const
  for (var key in format) {
    var id = locale + "__" + key;

    if (!this._dateTimeFormatters.hasOwnProperty(id)) {
      continue
    }

    delete this._dateTimeFormatters[id];
  }
};

VueI18n.prototype._localizeDateTime = function _localizeDateTime (
  value,
  locale,
  fallback,
  dateTimeFormats,
  key,
  options
) {
  var _locale = locale;
  var formats = dateTimeFormats[_locale];

  var chain = this._getLocaleChain(locale, fallback);
  for (var i = 0; i < chain.length; i++) {
    var current = _locale;
    var step = chain[i];
    formats = dateTimeFormats[step];
    _locale = step;
    // fallback locale
    if (isNull(formats) || isNull(formats[key])) {
      if (step !== locale && "production" !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
        warn(("Fall back to '" + step + "' datetime formats from '" + current + "' datetime formats."));
      }
    } else {
      break
    }
  }

  if (isNull(formats) || isNull(formats[key])) {
    return null
  } else {
    var format = formats[key];

    var formatter;
    if (options) {
      formatter = new Intl.DateTimeFormat(_locale, Object.assign({}, format, options));
    } else {
      var id = _locale + "__" + key;
      formatter = this._dateTimeFormatters[id];
      if (!formatter) {
        formatter = this._dateTimeFormatters[id] = new Intl.DateTimeFormat(_locale, format);
      }
    }

    return formatter.format(value)
  }
};

VueI18n.prototype._d = function _d (value, locale, key, options) {
  /* istanbul ignore if */
  if (false) {}

  if (!key) {
    var dtf = !options ? new Intl.DateTimeFormat(locale) : new Intl.DateTimeFormat(locale, options);
    return dtf.format(value)
  }

  var ret =
    this._localizeDateTime(value, locale, this.fallbackLocale, this._getDateTimeFormats(), key, options);
  if (this._isFallbackRoot(ret)) {
    if (false) {}
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n.d(value, key, locale)
  } else {
    return ret || ''
  }
};

VueI18n.prototype.d = function d (value) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  var locale = this.locale;
  var key = null;
  var options = null;

  if (args.length === 1) {
    if (isString(args[0])) {
      key = args[0];
    } else if (isObject(args[0])) {
      if (args[0].locale) {
        locale = args[0].locale;
      }
      if (args[0].key) {
        key = args[0].key;
      }
    }

    options = Object.keys(args[0]).reduce(function (acc, key) {
        var obj;

      if (includes(dateTimeFormatKeys, key)) {
        return Object.assign({}, acc, ( obj = {}, obj[key] = args[0][key], obj ))
      }
      return acc
    }, null);

  } else if (args.length === 2) {
    if (isString(args[0])) {
      key = args[0];
    }
    if (isString(args[1])) {
      locale = args[1];
    }
  }

  return this._d(value, locale, key, options)
};

VueI18n.prototype.getNumberFormat = function getNumberFormat (locale) {
  return looseClone(this._vm.numberFormats[locale] || {})
};

VueI18n.prototype.setNumberFormat = function setNumberFormat (locale, format) {
  this._vm.$set(this._vm.numberFormats, locale, format);
  this._clearNumberFormat(locale, format);
};

VueI18n.prototype.mergeNumberFormat = function mergeNumberFormat (locale, format) {
  this._vm.$set(this._vm.numberFormats, locale, merge(this._vm.numberFormats[locale] || {}, format));
  this._clearNumberFormat(locale, format);
};

VueI18n.prototype._clearNumberFormat = function _clearNumberFormat (locale, format) {
  // eslint-disable-next-line no-autofix/prefer-const
  for (var key in format) {
    var id = locale + "__" + key;

    if (!this._numberFormatters.hasOwnProperty(id)) {
      continue
    }

    delete this._numberFormatters[id];
  }
};

VueI18n.prototype._getNumberFormatter = function _getNumberFormatter (
  value,
  locale,
  fallback,
  numberFormats,
  key,
  options
) {
  var _locale = locale;
  var formats = numberFormats[_locale];

  var chain = this._getLocaleChain(locale, fallback);
  for (var i = 0; i < chain.length; i++) {
    var current = _locale;
    var step = chain[i];
    formats = numberFormats[step];
    _locale = step;
    // fallback locale
    if (isNull(formats) || isNull(formats[key])) {
      if (step !== locale && "production" !== 'production' && !this._isSilentTranslationWarn(key) && !this._isSilentFallbackWarn(key)) {
        warn(("Fall back to '" + step + "' number formats from '" + current + "' number formats."));
      }
    } else {
      break
    }
  }

  if (isNull(formats) || isNull(formats[key])) {
    return null
  } else {
    var format = formats[key];

    var formatter;
    if (options) {
      // If options specified - create one time number formatter
      formatter = new Intl.NumberFormat(_locale, Object.assign({}, format, options));
    } else {
      var id = _locale + "__" + key;
      formatter = this._numberFormatters[id];
      if (!formatter) {
        formatter = this._numberFormatters[id] = new Intl.NumberFormat(_locale, format);
      }
    }
    return formatter
  }
};

VueI18n.prototype._n = function _n (value, locale, key, options) {
  /* istanbul ignore if */
  if (!VueI18n.availabilities.numberFormat) {
    if (false) {}
    return ''
  }

  if (!key) {
    var nf = !options ? new Intl.NumberFormat(locale) : new Intl.NumberFormat(locale, options);
    return nf.format(value)
  }

  var formatter = this._getNumberFormatter(value, locale, this.fallbackLocale, this._getNumberFormats(), key, options);
  var ret = formatter && formatter.format(value);
  if (this._isFallbackRoot(ret)) {
    if (false) {}
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n.n(value, Object.assign({}, { key: key, locale: locale }, options))
  } else {
    return ret || ''
  }
};

VueI18n.prototype.n = function n (value) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

  var locale = this.locale;
  var key = null;
  var options = null;

  if (args.length === 1) {
    if (isString(args[0])) {
      key = args[0];
    } else if (isObject(args[0])) {
      if (args[0].locale) {
        locale = args[0].locale;
      }
      if (args[0].key) {
        key = args[0].key;
      }

      // Filter out number format options only
      options = Object.keys(args[0]).reduce(function (acc, key) {
          var obj;

        if (includes(numberFormatKeys, key)) {
          return Object.assign({}, acc, ( obj = {}, obj[key] = args[0][key], obj ))
        }
        return acc
      }, null);
    }
  } else if (args.length === 2) {
    if (isString(args[0])) {
      key = args[0];
    }
    if (isString(args[1])) {
      locale = args[1];
    }
  }

  return this._n(value, locale, key, options)
};

VueI18n.prototype._ntp = function _ntp (value, locale, key, options) {
  /* istanbul ignore if */
  if (!VueI18n.availabilities.numberFormat) {
    if (false) {}
    return []
  }

  if (!key) {
    var nf = !options ? new Intl.NumberFormat(locale) : new Intl.NumberFormat(locale, options);
    return nf.formatToParts(value)
  }

  var formatter = this._getNumberFormatter(value, locale, this.fallbackLocale, this._getNumberFormats(), key, options);
  var ret = formatter && formatter.formatToParts(value);
  if (this._isFallbackRoot(ret)) {
    if (false) {}
    /* istanbul ignore if */
    if (!this._root) { throw Error('unexpected error') }
    return this._root.$i18n._ntp(value, locale, key, options)
  } else {
    return ret || []
  }
};

Object.defineProperties( VueI18n.prototype, prototypeAccessors );

var availabilities;
// $FlowFixMe
Object.defineProperty(VueI18n, 'availabilities', {
  get: function get () {
    if (!availabilities) {
      var intlDefined = typeof Intl !== 'undefined';
      availabilities = {
        dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== 'undefined',
        numberFormat: intlDefined && typeof Intl.NumberFormat !== 'undefined'
      };
    }

    return availabilities
  }
});

VueI18n.install = install;
VueI18n.version = '8.28.2';

/* harmony default export */ var vue_i18n_esm = (VueI18n);

// CONCATENATED MODULE: ./src/plugins/i18n.ts













var lang = document.getElementsByTagName('html')[0].getAttribute('lang');
if (lang !== null) {
  lang = lang.split('-', 2)[0];
}
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.use(vue_i18n_esm);
function loadLocaleMessages() {
  var locales = __webpack_require__("49f8");
  var messages = {};
  locales.keys().forEach(function (key) {
    var matched = key.match(/([A-Za-z0-9-_]+)\./i);
    if (matched && matched.length > 1) {
      var locale = matched[1];
      messages[locale] = locales(key);
    }
  });
  return messages;
}
var i18n_I18n = /*#__PURE__*/function (_VueI18n) {
  Object(inherits["a" /* default */])(I18n, _VueI18n);
  var _super = Object(createSuper["a" /* default */])(I18n);
  function I18n(options) {
    var _this;
    Object(classCallCheck["a" /* default */])(this, I18n);
    _this = _super.call(this, options);
    _this.$v = vue_i18n_esm;
    return _this;
  }
  return Object(createClass["a" /* default */])(I18n);
}(vue_i18n_esm);
var i18n = new i18n_I18n({
  locale: lang || "en" || 'en',
  fallbackLocale: "en" || false,
  messages: loadLocaleMessages()
});
/* harmony default export */ var plugins_i18n = __webpack_exports__["a"] = (i18n);
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.prototype.$l = function (key, values) {
  var res = i18n.t(key, values);
  return res.toString();
};
external_commonjs_vue_commonjs2_vue_root_Vue_default.a.$l = external_commonjs_vue_commonjs2_vue_root_Vue_default.a.prototype.$l;

/***/ }),

/***/ "ff7b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("6642");

/* harmony default export */ __webpack_exports__["a"] = (Object(_size_js__WEBPACK_IMPORTED_MODULE_0__[/* getSizeMixin */ "b"])({
  xs: 30,
  sm: 35,
  md: 40,
  lg: 50,
  xl: 60
}));

/***/ })

/******/ });
});
//# sourceMappingURL=codeblocks.umd.js.map